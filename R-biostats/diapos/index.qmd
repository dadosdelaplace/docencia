---
title: "SOFTWARE PARA GESTIÓN DE BASES DE DATOS"
subtitle: "Introducción al análisis de datos en R (y Stata)"
title-slide-attributes:
  data-background-image: img/covid19-genetics.webp
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Máster de Bioestadística • curso 2023-2024"
affiliation: Facultad de Estudios Estadísticos (UCM)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    chalkboard: true
    multiplex: true
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier Álvarez Liébana</strong>](...) • Máster de bioestadística (UCM) • curso 2023-2024"
    slide-number: c/t
execute:
  echo: true
---

# ¡Bienvenidos a R!

[**Dejad vuestras hojas de cálculo a un lado**]{style="color:#444442;"}

---

## ¡Buenas!

[**Correo**]{.hl-green}: **<javalv09@ucm.es>**. [**Despacho**]{.hl-green}: 722 (3ª planta). [**Tutorías**]{.hl-green}: lunes (14:30-16:00), martes (12:00-13:00) y viernes (13:00-14:00).

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
-   [**Javier Álvarez Liébana**]{.hl-yellow}, de Carabanchel (Bajo).

-   Licenciado en Matemáticas (UCM). [**Doctorado en estadística**]{.hl-yellow} (UGR).

-   Encargado de la [**visualización y análisis de datos covid**]{.hl-yellow} del Principado de Asturias (2021-2022).

-   Miembro de la [**Sociedad Española de Estadística e IO**]{.hl-yellow} y la [**Real Sociedad Matemática Española**]{.hl-yellow}.
:::
:::
:::

. . .

Actualmente, [**investigador y docente en la Facultad de Estadística de la UCM**]{.hl-yellow}. Divulgando por [**Twitter**](https://twitter.com/dadosdelaplace) e [**Instagram**](https://instagram.com/javieralvarezliebana)


---

## Objetivos

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
-   Quitarnos el [**miedo a los errores en programación**]{.hl-yellow} → a programar se aprende programando

-   Entender los [**conceptos básicos de R**]{.hl-yellow} desde cero → aprender a abstraer ideas y algoritmos

-   Utilidad de programar → flujos de trabajo [**reproducibles**, **transparentes**]{.hl-yellow} y mantenibles

-   Introducción al [**análisis y preprocesamiento**]{.hl-yellow} de datos → `{tidyverse}`

-   Adquirir habilidades en la [**visualización de datos**]{.hl-yellow} → `{ggplot2}`
:::
:::
:::

---

## Evaluación

-   [**Asistencia**]{.hl-yellow}. La asistencia no será obligatoria pero si se [**valorará muy positivamente**]{.hl-purple} la participación en clase (nunca penalizando).

. . .

-   [**Evaluación**]{.hl-yellow}. A lo largo del curso se han planteado [**4 entregas individuales**]{.hl-purple}, así como una [**entrega final grupal**]{.hl-purple} (entre 2 y 4 personas) donde se deberá presentar el análisis realizado de un caso real.

. . .

-   [**Nota mínima**]{.hl-yellow}. Para no ir al examen final se [**deberá obtener al menos un 4/10**]{.hl-purple} en cada entrega o una [**media ponderada superior al 6/10**]{.hl-purple}. Se deberá obtener además en la [**entrega grupal una nota superior a 6-6.5-7/10**]{.hl-purple} (según 2-3-4 personas)

. . .

-   [**Examen final**]{.hl-yellow}. Cualquier alumno podrá presentarse a un examen final, siendo la valoración del mismo el 100% de su nota (perdiendo la evaluación continua).

---

## Planificación I

::: column-screen-inset-right
::: {style="font-size:20px"}
|  CLASE | SEMANA | FECHAS | TOPIC | SCRIPTS | EJ. | CASO PRÁCTICO | ENTREGA | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
|     [1](#clase-1-primeros-pasos)      | S1     | 11 sep |                  Primeros pasos en R                   | [📝](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  |                 [💻](#tu-turno)                 |                        |         | 
|     [2](#clase-2-primeros-datos)      | S1     | 13 sep |                 Tipos básicos de datos                 | [📝](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  |       [💻](#tu-turno-1) [💻](#tu-turno-2)  [💻]{#tu-turno-matrices}     |  [🐣](#caso-práctico-2)  |         |     
| [3](#clase-3-primeras-bases-de-datos) | S2     | 18 sep |                Primeras bases de datos. R base vs Tidyverse                   | [📝](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  | [💻](#tu-turno-tibble)  [💻](#tu-turno-3) | [🐣](#caso-práctico-3a) [🐣](#caso-práctico-3b)  |         |    
|   [4](#clase-5-importexport-comunicar)   | S2     | 19 sep |                  Importar/exportar e intro a Quarto/rmd                  | [📝](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  |                [💻](#tu-turno-4)                |        [🐣](#caso-práctico-4a)  [🐣](#caso-práctico-4b)             |         |    
|   [5](#clase-5-tidyverse-filas)   | S3     | 25 sep |                  Tidyverse (filas)                  | [📝](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  |                [💻](#tu-turno-7a) [💻](#tu-turno-7b)                |        [🐣](#caso-práctico-5)          |         | 
|   [6](#entrega-i)   | S3 | 27 sep | Entrega I |  |  [💻](#entrega-i)   |  |  🎯 10%  |
|   [7](#clase-7-tidyverse-columnas)   | S3     | 2 oct |                  Tidyverse (columnas)                  | [📝](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  |                [💻](#tu-turno-7d) [💻](#tu-turno-7e)                |   [🐣]{#caso-7a} |
|   [8](#clase-8)   | S4     | 4 oct |                  Tidyverse (crear/modificar variables)                  | [📝](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  |                [💻](#tu-turno-8a)  [💻](#tu-turno-8b)               |   [🐣]{#caso8a} |
|   [9](#clase-9-funciones)   | S5     | 9 oct |                  Funciones                 | [📝](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  |                [💻](#tu-turno-9)         |   [🐣] [🐣]|
:::
:::

---

## Materiales

* [**Diapositivas**]{.hl-yellow}: las diapositivas que usaremos en el aula a lo largo del curso, estructuradas por clases, estarán disponibles y actualizadas en **<https://javieralvarezliebana.es/docencia-R-master-bio-2324/diapos>** 

En el menú de las diapositivas (abajo a la izquierda) tienes una [**opción para descargarlas en pdf**]{.hl-yellow} en `Tools` (consejo: hazlo el final del curso ya que irán modificándose)
  
&nbsp;

* [**Material**]{.hl-yellow}: [**scripts de cada tema**](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material) y materiales extras

* [**Resúmenes de paquetes**]{.hl-yellow}: [**chuletas de los paquetes**](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/fichas%20paquetes) en formato .pdf

* [**Datos**]{.hl-yellow}: <https://drive.google.com/drive/folders/1iH3UCMDBNS_TJYKm7wx3-_120_3wmBdQ?usp=sharing>

# Clase 1: primeros pasos {#clase-1-primeros-pasos}

[**Instalando R y RStudio. Primeros pasos. Scripts y proyectos**]{style="color:#444442;"}

---

## Requisitos

Para el curso los únicos requisitos serán:

1.  [**Conexión a internet**]{.hl-yellow} (para la descarga de algunos datos y paquetes).

2.  [**Instalar R**]{.hl-yellow}[: será nuestro lenguaje. La descarga la haremos (gratuitamente) desde <https://cran.r-project.org/>]{.fragment .fade-in}

::: {.fragment .fade-in}
3.  [**Instalar RStudio**]{.hl-yellow} desde <https://posit.co/download/rstudio-desktop/>
:::

::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="420"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="420"}
:::
:::

---

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="400"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="470"}
:::
:::

::: {.fragment .fade-in-then-out}
Programaremos como escribimos (castellano, por ejemplo) → `R` es [**lenguaje**]{.hl-yellow}
:::

::: {.fragment .fade-up}
-   Necesitaremos una [**gramática**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}
-   Y un entorno, por ejemplo un [**Word**]{.hl-yellow} (`RStudio`), para escribirlo
:::
:::

---

## Instalación de R

El lenguaje `R` será nuestra [**gramática y ortografía**]{.hl-yellow} (nuestras reglas de juego)

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra en <https://cran.r-project.org/> y selecciona tu sistema operativo.

-   [**Paso 2**]{.hl-yellow}: para Mac basta con que hacer click en el **archivo .pkg**, y abrirlo una vez descargado. Para sistemas Windows, debemos clickar en **install R for the first time** y después en **Download R for Windows**. Una vez descargado, abrirlo como cualquier archivo de instalación.

-   [**Paso 3**]{.hl-yellow}: abrir el ejecutable de instalación.
:::

. . .

::: callout-warning
Siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), [**asegúrate de tener conexión a internet**]{.hl-orange}.
:::

---

## Primera operación

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deberías ver una **pantalla blanca** similar a esta.

Esa «pantalla blanca» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**Idea**]{.hl-yellow}: a una variable llamada `a` le asignaremos el valor `1` (escribiremos el código de abajo en la consola y daremos «enter»)

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## Primera operación

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deberías ver una **pantalla blanca** similar a esta.

Esa «pantalla blanca» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Idea**]{.hl-yellow}: definiremos otra variable llamada `b` y le asignaremos el valor `2`

```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

. . .

::: callout-note
## Fíjate que...

En `R` usaremos `<-` como una flecha: la variable a la izquierda de dicha flecha le asignamos el valor que hay a la derecha (por ejemplo, `a <- 1`)
:::

---

## Primera operación

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deberías ver una **pantalla blanca** similar a esta.

Esa «pantalla blanca» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="270"}
:::
:::

[**Idea**]{.hl-yellow}: haremos la suma `a + b` y nos devolverá su resultado

```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

---

## Instalación de R Studio

`RStudio` será el [**Word**]{.hl-yellow} que usaremos para escribir (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra la [web oficial de RStudio](https://posit.co/download/rstudio-desktop/) (ahora llamado Posit) y selecciona la descarga gratuita.

-   [**Paso 2**]{.hl-yellow}: selecciona el ejecutable que te aparezca acorde a tu sistema operativo.

-   [**Paso 3**]{.hl-yellow}: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro y dejar que termine la instalación.
:::

---

## Organización de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo código que antes (la suma de las variables) en ella. La consola será donde **ejecutaremos órdenes y mostraremos resultados**.

![](img/consola_rstudio.jpg){width="420"}

---

## Organización de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Environment**]{.hl-yellow}: la pantalla pequeña (puedes ajustar los márgenes con el ratón a tu gusto) que tenemos en la parte superior derecha. Nos mostrará las **variables que tenemos definidas**.

![](img/environment.jpg){width="420"}

---

## Organización de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha no servirá para buscar **ayuda de funciones**, además de para **visualizar gráficos**.

![](img/multiusos.jpg){width="420"}

---

## ¿Qué es R? ¿Por qué R?

![](img/meme_barco.jpg)

---

## ¿Qué es R? ¿Por qué R?

`R` es el [**lenguaje estadístico por excelencia**]{.hl-yellow}, creado por y para estadísticos/as, con 5 ventajas fundamentales [**frente a Excel**]{.hl-red}:

::: incremental
-   [**Lenguaje de programación**]{.hl-yellow}: la obviedad [→ análisis]{.fragment .fade-in}[**replicables**]{.hl-purple}

-   [**Gratuito**]{.hl-yellow}: la filosofía de la comunidad de `R` es el compartir código bajo **copyleft** [→]{.fragment .fade-in}[**uso ético de dinero público**]{.hl-purple}

-   [**Software libre**]{.hl-yellow}: no solo es gratis sino que permite acceder libremente a código ajeno, incluso al **propio código fuente** [→]{.fragment .fade-in}[**flexibilidad y transparencia**]{.hl-purple}

-   [**Lenguaje modular**]{.hl-yellow}: hemos instalado lo mínimo, pero existen códigos de otras personas que podemos reusar (casi 20 000 [**paquetes**]{.hl-yellow}) [→]{.fragment .fade-in}[**ahorro de tiempo**]{.hl-purple}

-   [**Lenguaje de alto nivel**]{.hl-yellow}: facilita la programación (como Python) [→]{.fragment .fade-in}[**menor curva de aprendizaje**]{.hl-purple}
:::

---

## ¿Qué es R? ¿Por qué R?

![](img/incel_excel.png)

---

## ¿Por qué programar?

-   [**Automatizar**]{.hl-yellow} → te permitirá automatizar tareas recurrentes.

-   [**Replicabilidad**]{.hl-yellow} → podrás replicar tu análisis siempre de la misma manera.

-   [**Flexibilidad**]{.hl-yellow} → podrás adaptar el software a tus necesidades.

-   [**Transparencia**]{.hl-yellow} → ser auditado por la comunidad.

![](img/the_general_problem.png)

---

## Idea fundamental: paquetes

Una de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: códigos que otras personas han implementado para **resolver un problema**

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}
-   [**Instalación**]{.hl-yellow}: descargamos los códigos de la web (necesitamos internet) → [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)

```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}
-   [**Carga**]{.hl-yellow}: con el paquete descargado, indicamos qué paquetes queremos usar cada vez que abramos `RStudio` → [**traer el libro de la estantería**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::
:::
:::

---

## Idea fundamental: paquetes

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
Una vez instalado, hay dos manera de usar un paquete (traerlo de la estantería)

::: {.fragment fragment-index="1"}
-   [**Paquete entero**]{.hl-yellow}: con `library()`, usando el nombre del paquete sin comillas, cargamos en la sesión [**todo el libro**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}
-   [**Funciones concretas**]{.hl-yellow} usando `paquete::funcion` le índicamos que solo queremos una [**página concreta de ese libro**]{.hl-purple}

```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## Te vas equivocar

Durante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera → [**te vas equivocar**]{.hl-yellow}. No solo será importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.

. . .

-   [**Mensajes de error**]{.hl-red}: precedidos de **«Error in...»** y serán aquellos fallos que [**impidan la ejecución**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Mensajes de warning**]{.hl-orange}: precedidos de **«Warning in...»** son los (posibles) fallos más delicados ya que son incoherencias que [**no impiden la ejecución**]{.hl-orange}

```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```

---

## Scripts (documentos .R)

::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}
Un [**script**]{.hl-yellow} será el documento en el que programamos, nuestro archivo `.doc` (aquí con extensión `.R`) donde escribiremos las órdenes. Para **abrir nuestro primero script**, haz click en el menú en `File < New File < R Script`.
:::
:::

::: callout-warning
## Cuidado

Es importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habrás perdido**]{.hl-orange}.
:::

---

## Ejecutando el primer script

Ahora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros códigos**]{.hl-yellow}. ¿Cómo ejecutarlo?

. . .

1.  **Escribimos** el código a ejecutar.

. . .

2.  **Guardamos** el archivo .R haciendo click en `Save current document`.

. . .

3.  El código no se ejecuta salvo que se lo indiquemos. Tenemos tres opciones:

-   [**Copiar y pegar**]{.hl-yellow} en consola.
-   [**Seleccionar líneas**]{.hl-yellow} y `Ctrl+Enter`
-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el código **completo**.

---

## 💻 Tu turno {#tu-turno}

[**Ejecuta tu primer script**: crea un script de cero, programa lo indicado debajo y ejecútalo (de las 3 maneras posibles)]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Define una variable de nombre `a` y cuyo valor sea -1

```{r}
#| code-fold: true
a <- -1
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Añade debajo otra línea para definir una variable `b` con el valor 5. Tras ello múltiplica ambas variables

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # sin guardar
multiplicacion <- a * b # guardado
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Modifica el código inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables.

```{r}
#| eval: false
c <- # deberías asignarle el valor 3
d <- # deberías asignarle el valor -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d # sin guardar
division <- c / d # guardado
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Asigna un valor positivo a `x` y calcula su raíz cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la función `abs()`.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Usando la variable `x` ya definida, completa/modifica el código inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.

```{r}
#| eval: false
z <- ? - ? # completa el código
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```
:::

::: callout-note
## Toma nota

Comandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: líneas de código que hemos «encapsulado» bajo un nombre, y dado unos argumentos de entrada, ejecuta las órdenes (una especie de atajo).
:::

---

## Sé organizado: proyectos

De la misma manera que en el ordenador solemos trabajar de manera [**ordenada por carpetas**]{.hl-yellow}, en `RStudio` podemos hacer lo mismo para trabajar de [**manera eficaz creando proyectos**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
Un [**proyecto será una «carpeta»**]{.hl-yellow} dentro de `RStudio`, de manera que nuestro directorio raíz automáticamente será la propia carpeta de proyecto (pudiendo pasar de un proyecto a otro con el menu superior derecho).

Podemos crear uno en una carpeta nueva o en una carpeta ya existente.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::

---

## Filosofía: de la CELDA a la TABLA

¿Qué [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg){fig-align="middle"}

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenación** de valores del mismo tipo ([**vectores**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenación de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenación de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenación de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

# Clase 2: primeros datos {#clase-2-primeros-datos}

[**¿Qué tipos de celdas (datos) existen? Concatenando celdas: vectores**]{style="color:#444442;"}

---

## De la CELDA a la TABLA

¿Qué [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg){fig-align="middle"}

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenación** de valores del mismo tipo ([**vectores**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenación de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenación de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenación de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

---

## Celdas: tipos de datos

¿Existen [**variables más allá de los números**]{.hl-yellow}?

. . .

Piensa por ejemplo en los datos guardados de una persona:

::: {.fragment .fade-up}
-   La edad o el peso será un [**número**]{.hl-yellow}.

```{r}
edad <- 33
```
:::

::: {.fragment .fade-up}
-   Su nombre será una cadena de [**texto (string o char)**]{.hl-yellow}.

```{r}
nombre <- "javi"
```
:::

::: {.fragment .fade-up}
-   A la pregunta «¿está usted soltero/a?» la respuesta será lo que llamamos una [**variable lógica**]{.hl-yellow} (`TRUE` si está soltero/a o `FALSE` en otro caso).

```{r}
soltero <- FALSE
```
:::

::: {.fragment .fade-up}
-   Su fecha de nacimiento será precisamente eso, una [**fecha**]{.hl-yellow}.
:::

---

## Variables numéricos

El dato más sencillo (ya lo hemos usado) serán las [**variables numéricas**]{.hl-yellow}

```{r}
#| eval: false
a <- 5
b <- 2
a + b
```

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

. . .

Para saber el tipo de una variable tenemos la función `class()`

```{r}
class(a)
```

. . .

Con las variables numéricas podemos realizar las [**operaciones aritméticas**]{.hl-yellow} de una calculadora: sumar (`+`), raíz cuadrada (`sqrt()`), cuadrado (`^2`), etc.

```{r}
a^2
abs(a)
```

---

## Variables de texto

Imagina que además de la edad de una persona queremos guardar su nombre: ahora la variable será de tipo `character`

```{r}
nombre <- "Javier"
class(nombre)
```

. . .

Las [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones aritméticas**]{.hl-red} (sí otras operaciones como pegar o localizar patrones).

```{r}
#| error: true
nombre + 1 # error al sumar número a texto
```

. . .

::: callout-warning
## Recuerda que...

Las variables de tipo texto (character o string) van [**SIEMPRE entre comillas**]{.hl-orange}: no es lo mismo `TRUE` (valor lógico, binario) que `"TRUE"` (texto).
:::

---

## Primera función: paste

En `R` llamaremos [**función**]{.hl-yellow} a un trozo de [**código encapsulado**]{.hl-yellow} bajo un nombre, y que depende de unos [**argumentos**]{.hl-yellow} de entrada. Nuestra primera función será `paste()`: dadas dos cadenas de texto nos permite pegarlas.

```{r}
paste("Javier", "Álvarez")
```

. . .

Fíjate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos añadir un [**argumento opcional**]{.hl-yellow} para indicarle el separador (en `sep = ...`).

```{r}
paste("Javier", "Álvarez", sep = "*")
```

---

## Primera función: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}
¿Cómo saber [**qué argumentos necesita una función**]{.hl-yellow}? Escribiendo en consola `? paste` te aparecerá una [**ayuda**]{.hl-yellow} en el panel multiusos.

En dicha ayuda podrás ver en su cabecera que argumentos ya tiene [**asignados por defecto**]{.hl-yellow} la función
:::
:::

. . .

Existe una función similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).

```{r}
paste0("Javier", "Álvarez")
```

---

## Primer paquete: glue

Una forma más intuitiva de trabajar con textos es usar el paquete `{glue}`: lo primero que haremos será «comprar el libro» (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue") # solo la primra vez
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

Con dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, «la edad es de ... años», donde la edad está guardada en una variable.

```{r}
edad <- 33
glue("La edad es de {edad} años")
```

. . .

Dentro de las llaves también podemos ejecutar operaciones

```{r}
unidades <- "días"
glue("La edad es de {edad * 365} {unidades}")
```

---

## Variables lógicas

Otro tipo fundamental serán las [**variables lógicas o binarias**]{.hl-yellow} (**dos valores**):

-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.
-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.

```{r}
soltero <- FALSE # ¿Está soltero? --> NO
class(soltero)
```

. . .

Puede tomar un tercer valor, `NA` o [**dato ausente**]{.hl-yellow}, representando las siglas de *not available*.

. . .

::: callout-important
## Importante

Las variables lógicas [**NO son variables de texto**]{.hl-red}: `"TRUE"` es un texto, `TRUE` es un valor lógico.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Condiciones lógicas

Los valores lógicos suelen ser resultado de [**evaluar condiciones lógicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos comprobar si una persona se llama Javi.

```{r}
nombre <- "María"
```

. . .

Con el [**operador lógico**]{.hl-yellow} `==` preguntamos sí a la izquierda es igual a la derecha

```{r}
nombre == "Javi"
```

. . .

Con su opuesto `!=` preguntamos si es distinto.

```{r}
nombre != "Javi"
```

. . .

::: callout-note
## Fíjate que...

No es lo mismo `<-` ([**asignación**]{.hl-yellow}) que `==` (estamos [**preguntando**]{.hl-yellow}, es una comparación lógica).
:::

---

## Condiciones lógicas

Además de las comparaciones «igual a» frente «distinto», también comparaciones de orden como `<, <=, > o >=`.

**¿Tiene la persona menos de 32 años?**

```{r}
edad <- 38
edad < 32 # ¿Es la edad menor de 32 años?
```

**¿La edad es mayor o igual que 38 años?**

```{r}
edad >= 38
```


---

## Variables de fecha

Un tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.

```{r}
fecha_char <- "2021-04-21"
```

. . .

Parece una simple cadena de texto pero [**representa un instante en el tiempo**]{.hl-yellow}. ¿Qué debería suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?

```{r}
#| error: true
fecha_char + 1
```

. . .

Las fechas [**no pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha con `as_date()` del paquete `{lubridate}`

```{r}
library(lubridate) # instala si no lo has hecho
fecha <- as_date("2023-03-28")
fecha + 1
class(fecha)
```

---

## Variables de fecha

En dicho paquete tenemos funciones muy útiles para [**manejar fechas**]{.hl-yellow}:

-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.

```{r}
today()
```

. . .

-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}

```{r}
now()
```

. . .

-   Con `year()`, `month()` o `day()` podemos [**extraer el año, mes y día**]{.hl-purple}

```{r}
fecha <- today()
year(fecha)
month(fecha)
```

---

## Resúmenes de paquetes

![](img/lubridate.png)

::: callout-note
## Amplia contenido

Tienes un resumen en pdf de los paquetes más importantes en la [**carpeta correspondiente en el campus**]{.hl-green}
:::

---

## 💻 Tu turno {#tu-turno-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Define una variable que guarde tu edad (llamada `edad`) y otra con tu nombre (llamada `nombre`)

```{r}
#| code-fold: true
edad <- 33
nombre <- "Javi"
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Define otra variable llamada `hermanos` que responda la pregunta «¿tienes hermanos?» y otra con la fecha de tu nacimiento (llamada `fecha_nacimiento`).

```{r}
#| code-fold: true
hermanos <- TRUE

library(lubridate)
fecha_nacimiento <- as_date("1989-09-10")
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Define otra variable con tus apellidos (llamada `apellidos`) y usa `glue()` para tener una sola variable `nombre_completo` (separando nombre y apellido por una coma)

```{r}
#| code-fold: true
#| eval: false
apellidos <- "Álvarez Liébana"
glue("{nombre}, {apellidos}")
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Calcula los días que han pasado desde la fecha de tu nacimiento hasta hoy (con la fecha de nacimiento definida en el ejercicio 2).

```{r}
#| code-fold: true
#| eval: false
today() - fecha_nacimiento
```
:::

---

## Vectores: concatenar

Cuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenación**]{.hl-purple} de celdas (valores) del [**mismo tipo**]{.hl-purple}

. . .

La forma más sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus **elementos entre paréntesis y separados por comas**

```{r}
edades <- c(33, 27, 60, 61)
edades
```

. . .

::: callout-tip
Un número individual `x <- 1` (o bien `x <- c(1)`) es en realidad un vector de longitud uno.
:::

---

## Vectores: concatenar

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}
Como ves ahora en el `environment` tenemos una **colección de elementos** guardada

```{r}
edades
```
:::
:::

. . .

 

La [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`

```{r}
length(edades)
```

. . .

También podemos [**concatenar vectores**]{.hl-yellow}

```{r}
c(edades, edades, 8)
```

---

## Secuencias numéricas

En muchas ocasiones querremos crear [**secuencias numéricas**]{.hl-yellow} (por ejemplo, los días del mes). El comando `seq(inicio, fin)` nos permite crear una **secuencia** desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.

```{r}
seq(1, 31)
```

. . .

El comando `1:n` nos devuelve lo mismo que `seq(1, n)` (si el elemento inicial es mayor que el final, entenderá que la secuencia es [**decreciente**]{.hl-purple})

```{r}
1:5
7:-3
```

---

## Secuencias numéricas

También podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

. . .

Otras veces nos interesará definir una [**secuencia con una longitud concreta**]{.hl-yellow}

```{r}
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```

. . .

Incluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}

```{r}
rep(0, 7) # vector de 7 ceros
```

---

## Vectores de caracteres

Un vector es una **concatenación** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente números. Vamos a crear una frase de ejemplo.

```{r}
frase <- "Me llamo Javi"
frase
length(frase)
```

. . .

En el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas

```{r}
vector <- c("Me", "llamo", "Javi")
vector
length(vector)
```

---

## Vectores de caracteres

¿Qué sucederá si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

Fíjate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}

. . .

```{r}
c(3, 4, TRUE, FALSE)
```

Es importante entender que los valores lógicos en realidad están [**almacenados internamente como 0/1**]{.hl-yellow}

---

## Operaciones con vectores

Con los vectores numéricos podemos hacer las mismas [**operaciones aritméticas**]{.hl-yellow} que con los números → un [**número es un vector**]{.hl-purple} (de longitud uno)

. . .

¿Qué sucederá si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Cuidado

Salvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}
:::

---

## Operaciones con vectores

Los vectores también pueden interactuar entre ellos, así que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)

```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Dado que la operación (por ejemplo, una suma) se realiza elemento a elemento, ¿qué sucederá si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?

. . .

```{r}
z <- c(1, 3, 5, 7)
x + z
```

Lo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que hará será reciclar del vector con menor longitud.

---

## Operaciones con vectores

Una operación muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones lógicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...

[**¿Qué días hizo menos de 22 grados?**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

Nos devolverá un [**vector lógico**]{.hl-yellow}, en función de si **cada elemento** cumple o no la condición pedida (de **igual longitud** que el vector preguntado)

. . .

Si tuviéramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese día), la condición evaluada también sería `NA`

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Operaciones con vectores

Las [**condiciones lógicas pueden ser combinadas**]{.hl-yellow} de dos maneras:

-   [**Intersección**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunción y**]{.hl-purple} con `&`) para devolver un `TRUE`

```{r}
x < 30 & x > 15
```

-   [**Unión**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunción o**]{.hl-purple} con `|`)

```{r}
x < 30 | x > 15
```

. . .

Con `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen

```{r}
any(x < 30)
all(x < 30)
```

---

## Operaciones con vectores

También podemos hacer uso de [**operaciones estadísticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**¿Qué sucede cuando falta un dato (ausente)?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

Por defecto, si tenemos un dato ausente, la [**operación también será ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`

```{r}
sum(x, na.rm = TRUE)
```

---

## Operaciones con vectores

Como hemos comentado que los valores lógicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritméticas.

 

Por ejemplo, si queremos [**averiguar el número de elementos que cumplen una condición**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendrán asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar dicho vector lógico para obtener el número de elementos que cumplen

```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Operaciones con vectores

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

 

-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La más conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores atípicos o outliers (valores muy grandes o muy pequeños), la media se perturba con mucha facilidad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Operaciones con vectores

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

 

-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Percentiles**]{.hl-yellow}: medidas de posición (nos dividen en partes iguales los datos).

```{r}
quantile(x) # por defecto percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

---

## Operaciones con vectores

Otra operación muy habitual es la de [**acceder a elementos**]{.hl-yellow} del mismo. La forma más sencilla es usar el operador `[i]` (acceder al elemento i-ésimo)

```{r}
edades <- c(20, 30, 33, NA, 61) 
edades[3] # accedemos a la edad de la tercera persona 
```

. . .

 

Dado que un número no es más que un vector de longitud uno, esta operación también la podemos aplicar usando un [**vector de índices a seleccionar**]{.hl-yellow}

```{r}
y <- c("hola", "qué", "tal", "estás", "?")
y[c(1:2, 4)] # primer, segundo y cuarto elemento
```

::: callout-tip
Para acceder al último, sin preocuparnos de cuál, podemos pasarle como índice la longitud `x[length(x)]`
:::

---

## Operaciones con vectores

Otras veces no querremos seleccionar sino [**eliminar algunos elementos**]{.hl-yellow}. Deberemos repetir la misma operación pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-ésimo del vector sino que lo «des-selecciona»

```{r}
y
y[-2]
```

 

. . .

En muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones lógicas**]{.hl-yellow}, en función de los valores, así que pasaremos como índice la propia condición (recuerda, `x < 2` nos devuelve un vector lógico)

```{r}
edades <- c(15, 21, 30, 17, 45)
nombres <- c("javi", "maría", "laura", "carla", "luis")
nombres[edades < 18] # nombres de los menores de edad
```

---

## Operaciones con vectores

Por último, una acción habitual es saber [**ordenar valores**]{.hl-yellow}:

-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(edades)
sort(edades, decreasing = TRUE)
```

. . .

-   `order()`: devuelve el [**vector de índices**]{.hl-yellow} que tendríamos que usar para tener el vector ordenado

```{r}
order(x)
x[order(x)]
```

---

## 💻 Tu turno {#tu-turno-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Define el vector `x` como la concatenación de los 5 primeros números impares, y calcula su suma.

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

sum(x)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Obtén los elementos de `x` mayores que 4. Calcula el número de elementos de `x` mayores que 4.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
sum(x > 4)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Calcula el vector `1/x` y obtén la versión ordenada (de menor a mayor).

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Encuentra el máximo y el mínimo del vector `x`

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Ejercicio 6**]{.hl-yellow}

📝 Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6. Elimina del vector el segundo elemento. Tras eliminarlo determina su suma y su media

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
y <- x[-2]
sum(y, na.rm = TRUE)
mean(y, na.rm = TRUE)
```
:::

---

## 🐣 Caso práctico {#caso-práctico-2}

En el paquete `{datasets}` tenemos diversos conjuntos de datos y uno de ellos es `airquality`. Debajo te he extraído 3 variables de dicho dataset

```{r}
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

1. ¿Qué [**representan los datos**]{.hl-yellow}? ¿Cómo averiguarlo?

```{r}
#| code-fold: true
#| eval: false
? airquality
```

Haciendo uso de `? ...` podemos consultar en el panel de ayuda lo que significa el objeto.

---

## 🐣 Caso práctico {#caso-práctico-2-2}

2. ¿Cuántos [**registros tenemos de mayo**]{.hl-yellow}? ¿Y de abril? Construye una nueva variable `date` con la [**fecha**]{.hl-yellow} de cada registro (combinando año, mes y día)

```{r}
#| code-fold: true
# Una forma para registros de mayo
sum(month == 5)
# Otra forma
length(month[month == 5])

# ídem en abril
sum(month == 4)

# variable date
dates <- lubridate::as_date(glue("{1973}-{month}-{day}"))
```

. . .

3. Crea una nueva variable `temp_celsius` con la [**temperatura en ºC**]{.hl-yellow}

```{r}
#| code-fold: true
# Temperatura en celsius
temp_celsius <- (temperature - 32) * (5/9)
```

---

## 🐣 Caso práctico {#caso-práctico-2-3}

4. ¿Cuál fue la [**media de temperatura**]{.hl-yellow} del mes de agosto? Extrae los días en los que la [**temperatura superó los 30 grados**]{.hl-yellow} y calcula la cantidad de días en los que lo hizo.

```{r}
#| code-fold: true
# media en agosto
mean(temperature[month == 8], na.rm = TRUE)
mean(temp_celsius[month == 8], na.rm = TRUE)

# Extremos días > 30
dates[temp_celsius > 30]
length(dates[temp_celsius > 30]) # n días
sum(temp_celsius > 30) # n días (otra forma)
```

---


## Antes de seguir: microbenchmark

Hay un paquete muy útil para [**medir tiempos de distintas órdenes que hacen lo mismo**]{.hl-yellow} (el paquete `{microbenchmark}`) para intentar ser con nuestro código lo más eficientes posible. Vamos a comparar por ejemplo `order()` y `sort()`.

```{r}
library(microbenchmark) # instalar primera vez
x <- rnorm(2e3) # 2000 elementos aleatorias
microbenchmark(sort(x), x[order(x)], times = 5e2) # 500 veces
```

---

## Primer intento: matrices

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una «tabla» que las recopile. La opción más inmediata son las [**matrices**]{.hl-yellow}: concatenación de variables del [**mismo tipo e igual longitud**]{.hl-purple}.

. . .

Imagina que tenemos estaturas y pesos de 4 personas. ¿Cómo [**crear un dataset con las dos variables**]{.hl-yellow}?

-   Con `cbind()` [**concatenamos vectores en forma de columnas**]{.hl-yellow}

```{r}
estaturas <- c(150, 160, 170, 180)
pesos <- c(63, 70, 85, 95)
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

---

## Primer intento: matrices

-   También podemos [**construir la matriz por filas**]{.hl-yellow} con la función `rbind()` (aunque lo recomendable es tener cada variable en columna e individuo en fila).

```{r}
# Construimos la matriz por filas
rbind(estaturas, pesos)
```

-   Podemos [**visualizar la matriz**]{.hl-yellow} con la función `View()`.

. . .

-   Podemos [**comprobar las dimensiones**]{.hl-yellow} con `dim()`, `nrow()` y `ncol()`: nuestros datos están tabulados:

```{r}
dim(datos_matriz)
nrow(datos_matriz)
```

---

## Primer intento: matrices

-   También podemos [**«darle vuelta» (matriz transpuesta)**]{.hl-yellow} con `t()`.

```{r}
t(datos_matriz)
```

. . .

-   Dado que ahora tenemos dos dimensiones, para [**acceder a elementos**]{.hl-yellow} deberemos proporcionar el índice de la fila y de la columna (si quedan libres implica todos de esa dimensión)

```{r}
datos_matriz[2, 1]
datos_matriz[, 2]
```

---

## Primer intento: matrices

-   También podemos definir una [**matriz a partir de un vector numérico**]{.hl-yellow}, reorganizando los valores en forma de matriz (sabiendo que los elementos se van **colocando por columnas**).

```{r}
z <- matrix(1:15, ncol = 5) 
z
```

. . .

Con las matrices sucede como con los vectores: cuando aplicamos una [**operación aritmética lo hacemos elemento a elemento**]{.hl-yellow}

```{r}
z/5
```

---

## Primer intento: matrices

También podemos [**realizar operaciones por columnas/filas**]{.hl-yellow} sin recurrir a bucles con la función `apply()`, y le indicaremos como **argumentos**

-   la matriz
-   el sentido de la operación (MARGIN = 1 por filas, MARGIN = 2 por columnas)
-   la función a aplicar

. . .

```{r}
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")

# (Cuasi)varianza (var) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "var")
```

. . .

[**No profundizaremos**]{.hl-red} más ya que nuestro objetivo es tener variables de misma longitud pero [**tipos diferentes**]{.hl-yellow} (pero que sepas que existen).

---

## 💻 Tu turno (matrices) {#tu-turno-matrices}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Modifica el código para definir una matriz `x` de ceros de 3 filas y 7 columnas de unos.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Ejercicio 2**]{.hl-yellow}

📝 A la matriz anterior, suma un 1 a cada número de la matriz y divide el resultado entre 5. Tras ello calcula su transpuesta y obtén sus dimensiones

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
dim(new_matrix)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Define la matriz `x <- matrix(1:12, nrow = 4)`. Obtén la primera fila, la tercera columna, y el elemento (4, 1).

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # primera fila
x[, 3] # tercera columna
x[4, 1] # elemento (4, 1)
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Con la matriz anterior definida como `x <- matrix(1:12, nrow = 4)`, calcula la media de todos los elementos, la media de cada fila y la media de cada columna. Calcula la suma de de cada fila y de cada columna

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
mean(x) # de todos
apply(x, MARGIN = 1, FUN = "mean") # media por filas
apply(x, MARGIN = 2, FUN = "mean") # media por columnas
apply(x, MARGIN = 1, FUN = "sum") # suma por filas
apply(x, MARGIN = 2, FUN = "sum") # suma por columnas

```

:::

---

## Segundo intento: data.frame

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte

```{r}
#| code-line-numbers: "4-5"
edades <- c(34, 24, NA)
soltero <- c(FALSE, NA, TRUE)
nombres <- c("javi", "carlos", "lucía")
matriz <- cbind(edades, soltero, nombres)
matriz
```

. . .

Al ya no ser números no podemos realizar operaciones aritméticas

```{r}
#| error: true
matriz + 1
```

---

## Segundo intento: data.frame

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos lo que se conoce como [**data.frame**]{.hl-yellow}: concatenación de variables de igual longitud pero pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
#| code-line-numbers: "1"
tabla <- data.frame(edades, soltero, nombres)
class(tabla)
tabla
```

---

## Segundo intento: data.frame

Dado que un `data.frame` es ya una «base de datos» las variables no son meros vectores matemáticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple}

```{r}
library(lubridate)
tabla <- data.frame("edad" = edades, "estado" = soltero, "nombre" = nombres,
             "f_nacimiento" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
tabla
```

---

## Segundo intento: data.frame

[**¡TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

![](img/view_tabla.jpg)

---

## Segundo intento: data.frame

Si queremos acceder a sus elementos, podemos como en las matrices (aunque no es recomendable): ahora [**tenemos dos índices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera característica de la segunda persona
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
También tiene ventajas de una [**«base» de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} (**recomendable** ya que las variables pueden cambiar de posición), poniendo el nombre de la tabla seguido del símbolo `$` (con el **tabulador**, nos aparecerá un menú de columnas a elegir)
:::
:::

---

## Segundo intento: data.frame

-   `names()`: nos muestra los nombres de las variables

```{r}
names(tabla)
```

. . .

-   `dim()`: nos muestra las dimensiones (también `nrow()` y `ncol()`)

```{r}
dim(tabla)
```

. . .

-   Podemos acceder a las variables por su nombre

```{r}
tabla[c(1, 3), "nombre"]
```

---

## Segundo intento: data.frame

Si tenemos uno ya creado y queremos [**añadir una columna**]{.hl-yellow} es tan simple como usar la función `data.frame()` que ya hemos visto para concatenar la columna. Vamos añadir por ejemplo una nueva variable, el número de hermanos de cada individuo.

```{r}
# Añadimos una nueva columna con nº de hermanos/as
hermanos <- c(0, 2, 3)
tabla <- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

# Clase 3: primeras bases de datos. R base vs Tidyverse {#clase-3-primeras-bases-de-datos}

[**Nuestra base de datos: tibble. Tidydata: un multiverso de datos limpios**]{style="color:#444442;"}

---

## Intento final: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}

La principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```

. . .

 

De ahora en adelante usaremos el formato `tibble` (un [**data.frame mejorado**]{.hl-yellow})

```{r}
library(tibble)
tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
       "IMC" = peso / (estatura^2))
```

---

## Intento final: tibble

```{r}
tabla <- tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
                "IMC" = peso / (estatura^2))
tabla
```

Las tablas en formato `tibble` nos permitirá una [**gestión más ágil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

-   [**Metainformación**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya automáticamente el número de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

---

## Intento final: tibble

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
tabla$invent
```

. . .

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de páginas web y documentos sencillos
:::


---

## 💻 Tu turno (tibble) {#tu-turno-tibble}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 Carga del paquete `{datasets}` el conjunto de datos `airquality` (variables de la calidad del aire de Nueva York desde mayo hasta septiembre de 1973). ¿Es el conjunto de datos airquality de tipo tibble? En caso negativo, conviértelo a tibble (busca en la documentación del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Una vez convertido a `tibble` obtén el nombre de las variables y las dimensiones del conjunto de datos. ¿Cuántas variables hay? ¿Cuántos días se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Filtra solo los datos del mes de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, ]
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Selecciona aquellos datos que no sean ni de julio ni de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[!(airquality_tb$Month %in% c(7, 8)), ]
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Modifica el siguiente código para quedarte solo con las variable de ozono y temperatura.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[, c("Ozone", "Temp")]
```

### [**Ejercicio 6**]{.hl-yellow}

📝 Selecciona los datos de temperatura y viento de agosto. Traduce a castellano el nombre de las columnas del conjunto filtrado.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, c("Temp", "Wind")]
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```
:::

---

## Resumen hasta ahora

-   Cada [**celda puede ser de un tipo diverso**]{.hl-yellow}: números, texto, fechas, valores lógicos, etc

. . .

-   Un [**vector es una concatenación de celdas**]{.hl-yellow} (las futuras columnas de nuestras tablas) --\> En `R` por defecto las operaciones se hacen [**elemento a elemento**]{.hl-yellow}

. . .

-   Una [**matriz**]{.hl-yellow} nos permite concatenar [**variables del MISMO tipo y MISMA longitud**]{.hl-yellow} --\> objeto bidimensional (dos índices)

. . .

-   Un [**data.frame**]{.hl-yellow} nos permite concatenar [**variables de DISTINTO tipo y MISMA longitud**]{.hl-yellow} --\> usaremos [**tibble**]{.hl-yellow} como una opción mejorada de base de datos

---

## 🐣 Caso práctico {#caso-práctico-3a}

Del paquete `Biostatistics` usaremos el conunto de datos `pinniped`

```{r}
#| eval: false
Biostatistics::pinniped
```


1. ¿Qué [**representan**]{.hl-yellow} los datos? ¿Qué [**tipo de dato**]{.hl-yellow} es? En caso de que no lo sea, convierte la base de datos a un `tibble` (renombra con `pinniped_tb`)

```{r}
#| code-fold: true
#| eval: false
? Biostatistics::pinniped
```

```{r}
#| code-fold: true
class(Biostatistics::pinniped) # no es un tibble
pinniped_tb <- as_tibble(Biostatistics::pinniped)
```

. . .

2. ¿Cuántos registros hay? ¿Y variables? ¿De qué tipo es cada una?


```{r}
#| code-fold: true
nrow(pinniped_tb)
ncol(pinniped_tb)
```


---

## 🐣 Caso práctico {#caso-práctico-3a-2}


3. Incorpora una [**variable extra llamada phoca**]{.hl-yellow} que sea de tipo lógico y que nos diga si una especie es de la categoría `Phoca` o no.

```{r}
#| code-fold: true
pinniped_tb$phoca <- pinniped_tb$Species == "Phoca"
```

. . .

4. ¿A qué sexo le [**pesa más el cerebro**]{.hl-yellow}: a las hembras o a los machos? ¿A quienes les [**pesa más el cuerpo**]{.hl-yellow}: a los monógamos o a los polígamos?

```{r}
#| code-fold: true
# ¿a quién le pesa más el cerebro?
mean(pinniped_tb$Male_brain_g, na.rm = TRUE) >
  mean(pinniped_tb$Female_brain_g, na.rm = TRUE)

# ¿a quién le pesa más el cerebro?
mean(c(pinniped_tb$Male_mass_Kg[pinniped_tb$Mate_type == "mono"],
       pinniped_tb$Female_mass_Kg[pinniped_tb$Mate_type == "mono"])) >
  mean(c(pinniped_tb$Male_mass_Kg[pinniped_tb$Mate_type == "poly"],
         pinniped_tb$Female_mass_Kg[pinniped_tb$Mate_type == "poly"]))
```

---

## 🐣 Caso práctico {#caso-práctico-3a-3}


5. Incopora una nueva variable que represente la [**diferencia entre el peso del cerebro entre machos y hembras**]{.hl-yellow} (machos - hembras) para cada especie.

```{r}
#| code-fold: true
pinniped_tb$dif_m_f <- pinniped_tb$Male_brain_g - pinniped_tb$Female_brain_g
pinniped_tb
```

---

## R base vs Tidyverse

Si conoces algún otro lenguaje de programación (o tienes gente cercana que programa) te extrañará que aún no hayamos hablado de conceptos habituales como

-   [**Bucles for**]{.hl-yellow}: repetir un código un número fijo de iteraciones.

-   [**Bucles while**]{.hl-yellow}: repetir un código hasta que se cumpla una condición

-   [**Estructuras if-else**]{.hl-yellow}: estructuras de control para decidir por donde camina el código en función del valor de las variables.

. . .

Y aunque conocer dichas estructuras puede sernos en algún momento interesante, en la [**mayoría de ocasiones vamos a poder evitarlas**]{.hl-red} (en especial los bucles)

---

## ¿Qué es tidyverse?

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

`{tidyverse}` es un [**«universo» de paquetes**]{.hl-yellow} para garanatizar un flujo de trabajo (de inicio a fin) eficiente, coherente y lexicográficamente sencillo de entender, basado en la idea de que [**nuestros datos están limpios y ordenados (tidy)**]{.hl-purple}

---

## ¿Qué es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: optimizando data.frame
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: gramática para depurar
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualización de datos
-   `{tidymodels}`: modelización/predicción
:::
:::

También tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.

---

## ¿Qué es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: gramática para depurar
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualización de datos
-   `{tidymodels}`: modelización/predicción
:::
:::

También tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.

---

## Filosofía base: tidy data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

El [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducido por **Hadley Wickham** (el Dios al que rezo) de [**estandarizar**]{.hl-yellow} el formato los datos para

::: incremental
-   [**sistematizar**]{.hl-green} la depuración
-   hacer más [**sencillo**]{.hl-green} su manipulación.
-   código [**legible**]{.hl-green}
:::

---

## Reglas del tidy data

Lo primero por tanto será entender qué son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos están estandarizados.

::: columns
::: {.column width="50%"}
::: {.fragment .fade-in}
1.  Cada [**variable**]{.hl-yellow} en una [**única columna**]{.hl-purple}
:::

::: {.fragment .fade-in}
2.  Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}
:::

::: {.fragment .fade-in}
3.  Cada [**celda**]{.hl-yellow} con un [**único valor**]{.hl-purple}
:::

::: {.fragment .fade-in}
4.  Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5.  Si queremos cruzar [**múltiples tablas**]{.hl-yellow} debemos tener una [**columna común**]{.hl-purple}
:::
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
:::

---

## Tubería (pipe)

En `{tidyverse}` será clave el [**operador pipe (tubería)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): será una [**tubería que recorre los datos**]{.hl-yellow} y los transforma.

. . .

::: columns
::: {.column width="50%"}
En R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, sería

```{r}
#| eval: false
third(second(first(datos)))
```
:::

::: {.column width="50%"}
En `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones

```{r}
#| eval: false
datos |> first() |> second() |> third()
```
:::
:::

 

. . .

::: callout-caution
## Apunte importante

Desde la versión 4.1.0 de `R` disponemos de `|>`, un pipe **nativo** disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `|>` que dependía del paquete `{magrittr}` (bastante problemático).
:::

---

## Tubería (pipe)

La principal ventaja es que el [**código sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas código.

 

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::

::: {.column width="50%"}
<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
:::

---

## Datos SUCIOS: messy data

¿Pero qué aspecto tienen los [**datos no tidy**]{.hl-yellow}? Vamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).

 

```{r}
library(tidyr)
table4a
```

 

[**¿Qué puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="40%"}
```{r}
table4a
```
:::

::: {.column width="60%"}
❎ Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) → las columnas `1999` y `2000` en realidad deberían ser en sí [**valores de una variable**]{.hl-yellow} y no nombres de columnas.
:::
:::

. . .

Incluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el año y otra que guarde el valor de la variable de interés en cada uno de esos años. Y lo haremos con la función `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="50%"}
```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
               values_to = "cases")
```
:::

::: {.column width="50%"}
![](img/table4a.jpg)
:::
:::

 

-   `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}
-   `names_to`: nombre de la nueva variable a la quemandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).
-   `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table2`

 

```{r}
table2
```

 

[**¿Qué puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_wider()

::: columns
::: {.column width="60%"}
```{r}
#| echo: false
table2
```
:::

::: {.column width="40%"}
❎ Cada [**observación está dividido en dos filas**]{.hl-red} → los [**registros con el mismo año deberían ser el mismo**]{.hl-yellow}
:::
:::

. . .

Lo que haremos será lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table3`


```{r}
table3
```


[**¿Qué puede estar fallando?**]{.hl-red}

---

## Separar: separate()

::: columns
::: {.column width="60%"}
```{r}
table3
```
:::

::: {.column width="40%"}
❎ Cada [**celda contiene varios valores**]{.hl-red}
:::
:::

. . .

Lo que haremos será hacer uso de la función `separate()` para mandar [**separar cada valor**]{.hl-yellow} a una columna diferente.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

---

## Separar: separate()

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

Fíjate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deberían ser variables numéricas. Para ello podemos añadir el argumento opcional `convert = TRUE`

. . .

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

---

## Datos SUCIOS: messy data

Veamos el último ejemplo con la tabla `table5`


```{r}
table5
```


[**¿Qué puede estar fallando?**]{.hl-red}

---

## Unir unite()

::: columns
::: {.column width="50%"}
```{r}
table5
```
:::

::: {.column width="50%"}
❎ Tenemos [**mismos valores divididos en dos columnas**]{.hl-red}
:::
:::

. . .

Usaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y año en una misma columna

```{r}
table5 |> unite(col = year_completo, century, year, sep = "")
```

---

## 💻 Tu turno {#tu-turno-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Echa un vistazo a la tabla `relig_income` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused",
               names_to = "income",
               values_to = "people")
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```

:::

---

## 🐣 Caso práctico {#caso-práctico-3b}

En el paquete `{tidyr}` contamos con el dataset `who` (dataset de la Organización Mundial de la Salud)

```{r}
#| eval: false
library(tidyr)
who
```


1. ¿Qué [**significan los datos**]{.hl-yellow}? ¿Cuántas [**variables y observaciones**]{.hl-yellow} tenemos?

```{r}
#| code-fold: true
# ? who
nrow(who)
ncol(who)
```


2. ¿Cuántos [**tipos de variables**]{.hl-yellow} tenemos?

---

## 🐣 Caso práctico {#caso-práctico-3b-1}

3. ¿Todas las variables son necesarias? [**Elimina la información redundante**]{.hl-yellow}.

```{r}
#| code-fold: true
who$iso2 <- NULL
```

Solo necesitamos uno de los códigos ISO

---

## 🐣 Caso práctico {#caso-práctico-3b-2}

4. [**Convierte a tidydata**]{.hl-yellow} la base de datos realizando todas las opciones que consideres (consejo: usa papel y boli para bocetar como debería quedar la base de datos).

Todos empiezan por `new_` (y no hay otro tipo) así que le indicamos al pivotar que los nombres tienen un prefijo a quitar. Además separamos ya entre tipo y sexo-edad (separados por _) y eliminamos ausentes. Tras ello separamos sexo de edad

```{r}
#| code-fold: true
who |>
  pivot_longer(cols = "new_sp_m014":"newrel_f65",
               names_to = c("type", "sex-age"),
               values_to = "cases",
               names_prefix = "new_",
               names_sep = "_",
               values_drop_na = TRUE) |> 
  separate(col = "sex-age", into = c("sex", "age"),
           sep = 1)
```

# Clase 4: import/export, comunicar

[**Importar/exportar datos en R. Comunicar resultados: rmd y Quarto**]{style="color:#444442;"}

---

## Comunicar: rmd y Quarto

Una de las [**principales fortalezas**]{.hl-yellow} de `R` es la [**facilidad para generar informes, libros, webs, apuntes y hasta diapositivas**]{.hl-yellow} (este mismo material por ejemplo). Para ello [**instalaremos**]{.hl-purple} antes

::: columns
::: {.column width="40%"}
-   el paquete `{rmarkdown}` (para generar archivos `.rmd`)

```{r}
#| eval: false
install.packages("rmarkdown")
```

-   instalar [**Quarto**](https://quarto.org/docs/get-started/) (el «nuevo» `.rmd` ahora como `.qmd`)
:::

::: {.column width="60%"}
![](img/quarto.png)
:::
:::

---

## Comunicar: rmd y Quarto

Hasta ahora solo hemos programado en scripts (archivos `.R`) dentro de proyectos, pero en muchas ocasiones [**no trabajaremos solos**]{.hl-yellow} y necesitaremos [**comunicar los resultados**]{.hl-yellow} en diferentes formatos:

-   apuntes (para nosotros mismos)
-   diapositivas
-   web
-   informes

. . .
 
Para todo ello usaremos [**Quarto (nuevo rmarkdown)**]{.hl-yellow}


---

## Comunicar: rmd y Quarto

Los archivos de extensión `.qmd` (o `.rmd`) nos permitirán fácilmente combinar:

-   [**Markdown**]{.hl-yellow}: [**lenguaje tipado**]{.hl-purple} que nos permite crear contenido simple (tipo wordpress, con texto, **negritas**, _cursivas_, etc) con un diseño legible.

. . .

-   [**Matemáticas (latex)**]{.hl-yellow}: lenguaje para escribir notación matemática como $x^2$ o $\sqrt{y}$ o $\int_{a}^{b} f(x) dx$

. . .

-   [**Código y salidas**]{.hl-yellow}: podremos no solo mostrar el paso final sino el código que has ido realizando (no solo en `R`), con [**cajitas de código llamadas chunks**]{.hl-purple}.

. . .

-   Imágenes, [**gráficas**]{.hl-yellow}, tablas, estilos (css, js), etc.

---

## Comunicar: rmd y Quarto

La principal ventaja de realizar este tipo de material en Quarto/Rmarkdown es que, al hacerlo desde `RStudio`, puedes generar un [**informe o una presentación sin salirte del entorno de programación**]{.hl-yellow} en el que estás trabajando

De esta forma podrás analizar los datos, resumirlos y a la vez comunicarlos con la misma herramienta.

. . .

Recientemente el equipo de `RStudio` desarrolló [**Quarto**]{.hl-yellow}, una versión mejorada de Rmarkdown (archivos `.qmd`), con un formato un poco más estético y simple. Tienes toda la documentación y ejemplos en [**https://quarto.org/**](https://quarto.org/)

---

## Nuestro primer informe

::: columns
::: {.column width="55%"}
![](img/quarto-create.png)
:::

::: {.column width="45%"}
Vamos a crear el [**primer fichero rmarkdown con Quarto**]{.hl-yellow} con extensión `.qmd`. Para ello solo necesitaremos hacer click en

`File << New File << Quarto Document`
:::
:::

---

## Nuestro primer informe

:::: columns
::: {.column width="45%"}
![](img/quarto-format.png)
:::

::: {.column width="55%"}
Tras hacerlo nos aparecerán varias [**opciones de formatos de salida**]{.hl-yellow}:

-   archivo `.pdf`
-   archivo `.html` ([**recomendable**]{.hl-yellow}): documento dinámico, permite la interacción con el usuario, como una «página web».
-   archivo `.doc` (nada recomendable)
:::
::::

. . .

De momento dejaremos marcado el [**formato HTML que viene por defecto**]{.hl-yellow}, y escribiremos el [**título**]{.hl-yellow} de nuestro documento. Tras ello tendremos nuestro [**archivo .qmd**]{.hl-yellow} (ya no es un script .R como los que hemos abierto hasta ahora).

---

## Nuestro primer informe

:::: columns
::: {.column width="60%"}
![](img/quarto-example.png)
:::

::: {.column width="40%"}

Deberías tener algo similar a la captura de la imagen con [**dos modos de edición**]{.hl-yellow}: `Source` (con código, la opción recomendada hasta que lo domines) y `Visual` (más parecido a un blog)

:::
::::

Para [**ejecutar TODO el documento**]{.hl-yellow} debes clickar `Render on Save` y darle a guardar.

## Cabecera de un qmd

![](img/quarto-prueba-html.png)

Deberías haber obtenido una [**salida en html similar a esta**]{.hl-yellow} (y se te ha generado en tu ordenador un [**archivo html**]{.hl-yellow})

---

## Nuestro primer informe

:::: columns
::: {.column width="50%"}
![](img/quarto-example.png)

:::

::: {.column width="50%"}

Un fichero `.qmd` se [**divide básicamente en tres partes**]{.hl-yellow}:

* [**Cabecera**]{.hl-yellow}: la parte que tienes al inicio entre `---`.

* [**Texto**]{.hl-yellow}: que podremos formatear y mejorar con negritas (escrito como **negritas**, con doble astérisco al inicio y final), cursivas (_cursivas_, con barra baja al inicio y final) o destacar nombres de funciones o variables de R. Puedes añadir ecuaciones como $x^2$ (he escrito `$x^2$`, entre dólares).

* [**Código R**]{.hl-yellow}

:::
::::

---

## Cabecera de un qmd

La [**cabecera están en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento:

:::: columns
::: {.column width="30%"}
![](img/quarto-cabecera.png)
:::

::: {.column width="70%"}

* `title` y `subtitle`: el título/subtítulo del documento
* `author`: autor del mismo
* `date`: fecha
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes algún archivo de estilos
  * `toc`: si quieres índice o no
  * `toc-location`: posición del índice
  * `toc-title`: título del índice
  * `toc-depth`: profundidad del índice
* `editor`: si estás en modo visual o source.

:::
::::

---

## Texto de un qmd

Respecto a la escritura solo hay una [**cosa importante**]{.hl-yellow}: salvo que indiquemos lo contrario, [**TODO lo que vamos a escribir es texto (normal)**]{.hl-yellow}. No código R.

:::: columns
::: {.column width="35%"}
![](img/quarto-prueba-qmd2.png){width=350}
![](img/quarto-prueba-html2.png){width=320}
:::

::: {.column width="65%"}
Vamos a empezar escribiendo una sección al inicio (`# Intro` y detrás por ej. la frase

> Este material ha sido diseñado por el profesor Javier Álvarez Liébana, docente en la Universidad Complutense de Madrid

Además al `Running Code` le añadiremos una almohadilla `#`: las [**almohadillas FUERA DE CHUNKS**]{.hl-yellow} nos servirán para crear [**epígrafes (secciones)**]{.hl-yellow} en el documento


:::
::::


---

## Índice de un qmd

:::: columns
::: {.column width="40%"}
![](img/quarto-indice-qmd-2.png){width=370}
![](img/quarto-indice-html2.png){width=370}
:::

::: {.column width="60%"}
Para que el [**índice capture dichas secciones**]{.hl-yellow} modificaremos la cabecera del archivo como se observa en la imagen (puedes cambiar la localización del índice y el título si quieres para probar).

:::
::::

---

## Texto en un qmd

Vamos a [**personalizar un poco el texto**]{.hl-yellow} haciendo lo siguiente:


:::: columns
::: {.column width="50%"}
![](img/quarto-texto-mejorado-qmd.png){width=370}
![](img/quarto-texto-mejorado-html.png){width=370}
:::

::: {.column width="50%"}
* Vamos a añadir [**negrita al nombre**]{.hl-yellow} (poniendo ** al inicio y al final).

* Vamos añadir [**cursiva**]{.hl-yellow} a la palabra material (poniendo _ al inicio y al final).

* Vamos añadir un [**enlace**]{.hl-yellow} <https://www.ucm.es>, asociándolo al nombre de la Universidad. Para ello el título lo ponemos entre corchetes y justo detrás el enlace entre paréntesis `[«Universidad Complutense de Madrid»](https://www.ucm.es)`

:::
::::

---

## Código en un qmd

Para [**añadir código R**]{.hl-yellow} debemos crear nuestras [**cajas de código llamadas chunks**]{.hl-yellow}: altos en el camino en nuestro texto markdown donde podremos incluir código de casi cualquier lenguaje (y sus salidas).

&nbsp;

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-qmd.png){width=470}
:::

::: {.column width="50%"}

Para incluir uno deberá de ir [**encabezado**]{.hl-yellow} de la siguiente forma tienes un atajo `Command + Option + I` (Mac) o `Ctrl + Shift + I` (Windows)
:::

::::

---

## Código en un qmd

Dentro de dicha cajita (que tiene ahora otro color en el documento) [**escribiremos código R**]{.hl-yellow} como lo veníamos haciendo hasta ahora en los scripts.

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-1-qmd.png){width=410}
![](img/quarto-chunk-1-html.png){width=410}
:::

::: {.column width="50%"}

 Vamos por ejemplo a definir dos variables y su suma de la siguiente manera, escribiendo dicho código en nuestro `.qmd` (dentro de ese chunk)

```{r}
# Código R
x <- 1
y <- 2
x + y
```

:::

::::


---

## Etiquetando chunks


:::: columns
::: {.column width="50%"}
![](img/quarto-tag-chunks-qmd.png){width=400}
![](img/quarto-tag-chunks-html.png){width=400}
:::

::: {.column width="50%"}
Los chunks pueden tener un [**nombre o etiqueta**]{.hl-yellow}, de forma que podamos referenciarlos de nuevo para no repetir código.
:::
::::


---

## Ejecutando chunks

:::: columns
::: {.column width="40%"}
![](img/quarto-inline-qmd.png){width=400}
![](img/quarto-inline-html.png){width=380}
:::

::: {.column width="60%"}
En cada chunk aparecen [**dos botones**]{.hl-yellow}:

* botón de [**play**]{.hl-yellow}: activa la [**ejecución y salida de ese chunk particular**]{.hl-yellow} (lo puedes visualizar dentro de tu propio `RStudio`)

* botón de [**rebobinar**]{.hl-yellow}: activa la [**ejecución y salida de todos los chunk hasta ese**]{.hl-yellow} (sin llegar a él)

&nbsp;

Además podemos [**incluir código R dentro de la línea de texto**]{.hl-yellow} (en lugar de mostrar el texto x ejecuta el código R mostrando la variable).
:::
::::



---

## Personalización de chunks

Los [**chunks podemos personalizarlos**]{.hl-yellow} con opciones al inicio del chunk precedido de `#|`:

* `#| echo: false`: [**ejecuta código**]{.hl-green} y se [**muestra resultado**]{.hl-green} pero [**no visualiza código**]{.hl-red} en la salida.

* `#| include: false`: [**ejecuta código**]{.hl-green} pero [**no muestra resultado**]{.hl-red} y [**no visualiza código**]{.hl-red} en la salida.

* `#| eval: false`: [**no ejecuta código**]{.hl-red}, [**no muestra resultado**]{.hl-red} pero [**sí visualiza código**]{.hl-green} en la salida.

* `#| message: false`: [**ejecuta código**]{.hl-green} pero [**no muestra mensajes de salida**]{.hl-red}.

* `#| warning: false`: [**ejecuta código**]{.hl-green} pero [**no muestra mensajes de warning**]{.hl-red}.

* `#| error: true`: [**ejecuta código**]{.hl-green} y [**permite que haya errores**]{.hl-green} mostrando el mensaje de error en la salida.


![](img/quarto-options-chunk.png){width=380}

Estas opciones podemos aplicarlas chunk a chunk o fijar los parámetros de forma global con `knitr::opts_chunk$set()` al inicio del documento (dentro de un chunk).

---

## Organizando qmd

Además de texto y código podemos introducir lo siguiente:

* [**Ecuaciones**]{.hl-yellow}: puedes añadir además ecuaciones como $x^2$ (he escrito `$x^2$`, la ecuación entre dólares).

* [**Listas**]{.hl-yellow}: puedes itemizar elementos poniendo `*`

`* Paso 1: ...`

`* Paso 2: ...`

* [**Cross-references**]{.hl-yellow}: puedes etiquetar partes del documento (la etiqueta se construye con `{#nombre-seccion}`) y llamarlas luego con `[Sección](@nombre-seccion)`

---

## Gráficas/imágenes en qmd

:::: columns
::: {.column width="50%"}
![](img/quarto-fig-qmd.png){width=340}
![](img/quarto-fig-html.png){width=390}
:::

::: {.column width="50%"}
Por último, también podemos [**añadir pies de gráficas o imágenes**]{.hl-yellow} añadiendo `#| fig-cap: "..."`
:::
::::

. . .

:::: columns
::: {.column width="65%"}
Fíjate que el [**caption está en el margen**]{.hl-yellow} (por ejemplo). Puedes cambiarlo introduciendo [**ajustes en la cabecera**]{.hl-yellow} (todo lo relativo a figuras empieza por `fig-`, y puedes ver las opciones tabulando). Tienes más información en **<https://quarto.org/>**
:::

::: {.column width="35%"}
![](img/quarto-cabecera-desplegable.png){width=400}
:::
::::

---

## Añadir estilos

:::: columns
::: {.column width="50%"}
![](img/quarto-estilos-qmd.png){width=400}
![](img/quarto-estilos-html.png){width=400}
:::

::: {.column width="50%"}
Por último puedes añadir un [**tema personalizado**]{.hl-yellow} incluyendo un [**archivo de estilos**]{.hl-yellow} (archivo en formato `.scss` o `.css`). Te he dejado uno en <https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material>.

::: callout-important
## Importante

El archivo de estilos debe estar en la misma carpeta que el archivo `.qmd`
:::
:::
::::

---

## 🐣 Caso práctico {#caso-práctico-4a}

Elabora 3 informes `.qmd` tal que


* Crea un archivo por cada uno de los [**3 casos prácticos de los anteriores temas**]{.hl-yellow}, uno por tema

. . .

* En cada uno de ellos haz [**una sección por ejercicio**]{.hl-yellow}

. . .

* [**Detalla todos los pasos**]{.hl-yellow} que consideres mezclando texto, código y salidas

. . .

* Si aparecen medidas estadísticas como la media, [**prueba a meter fórmulas**]{.hl-yellow} con `$$` (busca información de cómo introducir ecuaciones en latex)

. . .

* Para avanzados: investiga las opciones del paquete `{DT}` (con la función `datatable()`) que nos permite [**introducir dentro de los `.qmd` los datos en formato de tabla dinámica**]{.hl-yellow}, permitiendo ordenar y filtrar.


---


## Importar/exportar datos

Hasta ahora solo hemos usado datos cargados ya en paquetes pero muchas veces [**necesitaremos importar datos de manera externa**]{.hl-yellow}. Una de las principales [**fortalezas**]{.hl-yellow} de `R` es que podemos importar datos de manera muy sencilla en distintos formatos:


* [**Formatos nativos de R**]{.hl-yellow}: formatos `.rda`, `.RData` y `.rds`

* [**Datos rectangulares (tabulados)**]{.hl-yellow}: formatos `.csv` y `.tsv`

* [**Datos sin tabular**]{.hl-yellow}: formato `.txt`

* [**Datos en excel**]{.hl-yellow}: formatos `.xls` y `.xlsx`

* [**Datos desde SAS/Stata/SPSS**]{.hl-yellow}: formatos `.sas7bdat`, `.sav` y `.dat`

* [**Datos Google Drive**]{.hl-yellow}

* [**Datos desde API**]{.hl-yellow}: aemet, catastro, twitter, spotify, etc


---

## Formatos nativos de R

Los [**ficheros más simples**]{.hl-yellow} para importar en `R` (y que suele ocupar menos espacio en disco) son sus propias [**extensiones nativas**]{.hl-yellow}: archivos con formatos `.RData`, `.rda` y `.rds`. Para cargar los primeros simplemente necesitamos [**usar la función nativa**]{.hl-yellow} `load()` indicándole la ruta del archivo.

* Archivo `.RData`: vamos a importar un dataset con las distintas características de los [**viajeros del Titanic**]{.hl-purple}, incluyendo quién sobrevivió y quién murió.


```{r}
#| eval: false
load("./datos/titanic.RData")
as_tibble(titanic)
```

```{r}
#| echo: false
library(tidyverse)
load("./datos/titanic.RData")
as_tibble(titanic) |> slice(1:5)
```


---

## Formatos nativos de R


* Archivo `.rda`: vamos a importar un dataset con [**datos de cáncer de pecho**]{.hl-purple} de [**Royston and Altman (2013)**](https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/1471-2288-13-33), incluyendo 2982 pacientes y sus características


```{r}
#| eval: false
load("./datos/rotterdam_breast_cancer.rda")
as_tibble(rotterdam)
```

```{r}
#| echo: false
library(tidyverse)
load("./datos/rotterdam_breast_cancer.rda")
as_tibble(rotterdam) |> slice(1:7)
```


---

## Formatos nativos de R

* Archivo `.rds`: para este tipo debemos usar `readRDS()`, y necesitamos incorporar un [**argumento `file`**]{.hl-yellow} con la ruta. En este caso vamos a importar [**datos de cáncer de pulmón**]{.hl-purple} del North Central Cancer Treatment Group.

```{r}
#| eval: false
lung_cancer <-
  readRDS(file = "./datos/NCCTG_lung_cancer.rds") |> as_tibble()
```

```{r}
#| echo: false
lung_cancer <-
  readRDS(survival::cancer, file = "./datos/NCCTG_lung_cancer.rds") |> 
  as_tibble()
lung_cancer |> slice(1:5)
```

::: callout-important

## Importante

Las [**rutas**]{.hl-yellow} deben ir siempre [**sin espacios, ni eñes, ni tildes**]{.hl-yellow}. Y fíjate que los archivos cargados con `load()` se cargan automáticamente en el environment (con el nombre guardado originalmente), pero las funciones `read()` solo se carga de manera local (sino se guarda, no existe a futuro)

:::

---

## Datos rectangulares: readr

El paquete `{readr}` dentro del entorno `{tidyverse}` contiene distintas funciones útiles para la [**carga de datos rectangulares (sin formatear)**]{.hl-yellow}.

:::: columns
::: {.column width="50%"}

* `read_csv()`: archivos `.csv` cuyo [**separador sea la coma**]{.hl-purple}
* `read_csv2()`: [**punto y coma**]{.hl-purple}
* `read_tsv()`: [**tabulador**]{.hl-purple}.
* `read_table()`: [**espacio**]{.hl-purple}.
* `read_delim()`: función genérica para [**archivos delimitados por caracteres**]{.hl-purple}.


:::

::: {.column width="50%"}

![](img/data-import-readr.png)
:::
::::

Todos necesitan como **argumento la ruta del archivo** amén de **otros opcionales** (saltar o no cabecera, decimales, etc). Ver más en <https://readr.tidyverse.org/>

---

## Datos tabulados (.csv, .tsv)

La principal ventaja de `{readr}` es que [**automatiza el formateo**]{.hl-yellow} para pasar de un archivo plano (sin formato) a un tibble (en filas y columnas, con formato).

. . .

* Archivo `.csv`: con `read_csv()` cargaremos archivos [**separados por coma**]{.hl-purple}, pasando como [**argumento la ruta**]{.hl-yellow} en `file = ...`. Vamos a importar el dataset `chickens.csv` (sobre pollos de dibujos animados, why not). Si te fijas en la salida nos proporciona el tipo de variables.

```{r}
library(readr)
chickens <- read_csv(file = "./datos/chickens.csv")
chickens
```

---

## Datos tabulados (.csv, .tsv)


El [**formato de las variables**]{.hl-yellow} normalmente lo hará `read_csv()` de forma [**automática**]{.hl-yellow}, y podemos consultarlo con `spec()`

```{r}
spec(chickens)
```

---

## Datos tabulados (.csv, .tsv)

Aunque lo haga normalmente bien de forma automática podemos [**especificar el formato explícitamente**]{.hl-yellow} en `col_types = list()` (en formato lista, con `col_xxx()` para cada tipo de variable, por ejemplo una la pondremos como cualitativa o factor). Incluso podemos indicar que [**variables que queremos seleccionar**]{.hl-yellow} (sin ocupar memoria), indicándoselo en `col_select = ...`


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_types = list(col_character(), col_factor(), col_double(), col_character()),
           col_select = c(chicken, sex, eggs_laid))
chickens
```



---


## Datos sin tabular (.txt)

¿Qué sucede cuando el [**separador no es el correcto**]{.hl-red}?

. . .

Si usamos `read_csv()` espera que el separador entre columnas sea una coma pero, como puedes ver con el siguiente `.txt`, nos interpreta todo como una sola columna: [**no tiene comas y no sabe por donde separar**]{.hl-yellow}

```{r}
datos_txt <- read_csv(file = "./datos/massey-rating.txt")
dim(datos_txt)
as_tibble(datos_txt)
```


---

## Datos sin tabular (.txt)

Para ello tenemos

* `read_csv2()` cuando el [**separador sea el punto y coma**]{.hl-yellow}, `read_tsv()` cuando el [**sea un tabulador**]{.hl-yellow} y `read_table()` cuando el [**sea un espacio**]{.hl-yellow}

* `read_delim()` en general

```{r}
datos_txt <- read_table(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```


---

## Datos en excel (.xls, .xlsx)

Otro de los paquetes fundamentales de importación será el paquete  `{readxl}` para [**importar datos desde una Excel**]{.hl-yellow}. Tres funciones serán claves:

* `read_xls()` específica para `.xls`, `read_xlsx()` específica para `.xlsx`
* `read_excel()`: para ambas

. . .

Vamos a importar `deaths.xlsx` con registros de fallecimientos de famosos

```{r}
#| eval: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths |> slice(1:8)
```

---

## Datos en excel (.xls, .xlsx)


```{r}
#| eval: false
deaths
```

```{r}
#| echo: false
deaths |> slice(1:8)
```

Algo por [**desgracia muy habitual**]{.hl-yellow} es que haya algún tipo de comentario o texto al inicio del archivo, teniendo que [**saltarnos dichas filas**]{.hl-yellow}.

---

## Datos en excel (.xls, .xlsx)

Podemos [**saltarnos dichas filas**]{.hl-yellow} directamente en la carga con `skip = ...` (indicando el número de filas que nos saltamos)

```{r}
#| eval: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths |> slice(1:5)
```

---

## Datos en excel (.xls, .xlsx)

Además con `col_names = ...` podemos renombrar ya las columnas en la importación (si [**proporcionamos nombres asume la 1ª línea ya como un dato**]{.hl-yellow})

```{r}
#| eval: false
#| code-line-numbers: "3"
deaths <-
  read_xlsx(path = "./datos/deaths.xlsx",
            skip = 5,
            col_names = c("name", "profession", "age", "kids", "birth", "death"))
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 5,
                    col_names = c("name", "profession", "age", "kids", "birth", "death"))
deaths |> slice(1:7)
```
        
---

## Datos en excel (.xls, .xlsx)


En ocasiones las [**fechas de Excel están mal formateadas**]{.hl-red} (sorpresa): podemos hacer uso de `convertToDate()` del paquete `{openxlsx}` para convertirlo


```{r}
#| eval: false
library(openxlsx)
deaths$death <- convertToDate(deaths$death)
deaths
```
   
```{r}
#| echo: false
library(openxlsx)
deaths$death <- convertToDate(deaths$death)
deaths |> slice(1:7)
```

---

## Datos en excel (.xls, .xlsx)

También podemos [**cargar un Excel con varias hojas**]{.hl-yellow}: para [**indicarle la hoja**]{.hl-yellow} (bien por su nombre bien por su número) usaremos el argumento `sheet = ...`

```{r}
#| eval: false
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars
```


```{r}
#| echo: false
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars |> slice(1:5)
```


. . .
 
Incluso podemos indicar el [**rango de celdas**]{.hl-yellow} a cargar con `range = ...`

```{r}
iris <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "iris", range = "C1:E4")
iris
```



---

## Desde SAS/STATA/SPSS

El paquete `{haven}` dentro de la órbita tidyverse nos permitirá [**importar archivos de los 3 software de pago más importantes**]{.hl-yellow}: SAS, SPSS y Stata

```{r}
library(haven)

# SAS
iris_sas <- read_sas(data_file = "./datos/iris.sas7bdat")

# SPSS
iris_spss <- read_sav(file = "./datos/iris.sav")

# Stata
iris_stata <- read_dta(file = "./datos/iris.dta")
```

---

## Exportar

De la misma manera que podemos importar también podemos [**exportar**]{.hl-yellow}

* exportado en `.RData` (opción recomendada para variables guardadas en `R`). Recuerda que esta extensión [**solo se podrá usar en `R`**]{.hl-yellow}. Para ello nos basta con usar `save(objeto, file = ruta)`

```{r}
tabla <- tibble("a" = 1:4, "b" = 1:4)
save(tabla, file = "./datos/tabla_prueba.RData")
rm(tabla) # eliminar
load("./datos/tabla_prueba.RData")
tabla
```


---

## Exportar

De la misma manera que podemos importar también podemos [**exportar**]{.hl-yellow}

* exportado en `.csv`. Para ello nos basta con usar `write_csv(objeto, file = ruta)`

```{r}
write_csv(tabla, file = "./datos/tabla_prueba.csv")
read_csv(file = "./datos/tabla_prueba.csv")
```

---

## Desde web

Una de las principales ventajas de `R` es que podemos hacer uso de todas las funciones anteriores de [**importar pero directamente desde una web**]{.hl-yellow}, sin necesidad de realizar la descarga manual: en lugar de pasarle la ruta local le indicaremos el [**enlace**]{.hl-yellow}. Por ejemplo, vamos a descargar los datos de covid del ISCIII (<https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>)


```{r}
#| eval: false
covid_datos <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv", n_max = 700)
covid_datos
```

---

## Desde google drive

Otra opción disponible (sobre todo si trabajamos con otras personas que trabajan) es [**importar desde una hoja de cálculo Google Drive**]{.hl-yellow}, haciendo uso de `read_sheet()` del paquete `{googlesheets4}`

La primera vez te pedirá un permiso de tidyverse para interactuar con vuestro drive

```{r}
#| eval: false
library(googlesheets4)
google_sheet <-
  read_sheet("https://docs.google.com/spreadsheets/d/1n_UTbD93-oDJR2r-rsMNff5ro147NL_ZN_vYIA2eJ3Q/edit?usp=sharing")
google_sheet
```

---

## Desde API (owid)

Una opción también muy interesante es la [**carga de datos desde una API**]{.hl-yellow}: un intermediario entre una app o proveedor datos y nuestro `R`. Por ejemplo, vamos a cargar la librería `{owidR}`, que nos permite la descarga de datos de la web <https://ourworldindata.org/>. La función `owid_covid()` nos carga sin darnos cuenta más de 300 000 registros con más de 50 variables de 238 países

```{r}
#| eval: false
library(owidR)
owid_covid()
```

```{r}
#| echo: false
#| eval: false
library(owidR)
owid_covid() |> slice(1:5)
```

---

## Desde API (owid)

Este paquete tiene la función `owid_search()` para buscar datasets por palabras clave, por ejemplo, `emissions`, dándonos un dataset con el título de la base de datos y su id para luego usarla.

```{r}
#| eval: false
as_tibble(owid_search("emissions"))
```

```{r}
#| echo: false
#| eval: false
as_tibble(owid_search("emissions")) |> slice(1:4)
```

. . .

Vamos a pedirle por ejemplo las [**emisiones de la oecd**]{.hl-yellow}

```{r}
#| eval: false
owid("emissions-of-air-pollutants-oecd")
```

```{r}
#| echo: false
#| eval: false
owid("emissions-of-air-pollutants-oecd") |> slice(1:5)
```

---

## Desde API (aemet)

En muchas ocasiones para conectar con la API tendremos antes que [**registrarnos y obtener una clave**]{.hl-yellow}, es el caso del paquete `{climaemet}` para acceder a datos meteorológicos (<https://opendata.aemet.es/centrodedescargas/inicio>)


Una vez que tenemos la clave de la API la registramos en nuestro RStudio para poder usarla a futuro


```{r}
#| eval: false
library(climaemet)

# Definir la clave
apikey <- "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqYXZhbHYwOUB1Y20uZXMiLCJqdGkiOiI4YTU1ODUxMS01MTE3LTQ4MTYtYmM4OS1hYmVkNDhiODBkYzkiLCJpc3MiOiJBRU1FVCIsImlhdCI6MTY2NjQ2OTcxNSwidXNlcklkIjoiOGE1NTg1MTEtNTExNy00ODE2LWJjODktYWJlZDQ4YjgwZGM5Iiwicm9sZSI6IiJ9.HEMR77lZy2ASjmOxJa8ppx2J8Za1IViurMX3p1reVBU"

aemet_api_key(apikey, install = TRUE)
```


```{r}
#| echo: false
library(climaemet)
```

--- 

## Desde API (aemet)


Con dicho paquete podemos hacer una [**búsqueda de estaciones**]{.hl-yellow} para conocer tanto su código postal como su código identificador dentro de la red AEMET (por ejemplo, la estación del aeropuerto de El Prat, Barcelona, es el código `"0076"`)

```{r}
#| eval: false
stations <- aemet_stations()
stations
```

```{r}
#| echo: false
#| eval: false
stations <- aemet_stations()
stations |> slice(1:4)
```

```{r}
#| eval: false
aemet_last_obs("0076")
```

```{r}
#| echo: false
#| eval: false
aemet_last_obs("0076") |> slice(1:4)
```

---

## Desde API (catastro)

También puedes conectar con la [**API del catrastro**]{.hl-yellow} y buscar por ejemplo por coordenadas

```{r}
#| eval: false
library(CatastRo)
catr_ovc_get_rccoor(lat = 38.61965, lon = -3.45624, srs = "4230")
```


---


## 💻 Tu turno {#tu-turno-4}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 El dataset `who` que hemos usado en ejercicios anteriores, expórtalo a un formato nativo de `R` en la carpeta `datos` del proyecto

```{r}
#| code-fold: true
#| eval: false
library(tidyr)
save(who, file = "./datos/who.RData")
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Carga el dataset `who` pero desde la carpeta de datos (importa el archivo creado en el ejercicio anterior)

```{r}
#| code-fold: true
#| eval: false
load("./datos/who.RData")
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Repite lo mismo (exportar e importar) en 4 formatos: `.csv`, `.xlsx`, `.sav` (spss) y `.dta` (stata)

```{r}
#| code-fold: true
#| eval: false

# csv
library(readr)
write_csv(who, file = "./datos/who.csv")
who_data <- read_csv(file = "./datos/who.csv")

# excel
library(openxlsx)
write.xlsx(who, file = "./datos/who.xlsx")
who_data <- read_xlsx(path = "./datos/who.xlsx")

# sas y stata
library(haven)
write_sav(who, path = "./datos/who.sav")
who_data <- read_spss(path = "./datos/who.sav")

write_dta(who, path = "./datos/who.dta")
who_data <- read_dta(path = "./datos/who.dta")
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Repite la carga del `who.csv` pero solo selecciona ya en la carga las 4 primeras columnas

```{r}
#| code-fold: true
#| eval: false
who_select <-
  read_csv(file = "./datos/who.csv",
           col_select = c("country", "iso2", "iso3", "year"))
```


:::

---

## 🐣 Caso práctico {#caso-práctico-4b}


En la carpeta de datos tienes el dataset `breast-cancer-wisconsin-data.csv`. Crea un archivo `.qmd` y personalízalo incluyendo lo siguiente:

1. Importa el archivo csv a un `tibble`. ¿Es tidydata? ¿Cuántos pacientes y variables tenemos?

```{r}
#| code-fold: true
datos <- read_csv(file = "./datos/breast-cancer-wisconsin-data.csv")
datos
```

---

## 🐣 Caso práctico {#caso-práctico-4b-1}


2. El dataset representa datos de cáncer de pecho (`id` identificador, `diagnosis` el diagnóstico maligno/benigno y el resto propiedades del tumor). Usando SOLO LO APRENDIDO, ¿qué % tenían un tumor maligno y qué % uno benigno?

```{r}
#| code-fold: true
100 * sum(datos$diagnosis == "M") / nrow(datos)
100 * sum(datos$diagnosis == "B") / nrow(datos)
```

. . .

3. ¿Cuál de los dos tipos de tumores tienen, de media, un radio más elevado? 

```{r}
#| code-fold: true
mean_M <- mean(datos$radius_mean[datos$diagnosis == "M"], na.rm = TRUE)
mean_B <- mean(datos$radius_mean[datos$diagnosis == "B"], na.rm = TRUE)
```

---

## 🐣 Caso práctico {#caso-práctico-4b-1}


4. Busca la ayuda de la función `t.test()`. Dicha función nos permite contrastar si la media de dos distribuciones son o no iguales. ¿Podemos rechazar la hipótesis nula de que la media del radio sea la misma, bajo una significancia de $\alpha = 0.05$?

```{r}
#| code-fold: true
datos_M <- datos$radius_mean[datos$diagnosis == "M"]
datos_B <- datos$radius_mean[datos$diagnosis == "B"]
t.test(datos_M, datos_B, conf.level = 0.95)
```

Sí, podemos rechazar.

# Clase 5: tidyverse (filas) {#clase-5-tidyverse-filas}

[**Operaciones con filas**]{style="color:#444442;"}

---

## ¿Qué es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: [**gramática para depurar**]{.hl-yellow}
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualización de datos
-   `{tidymodels}`: modelización/predicción
:::
:::

También tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.


---

## Preprocesamiento: dplyr

Dentro de `{tidyverse}` usaremos el paquete `{dplyr}` para el [**preprocesamiento y depuración**]{.hl-yellow} de datos de datos.

::: columns
::: {.column width="60%"}
![](img/dplyr.png){width=450}
:::

::: {.column width="40%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::
:::

La idea es que el [**código sea legible**]{.hl-yellow}, como si fuese una lista de instrucciones que al leerla nos diga de manera muy evidente lo que está haciendo.

---

## Hipótesis: tidydata

::: columns
::: {.column width="50%"}
Toda la depuración que vamos a realizar es sobre la [**hipótesis de que nuestros datos están en tidydata**]{.hl-yellow}
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
::::

Recuerda que en `{tidyverse}` será clave el [**operador pipe (tubería)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): será una [**tubería que recorre los datos**]{.hl-yellow} y los transforma.

. . .

Vamos a practicar con el dataset `starwars` del paquete cargado `{dplyr}`

```{r}
#| eval: false
library(tidyverse)
starwars
```

---


## Muestreo

:::: columns
::: {.column width="60%"}

Una de las operaciones más comunes es lo que se conoce en estadística como [**muestreo**]{.hl-yellow}: una [**selección o filtrado de registros**]{.hl-yellow} (una submuestra)

:::

::: {.column width="40%"}

![](img/muestreo.jpeg){width=500}
:::
::::

. . .


* [**No aleatorio (por cuotas)**]{.hl-purple}: en base a condiciones lógicas sobre los registros (`filter()`)

. . .

* [**No aleatorio (intencional/discreccional)**]{.hl-purple}: en base a posición (`slice()`)

. . .

* [**Aleatorio simple**]{.hl-purple} (`slice_sample()`)

. . .

* [**Aleatorio estratificado**]{.hl-purple} (`group_by()` + `slice_sample()`)


---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

El más simple es cuando [**filtramos registros**]{.hl-yellow} en base a alguna condición lógica: con `filter()` se seleccionarán solo individuos que cumplan ciertas condiciones (muestreo no aleatorio por condiciones)


::: incremental
-   `==`, `!=`: [**igual**]{.hl-purple} o [**distinto**]{.hl-yellow} que (`|> filter(variable == "a")`)
-   `>`, `<`: [**mayor**]{.hl-purple} o [**menor**]{.hl-yellow} que (`|> filter(variable < 3)`)
-   `>=`, `<=`: [**mayor o igual**]{.hl-yellow} o [**menor o igual**]{.hl-purple} que (`|> filter(variable >= 5)`)
-   `%in%`: valores [**pertenencen**]{.hl-yellow} a un listado de opciones (`|> filter(variable %in% c("azul", "verde"))`)
-   `between(variable, val1, val2)`: si los valores (continuos) [**caen dentro de un rango**]{.hl-yellow} de valores (`|> filter(between(variable, 160, 180))`)
:::

---

## Filtrar filas: filter()

Dichas [**condiciones lógicas**]{.hl-yellow} las podemos [**combinar**]{.hl-yellow} de diferentes maneras (y, o, o excluyente)

![](img/tablas_verdad.png)

. . .


::: callout-tip
## Importante

Recuerda que dentro de `filter()` debe ir siempre algo que devuelva un [**vector de valores lógicos**]{.hl-green}.
:::

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¿Cómo harías para... [**filtrar**]{.hl-yellow} los personajes de [**ojos marrones**]{.hl-purple}?

. . .

[**¿Qué tipo de variable es?**]{.hl-yellow} --> La variable `eye_color` es cualitativa así que está representada por textos

. . .

```{r}
#| echo: false
#| include: false
library(tidyverse)
```

```{r}
starwars |>
  filter(eye_color == "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¿Cómo harías para... [**filtrar**]{.hl-yellow} los personajes que [**no tienen ojos marrones**]{.hl-purple}?

. . .


```{r}
starwars |>
  filter(eye_color != "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¿Cómo harías para ... [**filtrar**]{.hl-yellow} los personajes que [**tengan los ojos marrones o azules**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color %in% c("blue", "brown"))
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Fíjate que `%in%` es equivalente a concatenar varios `==` con una conjunción o (`|`)

```{r}
starwars |>
  filter(eye_color == "blue" | eye_color == "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¿Cómo harías para ... [**filtrar**]{.hl-yellow} los personajes que [**midan entre 120 y 160 cm**]{.hl-purple}?

. . .

[**¿Qué tipo de variable es?**]{.hl-yellow} --> La variable `height` es cuantitativa continua así que deberemos filtrar por rangos de valores (intervalos) --> usaremos `between()`

. . .

```{r}
starwars |>
  filter(between(height, 120, 160))
```


---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color == "brown" & species != "Human")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos, o que tengan más de 60 años**]{.hl-purple}? Piénsalo bien: los [**paréntesis son importantes**]{.hl-yellow}: no es lo mismo $(a+b)*c$ que $a+(b*c)$

. . .

```{r}
starwars |>
  filter((eye_color == "brown" & species != "Human") | birth_year > 60)
```

---

## Eliminar ausentes: drop_na()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  retirar_ausentes(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(var1, var2, ...)
```
:::
:::

Hay un filtro especial para una de las operaciones más habituales en depuración: [**retirar los ausentes**]{.hl-yellow}. Para ello podemos usar dentro de un filtro `is.na()`, que nos devuelve `TRUE/FALSE` en función de si es ausente, o bien ...

. . .

Usar `drop_na()`: si no indicamos variable, elimina registros con ausente en cualquier variable. Más adelante veremos como [**imputar esos ausentes**]{.hl-yellow} 

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(mass, height)
```

```{r}
#| echo: false
starwars |>
  drop_na(mass, height, sex) |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na()
```

```{r}
#| echo: false
starwars |>
  drop_na() |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::
:::

---

## 💻 Tu turno {#tu-turno-7a}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 Selecciona del conjunto de starwars solo los personajes que sean androides o cuyo valor en `species` sea desconocido

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Droid" | is.na(species))
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Selecciona del conjunto de starwars solo los personajes cuyo peso esté entre 65 y 90 kg.

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(between(mass, 65, 90))
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Tras limpiar de ausentes en todas las variables, selecciona del conjunto de starwars solo los personajes que sean humanos y que vengan de Tatooine

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na() |> 
  filter(species == "Human" & homeworld == "Tatooine")
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Selecciona del conjunto original de starwars los personajes no humanos, `male` en el sexo y que midan entre 120 y 170 cm, o los personajes con ojos marrones o rojos.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter((species != "Human" & sex == "male" &
            between(height, 120, 170)) |
           eye_color %in% c("brown", "red"))
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Busca información en la ayuda de la función `str_detect()` del paquete `{stringr}` (cargado en `{tidyverse}`). Consejo: prueba antes las funciones que vayas a usar con algún vector de prueba para poder comprobar su funcionamiento. Tras saber lo que hace, filtra solo aquellos personajes con apellido `Skywalker`

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(str_detect(name, "Skywalker"))
```
:::

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice(posiciones)
```
:::
:::

A veces nos puede interesar realizar un [**muestreo no aleatorio discreccional**]{.hl-yellow}, o lo que es lo mismo, [**filtrar por posición**]{.hl-yellow}: con `slice(posiciones)` podremos seleccionar filas concretas pasando como argumento un [**vector de índices**]{.hl-yellow}

. . .

::: columns
::: {.column width="50%"}
```{r}
#| eval: false

# fila 1
starwars |>
  slice(1)
```

```{r}
#| echo: false
starwars |> slice(1) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false

# filas de la 7 a la 9
starwars |>
  slice(7:9)
```

```{r}
#| echo: false
starwars |> slice(7:9) |> select(name:hair_color)
```
:::
:::

. . .

```{r}
#| eval: false

# filas 2, 7, 10 y 31
starwars |>
  slice(c(2, 7, 10, 31))
```

```{r}
#| echo: false
starwars |>
  slice(c(2, 7, 10, 31)) |> select(name:sex)
```

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(posiciones)
```
:::
:::

Disponemos de opciones por defecto:

* con `slice_head(n = ...)` y `slice_tail(n = ...)` podemos obtener la [**cabecera y cola**]{.hl-yellow} de la tabla

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_head(n = 2)
```

```{r}
#| echo: false
starwars |> slice_head(n = 2) |> select(name:hair_color)
```
:::

::: {.column width="\"50%"}
```{r}
#| eval: false
starwars |> slice_tail(n = 2)
```

```{r}
#| echo: false
starwars |> slice_tail(n = 2) |> select(name:hair_color)
```
:::
:::

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(posiciones)
```
:::
:::

Disponemos de opciones por defecto:

* con `slice_max()` y `slice_min()` obtenemos la [**filas con menor/mayor valor de una variable**]{.hl-yellow} (si empate, todas salvo que `with_ties = FALSE`) que indicamos en `order_by = ...`

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_min(mass, n = 2)
```

```{r}
#| echo: false
starwars |> slice_min(n = 2, order_by = mass) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_max(height, n = 2)
```

```{r}
#| echo: false
starwars |> slice_max(n = 2, order_by = height) |> select(name:hair_color)
```
:::
:::

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

El conocido como [**muestreo aleatorio simple**]{.hl-yellow} se basa en [**seleccionar individuos aleatoriamente**]{.hl-yellow}, de forma que cada uno tenga ciertas [**probabilidades**]{.hl-yellow} de ser seleccionado. Con `slice_sample(n = ...)` podemos extraer n registros aleatoriamente (a priori equiprobables).

```{r}
starwars |> slice_sample(n = 2)
```

. . .

::: callout-important
## Importante...

[**«Aleatorio» no implica equiprobable**]{.hl-yellow}: es igual de aleatorio un dado normal que uno trucado. No hay cosas «más aleatorias» que otras, simplemente tienen subyacente distintas leyes de probabilidad.

:::

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

También podremos indicarle la [**proporción de datos a samplear**]{.hl-yellow} (en lugar del número) y si queremos que sea [**con reemplazamiento (que se puedan repetir)**]{.hl-yellow}.

```{r}
# 5% de registros aleatorios con reemplazamiento
starwars |> 
  slice_sample(prop = 0.05, replace = TRUE)

```


---


## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

Como decíamos, «aleatorio» no es igual que «equiprobable», así que podemos pasarle un [**vector de probabilidades**]{.hl-yellow}. Por ejemplo, vamos a forzar que sea muy improbable sacar una fila que no sean las dos primeras

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

. . .

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

---

## Paréntesis: sample()

La función `slice_sample()` es simplemente una integración de `{tidyverse}` de la función básica de `R` conocida como `sample()` que nos permite [**muestrear elementos**]{.hl-yellow}

. . .

Por ejemplo, vamos a [**muestrear 10 tiradas de un dado**]{.hl-yellow}, indicándole

- [**soporte**]{.hl-purple} de nuestra variable aleatorio (valores permitidos en `x`)
- [**tamaño**]{.hl-purple} muestral (`size`)
- [**reemplazamiento**]{.hl-purple} (si `TRUE` entonces pueden salir repetidas, como en el caso del dado)

```{r}
sample(x = 1:6, size = 10, replace = TRUE)
```

---

## Paréntesis: sample()

La opción anterior lo que genera son sucesos de una variable aleatoria [**equiprobable**]{.hl-yellow} pero al igual que antes, podemos asignarle un vector de probabilidades o [**función de masa**]{.hl-yellow} concreta con el argumento  `prob = ...`

```{r}
sample(x = 1:6, size = 50, replace = TRUE,
       prob = c(0.5, 0.2, 0.1, 0.1, 0.05, 0.05))
```

---


## Paréntesis: sample()

**¿Cómo harías el siguiente enunciado?**

&nbsp;

Supongamos que en una ciudad se han estudiado episodios de gripe estacional. Sean las variables aleatorias $X_m$ y $X_p$ tal que $X_m=1$ si la madre tiene gripe, $X_m=0$ si la madre no tiene gripe, $X_p=1$ si el padre tiene gripe y $X_p=0$ si el padre no tiene gripe. El modelo teórico asociado a este tipo de epidemias indica que la distribución conjunta viene dada por $P(X_m = 1, X_p=1)=0.02$, $P(X_m = 1, X_p=0)=0.08$, $P(X_m = 1, X_p=0)=0.1$ y $P(X_m = 0, X_p=0)=0.8$

**Genera una muestra** de tamaño $n = 1000$ (soporte `"10"`, `"01"`, `"00"` y `"11"`) haciendo uso de `runif()` y haciendo uso de `sample()`

---

## 💻 Tu turno {#tu-turno-7b}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Selecciona solo los personajes que sean humanos y de ojos marrones, para después ordernarlos en altura descendente y peso ascendente.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(eye_color == "brown" & species == "Human") |> 
  arrange(height, desc(mass))
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Extrae 3 registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(n = 3)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Extrae el 10% de los registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(prop = 0.1)
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Extrae aleatoriamente 10 personajes pero de forma que la probabilidad de que salga cada uno sea proporcional a su peso (más pesados, más probable)

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass) |> 
  slice_sample(n = 10, weight_by = mass)
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Selecciona los 3 personajes más mayores.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_max(birth_year, n = 3)
```


:::



# Clase 6: entrega I {#entrega-i}

[**Primera entrega individual en clase**]{style="color:#444442;"}

---

## Ejercicios previos

[**Ejercicios recomendables para practicar antes de la práctica**]{.hl-yellow} y conocer el dataset en cuestión.


Realiza la importación de los [datos de covid del ISCIII](https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv) directamente desde la web (archivo `casos_hosp_uci_def_sexo_edad_provres.csv`) incluyendo todas las filas pero cargando solo las columnas `provincia_iso`, `sexo`, `grupo_edad`, `fecha` y `num_casos`.

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Determina el tipo de dato es cada variable importada

### [**Ejercicio 2**]{.hl-yellow}

📝 ¿Cuántas observaciones tenemos?

### [**Ejercicio 3**]{.hl-yellow}

📝 Renombra el nombre de las variables al inglés

### [**Ejercicio 4**]{.hl-yellow}

📝 ¿Podemos convertir el dataset a una matriz? Argumenta e ilustra el por qué sí o no.

### [**Ejercicio 5**]{.hl-yellow}

📝 Crea una nueva variable (fuera de la base de datos) que nos diga el número de días que han pasado de cada registro respecto a hoy.

:::

---

## Entrega I (27/09/2023)

Se actualizará al inicio de la clase correspondiente.

::: callout-important

## Importante

Esta [**entrega ponderará un 10% en la nota final**]{.hl-green}

Podrás [**usar todo el material del curso e internet**]{.hl-yellow} salvo cualquier aplicación de mensajería o sistema de comunicación: en caso de tener alguna abierta a lo largo de la entrega, aunque no se esté usando, deberás [**abandonar la entrega y contará como un 0**]{.hl-red}.

Contarás con aproximadamente 1 hora y 50 minutos, pero [**deberás realizar la entrega**]{.hl-yellow}, como tarde, a las [**18:00**]{.hl-yellow}. Será [**obligatorio subir tanto el `.qmd` como el `.html`**]{.hl-yellow}: una entrega que no haya podido ser renderizada (es decir, con errores graves) será [**penalizada contando solo un 65% de la nota obtenida**]{.hl-red} (si la entrega es perfecta, la nota máxima será un 6.5 sino se adjunta el `.html` generado).

Te recomiendo practicar bastante y preguntar dudas en clase y/o tutoría ya que [**irás justo de tiempo**]{.hl-yellow}, así que necesitas fluidez en los ejercicios.

Si usas un [**pc de la biblioteca**]{.hl-yellow} asegúrate de tomarlo con suficiente antelación para [**instalar todas las librerías necesarias antes de empezar**]{.hl-yellow} para no perder tiempo.

:::



# Clase 7: tidyverse (filas y columnas) {#clase-7-tidyverse-columnas}

[**Operaciones con columnas**]{style="color:#444442;"}

---


## Reordenar filas: arrange()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> ordenar(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(var1, var2, ...)
```
:::
:::

También podemos [**ordenar filas**]{.hl-yellow} en función de alguna variable con `arrange()`

```{r}
#| eval: false
starwars |> arrange(mass)
```

```{r}
#| echo: false
starwars |> arrange(mass) |> select(name:eye_color) |> slice(1:5) 
```

. . .

Por [**defecto de menor a mayor**]{.hl-yellow} pero podemos [**invertir el orden**]{.hl-purple} con `desc()`

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(desc(height))
```

```{r}
#| echo: false
starwars |> arrange(desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(mass, desc(height))
```

```{r}
#| echo: false
starwars |> arrange(mass, desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::
:::

---

## Eliminar duplicados: distinct()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> sin_duplicados(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> distinct(var1, var2, ...)
```
:::
:::

Muchas veces necesitaremos asegurarnos que no hay duplicados en alguna variable (DNI) y podemos [**eliminar filas duplicadas**]{.hl-yellow} con `distinct()`.

```{r}
starwars |> distinct(sex)
```

. . .

Para mantener todas las columnas de la tabla usaremos `.keep_all = TRUE`.

```{r}
#| eval: false
starwars |> distinct(sex, .keep_all = TRUE)
```

```{r}
#| echo: false
starwars |> distinct(sex, .keep_all = TRUE) |> slice(1:3)
```

---

## Añadir filas: bind_rows()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> encuadernar_filas(tibble2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> bind_rows(tibble2)
```
:::
:::

Por último, podemos [**concatenar nuevas filas**]{.hl-yellow} con `bind_rows()` con [**las nuevas observaciones en tabla**]{.hl-red} (si no cuadran columnas rellena con ausentes)

```{r}
datos <-
  tibble("nombre" = c("javi", "laura"), "edad" = c(33, 50))
datos
```

. . .

```{r}
datos |> bind_rows(tibble("nombre" = c("carlos", NA), "cp" = c(28045, 28019)))
```

---

## 💻 Tu turno {#tu-turno-7c}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Para saber que valores únicos hay en el color de pelo, elimina duplicados de la variable `hair_color`, eliminando antes los ausentes de dicha variable.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(hair_color) |> 
  distinct(hair_color)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 De los personajes que son humanos y miden más de 160 cm, elimina duplicados en color de ojos, elimina ausentes en peso, selecciona los 3 más altos, y orden de mayor a menor peso. Devuelve la tabla.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Human" & height > 160) |> 
  distinct(eye_color, .keep_all = TRUE) |> 
  drop_na(mass) |> 
  slice_max(height, n = 3) |> 
  arrange(desc(mass))
```
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantísimo que el código se entienda, por nuestro yo el futuro pero también por la [**transparencia algorítmica**]{.hl-yellow} hacia los demás

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 más altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "2"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "2"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantísimo que el código se entienda, por nuestro yo el futuro pero también por la [**transparencia algorítmica**]{.hl-yellow} hacia los demás

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 más altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "3"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "3"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantísimo que el código se entienda, por nuestro yo el futuro pero también por la [**transparencia algorítmica**]{.hl-yellow} hacia los demás

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 más altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "4"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "4"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantísimo que el código se entienda, por nuestro yo el futuro pero también por la [**transparencia algorítmica**]{.hl-yellow} hacia los demás

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 más altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "5"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "5"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen

La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantísimo que el código se entienda, por nuestro yo el futuro pero también por la [**transparencia algorítmica**]{.hl-yellow} hacia los demás

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 más altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "6"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "6"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::


--- 

## 🐣 Caso práctico {#caso-práctico-5}

Vamos a usar el dataset `biopsy` que podemos encontrar en el agregador de datasets <https://vincentarelbundock.github.io/Rdatasets/index.html>. El [**dataset contiene datos de 699 pacientes a lo que se les realizó una biopsia de pecho**]{.hl-yellow}, obteniendo 11 variables (una que hace de id y 10 escalas medidas de 1 a 10)

Puedes ver la documentación en <https://vincentarelbundock.github.io/Rdatasets/doc/MASS/biopsy.html>

. . .

1. Crea de cero un [**informe en Quarto**]{.hl-yellow} donde hagas los ejercicios posteriores (usa un archivo de estilos para que quede estético)

. . .

2. [**Importa el `.csv` desde la propia web**]{.hl-yellow} (a través del enlace del archivo)

. . .

3. Habrás visto que hay 12 columnas en realidad importadas (la primera nos sobra ya que es solo un contador de filas). Vuelve a cargarlo [**seleccionando en la carga**]{.hl-yellow} solo desde `ID` hasta `class`

---

## 🐣 Caso práctico {#caso-práctico-5-1}

4. La variable `ID` en realidad es un identificador (una cualitativa). Repite la carga [**especificando los tipos de datos**]{.hl-yellow}: cualitativa o factor para ID y class, números para el resto de variables)

. . .

5. La variable `ID` debería ser identificador de cada registro: [**elimina duplicados**]{.hl-yellow} por dicha variable del dataset anterior.

. . .

6. Del dataset anterior [**filtra**]{.hl-yellow} solo los pacientes con tumor maligno y la variable `V9` con valor 4 o inferior, [**eliminando además cualquier registro que contenga ausente**]{.hl-yellow} en cualquiera de la variables.

. . .

7. Del dataset anterior obtén una [**muestra del 20% de los datos**]{.hl-yellow} (cada registro puede ser elegido con la misma probabilidad), y [**órdenalos**]{.hl-yellow} por de mayor a menor por la variable `V1` y, en caso de empate, de menor a mayor por la variable `V2`

---

## Selección columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

La opción más sencilla para [**seleccionar variables por nombre**]{.hl-yellow} es `select()`, dando como argumentos los nombres de columnas [**sin comillas**]{.hl-purple}.

```{r}
starwars |> select(name, hair_color)
```

---

## Selección columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

La función `select()` nos permite seleccionar varias variables a la vez, incluso [**concatenando sus nombres como si fuesen índices numéricos**]{.hl-yellow}

```{r}
#| eval: false
starwars |> select(name:eye_color) 
```

```{r}
#| echo: false
starwars |> select(name:eye_color) |> slice(1:4)
```

. . .

Y podemos [**deseleccionar columnas**]{.hl-yellow} con `-` delante

```{r}
#| eval: false
starwars |>  select(-mass, -(eye_color:starships))
```

```{r}
#| echo: false
starwars |> select(-mass, -(eye_color:starships)) |> slice(1:4)
```

---

## Selección columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Tenemos además [**palabras reservadas**]{.hl-yellow}: `everything()` [**todas las variables**]{.hl-purple}...

```{r}
#| eval: false
starwars |> select(mass, homeworld, everything())
```

```{r}
#| echo: false
starwars |> select(mass, homeworld, everything()) |> slice(1:4)
```

. . .

...y `last_col()` para referirnos a [**la última columna**]{.hl-purple}.

```{r}
#| eval: false
starwars |> select(name:mass, homeworld, last_col())
```

```{r}
#| echo: false
starwars |> select(name:mass, homeworld, last_col()) |> slice(1:4)
```

---

## Selección columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

También podemos jugar con [**patrones**]{.hl-yellow} en el nombre, aquellas que [**comiencen por un prefijo**]{.hl-purple} (`starts_with()`), [**terminen con un sufijo**]{.hl-purple} (`ends_with()`), [**contengan un texto**]{.hl-purple} (`contains()`) o cumplan una [**expresión regular**]{.hl-purple} (`matches()`).

```{r}
# variables cuyo nombre acaba en "color" y contengan sexo o género
starwars |> select(ends_with("color"), matches("sex|gender"))
```

---

## Selección columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Incluso podemos [**seleccionar por rango numérico**]{.hl-yellow} si tenemos variables con un prefijo y números.

```{r}
datos <-
  tibble("semana1" = c(115, 141, 232), "semana2" = c(7, NA, 17),
         "semana3" = c(95, 162, NA), "semana4" = c(11, 19, 15),
         "semana5" = c(NA, 262, 190), "semana6" = c(21, 15, 23))
```

. . .

Con `num_range()` podemos seleccionar con un prefijo y una secuencia numérica.

```{r}
datos |> select(num_range("semana", 1:4))
```

---

## Selección columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Por último, podemos seleccionar columnas por [**tipo de dato**]{.hl-yellow} haciendo uso de `where()` y dentro una función que devuelva un valor lógico de tipo de dato.

```{r}
# Solo columnas numéricas o de texto
starwars |> select(where(is.numeric) | where(is.character))
```

---

## Mover columnas: relocate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  recolocar(var1, despues_de = var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  relocate(var1, .after = var2)
```
:::
:::

Para facilitar la [**recolocación de variables**]{.hl-yellow} tenemos una función para ello, `relocate()`, indicándole en `.after` o `.before` [**detrás**]{.hl-purple} o [**delante**]{.hl-purple} de qué columnas queremos moverlas.

```{r}
starwars |> relocate(species, .before = name)
```

---

## Renombrar: rename()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> renombrar(nuevo = antiguo)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> rename(nuevo = antiguo)
```
:::
:::

A veces también podemos querer [**modificar la «metainformación»**]{.hl-yellow} de los datos, [**renombrando columnas**]{.hl-yellow}. Para ello usaremos de `rename()` poniendo [**primero el nombre nuevo**]{.hl-purple} y luego el [**antiguo**]{.hl-purple}.

```{r}
starwars |> rename(nombre = name, altura = height, peso = mass)
```

---

## Extraer columnas: pull()


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> retirar(var)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> pull(var)
```
:::
:::


Si observas la salida de los `select()` [**sigue siendo una tabla tibble**]{.hl-yellow}, ya que nos preserva la naturaleza de nuestros datos.

```{r}
starwars |> select(name)
```

---


## Extraer columnas: pull()


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> retirar(var)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> pull(var)
```
:::
:::


A veces no querremos dicha estructura sino [**extraer literalmente la columna en un vector**]{.hl-yellow}, algo que podemos hacer con `pull()`

```{r}
starwars |> pull(name)
```


---


## 💻 Tu turno {#tu-turno-7d}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Filtra el conjunto de personajes y quédate solo con aquellos que en la variable `height` no tengan un dato ausente. Con los datos obtenidos del filtro anterior, selecciona solo las variables name, height, así como todas aquellas variables que CONTENGAN la palabra color en su nombre.

### [**Ejercicio 2**]{.hl-yellow}

📝 Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano

### [**Ejercicio 3**]{.hl-yellow}

📝 Con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detrás de la variable de nombres.

### [**Ejercicio 4**]{.hl-yellow}

📝 Con los datos obtenidos del ejercicio anterior, comprueba cuántas modalidades únicas hay en la variable de color de pelo (sin usar `unique()`).

### [**Ejercicio 5**]{.hl-yellow}

📝 Del conjunto de datos originales, elimina las columnas de tipo lista, y tras ello elimina duplicados en la variable `eye_color`. Tras eliminar duplicados extrae dicha columna en un vector.

:::

---


## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

En muchas ocasiones querremos [**modificar o crear variables**]{.hl-yellow} con `mutate()`. 


. . . 

Vamos a crear por ejemplo una nueva variable `height_m` con la altura en metros.

```{r}
starwars |> mutate(height_m = height / 100)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

Además con los argumentos opcionales podemos [**recolocar la columna modificada**]{.hl-yellow}

```{r}
starwars |> 
  mutate(height_m = height / 100,
         IMC = mass / (height_m^2), .before = name)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

::: callout-important
## Importante...

Cuando aplicamos `mutate()`, debemos de acordarnos que las [**operaciones se realizan de manera vectorial**]{.hl-yellow}, elemento a elemento, por lo que la función que usemos dentro debe devolver un vector de igual longitud. En caso contrario, [**devolverá una constante**]{.hl-red}
:::

. . .

```{r}
starwars |> 
  mutate(constante = mean(mass, na.rm = TRUE), .before = name)
```

# Clase 8: tidyverse (resúmenes) y recategorizar {#clase-8}

[**Summarise y group_by(). Contar y resumir: estadísticas desagregadas por factores/grupos**]{style="color:#444442;"}

---

## Recategorizar: if_else()

También podemos combinar `mutate()` con la expresión de control `if_else()` para [**recategorizar la variable**]{.hl-yellow}: si [**se cumple una condición**]{.hl-purple}, hace una cosa, en caso contrario otra.

```{r}
starwars |> 
  mutate(human = if_else(species == "Human", "Human", "Not Human"),
         .after = name) |> 
  select(name:mass)
```

---

## Recategorizar: case_when()

Para [**recategorizaciones más complejas**]{.hl-yellow} tenemos `case_when()`, por ejemplo, para crear una categoría de los personajes en función de su altura.

```{r}
starwars |> 
  drop_na(height) |> 
  mutate(altura = case_when(height < 120 ~ "enanos",
                            height < 160 ~ "bajito",
                            height < 180 ~ "normal",
                            height < 200 ~ "alto",
                            TRUE ~ "gigante"), .before = name)
```

---

## 💻 Tu turno {#tu-turno-8a}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Selecciona solo las variables nombre, altura y así como todas aquellas variables relacionadas con el color, a la vez que te quedas solo con aquellos que no tengan ausente en la altura.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(name, height, contains("color")) |> 
  drop_na(height)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(name, height, contains("color")) |> 
  drop_na(height) |> 
  rename(nombre = name, altura = height,
         color_pelo = eye_color, color_piel = skin_color,
         color_pelo = hair_color)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detrás de la variable de nombres.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  select(name, height, contains("color")) |> 
  drop_na(height) |> 
  rename(nombre = name, altura = height,
         color_pelo = eye_color, color_piel = skin_color,
         color_pelo = hair_color) |> 
  relocate(color_pelo, .after = nombre)
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Con los datos originales, comprueba cuántas modalidades únicas hay en la variable de color de pelo.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  distinct(hair_color) |> 
  nrow()
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Del dataset original, selecciona solo las variables numéricas y de tipo texto. Tras ello define una nueva variable llamada `under_18` que nos recategorice la variable de edad: `TRUE` si es menor de edad y `FALSE` en caso contrario

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(where(is.numeric) | where(is.character)) |> 
  mutate(under_18 = birth_year < 18)
```

### [**Ejercicio 6**]{.hl-yellow}

📝 Del dataset original, crea una nueva columna llamada `auburn` (cobrizo/caoba) que nos diga TRUE si el color de pelo contiene dicha palabra y FALSE en caso contrario (reminder `str_detect()`).

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(auburn = str_detect(hair_color, "auburn"))
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Del dataset original, incluye una columna que calcule el IMC. Tras ello, crea una nueva variable que valga `NA` si no es humano, `delgadez` por debajo de 18, `normal` entre 18 y 30, `sobrepeso` por encima de 30.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(IMC = mass / ((height/100)^2),
         IMC_recat = case_when(species != "Human" ~ NA,
                               IMC < 18 ~ "delgadez",
                               IMC < 30 ~ "normal",
                               TRUE ~ "sobrepeso"),
         .after = name)
```

:::

---

## 🐣 Caso práctico 8 {#caso8}


Haciendo uso de todo lo aprendido, vamos a proceder a [**crear una tabla con datos de bebés**]{.hl-yellow} de tamaño `n = 20` en donde [**simulemos el sexo de los bebés y su peso**]{.hl-yellow}

. . .

1. Crea un `tibble` con dos columnas, una llamada `id_bebe` y otra llamada `sexo`. En el primer caso debe ir de 1 a 20. En el segundo caso, simula su sexo de manera que haya un 0.5 de probabilidad de `chico` y 0.5 de `chica`.

. . .

2. Conocido el sexo, crea una tercera columna llamada `peso` en la que simules dicho valor. Supondremos que para los chicos el peso sigue una distribución $N(\mu = 3.266kg, \sigma = 0.514)$ y que para las chicas sigue una distribución $N(\mu = 3.155kg, \sigma = 0.495)$.




---


## Contar: count()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
:::

Hasta ahora solo hemos transformado o consultado los datos pero no hemos generado estadísticas. Empecemos por lo sencillo: [**¿cómo contar (frecuencias)?**]{.hl-yellow}

. . .

Cuando lo usamos en solitario `count()` nos devolverá simplemente el número de registros , pero cuando lo usamos con variables `count()` calcula lo que se conoce como [**frecuencias**]{.hl-yellow}: [**número de elementos de cada modalidad**]{.hl-purple}.

```{r}
starwars |> count(sex)
```

---

## Contar: count()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
:::

Además si pasamos varias variables nos calcula lo que se conoce como una [**tabla de contigencia**]{.hl-yellow}. Con `sort = TRUE` nos devolverá el [**conteo ordenado**]{.hl-purple} (más frecuentes primero).

```{r}
starwars |> count(sex, gender, sort = TRUE)
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Una de las [**funciones más potentes**]{.hl-yellow} a combinar con las acciones vistas es `group_by()`, que nos permitirá [**agrupar nuestros registros**]{.hl-yellow} previamente

```{r}
starwars |> 
  group_by(sex) |>
  count() |>
  ungroup()
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Cuando apliquemos `group_by()` es importante entender que [**NO MODIFICA los datos**]{.hl-yellow}, sino que nos crea una [**variable de grupo**]{.hl-yellow} (subtablas por cada grupo) que modificará las acciones futuras: las [**operaciones se aplicarán a cada subtabla por separado**]{.hl-purple}

. . .

Por ejemplo, imaginemos que queremos extraer el personaje más alto con `slice_max()`.

```{r}
starwars |> slice_max(height)
```


---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

¿Y si queremos [**extraer el personaje más alto pero...de cada uno de los sexos**]{.hl-yellow}?

. . .

```{r}
starwars |>
  group_by(sex) |> 
  slice_max(height) |> 
  ungroup()
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

::: columns
::: {.column width="50%"}
![](img/tidydatatutor_1.jpg)
:::

::: {.column width="50%"}
![](img/tidydatatutor_2.jpg)
:::
:::

La web <https://tidydatatutor.com/> permite visualizar las operaciones de `{tidyverse}` (con el pipe antiguo)

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |>
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |>
  ungroup()
```
:::
:::

::: callout-important
## Importante

Recuerda siempre [**hacer ungroup**]{.hl-red} para eliminar la variable de grupo creada
:::

. . .

En la nueva versión de `{dplyr}` ahora se [**permite incluir la variable de grupo**]{.hl-yellow} en la llamada a muchas funciones con el argumento `by = ...` o `.by = ...`

```{r}
#| eval: false
starwars |> slice_max(height, by = sex)
```

```{r}
#| echo: false
starwars |> slice_max(height, by = sex) |> select(name:eye_color)
```

---

## Fila-a-fila: rowwise()

Una opción muy útil usada antes de una operación también es `rowwise()`: toda [**operación que venga después se aplicará en cada fila por separado**]{.hl-yellow}. Por ejemplo, vamos a definir un conjunto dummy de notas.

```{r}
notas <- tibble("mates" = c(7.5, 8, 9.1, 3),
                "lengua" = c(8, 6, 6.5, 9.2))
```

. . .

Si aplicamos la media directamente el valor será idéntico ya que nos ha hecho la media global, pero nos gustaría sacar una [**media por registro**]{.hl-yellow}. Para eso usaremos `rowwise()`

```{r}
notas |> 
  rowwise() |> 
  mutate(media_curso = mean(c(mates, lengua)))
```

---

## Resumir: summarise()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
:::

Por último tenemos `summarise()`, que nos permitirá sacar resúmenes estadísticos. Por ejemplo, vamos a [**calcular la media de las alturas**]{.hl-yellow}.

```{r}
starwars |> 
  drop_na(height) |> 
  summarise(media_altura = mean(height))
```

. . .

::: callout-warning
## Cuidado

Fíjate que `mutate()` devuelve [**tantas filas como registros originales**]{.hl-yellow}, mientras que con `summarise()` calcula un [**nuevo dataset de resumen**]{.hl-purple}, solo incluyendo aquello que esté indicado.
:::

---

## Resumir: summarise()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
:::

Si además esto lo [**combinamos con la agrupación**]{.hl-yellow} de `group_by()` o `.by = ...`, en pocas líneas de código puedes obtener [**estadísticas desagreagadas**]{.hl-purple}

```{r}
starwars |> 
  drop_na(sex, height, mass) |> 
  summarise(media_altura = mean(height),
            media_peso = mean(mass),
            .by = sex)
```

---

## Resumir: reframe()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> reframe()
```
:::
:::

En el nuevo `{dplyr}` han incluido `reframe()` para evitar problemas de `summarise()` cuando [**devolvemos más de un valor por variable**]{.hl-yellow}.

::: columns
::: {.column width="50%"}
```{r}
#| warning: true
starwars |>
  drop_na(mass) |>
  summarise(quantile(mass))
```
:::

::: {.column width="50%"}
```{r}
starwars |>
  drop_na(mass) |>
  reframe(quantile(mass))
```
:::
:::

---

## Selectores: across()

Un truco es [**hacer uso de selectores**]{.hl-yellow} `across()` y `where()`. El primero nos permite [**actuar sobre varias columnas por nombre**]{.hl-purple} (con `mutate()` o `summarise()`)

```{r}
starwars |> summarise(medias = across(height:mass, mean, na.rm = TRUE), .by = sex)
```

. . .

El segundo, `where()`, nos permite hacer lo mismo pero [**seleccionando por tipo**]{.hl-yellow}.

```{r}
starwars |> 
  summarise(across(where(is.numeric), mean, na.rm = TRUE), .by = c(sex, gender))
```

---

## 💻 Tu turno {#tu-turno-8b}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Calcula cuántos personajes hay de cada especie, ordenados de más a menor frecuencia.

```{r}
#| code-fold: true
#| eval: false
starwars |> count(species, sort = TRUE)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Tras eliminar ausentes en las variables de peso y estatura, añade una nueva variable que nos calcule el IMC de cada personaje, y determina el IMC medio de nuestros personajes desagregada por sexo

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass, height) |> 
  mutate(IMC = mass / ((height/100)^2)) |> 
  summarise(IMC_medio = mean(IMC), .by = sex)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Obtén el personaje más joven por cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  slice_min(birth_year, by = sex)
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Obtén la edad del personaje más joven y más viejo de cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(birth_year) |>
  summarise(min(birth_year), max(birth_year), .by = sex)
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Determina la cantidad de personajes en cada década (echa un vistazo a `round()`, primero sin desagregar y luego desagregado por sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  count(birth_decade = round(birth_year, -1))
```
:::

# Clase 9: repaso e intro a funciones {#clase-9-funciones}

[**¿Qué es una función? ¿Cómo se definen?**]{style="color:#444442;"}

## 🐣 Caso práctico 9 {#caso9}

Vamos antes a hacer un [**repaso de lo aprendido**]{.hl-yellow} en `{tidyverse}`

1. Carga la tabla billboard del paquete `{tidyr}`.

```{r}
#| code-fold: true
#| eval: false
billboard
```

. . .

2. Antes de nada, selecciona solo las [**primeras 52 semanas**]{.hl-yellow}. Tras ello convierte el dataset a [**tidydata**]{.hl-yellow} con los formatos y tipos adecuados para cada variable

```{r}
#| code-fold: true
#| eval: false
billboard_tidy <-
  billboard |> 
  select(artist:date.entered, wk1:wk52) |> 
  pivot_longer(cols = wk1:wk52,
               names_to = "week",
               values_to = "rank",
               values_drop_na = TRUE,
               names_prefix = "wk") |> 
  mutate(week = as.numeric(week))
```

. . .

3. Extrae la [**lista de artistas distintos**]{.hl-yellow} que aparecen en la tabla, incluyendo [**cuántas veces**]{.hl-yellow} aparece cada uno.

```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  count(artist)
```

---

## 🐣 Caso práctico 9


4. Determina [**cuántas canciones tiene cada artistal**]{.hl-yellow}

```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  distinct(artist, track) |> 
  count(artist)
```

. . .

5. Determina las [**5 canciones que más semanas**]{.hl-yellow} aparecen en la lista de éxitos. 
```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  count(track) |> 
  slice_max(n = 5, n)
```

. . .

6. Determina [**para cada artista la canción que más semanas**]{.hl-yellow} aparece en la lista de éxitos. 

```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  count(artist, track) |> 
  slice_max(n = 1, n, by = artist)
```


---

## 🐣 Caso práctico 9

7. Determina el [**artista con más canciones**]{.hl-yellow} en la lista


```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  distinct(artist, track) |> 
  count(artist) |> 
  slice_max(n = 1, n)
```

. . .

8. Calcula la [**posición más alta**]{.hl-yellow} en la que ha estado cada canción. Calcula la posición más alta en la que ha estado un artista


```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  slice_min(rank, n = 1, with_ties = FALSE, by = track)
```

```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  slice_min(rank, n = 1, with_ties = FALSE, by = artist)
```

---

## 🐣 Caso práctico 9

9. Obtén una [**tabla resumen**]{.hl-yellow} con el ranking medio de cada artista (contando solo el ranking más alto alcanzado por sus canciones), así como el número de canciones (distintas) que ha colocado en el top 100.


```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  slice_min(rank, n = 1, with_ties = FALSE, by = track) |> 
  summarise(avg_rank = mean(rank), n_songs = n(), .by = artist)
```

. . .

10. Realiza un muestreo aleatorio estratificado, extrayendo el 50% de los datos pero manteniendo la proporción de datos entre los distintos cuatrimestres.


```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  mutate(quarter = quarter(date.entered)) |> 
  slice_sample(prop = 0.5, by = quarter)
```


---

## Creando funciones

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, además podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**.

¿Cómo [**crear nuestra propia función**]{.hl-purple}? Veamos su **esquema básico**:

. . .

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraños). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

. . .

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

. . .

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
}
```

---

## Creando funciones

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, además podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**.

¿Cómo [**crear nuestra propia función**]{.hl-purple}? Veamos su **esquema básico**:


* [**Cuerpo**]{.hl-yellow} de la función dentro de `{ }`.

. . .

* Finalizamos la función con los [**argumentos de salida**]{.hl-yellow} con `return()`.


```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # Código que queramos ejecutar
  código
  
  # Salida
  return(var_salida)
}
```


---

## Creando funciones

* `arg1, arg2, ...`: serán los [**argumentos de entrada**]{.hl-yellow}, los argumentos que toma la función para ejecutar el código que tiene dentro

* `código`: líneas de código que queramos que [**ejecute la función**]{.hl-yellow}. 

* `return(var_salida)`: se introducirán los [**argumentos de salida**]{.hl-yellow}.


```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # Código que queramos ejecutar
  código
  
  # Salida
  return(var_salida)
}
```

::: callout-important
## Importante

Todas las variables que definamos dentro de la función son [**variables locales: solo existirán dentro de la función**]{.hl-yellow} salvo que especifiquemos lo contrario.

:::

---

## Creando funciones

Veamos un ejemplo muy simple de función para [**calcular el área de un rectángulo**]{.hl-yellow}.

. . .

Dado que el área de un rectángulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serán los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} será justo su **área** ($lado_1 * lado_2$).

. . .

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  return(area)
  
}
```

---

## Creando funciones


También podemos hacer una definición directa, **sin almacenar variables por el camino**.

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  return(lado_1 * lado_2)
  
}
```


[**¿Cómo aplicar la función?**]{.hl-yellow}

```{r}
calcular_area(5, 3) # área de un rectángulo 5 x 3 
calcular_area(1, 5) # área de un rectángulo 1 x 5
```

---

## Argumentos por defecto

Imagina ahora que nos damos cuenta que el 90% de las veces usamos dicha función para [**calcular por defecto el área de un cuadrado**]{.hl-yellow} (es decir, solo necesitamos un lado). Para ello, podemos definir [**argumentos por defecto**]{.hl-yellow} en la función: tomarán dicho valor salvo que le asignemos otro.

¿Por qué no asignar `lado_2 = lado_1` por defecto, para ahorrar líneas de código y tiempo?

. . .

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

---

## Argumentos por defecto


```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```


Ahora [**por defecto**]{.hl-yellow} el segundo lado será igual al primero (si se lo añadimos usará ambos).


```{r}
calcular_area(lado_1 = 5) # cuadrado
calcular_area(lado_1 = 5, lado_2 = 7) # rectángulo
```

---
 
## Salida múltiple

Compliquemos un poco la función y añadamos en la salida los valores de cada lado, etiquetados como `lado_1` y `lado_2`, [**empaquetando la salida en una lista**]{.hl-yellow}.

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```


# Clase 10: profundizando funciones {#clase-10}

[**¿Qué es una función? ¿Cómo se definen? Variables locales vs globlales. Introducción a listas**]{style="color:#444442;"}


---

## Funciones en R

Repasando el último día...

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

. . .

```{r}
salida <- calcular_area(5, 3)
salida["area"]
salida["lado_1"]
```

. . .

::: callout-important
## Importante

Todas las variables que definamos dentro de la función son [**variables locales: solo existirán dentro**]{.hl-yellow}

:::

---

## Introducción a listas

Veamos un pequeño resumen de los datos que ya conocemos:

* [**vectores**]{.hl-yellow}: colección de elementos de igual tipo. Pueden ser números, caracteres o valores lógicos, entre otros.

* [**matrices**]{.hl-yellow}: colección BIDIMENSIONAL de elementos de igual tipo e igual longitud.

* [**data.frame / tibble**]{.hl-yellow}: colección BIDIMENSIONAL de elementos de igual longitud pero de cualquier tipo.

. . .

Las [**listas**]{.hl-yellow} serán [**colecciones de variables de diferente tipo y diferente longitud**]{.hl-purple}, con estructuras totalmente heterógeneas (incluso una lista puede tener dentro a su vez otra lista).

---

## Introducción a listas


Vamos a crear [**nuestra primera lista**]{.hl-yellow} con `list()` con tres elementos: el nombre de nuestros padres/madres, nuestro lugar de nacimiento y edades de nuestros hermanos.

```{r}
variable_1 <- c("Paloma", "Gregorio")
variable_2 <- "Madrid"
variable_3 <- c(25, 30, 26)

lista <- list("progenitores" = variable_1, "lugar_nacimiento" = variable_2,
              "edades_hermanos" = variable_3)
lista
```

---

## Introducción a listas

```{r}
length(lista)
```

Si observas el objeto que hemos definido como lista, su [**longitud**]{.hl-yellow} del es de 3 ya que tenemos **guardados tres elementos**: un vector de caracteres (de longitud 2), un caracter (vector de longitud 1), y un vector de números (de longitud 3)

. . .

Tenemos guardados elementos de [**distinto tipo**]{.hl-yellow} (algo que ya podíamos hacer) pero, además, de **longitudes dispares**.

```{r}
dim(lista) # devolverá NULL al no tener dos dimensiones
class(lista) # de tipo lista
```

---

## Introducción a listas

Si los juntásemos con un `tibble()`, al tener distinta longitud, obtendríamos un [**error**]{.hl-red}.

```{r}
#| error: true
library(tibble)
tibble("progenitores" = variable_1,
       "lugar_nacimiento" = variable_2,
       "edades_hermanos" = variable_3)
```

---


## Introducción a listas

* [**Acceder por índice**]{.hl-yellow}: con el operador `[[i]]` accedemos al **elemento i-ésimo** de la lista.

```{r}
lista[[1]]
```

. . .

* [**Acceder por nombre**]{.hl-yellow}: con el operador `$nombre_elemento` accedemos por su nombre.

```{r}
lista$progenitores
```

. . .

En contraposición, el [**corchete simple**]{.hl-yellow} nos permite acceder a [**varios elementos**]{.hl-yellow} a la vez

```{r}
# Varios elementos
lista[1:2]
```

---

## Salida múltiple

Antes nos daba igual el orden de los argumentos pero ahora el [**orden de los argumentos de entrada importa**]{.hl-yellow}, ya que en la salida incluimos `lado_1` y `lado_2`. 

. . .

::: callout-note
## Recomendación

Es altamente recomendable hacer la llamada a la función [**indicando explícitamente los argumentos**]{.hl-yellow} para mejorar la **legibilidad e interpretabilidad**.

```{r}
# Equivalente a calcular_area(5, 3)
calcular_area(lado_1 = 5, lado_2 = 3)
```

:::

---

## Funciones: generando conocimiento

Parece una tontería lo que hemos hecho pero hemos cruzado una frontera importante: hemos pasado de [**consumir conocimiento**]{.hl-yellow} (código de otros paquetes, elaborado por otros/as), a [**generar conocimiento**]{.hl-purple}, creando nuestras propias funciones.

---

## Variables locales vs globales

Un aspecto importante sobre el que reflexionar con las funciones: ¿qué sucede si [**nombramos a una variable dentro**]{.hl-yellow} de una función a la que se nos ha **olvidado asignar** un valor dentro de la misma?

. . .

Debemos ser cautos al usar funciones en `R`, ya que debido a la [**«regla lexicográfica»**]{.hl-yellow}, si una variable no se define dentro de la función, `R` [**buscará dicha variable en el entorno**]{.hl-purple} de variables.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  print(x) # No devuelve nada, solo realiza la acción 
}
funcion_ejemplo()
```

---

## Variables locales vs globales

Si una variable  [**ya está definida fuera de la función (entorno global)**]{.hl-yellow}, y además es usada dentro de cambiando su valor, el valor [**solo cambia dentro**]{.hl-yellow} pero [**no en el entorno global**]{.hl-red}.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  x <- 2
  print(x) # lo que vale dentro
}
```

```{r}
# lo que vale dentro
funcion_ejemplo() #<<
# lo que vale fuera
print(x) #<<
```

---

## Variables locales vs globales


Si queremos que además de cambiar localmente lo haga [**globalmente**]{.hl-yellow} deberemos usar la [**doble asignación**]{.hl-yellow} (`<<-`).

```{r}
x <- 1
y <- 2
funcion_ejemplo <- function() {
  
  # no cambia globalmente, solo localmente
  x <- 3 
  # cambia globalmente
  y <<- 0 #<<
  
  print(x)
  print(y)
}

funcion_ejemplo() # lo que vale dentro
x # lo que vale fuera
y # lo que vale fuera
```

---


## 💻 Tu turno {#tu-turno-9}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 Modifica el código inferior para definir una función llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.

```{r}
#| eval: false
nombre <- function(x, y) {
  suma <- # código a ejecutar
  return()
}
# Aplicamos la función
suma(3, 7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_suma <- function(x, y) {
  suma <- x + y
  return(suma)
}
funcion_suma(3, 7)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Modifica el código inferior para definir una función llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado

```{r}
#| eval: false
nombre <- function(x, y) {
  producto <- # código de la multiplicación
  return()
}
producto(3)
producto(3, -7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_producto <- function(x, y = x) {
  producto <- x * y
  return(producto)
}
funcion_producto(3)
funcion_producto(3, -7)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Define una función llamada `igualdad_nombres` que, dados dos nombres, nos diga si son iguales o no. Hazlo considerando importantes las mayúsculas, y sin que importen las mayúsculas. Echa un vistazo al paquete `{stringr}`.

```{r}
#| code-fold: true
#| eval: false
# Distinguiendo mayúsculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Lucía")

# Sin importar mayúsculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(toupper(persona_1) == toupper(persona_2))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Lucía")
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Crea una función llamada `calculo_IMC` que, dados dos argumentos (peso y estatura en metros) y un nombre, devuelva una lista con el IMC y el nombre.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura) {
  
  return(list("nombre" = nombre, "IMC" = peso/(estatura^2)))
}
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Repite el ejercicio anterior pero con otro argumento opcional que se llame unidades (por defecto, `unidades = "metros"`). Desarrolla la función de forma que haga lo correcto si `unidades = "metros"` y si `unidades = "centímetros"`.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  
  return(list("nombre" = nombre,
              "IMC" = peso/(if_else(unidades == "metros", estatura, estatura/100)^2)))
}
```

 
### [**Ejercicio 6**]{.hl-yellow}

📝 Crea un tibble ficticio de 7 personas, con tres variables (inventa nombre, y simula peso, estatura en centímetros), y aplica la función definida de forma que obtengamos una cuarta columna con su IMC.

```{r}
#| code-fold: true
#| eval: false
datos <-
  tibble("nombres" = c("javi", "sandra", "laura",
                       "ana", "carlos", "leo", NA),
         "peso" = rnorm(n = 7, mean = 70, sd = 1),
         "estatura" = rnorm(n = 7, mean = 168, sd = 5))

datos |> 
  mutate(IMC = calculo_IMC(nombres, peso, estatura, unidades = "centímetros")$IMC)
```


:::


---

## 🐣 Caso práctico 10: funciones {#caso10a}

Define una función llamada `conversor_temperatura` que, dada una temperatura en Fahrenheit, Celsius o Kelvin, la convierta a cualquiera de las otras (piensa que argumentos necesita el usuario). Aplica la función a la columna `Temp` del conjunto `airquality`, e incorpórala al fichero en una nueva columna `Temp_Celsius`.

---

## 🐣 Caso práctico 10: tidyverse {#caso10b}


Acude a <https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos> e importa  `casos_hosp_uci_def_sexo_edad_provres.csv`. Documentación en <https://cnecovid.isciii.es/covid19/resources/metadata_casos_hosp_uci_def_sexo_edad_provres.pdf>

. . .

1. ¿Cuántos casos hay notificados para edad desconocida? ¿Y desagregado por sexo? Recodifica adecuadamente las provincias

. . .

2. Dado su escaso peso en el total, genera una nueva base de datos en la que borremos aquellos registros con franja de edad desconocida. 

. . .


3. Con la base de datos generada en el ejercicio anterior, calcula la proporción de casos con sexo desconocido. Haz lo mismo con provincia desconocida. Elimina dichos registros si el número de casos representa menos del 1% (para cada una).


---

## 🐣 Caso práctico 10: tidyverse


4. Del dataset anterior, elimina la variables de hospitalizados y UCI. Tras ello renombra las columnas de casos y fallecidos por `casos_diarios` y `fallec_diarios`, respectivamente. Tras ello crea dos nuevas variables llamadas `casos_acum` y otra `fallec_acum`, que contengan los casos acumulados y fallecidos acumulados para cada fecha, desagregados por provincia, tramo etario y sexo.

. . .

5. ¿Cuáles fueron las 7 provincias con más casos a lo largo de toda la pandemia? ¿Y las 5 provincias con menos fallecidos? ¿Y si lo desagregamos por sexo?

---

## 🐣 Caso práctico 10: tidyverse

6. Define una función llamada `calculo_letalidad()` que, dados como argumentos un vector ordenado (por fecha) de casos y otro de fallecidos, devuelva el % de casos que han fallecido, de manera acumulada en cada fecha. Haz uso de dicha función y crea una nueva variable que represente la letalidad, en cada grupo de edad, sexo y provincia.

Tras ello, determina las 5 provincias con mayor letalidad en mujeres mayores de 80 años a fecha 01 de marzo de 2022.


# Clase 11: entrega II

[**Segunda entrega individual en clase**]{style="color:#444442;"}

---

## Entrega II

Se actualizará al inicio de la clase correspondiente.

::: callout-important

## Importante

Esta [**entrega ponderará un 15% en la nota final**]{.hl-green}

Podrás [**usar todo el material del curso e internet**]{.hl-yellow} salvo cualquier aplicación de mensajería o sistema de comunicación: en caso de tener alguna abierta a lo largo de la entrega, aunque no se esté usando, deberás [**abandonar la entrega y contará como un 0**]{.hl-red}.

Contarás en clase con aproximadamente 1 hora y 50 minutos, pero [**podrás realizar la entrega**]{.hl-yellow}, como tarde, hasta las [**18:00**]{.hl-yellow}. Será [**obligatorio subir tanto el `.qmd` como el `.html`**]{.hl-yellow}: una entrega que no haya podido ser renderizada (es decir, con errores graves) será [**penalizada contando solo un 65% de la nota obtenida**]{.hl-red} (si la entrega es perfecta, la nota máxima será un 6.5 sino se adjunta el `.html` generado).

Te recomiendo practicar bastante y preguntar dudas en clase y/o tutoría ya que [**irás justo de tiempo**]{.hl-yellow}, así que necesitas fluidez en los ejercicios.

Si usas un [**pc de la biblioteca**]{.hl-yellow} asegúrate de tomarlo con suficiente antelación para [**instalar todas las librerías necesarias antes de empezar**]{.hl-yellow} para no perder tiempo.

[**Evita copiar**]{.hl-red}: la IA detecta bastante bien el plagio :)

:::

# Clase 12: inicio a la visualización {#clase-12-dataviz}

[**Visualización de datos**]{style="color:#444442;"}


---

## Dataviz: historia


La aparición de gráficos estadísticos es [**relativamente reciente en la ciencia**]{.hl-yellow} ya que hasta la Edad Media la única visualización estaba en los [**mapas**]{.hl-yellow}. [^1] Las propias palabras _chart_ y _cartography_ derivan del mismo origen latino, _charta_, aunque el primer uso de coordenadas viene de los egipcios. [^2] [^3]

. . .

:::: columns
::: {.column width="55%"}

No es hasta la Edad Media, cuando la [**navegación y la astronomía**]{.hl-yellow} empezaban a tomar relevancia, cuando aparece la primera gráfica (no propiamente estadística), del **movimiento cíclico de los planetas** (siglos X y XI)

:::

::: {.column width="45%"}
![](img/dataviz_historico_1.png){width="370"}
:::
::::
 

[^1]: [«Gramática de las gráficas: pistas para mejorar las representaciones de datos» de Joaquín Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)

[^2]: [«Presentation Graphics» de Leland Wilkinson. International Encyclopedia of the Social & Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

[^3]: [«Quantitative Graphics in Statistics: A Brief History» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)]


---

## Navegación y astronomía


Con una motivación similar, en torno a 1360 el matemático **Nicole Oresme** diseñó el [**primer gráfico de barras**]{.hl-yellow} (pero no estadístico), con la idea de visualizar a la vez dos **magnitudes físicas teóricas**. [^4]


![](img/dataviz_historico_2.jpeg){width="300"}


[^4]: [«The First (Known) Statistical Graph: Michael Florent van Langren and the 'Secret' of Longitude» de M. Friendly y P. M. Valero-Mora. The American Statistician (2010)](https://www.researchgate.net/publication/227369016_The_First_Known_Statistical_Graph_Michael_Florent_van_Langren_and_the_Secret_of_Longitude)

 
---

## Primer gráfico estadístico

La mayoría de expertos, como Tufte [^5] [^6], consideran este gráfico casi longitudinal como la [**primera visualización de datos**]{.hl-yellow} de la historia, hecha por **Van Langren** en 1644, representando la [**distancia entre Toledo y Roma**]{.hl-yellow}.


```{r}
#| echo: false
knitr::include_graphics("./img/longitud_dataviz.jpg")
``` 

```{r}
#| echo: false
knitr::include_graphics("./img/dataviz_historico_3.jpeg")
``` 


[^5]: [«Visual explanations: images and quantities, evidence and narrative» de E. Tufte](https://archive.org/details/visualexplanatio00tuft)

[^6]: [«PowerPoint is evil» de E. Tufte](https://www.wired.com/2003/09/ppt2/)

---

## ¿Qué es una dataviz?


¿Es una gráfica estadística? ¿Por qué sí o por qué no?


![](img/cuadro_dataviz.jpg)


. . .

No hay [**ninguna INFORMACIÓN**]{.hl-red} representada


---

## ¿Qué es una dataviz?


¿Es una gráfica estadística? ¿Por qué sí o por qué no?

![](img/horoscopo_dataviz.jpg)

. . .

No hay [**ningún PROCESO DE MEDIDA**]{.hl-red} representado, no cuantifica nada (real).


---

## ¿Qué es una dataviz?

¿Es una gráfica estadística? ¿Por qué sí o por qué no?

![](img/celsius_dataviz.jpg)

. . .

No hay [**ningún DATO**]{.hl-red} representado en él, es una magnitud física teórica, no un dato (medido empíricamente o simulado).


---

## ¿Qué es una dataviz?

Esas mismas preguntas se hizo **Joaquín Sevilla** [^1], proporcionando [**3 requisitos**]{.hl-yellow}:

. . .

1. Que se base en el esquema de composición de [**eje métrico**]{.hl-yellow} (proceso de medida): debe [**medir algo**]{.hl-yellow}.

. . .

2. Debe incluir [**información estadística (datos)**]{.hl-yellow}

. . .
 
3. La  [**relación de representatividad**]{.hl-yellow} debe ser [**reversible**]{.hl-purple}: los datos deberían poder «recuperarse» a partir de la gráfica .



[^1]: [«Gramática de las gráficas: pistas para mejorar las representaciones de datos» de Joaquín Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)

---

## Abolición de tartas

Hay muchas formas de hacer una gráfica estadística, y no suele pasar por un [**gráfico de tartas**]{.hl-yellow} ya que tienen un grave [**problema de reversibilidad**]{.hl-red}:

. . .

:::: columns
::: {.column width="50%"}
* Si hay **muchas variables**: salvo que tengas transportador de ángulos...

* Si hay **pocas variables**: ¿aporta algo distinto (y/o mejor) que una tabla?

:::

::: {.column width="50%"}
![](img/sectores_muchas_categorías.png)
:::
::::

---

## Abolición de tartas


El principal problema de un diagrama de sectores es que la posible información está [**contenida en los ángulos**]{.hl-yellow}, pero nuestra interpretación la realizamos a través de la [**comparación de áreas**]{.hl-yellow} (nuestros ojos no miden bien ángulos), las cuales dependen no solo del ángulo sino del radio.

&nbsp;

Algo similar sucede con los mal llamados [**gráficos tridimensionales**]{.hl-yellow} (son bidimensionales con perspectiva en realidad): los valores más cercanos aparecen sobredimensionados, siendo prácticamente imposible la reversibilidad por la [**distorsión**]{.hl-yellow}.


---

## Vizfails

::: columns
::: {.column width="55%"}
![](img/persona_dataviz.jpg)
:::

::: {.column width="45%"}
* La figura elegida (persona caminando) sin relación con lo visualizado: [**mala metáfora**]{.hl-red}.

* Los [**sectores señalados sin relación con el ítem**]{.hl-red} a representar, lo que dificulta su interpretación.

* Los [**colores sin codificar**]{.hl-red}: no dan información de ningún tipo.

* Las [**formas irregulares impiden la comparación**]{.hl-red} de las áreas (amén de que la suma total supera el 100%).

* **Sin fuente**

:::
::::


---

## Vizfails

![](img/viz_fail_covid.jpg)

---

## Vizfails

![](img/viz_fail_uk.jpg)

---

## La importancia del CONTEXTO

Una **buena idea** puede estar mal ejecutada: la forma de llevarla a cabo es importante

![](img/semaforos.jpg)

---

## Dataviz: historia

En el siglo XVII hubo un boom de la estadística al empezar a aplicarse en [**demografía**]{.hl-yellow}. Uno de los autores más importantes fue [**J. Graunt**]{.hl-purple}, autor de «Natural and Political Observations Made upon the Bills of Mortality» (1662), estimando la población de Londres con las [**primeras tablas de natalidad y mortalidad**]{.hl-yellow}.

. . .

::: columns
::: {.column width="50%"}

Son precisamente las tablas de Graunt las que usó [**Christiaan Huygens**]{.hl-yellow} para generar la [**primera gráfica de densidad**]{.hl-yellow} de una distribución continua (esperanza de vida vs edad).

:::

::: {.column width="50%"}

```{r echo = FALSE,  out.width = "100%", fig.align = "center", fig.cap = "Primera función de densidad, extraída de https://omeka.lehigh.edu/exhibits/show/data_visualization/vital_statistics/huygen"}
knitr::include_graphics("./img/primera_densidad.jpg")
``` 

:::
::::

---

## Gráficos de Playfair

La figura que cambió el dataviz fue, sin lugar a dudas, el economista y político [**William Playfair (1759-1823)**]{.hl-yellow}, publicando en 1786 el **«Atlas político y comercial»** [^11] [^12] con 44 gráficas (43 series temporales y el diagrama de barras más famoso de la historia).

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "70%", fig.align = "center", fig.cap = "Extraídas de Funkhouser y Walker (1935)"}
knitr::include_graphics("./img/playfair_1.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "25%", fig.align = "center", fig.cap = "Extraídas de Funkhouser y Walker (1935)"}
knitr::include_graphics("./img/playfair_2.jpg")
``` 

:::
::::

[^10]: [«Atlas político y comercial» de William Playfair (1786)](https://www.amazon.es/Playfairs-Commercial-Political-Statistical-Breviary/dp/0521855543)

[^11]: [«Playfair and his charts» de H. Gray Funkhouser and  Helen M. Walker (1935)](https://www.jstor.org/stable/45366440)

---


## Gráficos de Playfair

Playfair no solo fue el primero en usar el dataviz para entender (y no solo describir): fue el primero en usar [**conceptos modernos**]{.hl-yellow} como _grid_, tema o color

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "Extraída de https://friendly.github.io/HistDataVis"}
knitr::include_graphics("./img/playfair_3.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "Extraída de la wikipedia."}
knitr::include_graphics("./img/playfair_4.png")
``` 

:::
::::

---

## Gráficos de Playfair

Playfair es además el autor del [**gráfico de barras más famoso**]{.hl-yellow} (no fue el primero pero sí quien lo hizo _mainstream_).

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "Gráficas de Playfair de importaciones (barras grises) y exportaciones (negras) de Escocia en 1781, extraídas de la wikipedia."}
knitr::include_graphics("./img/playfair_5.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "Primer diagrama de barras (P. Buache y G. de L’Isle), visualizando los niveles del Sena (1732 - 1766), extraída de https://friendly.github.io/HistDataVis"}
knitr::include_graphics("./img/playfair_6.jpg")
``` 
:::
::::

---

## Gráficos de Playfair


Playfair además fue el primero en [**combinar gráficos en la misma visualización**]{.hl-yellow} [^12] [^13]

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "85%", fig.align = "center", fig.cap = "Visualiza 3 series temporales: precios (barras) del trigo, salarios (línea) y time-line con reinados, extraída de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/playfair_7.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "85%", fig.align = "center", fig.cap = "Time-line histórico, extraída de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/playfair_8.png")
``` 

:::
::::

[^12]: [«A Letter on Our Agricultural Distresses, Their Causes and Remedies» de W. Playfair (1821)](http://onlinebooks.library.upenn.edu/webbin/book/lookupid?key=ha009726110)

[^13]: [«An Inquiry Into the Permanent Causes of the Decline and Fall of Powerful and Wealthy Nations» de William Playfair (1821)](https://www.amazon.com/Permanent-Powerful-Nations-Prosperity-Prolonged/dp/140691830X)

---

## Mapas de Minard

Otro pionero en [**combinar visualizaciones**]{.hl-yellow} fue Minard, autor del famoso «Carte figurative des pertes successives en hommes de l'Armée Française dans la campagne de Russie 1812-1813», según Tufte [**«el mejor gráfico estadístico jamás dibujado»**]{.hl-yellow}, publicado en 1869 sobre la desastrosa campaña rusa de Napoleón en 1812 (3 variables en un gráfico bidimensional)

```{r echo = FALSE, out.width = "60%", fig.align = "center", fig.cap = "Extraída de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/minard_2.png")
```

---

## Primer scatter plot

Según J. Sevilla, se considera al astrónomo británico **John Frederick William Herschel** el autor del [**primer diagrama de dispersión o scatterplot**]{.hl-yellow} en 1833, visualizando el movimiento de la estrella doble Virginis (tiempo en el eje horizontal, posición angular en el eje vertical)


```{r echo = FALSE, out.width = "35%", fig.align = "center", fig.cap = "Extraído de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/herschel.jpg")
``` 

---

## Primera pirámide poblacional

La [**primera pirámide de población**]{.hl-yellow} (doble histograma de población), fue publicada por **Francis Amasa Walker**, superintendente del censo de EE.UU., en 1874.

```{r echo = FALSE, out.width = "45%", fig.align = "center", fig.cap = "Extraída de https://www.depauw.edu/learn/dew/wpaper/workingpapers/DePauw2016-02-Barreto-DemographyEconomics.pdf"}
knitr::include_graphics("./img/walker_piramide.jpg")
``` 

---

## Florence Nigthingale

::: columns
::: {.column width="65%"}


* El 21 de octubre de 1854 [**Florence Nigthingale**]{.hl-yellow} fue enviada para mejorar las **condiciones sanitarias** de los soldados británicos en la guerra de Crimea. 

* A su regreso demostró que los [**soldados fallecían por las condiciones sanitarias**]{.hl-yellow}. Nigthingale es la creadora del famoso [**diagrama de rosa**]{.hl-yellow}, visualizando tres variables a la vez y su estacionalidad.

* El 8 de febrero de 1955, The Times la describió como la **«ángel guardián» de los hospitales**, y acabó siendo conocida como [**«The Lady with the Lamp»**]{.hl-yellow} tras un poema de H. W. Longfellow (1857).

* Años después se convirtió en la [**primera mujer en la Royal Statistical Society**]{.hl-yellow}.

:::

::: {.column width="35%"}

```{r echo = FALSE, out.width = "95%", fig.align = "center"}
knitr::include_graphics("./img/the_lady_with_the_lamp.png")
``` 

:::
::::

---

## Diagrama de rosa

Florence Nigthingale es la creadora del famoso [**diagrama de rosa**]{.hl-yellow}, permitiendo pintar [**tres variables a la vez y su estacionalidad**]{.hl-yellow}: **tiempo** (cada **gajo** es un mes), **nº de muertes** (**área** del gajo) y **causa** de la muerte (**color** del gajo: azules enfermedades infecciosas, rojas por heridas, negras otras causas).


```{r echo = FALSE, out.width = "75%", fig.align = "center"}
knitr::include_graphics("./img/rosa_nightingale.jpg")
``` 

---


## Recursos de dataviz


📚 [«The Functional Art: an introduction to information graphics and visualization» de Alberto Cairo](https://www.amazon.es/Functional-Art-Voices-That-Matter/dp/0321834739)


📚 [«Gramática de las gráficas: pistas para mejorar las representaciones de datos» de Joaquín Sevilla](https://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)


📚 [«A Brief History of Visualization» de Friendly et al. (2008)](https://www.researchgate.net/publication/226400313_A_Brief_History_of_Data_Visualization)

📚 [«Quantitative Graphics in Statistics: A Brief History» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)]

📚 [«Presentation Graphics» de Leland Wilkinson. International Encyclopedia of the Social & Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

📚 [«The Grammar of Graphics» de Leland Wilkinson](https://www.amazon.es/Grammar-Graphics-Statistics-Computing/dp/0387245448)


📚 [«The Minard System: The Graphical Works of Charles-Joseph Minard» de Sandra Rendgen](https://www.amazon.es/gp/product/1616896337/ref=sw_img_1?smid=A1AT7YVPFBWXBL&psc=1)

📚 [«The Visual Display of Quantitative Information» de E. W. Tufte](https://www.amazon.es/Visual-Display-Quantitative-Information/dp/0961392142)

---

## Dataviz en R: ggplot2

:::: columns
::: {.column width="50%"}

El paquete `{ggplot2}` se basa en la idea de Wilkinson en [**«Grammar of graphics»**]{.hl-yellow}: dotar a los gráficos de una gramática propia. Una de las principales fortalezas de `R` es la [**visualización**]{.hl-yellow} con `{ggplot2}`.

```{r}
library(ggplot2)
```

La [**visualización de datos**]{.hl-yellow} debería ser una parte fundamental de todo análisis de datos. No es solo una cuestión estética.
:::

::: {.column width="50%"}
![](img/telling_dataviz.jpg){width="400"}
:::
::::

---

## Dataviz en R: ggplot2

La filosofía detrás de `{ggplot2}` es entender los [**gráficos como parte del flujo**]{.hl-yellow} de trabajo, dotándoles de una [**gramática**]{.hl-yellow}. El objetivo es empezar con un lienzo en blanco e ir [**añadiendo capas a tu gráfico**]{.hl-yellow}. La ventaja de `{ggplot2}` es poder [**mapear atributos estéticos**]{.hl-purple} (color, forma, tamaño) de objetos geométricos (puntos, barras, líneas) en función de los datos.

&nbsp;


La **documentación** del paquete puedes consultarla en <https://ggplot2-book.org/introduction.html> 

![](img/grammar_ggplot2.jpg)


---

## Dataviz en R: ggplot2

![](img/tarta_ggplot2.png)

---

## Dataviz en R: ggplot2

:::: columns
::: {.column width="40%"}
![](img/tarta_recortada_ggplot2.jpg)
:::

::: {.column width="60%"}
Un gráfico se podrá componer de [**capas**]{.hl-yellow}

* [**Datos (data)**]{.hl-purple}
* [**Mapeado (aesthetics)**]{.hl-purple} de elementos estéticos: ejes, color, forma, etc (en función de los datos)
* [**Geometría (geom)**]{.hl-purple}: puntos, líneas, barras, polígonos, etc.
* [**Componer gráficas (facet)**]{.hl-purple}
* [**Transformaciones (stat)**]{.hl-purple}: ordenar, resumir, etc.
* [**Coordenadas (coord)**]{.hl-purple}: coordenadas cartesianas, polares, grids, etc.
* [**Temas (theme)**]{.hl-purple}: fuente, tamaño de letra, subtítulos, captions, leyenda, ejes, etc.

:::
::::

---

## Primer intento: scatter plot

Veamos un **primer intento** para entender la filosofía ggplot. Imagina que queremos dibujar un [**scatter plot**]{.hl-yellow} (diagrama de dispersión de puntos). Para ello vamos a usar el conjunto de datos `gapminder`, del paquete homónimo: un fichero con **datos de esperanzas de vida, poblaciones y renta per cápita** de distintos países en distintos momentos temporales.

```{r}
library(gapminder)
gapminder
```

---

## Primer intento: scatter plot

El fichero consta de 1704 registros y 6 variables: `country`, `continent`, `year`, `lifeExp` (esperanza de vida), `pop` (población)  y `gdpPercap` (renta per cápita).

```{r}
glimpse(gapminder)
```

Para empezar con algo sencillo [**filtraremos solo los datos de 1997**]{.hl-yellow}

```{r}
gapminder_1997 <-
  gapminder |>
  filter(year == 1997) |> 
  drop_na(gdpPercap, lifeExp, pop)
```

---

## Ingredientes: (x, y)


¿Qué [**elementos necesitamos**]{.hl-yellow} para realizar un diagrama de puntos? Para [**iniciar el lienzo**]{.hl-pùrple} necesitamos una base de datos y dos variables a representar.

. . .

:::: columns
::: {.column width="45%"}

* [**Datos (data)**]{.hl-yellow}: conjunto `gapminder_1997`.

* [**Mapeado**]{.hl-yellow}: indicar dentro de `aes()` (aesthetics) las variables en cada coordenada. Todo [**dentro de aes() será mapeado de los datos**]{.hl-purple}

```{r}
#| eval: false
ggplot(data = gapminder_1997,
       aes(x = gdpPercap, y = pop))
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop))
```

:::
::::

---


## Primera geometría: geom_point()

:::: columns
::: {.column width="45%"}

* [**Geometría (geom)**]{.hl-yellow}: optaremos por **puntos** usando `geom_point()`.

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop)) +
  geom_point()
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(x = gdpPercap, y = pop)) +
  geom_point()
```

:::
::::

---

## Rol de os ejes: (x, y)


:::: columns
::: {.column width="45%"}

Vamos a profundizar en ese mapeado: ¿cómo [**cambiar el rol**]{.hl-yellow} de los ejes (población en el eje X y renta per cápita en el eje Y)? 

* **Eje X**: población (variable `pop`)
* **Eje Y**: renta per cápita (variable `gdpPercap`)


```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = pop)) +
  geom_point() 
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop)) +
  geom_point() 
```
:::
::::

---

## Rol de os ejes: (x, y)


:::: columns
::: {.column width="45%"}

¿Y un scatter plot con **esperanza de vida** en eje X frente a **renta per cápita**?


* **Eje X**: esperanza de vida (variable `lifeExp`)
* **Eje Y**: renta per cápita (variable `gdpPercap`)


```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point()
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point()
```

:::
::::

---

## Color, size, shape: fijos

Dentro de `geom_point()` tenemos varios argumentos a usar:


* `na.rm = ...`: si queremos que nos quite ausentes.

* `color = ...`: color (si tiene dimensión, color del contorno)

* `fill = ...`: color del relleno.

. . .

:::: columns
::: {.column width="45%"}

Empezaremos por un [**color fijo**]{.hl-yellow}, por ejemplo `"red"` (existen otros como `"blue"`, `"black"`, `"yellow"`, etc)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red")
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red")
```

:::
::::

---

## Color, size, shape: fijos

:::: columns
::: {.column width="45%"}

* `size = ...`: tamaño  de la geometría (en este caso el [**tamaño de los puntos**]{.hl-yellow}), cuanto mayor sea el número, mayor será el tamaño de la geometría.

  
```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7) 
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7)
```

:::
::::

---

## Color, size, shape: fijos


:::: columns
::: {.column width="45%"}

* `alpha = ...`: grado de opacidad del color (1 totalmente opaco, 0 totalmente transparente)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7,
             alpha = 0.4)
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7, alpha = 0.4)
```

:::
::::

---

## Color, size, shape: fijos


:::: columns
::: {.column width="45%"}

* `shape = ...`: forma de la geometría, en este caso del «punto» (ver todas las opciones en `vignette("ggplot2-specs")`)


```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red",
             fill = "black",
             size = 7,
             alpha = 0.4,
             shape = 23)
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", fill = "black",
             size = 7, alpha = 0.4, shape = 23)
```

:::
::::

---

## Color, size, shape: fijos


:::: columns
::: {.column width="45%"}

* `stroke = ...`: tamaño del contorno

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7,
             alpha = 0.4, stroke = 3)
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", alpha = 0.4,
             size = 7, stroke = 3)
```

:::
::::


---

## Color, size, shape: fijos


:::: columns
::: {.column width="45%"}

Los colores también podemos asignárselos por su **código hexadecimal**, consultando en <https://htmlcolorcodes.com/es/>, eligiendo el color que queramos. El código hexadecimal siempre comenzará con `#`


```{r}
#| eval: false
# Color en hexadecimal
# https://htmlcolorcodes.com/es/
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "#A02B85",
             alpha = 0.4, size = 7) 
```


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "#A02B85", alpha = 0.4, size = 7)
```

:::
::::

  
---

## Mapeado estético: aes()


Hasta ahora los **atributos estéticos** se los hemos pasado fijos y [**constantes**]{.hl-yellow}.  Pero la verdadera potencia y versatilidad de `ggplot` es que podemos [**mapear los atributos estéticos en función de los datos**]{.hl-yellow} en `aes()` para que dependan de variables de los datos.

. . .

:::: columns
::: {.column width="45%"}

Por ejemplo, vamos a asignar un [**color a cada dato en función de su continente**]{.hl-yellow} con `aes(color = continent)`

```{r}
#| eval: false
# Tamaño fijo
# Color por continentes
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent)) +
  geom_point(size = 7)
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(size = 5)
```

:::
::::

---

## Mapeado estético: aes()


:::: columns
::: {.column width="50%"}
  
Podemos combinarlo con lo que hemos hecho anteriormente:

* [**color**]{.hl-yellow} en función del [**continente**]{.hl-purple}.

* [**tamaño**]{.hl-yellow} en función de la [**población**]{.hl-purple}.

* [**transparencia**]{.hl-yellow} la fijamos [**constante**]{.hl-purple} del 50%.

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7)
```

A este scatter plot particular se le conoce **BUBBLE CHART**

:::

::: {.column width="50%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7)
```

:::
::::

---

## Visualización multivariante
  
Reflexionemos sobre el gráfico anterior:

* **color** en función del **continente**.
* **tamaño** en función de la **población**
* **transparencia** fija del 50%

&nbsp;

Usando los datos hemos conseguido dibujar en un [**gráfico bidimensional 4 variables** ]{.hl-yellow}: `lifeExp` y `gdpPercap` en los ejes , `continent` como color y `pop` como tamaño de la geometría, con muy pocas líneas de código.

---

## Etiquetas sencillas: labs()

Podemos [**personalizar de manera sencilla**]{.hl-yellow}  haciendo uso de la capa `labs()`:

:::: columns
::: {.column width="43%"}

* `title, subtitle`:  título/subtítulo
* `caption`: pie de gráfica
* `x, y`: nombres de los ejes
* `size, color, fill, ...`: nombre en la leyenda de las variables que codifiquen los distintos atributos


:::

::: {.column width="57%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  labs(x = "Esperanza de vida",
       y = "Renta per cápita",
       title = "Primer ggplot",
       caption = "J. Álvarez Liébana",
       color = "continente",
       size = "población")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  labs(x = "Esperanza de vida", y = "Renta per cápita",
       title = "Primer ggplot", subtitle = "Datos de gapminder",
       caption = "J. Álvarez Liébana", color = "continente", size = "población")
```


---

## Eliminar de la leyenda

Podemos eliminar variables de la leyenda con `guides(atributo = "none")`

:::: columns

::: {.column width="45%"}

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, 
           x = lifeExp,
           color = continent, 
           size = pop)) +
  geom_point(alpha = 0.7) +
  guides(size = "none") +
  labs(x = "Esperanza de vida",
       y = "Renta per cápita",
       title = "Primer ggplot",
       caption = "J. Álvarez Liébana",
       color = "continente")
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  guides(size = "none") +
  labs(x = "Esperanza de vida",
       y = "Renta per cápita",
       title = "Primer ggplot",
       caption = "J. Álvarez Liébana",
       color = "continente")
```

:::
::::

---

## Escalas (scale): ejes

Una de las capas más importantes es la [**capa de escalas**]{.hl-yellow}: dentro de `aes()` solo le indicamos que variable mapeamos pero no sus ajustes.

. . .


:::: columns

::: {.column width="47%"}

Vamos a configurar el eje x para tener marcas cada 10 unidades (`scale_x_continuous()`)


:::

::: {.column width="53%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  labs(x = "Esperanza de vida", y = "Renta per cápita",
       title = "Primer ggplot", caption = "J. Álvarez Liébana",
       color = "continente")
```

---

## Escalas (scale): colores

La misma idea la podemos aplicar a otro atríbuto como los [**colores**]{.hl-yellow} con `scale_color_...()` y `scale_fill_...()`: hemos indicado que mapeé dicho atributo por continente pero...¿qué colores usar?

. . .

:::: columns

::: {.column width="50%"}

Con `scale_color_manual()` podemos indicar manualmente una [**paleta**]{.hl-yellow} (puedes buscar en <https://htmlcolorcodes.com/>)


         
:::

::: {.column width="50%"}

```{r}
#| echo: false
pal <- c("#A02B85", "#2DE86B", "#4FB2CA", "#E8DA2D", "#E84C2D")
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = pal) +
  labs(x = "Esperanza de vida", y = "Renta per cápita",
       title = "Primer ggplot", caption = "J. Álvarez Liébana",
       color = "continente")
```

:::
::::
      
```{r}
#| eval: false
pal <- c("#A02B85", "#2DE86B", "#4FB2CA", "#E8DA2D", "#E84C2D")
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = pal) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```

---

## Escalas (scale): colores


Otra opción es elegir alguna de las [**paletas de colores diseñadas**]{.hl-yellow} en el paquete `{ggthemes}`:

:::: columns

::: {.column width="40%"}

* `scale_color_economist()`: paleta de colores basada en los colores de **The Economist**.

:::

::: {.column width="60%"}

```{r}
#| echo: false
library(ggthemes)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_economist() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_economist() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```


---

## Escalas (scale): colores

Otra opción es elegir alguna de las [**paletas de colores diseñadas**]{.hl-yellow} en el paquete `{ggthemes}`:

:::: columns

::: {.column width="40%"}


* `scale_color_colorblind()`: paleta de colores basada en los colores de  [**daltónicos/as**]{.hl-yellow}.

:::

::: {.column width="60%"}

```{r}
#| echo: false
library(ggthemes)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```


:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```



---

## Escalas (scale): colores


Incluso cargar [**paletas de colores diseñadas en base a películas o arte**]{.hl-yellow}


:::: columns

::: {.column width="44%"}

* [**películas**]{.hl-yellow}: paquete `{harrypotter}` (repositorio de Github `aljrico/harrypotter`) usando `scale_color_hp_d()`.


```{r echo = FALSE,  out.width = "20%", fig.align = "center", fig.cap = "Paleta basada en la casa Ravenclaw"}
knitr::include_graphics("https://raw.githubusercontent.com/aljrico/harrypotter/master/readme_raw_files/palettes/ravenclaw.png")
``` 

:::

::: {.column width="55%"}

```{r}
#| echo: false
library(harrypotter)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_hp_d(option = "ravenclaw")+
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```



:::

::::

```{r}
#| eval: false
devtools::install_github(repo = "aljrico/harrypotter") 
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  harrypotter::scale_color_hp_d(option = "ravenclaw")+
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```


---

## Escalas (scale): colores

Incluso cargar [**paletas de colores diseñadas en base a películas o arte**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* [**cuadros**]{.hl-yellow}: paquete `{MetBrewer}` (repositorio de Github `BlakeRMills/MetBrewer`) usando `scale_colour_manual(values = met.brewer(...))`.

:::


::: {.column width="55%"}

```{r}
#| echo: false
library(MetBrewer)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = met.brewer("Monet")) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```

:::
::::

```{r}
#| eval: false
devtools::install_github(repo = "BlakeRMills/MetBrewer") 
library(MetBrewer)

ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = met.brewer("Monet")) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```


---


## Escalas (scale): colores

Incluso cargar [**paletas de colores diseñadas en base a películas o arte**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* [**discos**]{.hl-yellow}: paquete `{peRReo}` (repositorio de Github `jbgb13/peRReo`) usando `scale_colour_manual(values = latin_palette())`.

:::

::: {.column width="55%"}

```{r}
#| echo: false
library(peRReo)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = latin_palette("rosalia")) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```

:::
::::

```{r}
#| eval: false
devtools::install_github(repo = "jbgb13/peRReo") 
library(peRReo)

ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = latin_palette("rosalia")) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```

---

## Escalas : otros atributos

Lo mismo que hemos hecho para los ejes o colores podemos hacer para el [**resto de atríbutos estéticos**]{.hl-yellow}

:::: columns

::: {.column width="40%"}


Por ejemplo, vamos a indicarle que mapeé el tamaño en función de población pero indicándole el [**rango de valores**]{.hl-yellow} (continuo en este caso) entre los que moverse con `scale_size_continuous()`

:::


::: {.column width="60%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  scale_size_continuous(range = c(3, 17)) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  scale_size_continuous(range = c(3, 15)) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```

:::
::::

---

## Tema (básico)

Por último en este primer gráfico, vamos personalizar el tema con alguna de las capas `theme_...()`


:::: columns

::: {.column width="45%"}

Por ejemplo, vamos a usar `theme_minimal()` para tener un tema "austero" y minimalista (aprenderemos a definir cada detalle de nuestro tema).

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```



# Clase 13: profundizando en ggplot {#clase-13}

[**Visualización de datos**]{style="color:#444442;"}


---

## Resumen de capas

Vamos a hacer un pequeño resumen de lo que llevamos aprendido hasta ahora respecto a `{ggplot2}`

. . .

* [**Capa de datos**]{.hl-yellow}: normalmente un gráfico en `{ggplot2}` empieza con `ggplot(datos)`.

. . .

* [**Mapeo de atributos estéticos**]{.hl-yellow}: todo lo que queramos que se [**codifique en función de los datos**]{.hl-purple} debe ir dentro de `aes()`

. . .

* [**Capa geométrica**]{.hl-yellow}: para decidir si queremos un scatter plot, un diagrama de barras, un histograma, etc

. . .

* [**Capas de escalas**]{.hl-yellow}: para decidir los ajustes personalizados de atributos estéticos (escala del alpha o size, paleta de colores, etc)

. . . 

* [**Tema**]{.hl-yellow}: tema para personalizar el gráfico (y etiquetas)

---

## Capa de escalas

Vamos a profundizar un poco dentro de nuestro scatter plot en  [**escalas**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* ¿Cómo [**fijar límites en los ejes**]{.hl-purple}? En `scale_x_continuous()` y `scale_y_continuous()`, además de "saltos" podemos indicar límites con `limits = ...`

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(limits = c(50, 70),
                     breaks = seq(50, 70, by = 5)) +
  scale_y_continuous(limits = c(1000, 18000),
                      breaks = seq(0, 18000, by = 1000)) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(limits = c(50, 70), breaks = seq(50, 70, by = 5)) +
  scale_y_continuous(limits = c(1000, 18000), breaks = seq(0, 18000, by = 1000)) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

---

## Capa de escalas


:::: columns

::: {.column width="45%"}

* ¿Cómo [**etiquetar las unidades de los ejes**]{.hl-purple}? Haciendo uso del paquete `{scales}` podemos añadir [**prefijos/sufijos**]{.hl-yellow} con `labels = label_number(...)`


:::

::: {.column width="55%"}

```{r}
#| echo: false
library(scales)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(limits = c(50, 70), breaks = seq(50, 70, by = 5),
                     labels = label_number(suffix = " años")) +
  scale_y_continuous(limits = c(1000, 18000), breaks = seq(0, 18000, by = 1000),
                     labels = label_number(suffix = " $")) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
library(scales)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(limits = c(50, 70), breaks = seq(50, 70, by = 5),
                     labels = label_number(suffix = " años")) +
  scale_y_continuous(limits = c(1000, 18000), breaks = seq(0, 18000, by = 1000),
                     labels = label_number(suffix = " $")) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

---

## Capa de escalas

Vamos a profundizar un poco dentro de nuestro scatter plot en  [**escalas**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* ¿Cómo [**cambiar los ajustes de tamaño, alpha, etc**]{.hl-purple}? Igual que tenemos `scale_x_...()` o `scale_color_...()`, tenemos también `scale_size_...()` y `scale_alpha_...()`


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(aes(alpha = pop)) +
  scale_size(range = c(4, 12)) +
  scale_alpha(range = c(0.1, 0.95)) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none", alpha = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(aes(alpha = pop)) +
  scale_size(range = c(4, 12)) +
  scale_alpha(range = c(0.1, 0.5)) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none", alpha = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

---

## Capa de escalas

Vamos a profundizar un poco dentro de nuestro scatter plot en  [**escalas**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* ¿Cómo [**cambiar la escala (relación) lineal entre los ejes**]{.hl-purple}? Con `scale_x_sqrt()` o `scale_x_log10()` podemos cambiar la escala de los ejes.


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_y_log10() +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_y_log10() +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```


---

## scale_color: paleta Brewer

Una de las capas de escalas más importantes son las [**capas de color**]{.hl-yellow}. Ya vimos como definir paletas manuales, ¿pero qué [**opciones hay para escalas continuas de colores**]{.hl-purple}?

. . .

Existen unas [**paletas de colores conocidas como ColorBrewer**]{.hl-yellow} pudiendo definirse de manera **secuencial**, **divergente** o de manera **cualitativa** (ver info en <https://colorbrewer2.org>)

```{r}
RColorBrewer::brewer.pal.info
```

---

## scale_color: paleta Brewer

Con `RColorBrewer::brewer.pal()` podemos obtener el vector de n colores para una paleta dada

```{r}
RColorBrewer::brewer.pal(n = 5, name = "RdYlBu")
```

. . .

Con `RColorBrewer::display.brewer.pal()` podemos **visualizar los colores** de dicha paleta

```{r}
RColorBrewer::display.brewer.pal(n = 5, name = "RdYlBu")
```

---


## scale_color: paleta Brewer


:::: columns

::: {.column width="45%"}

Para incluirlo podemos usar `scale_colour_brewer()` o bien `scale_color_distiller()` si queremos crear una **escala continua** (interpolando entre los colores)


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.7, size = 3) +
  scale_x_log10() +
  scale_color_distiller(palette = "RdYlBu") +
  guides(size = "none") +
  labs(x = "Población", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "esperanza de vida") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.7, size = 3) +
  scale_x_log10() +
  scale_color_distiller(palette = "RdYlBu") +
  guides(size = "none") +
  labs(x = "Población", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "esperanza de vida") +
  theme_minimal()
```


---

## Gradiente de color manual


:::: columns

::: {.column width="45%"}

Tambien podemos crear un [**gradiente de color manual**]{.hl-yellow} son `scale_..._gradient()` para dos colores, `scale_..._gradient2()` para tres colores (bajo, medio y alto) y `scale_..._gradientn()` para n colores



:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.8, size = 3) +
  scale_x_log10() +
  scale_color_gradient2(low = "#E92745", mid = "#F4ED5B", high = "#56B1F7", midpoint = 60) +
  labs(x = "Población", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "esperanza de vida") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.8, size = 3) +
  scale_x_log10() +
  scale_color_gradient2(low = "#E92745", mid = "#F4ED5B", high = "#56B1F7", midpoint = 60) +
  labs(x = "Población", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "esperanza de vida") +
  theme_minimal()
```

---

## Capa de coordenadas


:::: columns

::: {.column width="45%"}


Además de escalas tenemos una [**capa de coordenadas**]{.hl-yellow} con `coord_...` para indicar si queremos un sistema cartesiano (y sus límites), coordenadas polares (`coord_polar()`), si queremos coordenadas iguales (`coord_equal()`) o invertir su rol (`coord_flip()`)


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.8, size = 3) +
  scale_x_log10() +
  scale_color_gradient2(low = "#E92745", mid = "#F4ED5B", high = "#56B1F7", midpoint = 60) +
  coord_flip() +
  labs(x = "Población", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "esperanza de vida") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.8, size = 3) +
  scale_x_log10() +
  scale_color_gradient2(low = "#E92745", mid = "#F4ED5B", high = "#56B1F7", midpoint = 60) +
  coord_flip() +
  labs(x = "Población", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "esperanza de vida") +
  theme_minimal()
```


---

## Capa de stats

Una capa importante es la [**capa de estadísticas**]{.hl-yellow}

:::: columns

::: {.column width="45%"}


* `stat_smooth()`: visualiza un [**ajuste suavizado**]{.hl-yellow} de los datos (reg. lineal, glm, loess, gam, etc).

Con `stat_smooth(method = "lm", se = FALSE)` una recta de regresión (sin intervalos). 

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE, linewidth = 1.5) +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```
:::
::::


```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE, linewidth = 1.5) +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

---

## Capa de stats

Una capa importante es la [**capa de estadísticas**]{.hl-yellow} que nos permite combinar en nuestro gráfico algunas funcionalidades

:::: columns

::: {.column width="45%"}

Fíjate que si usas en la [**primera capa parámetros estéticos**]{.hl-yellow} se acaban [**heredando a capas posteriores**]{.hl-purple}, en concreto al ajuste visualizado.

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE, linewidth = 1.5) +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```
:::
::::


```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE, linewidth = 1.5) +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

---

## geom_text()

:::: columns

::: {.column width="45%"}


Podemos añadirle [**textos simples**]{.hl-yellow} con `geom_text(label = ...)`, por ejemplo, para añadir la correlación del ajuste.

:::


::: {.column width="55%"}

```{r}
#| echo: false
cor <- round(cor(gapminder_1997$gdpPercap, gapminder_1997$lifeExp), 3)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE) +
  geom_text(aes(x = 50, y = 20000), label = glue("Correlación: {cor}"),
            size = 5, color = "darkcyan") +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```
:::
::::


```{r}
#| eval: false
cor <- round(cor(gapminder_1997$gdpPercap, gapminder_1997$lifeExp), 3)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE) +
  geom_text(aes(x = 50, y = 20000, label = glue("Correlación: {cor}")),
                size = 5, color = "darkcyan") +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

---


## Capa de stats


:::: columns

::: {.column width="45%"}

Dentro de `stat_smooth()` podemos especificarle otro [**ajuste polinómico**]{.hl-yellow} dándole expresión en `formula = ...`
:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2) + I(x^3) + I(x^4) + I(x^5),
              color = "firebrick", se = FALSE, linewidth = 1.2) +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```
:::
::::


```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2) + I(x^3) + I(x^4) + I(x^5),
              color = "firebrick", se = FALSE, linewidth = 1.2) +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```


---

## Capa de stats


:::: columns

::: {.column width="45%"}

Sin `method` especificado ajuste por un LOESS (menos de 1000 puntos) o GAM (más de 1000 puntos)

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(color = "firebrick", se = FALSE, linewidth = 1.2) +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```
:::
::::


```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(color = "firebrick", se = FALSE, linewidth = 1.2) +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```


---

## Capa de stats


:::: columns

::: {.column width="45%"}

Con `stat_summary()` podemos incluso añadir [**estadísticas por grupos**]{.hl-yellow}, como la media o mediana.

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder, aes(y = gdpPercap, x = year)) +
  geom_point(size = 1.7, alpha = 0.2) +
  stat_summary(fun = "mean", size = 0.4, color = "coral") + 
  stat_summary(fun = "median", size = 0.4, color = "darkcyan") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

:::
::::


```{r}
#| eval: false
ggplot(gapminder, aes(y = gdpPercap, x = year)) +
  geom_point(size = 1.7, alpha = 0.2) +
  stat_summary(fun = "mean", size = 0.4, color = "coral") + 
  stat_summary(fun = "median", size = 0.4, color = "darkcyan") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```



---

## Capa de stats

:::: columns

::: {.column width="45%"}

Fíjate que si no tenemos una variable cuali, la media la hace con `n = 1` (es decir, es el propio punto).
:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder, aes(y = gdpPercap, x = pop)) +
  geom_point(size = 1.7, alpha = 0.2) +
  stat_summary(fun = "mean", size = 0.4, color = "coral") + 
  stat_summary(fun = "median", size = 0.4, color = "darkcyan") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

:::
::::


```{r}
#| eval: false
ggplot(gapminder, aes(y = gdpPercap, x = pop)) +
  geom_point(size = 1.7, alpha = 0.2) +
  stat_summary(fun = "mean", size = 0.4, color = "coral") + 
  stat_summary(fun = "median", size = 0.4, color = "darkcyan") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```


---

## Componiendo (facet)

También podemos [**desagregar los gráficos (facetar)**]{.hl-yellow} por grupos, equivalente al `group_by()` en tidyverse.


:::: columns

::: {.column width="45%"}

Por ejemplo, vamos a crear un [**gráfico por continente**]{.hl-yellow}, mostrando todos los gráficos a la vez (pero por separado) con `facet_wrap(~continent)`.

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent)+
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent) +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

---

## Componiendo (facet)

También podemos [**desagregar los gráficos (facetar)**]{.hl-yellow} por grupos, equivalente al `group_by()` en tidyverse.


:::: columns

::: {.column width="45%"}

Por defecto las escalas en los ejes son compartidas. Si queremos que la [**escala de los ejes**]{.hl-yellow} vaya por libre debemos usar `scales = "free_x"`, `scales = "free_y"` o `scales = "free"`


:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

---

## Componiendo (facet)

También podemos [**desagregar los gráficos (facetar)**]{.hl-yellow} por grupos, equivalente al `group_by()` en tidyverse.


:::: columns

::: {.column width="45%"}

Con `nrow = ...` y `ncol = ...` podemos especificar cuantas columnas y filas tenemos en la cuadrícula de gráficas

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent, scales = "free", nrow = 3) +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent, scales = "free", nrow = 3) +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```



---

## Componiendo (facet)



:::: columns

::: {.column width="45%"}

También le podemos pasar dos argumentos (variables) para formar un [**grid de gráficas**]{.hl-yellow}

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder |> filter(year >= 1962), aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  facet_grid(continent ~ year, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> filter(year >= 1962), aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  facet_grid(continent ~ year, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```


---

## Componiendo (facet)



:::: columns

::: {.column width="45%"}

Aprenderemos distintas personalizaciones del tema pero con `theme(legend.position = ...)` podemos [**decidir la posición de la leyenda**]{.hl-yellow}

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder |> filter(year >= 1962), aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  facet_grid(continent ~ year, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> filter(year >= 1962), aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  facet_grid(continent ~ year, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal() +
  theme(legend.position = "bottom")
```


# Clase 14: profundizando en ggplot {#clase-14}

[**Visualización de datos**]{style="color:#444442;"}


---

## Variables continuas

Hemos aprendido a realizar uno de los gráficos más famosos, un [**diagrama de dispersión**]{.hl-yellow}, pero...¿qué propiedades deben cumplir las variables?

. . .

Para visualizar dos variables con un [**diagrama de dispersión**]{.hl-yellow} es necesario que ambas sean [**variables numéricas continuas**]{.hl-purple}

. . .

¿Se te ocurre algúna gráfico básico para [**variables discretas**]{.hl-yellow}?

---


## Cualis: barras


¿Y si tengo [**variables discretas o cualitativas**]{.hl-yellow}?

. . .

Vamos a usar el ya conocido conjunto `starwars` para visualizar en un [**diagrama de barras**]{.hl-yellow}: vamos a representar la [**frecuencia**]{.hl-yellow} de una [**variable cualitativa**]{.hl-yellow} como es `sex`.

```{r}
starwars |>  
  count(sex)
```


---

## Cualis: barras

La ventaja de ggplot es que, al trabajar por [**capas**]{.hl-yellow},  todo lo que hemos aprendido nos sirve: solo tenemos que [**cambiar la geometría**]{.hl-purple}.

:::: columns

::: {.column width="40%"}

En este caso para realizar un [**diagrama de barras**]{.hl-yellow} usaremos `geom_bar()` en lugar de `geom_point()`, indicando [**solo la variable de grupo**]{.hl-purple} con `x = sex` (ggplot hará solo el recuento)

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(starwars, aes(x = sex)) +
  geom_bar() +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(starwars, aes(x = sex)) +
  geom_bar()
  theme_minimal()
```


---

## Cualis: barras

:::: columns

::: {.column width="40%"}


Podemos aplicar lo aprendido sobre [**colores para codificar**]{.hl-yellow} la información, en este caso vamos a usar las paletas ya cargadas en `scale_color_colorblind()` del paquete `{ggthemes}`

:::

::: {.column width="60%"}

```{r}
#| echo: false
library(ggthemes)
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(color = sex), alpha = 0.5) + 
  scale_color_colorblind() +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
library(ggthemes)
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(color = sex), alpha = 0.5) + 
  scale_color_colorblind() +
  theme_minimal()
```



---


## Cualis: barras

:::: columns

::: {.column width="40%"}

Fíjate que ahora [**solo nos ha coloreado el contorno**]{.hl-red}: en otras geometrías, como las barras, será importante distinguir entre `color` y `fill`


:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  theme_minimal()
```


---

## Cualis: barras




:::: columns

::: {.column width="40%"}

Podemos [**personalizar el gráfico**]{.hl-yellow} haciendo uso de las opciones ya vistas, por ejemplo, con escalas en ejes, títulos de las variables, leyendas, etc

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  labs(x = "sexo", y = "frecuencia absoluta",
       fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Álvarez Liébana") +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Álvarez Liébana") +
  theme_minimal()
```


---


## Cualis: barras




:::: columns

::: {.column width="40%"}

Para cambiar el rol de los ejes, generando un diagrama de [**barras horizontales**]{.hl-yellow}, podemos dejar el gráfico igual y luego simplemente hacer `coord_flip()`
:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Álvarez Liébana") +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Álvarez Liébana") +
  theme_minimal()
```



---

## Paréntesis: temas


Vamos a hacer un paréntesis y aprender a [**personalizar más nuestras gráficas**]{.hl-yellow}

:::: columns

::: {.column width="55%"}

* `theme_set(theme_minimal())` fija tema base

* `theme_update(...)` personaliza parámetros.

Por ejemplo, en `plot.title` vamos a indicarle el [**tamaño y negrita**]{.hl-yellow} en el título, dentro de `element_text()`

:::


::: {.column width="45%"}

```{r}
#| echo: false
theme_set(theme_minimal())
theme_update(plot.title = element_text(size = 25, face = "bold"))
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Álvarez Liébana")
```

:::
::::

```{r}
#| eval: false
theme_set(theme_minimal())
theme_update(plot.title = element_text(size = 25, face = "bold"))
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente", caption = "J. Álvarez Liébana")
```


---

## Paréntesis: temas

:::: columns

::: {.column width="40%"}

Podemos hacer lo mismo con otros textos con `plot.subtitle` o `plot.caption`

:::


::: {.column width="60%"}

```{r}
#| echo: false
theme_set(theme_minimal())
theme_update(
  plot.title =
    element_text(size = 25, face = "bold"),
  plot.subtitle = element_text(size = 13),
  plot.caption = element_text(size = 9))

starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Álvarez Liébana")
```

:::
::::

```{r}
#| eval: false
theme_set(theme_minimal())
theme_update(
  plot.title =
    element_text(size = 25, face = "bold"),
  plot.subtitle = element_text(size = 13),
  plot.caption = element_text(size = 9))
```


---

## Paréntesis: temas

:::: columns

::: {.column width="50%"}

Vamos incluso a [**elegir fuente o el color**]{.hl-yellow}

* `sysfonts::font_add_google()`: le indicaremos la tipografía de <https://fonts.google.com/>

* `showtext_auto()` del paquete `{showtext}` nos permite su uso.

:::

::: {.column width="50%"}

```{r}
#| echo: false
library(showtext)
library(sysfonts)
font_add_google(name = "Roboto")
showtext_auto()
theme_set(theme_minimal(base_family = "Roboto")) 

# Configurar tema
theme_update(
  plot.title = element_text(color = "#C34539", face = "bold", size = 33),
  plot.subtitle = element_text(color = "#3E6FCB", face = "bold", size = 21),
  axis.title.x = element_text(size = 19),
  axis.title.y = element_text(size = 19))

starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Álvarez Liébana")
```

:::
::::

```{r}
#| eval: false
library(showtext)
library(sysfonts)
font_add_google(name = "Roboto")
showtext_auto()
theme_set(theme_minimal(base_family = "Roboto")) 

# Configurar tema
theme_update(
  plot.title = element_text(color = "#C34539", face = "bold", size = 33),
  plot.subtitle = element_text(color = "#3E6FCB", face = "bold", size = 21),
  axis.title.x = element_text(size = 19),
  axis.title.y = element_text(size = 19))
```

---

## Cualis: barras apiladas

¿Podríamos visualizar [**dos variables discretas/cualis a la vez**]{.hl-yellow}?

. . .

:::: columns

::: {.column width="40%"}

Podemos incluir una en `x = ...` y otra en `fill = ...`, de manera que [**por defecto nos visualiza barras apiladas**]{.hl-yellow}, por ejemplo, para ver el reparto de sexos entre humanos y no humanos.

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  labs(x = "¿Humanos?", y = "frecuencia absoluta", fill = "sexo",  title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Álvarez Liébana")
```
 
:::
::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  labs(x = "¿Humanos?", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Álvarez Liébana")
```

---

## Cualis: barras solapas

:::: columns

::: {.column width="40%"}

Con `position = "dodge"` visualizamos las barras sin apilar, solapadas una al lado de otra

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5,
           position = "dodge") + 
  scale_fill_colorblind() +
  labs(x = "¿Humanos?", y = "frecuencia absoluta", fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Álvarez Liébana")
```
 
:::
::::


```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5, position = "dodge") + 
  scale_fill_colorblind() +
  labs(x = "¿Humanos?", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Álvarez Liébana")
```

---

## Cualis: barras fill


:::: columns

::: {.column width="40%"}

Con `position = "fill"` visualizamos las barras en forma de [**frecuencia relativa**]{.hl-yellow}, con las barras de la misma altura para facilitar la comparativa.

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5, position = "fill") + 
  scale_fill_colorblind() +
  labs(x = "¿Humanos?", y = "frecuencia relativa", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Álvarez Liébana")
```
 
:::
::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5,  position = "fill") + 
  scale_fill_colorblind() +
  labs(x = "¿Humanos?", y = "frecuencia relativa", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Álvarez Liébana")
```

---

## Paréntesis: factores

En el caso de las [**variables cualitativas**]{.hl-yellow}, llamaremos  **niveles o modalidades** a los **diferentes valores** que pueden tomar estos datos. Por ejemplo, en el caso de la variable `sex` del conjunto `starwars`, tenemos 4 niveles permitidos: `female`, `hermaphroditic`, `male` y `none` (amén de datos ausentes).

```{r}
starwars |> count(sex)
```


---

## Paréntesis: factores

Este tipo de variables se conocen en `R` como [**factores**]{.hl-yellow}. Y el paquete fundamental para tratarlos es `{forcats}` (del entorno `{tidyverse}`). 


![](./img/factors.jpg)

---

## Paréntesis: factores

Este paquete nos permite fijar los [**niveles**]{.hl-yellow} (guardados internamente como `levels`) que toma una determinada variable categórica, dándoles un [**tratamiento diferente a las cadena de texto normales**]{.hl-yellow}.

. . .

Veamos un ejempo sencillo definiendo una variable `estado` que tome los valores `"sano"`, `"leve"` y `"grave"` de la siguiente manera.

```{r}
estado <-
  c("leve", "grave", "sano", "sano", "leve", "sano", "sano", "grave",
    "grave", "leve", "grave", "sano", "sano")
estado
```

La variable `estado` actualmente es de [**tipo texto**]{.hl-yellow}, de tipo `chr`, algo que podemos comprobar con `class(estado)`.

```{r}
class(estado)
```

---

## Paréntesis: factores

Desde un punto de vista estadístico y computacional, para `R` esta variable ahora mismo sería equivalente una variable de nombres. Pero estadísticamente [**no es lo mismo una variable con nombres**]{.hl-yellow} (que identifican muchas veces el registro) que una variable categórica como estado que [**solo puede tomar esos 3 niveles**]{.hl-yellow}. ¿Cómo [**convertir a factor**]{.hl-yellow}?

. . .

Haciendo uso de la función `as_factor()` del paquete `{forcats}`.

```{r}
library(tidyverse)
estado_fct <- tibble(paciente = 1:length(estado),
                     estado = as_factor(estado))
estado_fct
```

---

## Paréntesis: factores


No solo ha cambiado la clase de la variable sino que ahora, debajo del valor guardado, nos aparece la frase `Levels: grave leve sano`: son las [**modalidades o niveles**]{.hl-yellow} de nuestra cualitativa. 

&nbsp;

Imagina que ese día en el hospital no tuviésemos a **nadie en estado grave**: aunque ese día nuestra variable no tome dicho valor, el estado `grave` es un [**nivel permitido en la base de datos**]{.hl-yellow}, así que aunque lo eliminemos, por ser un factor, el nivel permanece (no lo tenemos ahora pero es un nivel permitido).


```{r}
estado_fct |> 
  filter(estado %in% c("sano", "leve")) |> 
  pull(estado)
```

---

## Paréntesis: factores


Con `factor()` podemos [**especificar explícitamente**]{.hl-yellow} los nombres de las modalidades, incluso si son nominales u [**ordinales**]{.hl-yellow}

```{r}
estado_fct <-
  tibble(paciente = 1:length(estado),
         estado = factor(estado, ordered = TRUE))
estado_fct |> pull(estado)
```

---

## Paréntesis: factores


Con  `levels = ...` podemos indicarle explícitamente el [**orden de las modalidades**]{.hl-yellow}

```{r}
estado_fct <-
  tibble(paciente = 1:length(estado),
         estado = factor(estado,
                         levels = c("sano", "leve", "grave"),
                         ordered = TRUE))
estado_fct |> pull(estado)
```



---

## Paréntesis: factores


:::: columns

::: {.column width="50%"}

Si queremos indicarle que [**elimine un nivel no usado**]{.hl-yellow} en ese momento (y que queremos excluir de la definición) podemos hacerlo con `fct_drop()`

:::


::: {.column width="50%"}

![](img/drop_factor.jpg)

:::
::::

```{r}
estado_fct |> 
  filter(estado %in% c("sano", "leve")) |> 
  mutate(estado = fct_drop(estado)) |> 
  pull(estado)
```

---

## Paréntesis: factores

:::: columns

::: {.column width="50%"}

Al igual que podemos eliminar niveles podemos [**ampliar los niveles existentes**]{.hl-yellow} (aunque no existan datos de ese nivel en ese momento) con `fct_expand()`

:::

::: {.column width="50%"}

![](./img/factor_expand.jpg)

:::
::::

```{r}
estado_fct |> 
  mutate(estado = fct_expand(estado, c("UCI", "fallecido"))) |> 
  pull(estado)
```

---

## Paréntesis: factores

:::: columns

::: {.column width="50%"}

Además con `fct_explicit_na()` podemos [**asignar un nivel a los valores**]{.hl-yellow} para que sea incluido dicho nivel en los análisis y visualizaciones.

:::

::: {.column width="50%"}

![](./img/factor_explicit.jpg)

:::
::::

```{r}
fct_explicit_na(factor(c("a", "b", NA)))
```

---

## Paréntesis: factores


Incluso una vez definidos podemos [**reordenar los níveles**]{.hl-yellow} con `fct_relevel()`


```{r}
estado_fct_expand <- 
  estado_fct |> 
  mutate(estado = fct_expand(estado, c("UCI", "fallecido"))) |> 
  pull(estado)

estado_fct_expand |>
  fct_relevel(c("fallecido", "leve", "sano", "grave", "UCI"))
  
```


---

## Paréntesis: factores

:::: columns

::: {.column width="50%"}

Esta forma de trabajar con variables cualitativas nos permite dar una [**definición teórica**]{.hl-yellow} de nuestra base de datos, pudiendo incluso contar valores que aún no existen (pero que podrían), haciendo uso de `fct_count()`

:::

::: {.column width="50%"}

![](./img/fct_count.jpg)

:::
::::

```{r}
estado_fct |> 
  mutate(estado = fct_expand(estado, c("UCI", "fallecido"))) |> 
  pull(estado) |> 
  fct_count()
```


---

## Paréntesis: factores


Los níveles también podemos [**ordenarlos por frecuencia**]{.hl-yellow} con `fct_infreq()`

```{r}
estado_fct |> 
  mutate(estado = fct_infreq(estado)) |> 
  pull(estado) |> 
  fct_count()
```

---

## Paréntesis: factores


A veces querremos [**agrupar niveles**]{.hl-yellow}, por ejemplo, no permitiendo niveles que [**no sucedan un mínimo de veces**]{.hl-yellow} con `fct_lump_min(.., min = ..)` (las observaciones que no lo cumplan irán a un **nivel genérico** llamado `Other`, aunque se puede cambiar con el argumento `other_level`). 

:::: columns

::: {.column width="50%"}


```{r}
estado_fct |> 
  pull(estado) |> 
  fct_lump_min(min = 4)
```

:::

::: {.column width="50%"}


```{r}
estado_fct |> 
  pull(estado) |> 
  fct_lump_min(min = 4,
               other_level = "otros")
```

:::
::::

---

## Paréntesis: factores


Podemos hacer algo equivalente pero en función de su [**frecuencia relativa**]{.hl-yellow} con `fct_lump_prop()`.


```{r}
estado_fct |> 
  pull(estado) |> 
  fct_lump_prop(prop = 0.4,
                other_level = "otros")
```

---


## Paréntesis: factores

Esto lo podemos aplicar a nuestros conjuntos de datos para [**recategorizar variables**]{.hl-yellow} de forma muy rápida.

```{r}
starwars |> 
  drop_na(species) |> 
  mutate(species =
           fct_lump_min(species, min = 3,
                        other_level = "Otras")) |> 
  count(species)
```

---

## Paréntesis: factores

Con `fct_reorder()` podemos también indicar que queremos [**ordenar los factores**]{.hl-yellow} en función de una función aplicada a otra variable.


```{r}
starwars_factor <- 
  starwars |> 
  drop_na(height, species) |> 
  mutate(species =
           fct_lump_min(species, min = 3,
                        other_level = "Otras"))
```

:::: columns

::: {.column width="50%"}

```{r}
starwars_factor |> pull(species)
```

:::



::: {.column width="50%"}

```{r}
starwars_factor |>
  mutate(species = fct_reorder(species, height, mean)) |> 
  pull(species)
```

:::
::::

---

## 💻 Tu turno {#tu-turno-14}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 Dada la variable `meses` definida debajo (definida como un vector de caracteres), convierte dicha variable a factor (solo eso)

```{r}
meses <- c("Ene", "Feb", "Mar", "Abr")
```

```{r}
#| eval: false
#| code-fold: true
meses <- c("Ene", "Feb", "Mar", "Abr")
meses_fct <- as_factor(meses)
meses_fct
```
  
### [**Ejercicio 2**]{.hl-yellow}

📝 Dada la variable `meses` definida debajo convierte dicha variable a factor pero indicando los niveles de forma correcta.

```{r}
meses <- c(NA, "Abr", "Ene", "Oct", "Jul", "Ene", "Sep", NA, "Feb", "Dic",
           "Jul", "Mar", "Ene", "Mar", "Feb", "Abr", "May", "Oct", "Sep",  NA,
           "Dic", "Jul", "Nov", "Feb", "Oct", "Jun", "Sep", "Oct", "Oct", "Sep")
```

```{r}
#| eval: false
#| code-fold: true
meses <- c(NA, "Abr", "Ene", "Oct", "Jul", "Ene", "Sep", NA, "Feb", "Dic",
           "Jul", "Mar", "Ene", "Mar", "Feb", "Abr", "May", "Oct", "Sep",  NA,
           "Dic", "Jul", "Nov", "Feb", "Oct", "Jun", "Sep", "Oct", "Oct", "Sep")

# Orden de niveles correcto e incluimos agosto aunque no haya
meses_fct <-
  factor(meses,
         levels = c("Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"))
meses_fct
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Cuenta cuantos valores hay de cada mes pero teniendo en cuenta que son factores (quizás haya niveles sin ser usados y de los que debería obtener un 0).

```{r}
#| eval: false
#| code-fold: true
meses_fct |> fct_count()
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Dado que hay ausentes, indica que los ausentes sea un decimotercer nivel etiquetado como "ausente".

```{r}
#| eval: false
#| code-fold: true
meses_fct <- 
  meses_fct |>
  fct_explicit_na(na_level = "ausente")
meses_fct
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Elimina los niveles no usados.

```{r}
#| eval: false
#| code-fold: true
meses_fct <- 
  meses_fct |>
  fct_drop()
meses_fct
```

### [**Ejercicio 6**]{.hl-yellow}

📝 Ordena los niveles por frecuencia de aparición.
  
```{r}
#| eval: false
#| code-fold: true
meses_fct |> 
  fct_infreq()
```


### [**Ejercicio 7**]{.hl-yellow}

📝 Agrupa niveles de forma que todo nivel que no aparezca al menos el 7% de las veces se agrupe en un nivel llamado "otros meses"

```{r}
#| eval: false
#| code-fold: true
meses_fct <-
  meses_fct |> 
  fct_lump_prop(prop = 0.07, other_level = "otros")
meses_fct
```

:::

---


## Cualis: barras ordenadas

:::: columns

::: {.column width="40%"}

Haciendo uso de los que sabemos [**sobre factores**]{.hl-yellow} podemos indicarle que nos [**ordene las columnas de manera personalizada**]{.hl-purple} definiendo la variable cuali como un factor.

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
    drop_na(sex) |> mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |> 
    ggplot(aes(x = sex)) +
    geom_bar(aes(fill = sex), alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "frecuencia absoluta", fill = "sexo",
         title = "Primer diagrama de barras",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Álvarez Liébana")
```
:::
::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |> 
    ggplot(aes(x = sex)) +
    geom_bar(aes(fill = sex), alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Álvarez Liébana")
```
         
---



## Cualis: barras ordenadas

:::: columns

::: {.column width="40%"}

También podemos indicarle que nos [**ordene las columnas de mayor a menor frecuencia**]{.hl-yellow} usando simplemente `fct_infreq()`

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
    drop_na(sex) |> mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |> 
    ggplot(aes(x = fct_infreq(sex))) +
    geom_bar(aes(fill = sex), alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "frecuencia absoluta", fill = "sexo",
         title = "Primer diagrama de barras",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Álvarez Liébana")
```
:::
::::

```{r}
#| eval: false
starwars |> 
    drop_na(sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |> 
    ggplot(aes(x = fct_infreq(sex))) +
    geom_bar(aes(fill = sex), alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Álvarez Liébana")
```


---


## Cualis: barras ordenadas

:::: columns

::: {.column width="40%"}

Para [**invertir el orden de los factores**]{.hl-yellow} basta usar `fct_rev()`

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
    drop_na(sex) |> mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |> 
    ggplot(aes(x = fct_rev(fct_infreq(sex)))) +
    geom_bar(aes(fill = sex), alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "frecuencia absoluta", fill = "sexo",
         title = "Primer diagrama de barras",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Álvarez Liébana")
```
:::
::::

```{r}
#| eval: false
starwars |> 
    drop_na(sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |> 
    ggplot(aes(x = fct_rev(fct_infreq(sex)))) +
    geom_bar(aes(fill = sex), alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Álvarez Liébana")
```



---

## Cualis: geom_col()

La capa `geom_bar()` está solo pensada para [**conteos de variables discretas o cualitativas**]{.hl-yellow}. ¿Y si queremos visualizar en el peso por sexo?

. . .

:::: columns

::: {.column width="45%"}

Usaremos `geom_col()` (ahora si necesitamos `x,y`)

:::

::: {.column width="55%"}

```{r}
#| echo: false
starwars |> 
  drop_na(mass, sex) |>
    ggplot(aes(x = sex, y = mass)) +
    geom_col(aes(fill = sex), alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "Peso", fill = "sexo", title = "Primer diagrama de columnas",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Álvarez Liébana")
```

:::

::::


```{r}
#| eval: false
starwars |> 
  drop_na(mass, sex) |>
  ggplot(aes(x = sex, y = mass)) +
  geom_col(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  labs(x = "Sexo", y = "Peso", fill = "sexo", title = "Primer diagrama de columnas",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente", caption = "J. Álvarez Liébana")
```


---

## Cualis: geom_col()


Fíjate que [**por defecto**]{.hl-red} lo que hace es [**sumar la variable continua**]{.hl-yellow}. ¿Cómo pedir que visualice, por ejemplo, la [**media por grupos**]{.hl-purple}?

. . .

:::: columns

::: {.column width="45%"}

La forma más inmediata es hacer un `geom_col()` pero en lugar de a la tabla original a un resumen de la misma.

:::

::: {.column width="55%"}

```{r}
#| echo: false
starwars |> 
  drop_na(mass, sex) |> 
  summarise(mean_mass = mean(mass), .by = sex) |> 
  ggplot(aes(x = sex, y = mean_mass)) +
  geom_col(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  labs(x = "Sexo", y = "Peso (medio)", fill = "sexo", title = "Primer diagrama de columnas",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente", caption = "J. Álvarez Liébana")
```

:::

::::


```{r}
#| eval: false
starwars |> 
  drop_na(mass, sex) |> 
  summarise(mean_mass = mean(mass), .by = sex) |> 
  ggplot(aes(x = sex, y = mean_mass)) +
  geom_col(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  labs(x = "Sexo", y = "Peso (medio)", fill = "sexo", title = "Primer diagrama de columnas",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente", caption = "J. Álvarez Liébana")
```


---

## Cualis: geom_col()



:::: columns

::: {.column width="45%"}

Otra opción es no usar la capa geométrica sino la capa estadística, con `stat_summary()` e indicándole la función a visualizar y el geometría

:::

::: {.column width="55%"}

```{r}
#| echo: false
starwars |> 
    drop_na(mass, sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |>
    ggplot(aes(x = sex, y = mass, fill = sex)) +
    stat_summary(geom = "col", fun = mean, alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "Peso (medio)", fill = "sexo",
         title = "Primer diagrama de columnas",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Álvarez Liébana")
```

:::

::::


```{r}
#| eval: false
starwars |> 
    drop_na(mass, sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |>
    ggplot(aes(x = sex, y = mass, fill = sex)) +
    stat_summary(geom = "col", fun = mean, alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "Peso (medio)", fill = "sexo",
         title = "Primer diagrama de columnas",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Álvarez Liébana")
```


---

## Cualis: geom_col()

:::: columns

::: {.column width="45%"}

Fíjate que ambas formas nos permiten visualizar cualquier otro estadístico, por ejempo, la mediana

:::

::: {.column width="55%"}

```{r}
#| echo: false
starwars |> 
    drop_na(mass, sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |>
    ggplot(aes(x = sex, y = mass, fill = sex)) +
    stat_summary(geom = "col", fun = median, alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "Peso (mediana)", fill = "sexo",
         title = "Primer diagrama de columnas",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Álvarez Liébana")
```

:::

::::


```{r}
#| eval: false
starwars |> 
    drop_na(mass, sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |>
    ggplot(aes(x = sex, y = mass, fill = sex)) +
    stat_summary(geom = "col", fun = median, alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "Peso (mediana)", fill = "sexo",
         title = "Primer diagrama de columnas",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Álvarez Liébana")
```

---


## Cualis: geom_col()

:::: columns

::: {.column width="45%"}

La última opción es volver a nuestra conocida `geom_bar()`, indicándole `stat = "summary", fun = "mean"`, por ejemplo (por defecto `stat = "count"`) con ahora sí dos variables

:::

::: {.column width="55%"}

```{r}
#| echo: false
starwars |> 
    drop_na(mass, sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |>
    ggplot(aes(x = sex, y = mass)) +
    geom_bar(aes(fill = sex), alpha = 0.5,
             stat = "summary", fun = "mean") + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "Peso (media)", fill = "sexo",
         title = "Primer diagrama de columnas",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Álvarez Liébana")
```

:::

::::


```{r}
#| eval: false
starwars |> 
    drop_na(mass, sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |>
    ggplot(aes(x = sex, y = mass)) +
    geom_bar(aes(fill = sex), alpha = 0.5,
             stat = "summary", fun = "mean") + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "Peso (media)", fill = "sexo",
         title = "Primer diagrama de columnas",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Álvarez Liébana")
```

---

## Imitando a Nightingale

Vamos a intentar replicar el [**famoso gráfico de rosa o diagrama de área polar de Florence Nightingale**]{.hl-yellow}, cargando los datos de `{HistData}`. Los datos representan, por meses, las diferentes causas de mortalidad de los soldados ingleses en la Guerra de Crimea (busca en la ayuda para saber qué es cada cosa)

```{r}
library(HistData)
datos <- as_tibble(Nightingale)
```

![](./img/rosa_nightingale.jpg)

---

## Imitando a Nightingale

1. Filtra solo las variables relativas a fecha y las relativadas a tasas de mortalidad (por cada 1000 habitantes), aquellas que acaban por `".rate"`. Tras ello prepara los datos de manera adecuada para su visualización (todo en castellano)

```{r}
#| code-fold: true
datos_filtrados <-
  datos |> 
  select(Date:Year, contains("rate")) |> 
  pivot_longer(cols = contains("rate"),
               names_to = "causa",
               values_to = "tasa") |> 
  rename(fecha = Date, mes = Month, anno = Year) |> 
  mutate(causa =
           case_when(causa == "Disease.rate" ~ "infecciosas",
                     causa == "Wounds.rate" ~ "heridas",
                     TRUE ~ "otras"))
datos_filtrados
```

---

## Imitando a Nightingale

2. Realiza las transformaciones en los datos que consideres y replica el gráfico.

```{r}
#| code-fold: true
#| echo: false
#| fig-width: 11
datos_filtrados <-
  datos_filtrados |>
  mutate(periodo =
           ifelse(fecha >= "1855-04-01", "Abril 1855 - Marzo 1856", "Abril 1854 - Marzo 1855"),
         periodo =
           factor(periodo,
                  levels = c("Abril 1854 - Marzo 1855", "Abril 1855 - Marzo 1856"),
                  ordered = TRUE))

theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Álvarez Liébana | Data: {HistData}")
```



---

## Imitando a Nightingale


```{r}
#| code-fold: true
#| eval: false
datos_filtrados <-
  datos_filtrados |>
  mutate(periodo = ifelse(fecha >= "1855-04-01", "Abril 1855 - Marzo 1856", "Abril 1854 - Marzo 1855"),
         periodo =
           factor(periodo, levels = c("Abril 1854 - Marzo 1855", "Abril 1855 - Marzo 1856"),
                  ordered = TRUE))

theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Álvarez Liébana | Data: {HistData}")
```


        
---

## Imitando a Nightingale

3. Nuestros datos abarcan dos periodos: de abril 1854 a marzo 1855, y de abril 1855 a marzo 1856. Realiza los cambios necesarios  para obtener el siguiente gráfico.

```{r}
#| code-fold: true
#| echo: false
#| fig-width: 11
datos_filtrados <-
  datos_filtrados |>
  mutate(periodo = ifelse(fecha >= "1855-04-01", "Abril 1855 - Marzo 1856", "Abril 1854 - Marzo 1855"),
         periodo =
           factor(periodo, levels = c("Abril 1854 - Marzo 1855", "Abril 1855 - Marzo 1856"),
                  ordered = TRUE),
         mes = fct_relevel(mes, "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov",
                           "Dec", "Jan", "Feb", "Mar"))

theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Álvarez Liébana | Data: {HistData}")
```

---

## Imitando a Nightingale


```{r}
#| code-fold: true
#| eval: false
datos_filtrados <-
  datos_filtrados |>
  mutate(periodo = ifelse(fecha >= "1855-04-01", "Abril 1855 - Marzo 1856", "Abril 1854 - Marzo 1855"),
         periodo =
           factor(periodo, levels = c("Abril 1854 - Marzo 1855", "Abril 1855 - Marzo 1856"),
                  ordered = TRUE),
         mes = fct_relevel(mes, "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov",
                           "Dec", "Jan", "Feb", "Mar"))

theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Álvarez Liébana | Data: {HistData}")
```


---

## Imitando a Nightingale


4. Piensa que cambio hemos realizado en el siguiente gráfico. ¿Qué se ha cambiado en las coordenadas? ¿Tenemos alguna capa que pueda ayudarnos a realizarlo? Investiga


```{r}
#| code-fold: true
#| echo: false
#| fig-width: 11
theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  coord_polar() +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Álvarez Liébana | Data: {HistData}")
```

---

## Imitando a Nightingale


```{r}
#| code-fold: true
#| eval: false
theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  coord_polar() +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Álvarez Liébana | Data: {HistData}")
```

---

## Imitando a Nightingale


5. Ahora mismo se notan mucho las diferencias entre gajos. ¿Cómo podríamos reducir esa diferencia? ¿Qué tipo de cambio deberíamos realizar (qué tipo de capa usar)?



```{r}
#| code-fold: true
#| echo: false
#| fig-width: 11
theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  coord_polar() +
  scale_y_sqrt() +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Álvarez Liébana | Data: {HistData}")
```

---

## Imitando a Nightingale


```{r}
#| code-fold: true
#| eval: false
theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  coord_polar() +
  scale_y_sqrt() +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Álvarez Liébana | Data: {HistData}")
```

---

## Imitando a Nightingale


6. Dado que en el gráfico original no hay marcas en el eje Y, vamos **eliminar el eje Y** (sin título, sin textos, sin marcas). ¿Qué habría que cambiar? Investiga en `theme()` Situa además la leyenda en la parte inferior


```{r}
#| code-fold: true
#| echo: false
#| fig-width: 11
theme_set(theme_minimal())
theme_update(axis.title.y = element_blank(),
             axis.text.y = element_blank(),
             axis.ticks.y = element_blank(),
             legend.position = "bottom")
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  coord_polar() +
  scale_y_sqrt() +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Álvarez Liébana | Data: {HistData}")
```

---

## Imitando a Nightingale

```{r}
#| code-fold: true
#| eval: false
theme_set(theme_minimal())
theme_update(axis.title.y = element_blank(),
             axis.text.y = element_blank(),
             axis.ticks.y = element_blank(),
             legend.position = "bottom")
```


---

## Imitando a Nightingale

7. Para que sea más legible vamos a **reducir el tamaño de las etiquetas de los meses** y vamos a darle **etiquetas correctas a los meses** (July en lugar de Jul, December en lugar de Dec, etc).


```{r}
#| code-fold: true
#| echo: false
#| fig-width: 11
theme_set(theme_minimal())
theme_update(axis.title.y = element_blank(), axis.text.y = element_blank(),
             axis.ticks.y = element_blank(), axis.text.x = element_text(size = 6, face = "bold"),
             legend.position = "bottom")

ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  coord_polar() +
  scale_y_sqrt() +
  scale_x_discrete(labels =
                     c("JULY", "AUGUST", "SEPTEMBER", "OCTOBER", "NOVEMBER", "DECEMBER",
                       "JANUARY", "FEBRUARY", "MARCH", "APRIL", "MAY", "JUNE")) +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Álvarez Liébana | Data: {HistData}")
```

---

## Imitando a Nightingale

```{r}
#| code-fold: true
#| eval: false
theme_set(theme_minimal())
theme_update(axis.title.y = element_blank(), axis.text.y = element_blank(),
             axis.ticks.y = element_blank(), axis.text.x = element_text(size = 6, face = "bold"),
             legend.position = "bottom")

... + 
  scale_x_discrete(labels =
                     c("JULY", "AUGUST", "SEPTEMBER", "OCTOBER", "NOVEMBER", "DECEMBER",
                       "JANUARY", "FEBRUARY", "MARCH", "APRIL", "MAY", "JUNE"))
```



---

## 🐣 Caso práctico 14 a: ggplot 

Usa el dataset `gapminder` y visualiza en un gráfico la media de la variable `gdpPercap` por continente y año mediante un diagrama de barras en 3 formas:

* barras solapadas
* barras apiladas
* barras fill

---

## 🐣 Caso práctico 14 b: ggplot 

El objetivo es analizar un conjunto de datos que contiene las respuestas a las pregunta [**«¿Qué probabilidad (%) asignarías al término (entre otros) ...**]{.hl-yellow}

* **«almost no chance»**
* **«probable»**
* **«almost certainly»**

...con el objetivo de [**comprender cómo la gente percibe el vocabulario**]{.hl-yellow} de la probabilidad.

```{r}
datos <-
  read_csv("https://raw.githubusercontent.com/zonination/perceptions/master/probly.csv")
datos
```

---

## 🐣 Caso práctico 14 b: ggplot 

```{r}
datos <-
  read_csv("https://raw.githubusercontent.com/zonination/perceptions/master/probly.csv")
datos
```

Solo haciendo uso de los gráficos aprendidos hasta ahora, ¿cómo visualizarías dicho dataset? Realiza las tranformaciones que consideres para una correcta preparación de los datos.

# Clase 15: dataviz

[**Visualización de datos**]{style="color:#444442;"}

---


## Variables continuas

> Solo haciendo uso de los gráficos aprendidos hasta ahora, ¿cómo visualizarías dicho dataset? Realiza las tranformaciones que consideres para una correcta preparación de los datos.

```{r}
datos <-
  read_csv("https://raw.githubusercontent.com/zonination/perceptions/master/probly.csv")
```

. . .

Lo primero que deberemos hacer es [**preparar nuestros datos**]{.hl-yellow} para la posterior visualización en formato tidy

```{r}
datos_tidy <-
  datos |> 
  pivot_longer(cols = everything(),
               names_to = "termino", values_to = "prob")
datos_tidy
```

---


## Variables continuas

¿Cómo podemos visualizar estos datos?

. . .

Tenemos dos variables:

* `termino`: [**cualitativa ordinal**]{.hl-yellow}
* `prob`: [**cuantitativa continua**]{.hl-yellow}

Por lo que de momento no tenemos herramienta para visualizarlo ya que

* [**scatter plot**]{.hl-purple}: dos variables continuas.
* [**diagrama de barras**]{.hl-purple}: variables discretas o cualitativas

. . .

La única manera será [**realizar un resumen**]{.hl-yellow} de los datos visualizando, por ejemplo, la [**media de probabilidad**]{.hl-yellow} asignada

---

## Variables continuas

La única manera será [**realizar un resumen**]{.hl-yellow} de los datos visualizando, por ejemplo, la [**media de probabilidad**]{.hl-yellow} asignada

. . .

```{r}
resumen <- 
  datos_tidy |>
  summarise(mean_prob = mean(prob), .by = termino)
resumen
```

---

## Variables continuas

::: columns
::: {.column width="40%"}

Con `scale_fill_gradient2()` vamos a crear un gradiente de color, y con `scale_y_continuous()` incorporamos % en el eje Y.

:::

::: {.column width="60%"}
```{r}
#| echo: false
ggplot(resumen, aes(x = termino, y = mean_prob, fill = mean_prob)) +
  geom_col(alpha = 0.8) +
  scale_fill_gradient2(low = "#DA4A4A", mid = "#FEFADF", high = "#144F8D", midpoint = 50) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  labs(fill = "Prob. media", x = "Términos", y = "Probabilidad media",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(resumen, aes(x = termino, y = mean_prob, fill = mean_prob)) +
  geom_col(alpha = 0.8) +
  scale_fill_gradient2(low = "#DA4A4A", mid = "#FEFADF", high = "#144F8D", midpoint = 50) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  labs(fill = "Prob. media", x = "Términos", y = "Probabilidad media",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```


---

## Variables continuas



::: columns
::: {.column width="40%"}

Para mejorar la legibilidad vamos a reducir el tamaño de las etiquetas del eje X.

:::

::: {.column width="60%"}
```{r}
#| echo: false
ggplot(resumen, aes(x = termino, y = mean_prob, fill = mean_prob)) +
  geom_col(alpha = 0.8) +
  scale_fill_gradient2(low = "#DA4A4A", mid = "#FEFADF", high = "#144F8D", midpoint = 50) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  labs(fill = "Prob. media", x = "Términos", y = "Probabilidad media",
       title = "Percepción de la probabilidad") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 6, angle = 30))
```

:::
::::

```{r}
#| eval: false
ggplot(resumen, aes(x = termino, y = mean_prob, fill = mean_prob)) +
  geom_col(alpha = 0.8) +
  scale_fill_gradient2(low = "#DA4A4A", mid = "#FEFADF", high = "#144F8D", midpoint = 50) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  labs(fill = "Prob. media", x = "Términos", y = "Probabilidad media",
       title = "Percepción de la probabilidad") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 6, angle = 30))
```

---

## Variables continuas


::: columns
::: {.column width="40%"}

Por último, vamos a ordenar las barras de más a menos

:::

::: {.column width="60%"}
```{r}
#| echo: false
ggplot(resumen |> mutate(termino = fct_reorder(termino, mean_prob)), aes(x = termino, y = mean_prob, fill = mean_prob)) +
  geom_col(alpha = 0.8) +
  scale_fill_gradient2(low = "#DA4A4A", mid = "#FEFADF", high = "#144F8D", midpoint = 50) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  labs(fill = "Prob. media", x = "Términos", y = "Probabilidad media",
       title = "Percepción de la probabilidad") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 6, angle = 30))
```

:::
::::

```{r}
#| eval: false
ggplot(resumen |> mutate(termino = fct_reorder(termino, mean_prob)), aes(x = termino, y = mean_prob, fill = mean_prob)) +
  geom_col(alpha = 0.8) +
  scale_fill_gradient2(low = "#DA4A4A", mid = "#FEFADF", high = "#144F8D", midpoint = 50) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  labs(fill = "Prob. media", x = "Términos", y = "Probabilidad media",
       title = "Percepción de la probabilidad") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 6, angle = 30))
```

---

## Variables continuas

Aun así al haber sumarizado, estamos perdiendo información...

¿Qué otros gráficos se te ocurren para hacer con [**variables continuas**]{.hl-yellow}?

. . .

Algunos de los más habituales son:


* [**Distribuciones**]{.hl-purple}: histogramas, densidades (ridgeline), boxplot (alternativas: violín, raincloud plots)

. . .

* [**Evolución**]{.hl-purple}: gráficos de líneas, gráficos de área, series temporales, etc

. . .

* [**Correlaciones**]{.hl-purple}: mapas de calor, correlograma, grafos, etc

---

## Distribuciones: histogramas

::: columns
::: {.column width="40%"}

Nuestra primera alternativa será el conocido como [**histograma**]{.hl-yellow} con `geom_histogram()`

:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy, aes(x = prob)) +
  geom_histogram(alpha = 0.8, fill = "#144F8D") +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::

Fíjate que está realizando el histograma de todo el dataset.

```{r}
#| eval: false
ggplot(datos_tidy, aes(x = prob)) +
  geom_histogram(alpha = 0.8, fill = "#144F8D") +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

---

## Distribuciones: histogramas

::: columns
::: {.column width="40%"}


El argumento `bins = ...` nos servirá para personalizar el nímero de barras que queremos. Fíjate que el gráfico es una [**proximación discreta**]{.hl-yellow} de un gráfico de densidad.
:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy, aes(x = prob)) +
  geom_histogram(bins = 12, alpha = 0.8, fill = "#144F8D") +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy, aes(x = prob)) +
  geom_histogram(bins = 12, alpha = 0.8, fill = "#144F8D") +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

---

## Distribuciones: histogramas

::: columns
::: {.column width="40%"}


Si queremos hacer uno por término, basta con añadir a nuestro gráfico un `facet_wrap()` para componer

:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy, aes(x = prob, fill = termino)) +
  geom_histogram(bins = 12, alpha = 0.8) +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy, aes(x = prob, fill = termino)) +
  geom_histogram(bins = 12, alpha = 0.8) +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

---


## Distribuciones: histogramas

::: columns
::: {.column width="40%"}

Vamos a filtrar solo algunos términos para poder usar la paleta `scale_fill_brewer()` 

:::

::: {.column width="60%"}

```{r}
#| echo: false
datos_tidy <-
  datos_tidy |> 
  filter(!(termino %in% c("Chances Are Slight", "Improbable", "Probably Not", "Probable", "Likely", "Very Good Chance")))

ggplot(datos_tidy, aes(x = prob, fill = termino)) +
  geom_histogram(bins = 12, alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
datos_tidy <-
  datos_tidy |> 
  filter(!(termino %in% c("Chances Are Slight", "Improbable", "Probably Not", "Probable", "Likely", "Very Good Chance")))

ggplot(datos_tidy, aes(x = prob, fill = termino)) +
  geom_histogram(bins = 12, alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

---


## Distribuciones: histogramas

::: columns
::: {.column width="40%"}

Nos aparecen desordenadas así que de nuevo podemos hacer uso del paquete `{forcats}`


:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)), aes(x = prob, fill = termino)) +
  geom_histogram(bins = 12, alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)), aes(x = prob, fill = termino)) +
  geom_histogram(bins = 12, alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

---

## Paréntesis: tema y fuente

Vamos a añadir una fuente personaliza al gráfico anterior.

::: columns
::: {.column width="40%"}

Con el paquete `{showtext}` podemos cargar fuentes de <https://fonts.google.com/>: con `font_add_google()` añadimos la fuente y con `showtext_auto()` habilitamos su uso. 

Con `theme_set()` podemos fijar un tema base (en nuestro caso `theme_minimal(base_family = ...)`) y con `theme_update()` añadimos el resto de personalizaciones


:::

::: {.column width="60%"}

```{r}
#| echo: false
library(showtext)
font_add_google(family = "Roboto", name = "Roboto")
showtext_auto()
theme_set(theme_minimal(base_family = "Roboto"))
theme_update(
  plot.title = element_text(color = "black", face = "bold", size = 27),
  legend.position = "bottom")
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)), aes(x = prob, fill = termino)) +
  geom_histogram(bins = 12, alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
library(showtext)
font_add_google(family = "Roboto", name = "Roboto")
showtext_auto()

theme_set(theme_minimal(base_family = "Roboto"))
theme_update(
  plot.title = element_text(color = "black", face = "bold", size = 27),
  legend.position = "bottom")
```


---


## Distribuciones: densidades

Los histogramas en realidad son una [**aproximación discreta de los gráficos de densidad**]{.hl-yellow} (asumiendo que los intervalos se pudieran ir haciendo tan pequeños como queramos). 

::: columns
::: {.column width="40%"}

Las densidades mejoran la robustez al histograma. Para ello usaremos `geom_density()`


:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)), aes(x = prob, fill = termino)) +
  geom_density(alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia relativa",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)), aes(x = prob, fill = termino)) +
  geom_density(alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia relativa",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```


---


## Distribuciones: densidades

::: columns
::: {.column width="40%"}

A veces puede ser interesante [**superponer las densidades**], lo cual lo podemos hacer con `geom_density_ridges()` del paquete `{ggridges}` (ahora sí necesitamos indicarle un `y = ...`)

:::

::: {.column width="60%"}

```{r}
#| echo: false
library(ggridges)
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = prob, y = termino, fill = termino, color = termino)) +
  geom_density_ridges(alpha = 0.5) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Probabilidad", y = "Términos",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
library(ggridges)
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = prob, y = termino, fill = termino, color = termino)) +
  geom_density_ridges(alpha = 0.5) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Probabilidad", y = "Términos",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```


---

## Distribuciones: boxplot

Una opción muy habitual en variables continuas son los [**gráficos de cajas y bigotes**]{.hl-yellow} o boxplots


::: columns
::: {.column width="40%"}

Para realizar estos gráficos debemos usar la geometría `geom_boxplot()`

:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Términos", y = "Probabilidad",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Términos", y = "Probabilidad",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

---

## Distribuciones: jitter


::: columns
::: {.column width="40%"}

Los boxplot a veces pueden ser insuficiente y podemos usar `geom_jitter()` que nos añadirá puntos como un [**«gotelé aleatorio»**]{.hl-yellow} (ver <https://hausetutorials.netlify.app/posts/2019-02-22-why-we-should-never-use-barplots-use-geomquasirandom-instead/>)

:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8) +
  geom_jitter(alpha = 0.3, size = 2) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Términos", y = "Probabilidad",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8) +
  geom_jitter(alpha = 0.3, size = 2) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Términos", y = "Probabilidad",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

---

## Distribuciones: jitter



::: columns
::: {.column width="40%"}

Si te fijas los [**outliers**]{.hl-yellow} aparecen dos veces ya que el boxplot los marca. Dentro de `geom_boxplot()` podemos indicarle la forma, color y alpha de los atípicos.


:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8, outlier.shape = 23) +
  geom_jitter(alpha = 0.3, size = 2) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Términos", y = "Probabilidad",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8, outlier.shape = 23) +
  geom_jitter(alpha = 0.3, size = 2) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Términos", y = "Probabilidad",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

---

## Distribuciones: jitter



::: columns
::: {.column width="40%"}

Si te fijas los [**outliers**]{.hl-yellow} aparecen dos veces ya que el boxplot los marca. Dentro de `geom_boxplot()` podemos indicarle la forma, color y alpha de los atípicos.


:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8, outlier.alpha = 0) +
  geom_jitter(alpha = 0.3, size = 2) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Términos", y = "Probabilidad",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8, outlier.alpha = 0) +
  geom_jitter(alpha = 0.3, size = 2) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Términos", y = "Probabilidad",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

---

## Distribuciones: geom_quasirandom



::: columns
::: {.column width="40%"}

Podemos mejorar el [**«gotelé aleatorio»**]{.hl-yellow} con  `geom_quasirandom()` del paquete `{ggbeeswarm}` (con `width = ...` controlamos la anchura de lo aleatorio)


:::

::: {.column width="60%"}

```{r}
#| echo: false
library(ggbeeswarm)
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8, outlier.alpha = 0) +
  geom_quasirandom(size = 2, alpha = 0.4,  width = 0.7) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Términos", y = "Probabilidad",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8, outlier.alpha = 0) +
  geom_quasirandom(size = 2, alpha = 0.4,  width = 0.7) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Términos", y = "Probabilidad",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```



---

## Distribuciones: violin




::: columns
::: {.column width="40%"}


Para solventar los problemas de los box-plots, una alternativa muy popular son los [**gráficos de violín**]{.hl-yellow} (en realidad es una densidad reflejada)

:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_violin(alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Términos", y = "Probabilidad",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_violin(alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Términos", y = "Probabilidad",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```



---


## Distribuciones: violin




::: columns
::: {.column width="40%"}


Con el argumento `scale = "count"` las àreas son proporcionales al número de observaciones en cada violín (por defecto `scale = "area"`, todos la misma área). Con `bw = ...` modulamos la suavidad del kernel usado (bandwidth).

:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_violin(alpha = 0.8, scale = "count", bw = 1.5) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Términos", y = "Probabilidad",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

:::
::::


```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_violin(alpha = 0.8, scale = "count", bw = 1.5) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Términos", y = "Probabilidad",
       title = "Percepción de la probabilidad") +
  theme_minimal()
```

# Clase 16: dataviz

[**Visualización de datos**]{style="color:#444442;"}



## Evolución: gráficos de líneas


Otra categoría muy común de gráficos con variables continusa son los [**gráficos de evolución**]{.hl-yellow}

::: columns
::: {.column width="40%"}

El más simple es el [**gráfico de líneas**]
{.hl-yellow}, que podemos construir con `geom_line()`, y para el que ahora sí necesitamos un `x = ...`  y un `y = ...`

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, color = continent)) +
  geom_line(alpha = 0.8, linewidth = 2) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_color_colorblind() +
  labs(x = "Año", y = "Renta per cápita media",
       title = "Evolución en gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, color = continent)) +
  geom_line(alpha = 0.8, linewidth = 2) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_color_colorblind() +
  labs(x = "Año", y = "Renta per cápita media",
       title = "Evolución en gapminder") +
  theme_minimal()
```

---

## Evolución: gráficos de líneas


::: columns
::: {.column width="40%"}

Fíjate que dando `color = ...` nos hace solo una gráfica por variable de grupo. Si usamos `geom_step()` en su lugar obtenemos un [**gráfico de escalera**]{.hl-yellow}

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, color = continent)) +
  geom_step(alpha = 0.8, linewidth = 1.2) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_color_colorblind() +
  labs(x = "Año", y = "Renta per cápita media",
       title = "Evolución en gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, color = continent)) +
  geom_step(alpha = 0.8, linewidth = 1.2) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_color_colorblind() +
  labs(x = "Año", y = "Renta per cápita media",
       title = "Evolución en gapminder") +
  theme_minimal()
```

---

## Evolución: serie temporal

Un gráfico de línea muy particular son las [**series temporales**]{.hl-yellow}, donde en el eje X hay una variable de [**fecha y/o hora**]{.hl-purple}

. . .

Por ejemplo, vamos a cargar el siguiente dataset de Github de la [**evolución del precio de bitcoins**]{.hl-yellow} cuyo separado es el espacio

```{r}
data <- read_table(file = "https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/3_TwoNumOrdered.csv")
data
```

---

## Evolución: serie temporal

::: columns
::: {.column width="40%"}

La forma más sencilla es de nuevo usar `geom_line()`. Con `scale_x_date(date_breaks = ...)` podemos indicarle los saltos en las fechas de manera sencilla.

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(data, aes(x = date, y = value)) +
  geom_line(alpha = 0.8, color = "#145412", linewidth = 1.2) +
  scale_x_date(date_breaks = "4 months") +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_color_colorblind() +
  labs(x = "Fecha", y = "Precio del bitcoin",
       title = "Evolución del precio del bitcoin") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30))
```

:::
::::

```{r}
#| eval: false
ggplot(data, aes(x = date, y = value)) +
  geom_line(alpha = 0.8, color = "#145412", linewidth = 1.2) +
  scale_x_date(date_breaks = "4 months") +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_color_colorblind() +
  labs(x = "Fecha", y = "Precio del bitcoin",
       title = "Evolución del precio del bitcoin") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30))
```

---


## Evolución: gráficos de área

Una mejora de los gráficos de línea son los [**gráficos de área**]{.hl-yellow} (visualizando la curva con rellena)

::: columns
::: {.column width="40%"}

La forma más sencilla es de nuevo usar `geom_line()` pero añadiendo la capa `geom_area()` (con `fill` en lugar de `color`)

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(data, aes(x = date, y = value)) +
  geom_line(color = "#145412", linewidth = 1) +
  geom_area(alpha = 0.4, fill = "#145412") +
  scale_x_date(date_breaks = "4 months") +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "Fecha", y = "Precio del bitcoin",
       title = "Evolución del precio del bitcoin") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30))
```

:::
::::

```{r}
#| eval: false
ggplot(data, aes(x = date, y = value)) +
  geom_line(color = "#145412", linewidth = 1) +
  geom_area(alpha = 0.4, fill = "#145412") +
  scale_x_date(date_breaks = "4 months") +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "Fecha", y = "Precio del bitcoin",
       title = "Evolución del precio del bitcoin") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30))
```


---

## Paréntesis: interactivos

::: columns
::: {.column width="40%"}

Todo gráfico ggplot podemos hacerlo [**interactivo**]{.hl-yellow} guardándonos la gráfico y haciendo uso de `{plotly}`

:::

::: {.column width="60%"}


```{r}
#| echo: false
gg <- 
  ggplot(data, aes(x = date, y = value)) +
  geom_line(color = "#145412", linewidth = 1) +
  geom_area(alpha = 0.4, fill = "#145412") +
  scale_x_date(date_breaks = "4 months") +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "Fecha", y = "Precio del bitcoin",
       title = "Evolución del precio del bitcoin") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30))
plotly::ggplotly(gg)
```

:::
::::

```{r}
#| eval: false
gg <-
  ggplot(data, aes(x = date, y = value)) +
  geom_line(color = "#145412", linewidth = 1) +
  geom_area(alpha = 0.4, fill = "#145412") +
  scale_x_date(date_breaks = "4 months") +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "Fecha", y = "Precio del bitcoin",
       title = "Evolución del precio del bitcoin") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30))
plotly::ggplotly(gg)
```


---

## Evolución: áreas apiladas


::: columns
::: {.column width="40%"}

Los gráficas de áreas, al igual que sucedía con los diagrmaas de barras, pueden ser de [**áreas apiladas**]{.hl-yellow}, haciendo que `fill()` sea mapeado por `aes()`

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, fill = continent)) +
  geom_area(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_fill_colorblind() +
  labs(x = "Año", y = "Renta per cápita media",
       title = "Evolución de gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, fill = continent)) +
  geom_area(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_fill_colorblind() +
  labs(x = "Año", y = "Renta per cápita media",
       title = "Evolución de gapminder") +
  theme_minimal()
```

---

## Evolución: áreas apiladas


::: columns
::: {.column width="40%"}

Los gráficas de áreas, al igual que sucedía con los diagrmaas de barras, pueden ser de [**áreas apiladas**]{.hl-yellow}, haciendo que `fill()` sea mapeado por `aes()`

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, fill = continent)) +
  geom_area(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_fill_colorblind() +
  labs(x = "Año", y = "Renta per cápita media",
       title = "Evolución de gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, fill = continent)) +
  geom_area(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_fill_colorblind() +
  labs(x = "Año", y = "Renta per cápita media",
       title = "Evolución de gapminder") +
  theme_minimal()
```

---

## Evolución: áreas apiladas


::: columns
::: {.column width="40%"}

Haciendo una modificación en el preprocesamiento podemos hacer un [**gráfico de áreas apiladas**]{.hl-yellow} en relativo

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)) |> mutate(porc = 100 * mean_gdp/sum(mean_gdp), .by = year),
       aes(x = year, y = porc, fill = continent)) +
  geom_area(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  scale_fill_colorblind() +
  labs(x = "Año", y = "Renta per cápita mundial",
       title = "Evolución de gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)) |> mutate(porc = 100 * mean_gdp/sum(mean_gdp), .by = year),
       aes(x = year, y = porc, fill = continent)) +
  geom_area(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  scale_fill_colorblind() +
  labs(x = "Año", y = "Renta per cápita mundial",
       title = "Evolución de gapminder") +
  theme_minimal()
```

---


## Evolución: streamcharts

Una modificación de los gráficos de áreas apiladas son los conocidos como [**streamcharts**]{.hl-yellow}


::: columns
::: {.column width="40%"}

En ellos las formas son más suaves que en un gráfico de área al uso, con el paquete `{ggstream}` (y usando `geom_stream()`)


:::

::: {.column width="60%"}


```{r}
#| echo: false
library(ggstream)
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)),  aes(x = year, y = mean_gdp, fill = continent)) +
  geom_stream(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_fill_colorblind() +
  labs(x = "Año", y = "Renta per cápita mundial",
       title = "Evolución de gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
library(ggstream)
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)),  aes(x = year, y = mean_gdp, fill = continent)) +
  geom_stream(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_fill_colorblind() +
  labs(x = "Año", y = "Renta per cápita mundial",
       title = "Evolución de gapminder") +
  theme_minimal()
```

---


## Evolución: streamcharts

::: columns
::: {.column width="40%"}

Fíjate que por defecto lo hace [**en espejo**]{.hl-yellow}, usando el eje y de manera reflejada. Con `type = "ridge"` lo haemos de manera apilada.

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)),  aes(x = year, y = mean_gdp, fill = continent, color = continent)) +
  geom_stream(alpha = 0.7, type = "ridge") +
  scale_fill_colorblind() +
  scale_color_colorblind() +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "Año", y = "Renta per cápita mundial",
       title = "Evolución de gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)),  aes(x = year, y = mean_gdp, fill = continent, color = continent)) +
  geom_stream(alpha = 0.75, type = "ridge") +
  scale_fill_colorblind() +
  scale_color_colorblind() +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "Año", y = "Renta per cápita mundial",
       title = "Evolución de gapminder") +
  theme_minimal()
```

---

## Evolución: streamcharts

::: columns
::: {.column width="40%"}

 Con `type = "proportional"` lo haemos de manera relativa
:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)),  aes(x = year, y = mean_gdp, fill = continent, color = continent)) +
  geom_stream(alpha = 0.75, type = "proportional") +
  scale_fill_colorblind() +
  scale_color_colorblind() +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "Año", y = "Renta per cápita mundial",
       title = "Evolución de gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)),  aes(x = year, y = mean_gdp, fill = continent, color = continent)) +
  geom_stream(alpha = 0.75, type = "proportional") +
  scale_fill_colorblind() +
  scale_color_colorblind() +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "Año", y = "Renta per cápita mundial",
       title = "Evolución de gapminder") +
  theme_minimal()
```

---

## 🐣 Caso práctico 16: visualizando Netflix

Visualizaremos el número de películas y series de instituto que se han estrenado en Netflix en cada año. Los datos provienen originalmente de Kaggle, y contienen las películas y series de Netflix hasta enero de 2021. 

```{r}
netflix <-
  read_csv('https://raw.githubusercontent.com/elartedeldato/datasets/main/netflix_titles.csv')
netflix
```

---

## 🐣 Caso práctico 16: visualizando Netflix

* [**Paso 1**]{.hl-yellow}: piensa como filtrar las **películas y series que van sobre un instituto**.

. . .

* [**Paso 2**]{.hl-yellow}: tras dicho filtro, añade el año en el que se estrenó y elimina aquellas sin año conocido.

. . .

* [**Paso 3**]{.hl-yellow}: obtén el número de series por año

---


## 🐣 Caso práctico 16: visualizando Netflix

* [**Paso 4**]{.hl-yellow}: replica el siguiente gráfico

```{r}
#| echo: false
netflix_resumen <-
  netflix |> 
  filter(str_detect(toupper(description), "HIGH SCHOOL")) |> 
  mutate(year_added = year(mdy(date_added))) |>
  drop_na(year_added) |> 
  group_by(year_added) |>
  count() |> ungroup()

ggplot(netflix_resumen, aes(x = year_added, y = n)) +
  geom_col(fill = "red") +
  scale_x_continuous(breaks = netflix_resumen$year_added) +
  labs(title = "NETFLIX",
       subtitle = "Películas y series de instituto",
       x = "Año de estreno", y = "Cantidad")
```

---

## 🐣 Caso práctico 16: visualizando Netflix

* [**Paso 5**]{.hl-yellow}: replica el siguiente gráfico sabiendo que la fuente del título es "Bebas Neue" y la del subtítulo "Permanent Marker"

```{r}
#| echo: false
library(sysfonts)
library(showtext)
font_add_google(family = "Bebas Neue",
                name = "Bebas Neue")
font_add_google(family = "Permanent Marker",
                name = "Permanent Marker")
showtext_auto()

ggplot(netflix_resumen, aes(x = year_added, y = n)) +
  geom_col(fill = "red") +
  scale_x_continuous(breaks = netflix_resumen$year_added) +
  labs(title = "NETFLIX",
       subtitle = "Películas y series de instituto",
       x = "Año de estreno", y = "Cantidad") +
  theme_minimal() +
  theme(legend.position = "none",
        plot.title = element_text(family = "Bebas Neue",
                                  color = "red", size = 80),
        plot.subtitle = element_text(family = "Permanent Marker",
                                     size = 21, color = "black"))
```

---


## 🐣 Caso práctico 16: visualizando Netflix

* [**Paso 6**]{.hl-yellow}: replica el siguiente gráfico sabiendo que la fuente de los ejes es "Permanent Marker" y busca la función `annotate()`

```{r}
#| echo: false
ggplot(netflix_resumen, aes(x = year_added, y = n)) +
  geom_col(fill = "red") +
  scale_x_continuous(breaks = netflix_resumen$year_added) +
  labs(title = "NETFLIX",
       subtitle = "Películas y series de instituto",
       x = "Año de estreno", y = "Cantidad") +
  theme_void() +
  theme(plot.margin = margin(t = 4, r = 4, b = 4, l = 8, "pt"),
        legend.position = "none",
        plot.title = element_text(family = "Bebas Neue",
                                  color = "red", size = 80),
        plot.subtitle = element_text(family = "Permanent Marker",
                                     size = 21, color = "white"),
        axis.text = 
          element_text(size = 15, family = "Permanent Marker",
                       color = "white"),
        panel.background = element_rect(fill = "black"),
        plot.background = element_rect(fill = "black", 
                                       color = "black"),
        panel.grid.major.y =
          element_line(linewidth = 0.1, color = "white")) +
  annotate("text", label = "(hasta enero)", 
           x = 2021, y = 11, hjust = 0.3, vjust = 0, family = "Permanent Marker", size = 5, color='white', angle = 20) +
  annotate("curve", x = 2021, y = 9, xend = 2021, yend = 5,
           color = "white")
```



# Clase n + 1: joins, expresiones de control, listas y depuración

[**Cruzando datos. Bucles**]{style="color:#444442;"}


## Relacionando datos

Al trabajar con datos [**no siempre tendremos la información en una sola tabla**]{.hl-yellow} y a veces nos interesará cruzar la información de distintas fuentes.

. . .

Para ello usaremos un clásico de todo lenguaje que maneja datos: los famosos [**join**]{.hl-yellow}, una herramienta que nos va a permitir [**cruzar una o variables tablas**]{.hl-yellow}, haciendo uso de una [**columna identificadora**]{.hl-yellow} de cada una de ellas (por ejemplo, imagina que cruzamos datos de hacienda y de antecedentes penales, haciendo _join_ por la columna `DNI`).

---

## Relacionando datos


```{r}
#| eval: false
tabla_1 |>
  xxx_join(tabla_2, by = id)
```

* `inner_join()`: solo sobreviven los [**registros con id en ambas**]{.hl-yellow} tablas.

* `full_join()`: mantiene [**todos los registros de ambas**]{.hl-yellow} tablas.

* `left_join()`: mantiene [**todos los registros de la primera tabla**]{.hl-yellow}, y busca cuales tienen id también en la segunda (en caso de [**no tenerlo se rellena con NA**]{.hl-yellow} los campos de la 2ª tabla).

* `right_join()`: mantiene [**todos los registros de la segunda tabla**]{.hl-yellow}, y busca cuales tienen id también en la primera.

![](img/sql-joins.jpg)


---

## Relacionando datos

Vamos a probar los distintos joins con un ejemplo sencillo

```{r}
tb_1 <- tibble("key" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```

:::: columns
::: {.column width="50%"}

```{r}
tb_1
```

:::

::: {.column width="50%"}

```{r}
tb_2
```

:::
::::

---

## Left join

Imagina que queremos [**incorporar**]{.hl-yellow} a `tb_1` la [**información de la tabla_2**]{.hl-yellow}, identificando los registros por la columna key (indicando con `by = "key"` la columna por la que tiene que cruzar): queremos mantener todos los registros de la primera tabla y buscar cuales tienen id (mismo valor en `key`) también en la segunda tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1  |> 
  left_join(tb_2, by = "key")
```

:::
::: {.column width="50%"}


![](img/left_join.jpg)


:::
::::

---

## Left join

```{r}
tb_1 |> 
  left_join(tb_2, by = "key")
```

Fíjate que los [**registros de la primera cuya key no ha encontrado en la segunda**]{.hl-yellow} les ha dado el valor de [**ausente**]{.hl-yellow}.

---

## Right join

El `right_join()` realizará la operación contraria: vamos ahora a [**incorporar**]{.hl-yellow} a `tb_2` la [**información de la tabla_2**]{.hl-yellow}, identificando los registros por la columna key (indicando con `by = "key"` la columna por la que tiene que cruzar): queremos mantener todos los registros de la segunda y buscar cuales tienen id (mismo valor en `key`) también en la primera tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

:::

::: {.column width="50%"}

![](img/right_join.jpg)

:::
::::


---

## Right join


```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

Fíjate que ahora los [**registros de la segunda cuya key no ha encontrado en la primera**]{.hl-yellow} son los que les ha dado el valor de [**ausente**]{.hl-yellow}.

---


## Claves y sufijos

Las columnas clave que usaremos para el cruce [**no siempre se llamarán igual**]{.hl-yellow}.

```{r}
tb_1 <- tibble("key_1" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```

. . .

* `by = c("key_2" = "key_2")`: le indicaremos en qué columna de cada tabla están las claves por las que vamos a cruzar.

:::: columns
::: {.column width="50%"}

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

```{r}
# Right
tb_1  |> 
  right_join(tb_2, by = c("key_1" = "key_2"))
```

:::
::::

---

## Claves y sufijos

Además podemos [**cruzar por varias columnas a la vez**]{.hl-yellow} (interpretará como igual registro aquel que tenga el conjunto de claves igual), con `by = c("var1_t1" = "var1_t2", "var2_t1" = "var2_t2", ...)`. Modifiquemos el ejemplo anterior

```{r}
tb_1 <- tibble("k_11" = 1:3, "k_12" = c("a", "b", "c"),  "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("k_21" = c(1, 2, 4), "k_22" = c("a", "b", "e"), "val_y" = c("y1", "y2", "y3"))
```

. . .

```{r}
# Left
tb_1 |> 
  left_join(tb_2,
            by = c("k_11" = "k_21", "k_12" = "k_22"))
```


---

## Claves y sufijos

También podría suceder que al cruzar dos tablas, haya [**columnas de valores que se llamen igual**]{.hl-yellow}


```{r}
tb_1 <- tibble("key_1" = 1:3, "val" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val" = c("y1", "y2", "y3"))
```

. . .

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

Fíjate que [**por defecto nos añade los sufijos**]{.hl-yellow} `.x` y `.y` para indicarnos de que tabla vienen.

---

## Claves y sufijos


Dicho [**sufijo podemos especificárselo**]{.hl-yellow} en el argumento opcional `suffix = ...`, que nos permita [**distinguir las variables**]{.hl-yellow} de una tabla y de otra.


```{r}
# Left
tb_1 |>
  left_join(tb_2, by = c("key_1" = "key_2"), suffix = c("_tabla1", "_tabla2"))
```


---

## Full join

Los dos anteriores casos forman lo que se conoce como [**outer joins**]{.hl-yellow}: cruces donde se mantienen observaciones que salgan en al menos una tabla. El tercer outer join es el conocido como `full_join()` que nos [**mantendrá las observaciones de ambas**]{.hl-yellow} tablas, [**añadiendo las filas**]{.hl-yellow} que no casen con la otra tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  full_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

![](img/full_join.jpg)

:::
::::


---

## Inner join

Frente a los outer join está lo que se conoce como [**inner join**]{.hl-yellow}, con `inner_join()`: un cruce en el que solo se mantienen las [**observaciones que salgan en ambas tablas**]{.hl-yellow}, solo mantiene aquellos registros matcheados.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

![](img/inner_join.png)


:::
::::

---

## Inner join

Fíjate que en términos de registros, `inner_join` si es conmutativa, **nos da igual el orden de las tablas**: lo único que cambia es el orden de las columnas que añade.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

:::

::: {.column width="50%"}


```{r}
tb_2 |> 
  inner_join(tb_1, by = c("key_2" = "key_1"))
```

:::
::::

---

## Anti/semi join

Por último tenemos dos herramientas interesantes para [**filtrar (no cruzar) registros**]{.hl-yellow}: `semi_join()` y `anti_join()`. El [**semi join**]{.hl-yellow} nos deja en la [**primera tabla los registros que cuya clave está también en la segunda**]{.hl-yellow} (como un inner join pero sin añadir la info de la segunda tabla). Y el segundo, los anti join, hace justo lo contrario (aquellos que no están).


:::: columns
::: {.column width="50%"}

```{r}
# semijoin
tb_1 |> 
  semi_join(tb_2, by = c("key_1" = "key_2"))
```

:::

::: {.column width="50%"}

```{r}
# antijoin
tb_1 |> 
  anti_join(tb_2, by = c("key_1" = "key_2"))
```

:::
::::


---


## 💻 Tu turno {#tu-turno-16}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

Para los ejercicios usaremos las tablas disponibles en el paquete `{nycflights13}` (echa un vistazo antes)

```{r}
library(nycflights13)
```

* [**airlines**]{.hl-yellow}: nombre de aerolíneas (con su abreviatura).
* [**airports**]{.hl-yellow}: datos de aeropuertos (nombres, longitud, latitud, altitud, etc).
* [**flights**]{.hl-yellow}: datos de vuelos.
* [**planes**]{.hl-yellow}: datos de los aviones.
* [**weather**]{.hl-yellow}: datos meteorológicos horarios de las estaciones LGA, JFK y EWR.

---

## 💻 Tu turno {#tu-turno-16}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 Del paquete `{nycflights13}` cruza la tabla `flights` con `airlines`. Queremos mantener todos los registros de vuelos, añadiendo la información de las aerolíneas a la tabla de aviones.

```{r}
#| eval: false
#| code-fold: true
flights_airlines <-
  flights |> 
  left_join(airlines, by = "carrier")
flights_airlines
```

### [**Ejercicio 2**]{.hl-yellow}

📝 A la tabla obtenida del cruce del apartado anterior, cruza después con los datos de los aviones en `planes`, pero incluyendo solo aquellos vuelos de los que tengamos información de sus aviones (y viceversa). 


```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum")
flights_airlines_planes
```


### [**Ejercicio 3**]{.hl-yellow}

📝 Repite el ejercicio anterior pero conservando ambas variables `year` (en una es el año del vuelo, en la otra es el año de construcción del avión), y distinguiéndolas entre sí



```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum",
             suffix = c("_flight", "_build_aircraft"))
flights_airlines_planes
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Al cruce obtenido del ejercicio anterior incluye la longitud y latitud de los aeropuertos en `airports`, distinguiendo entre la latitud/longitud del aeropuerto en destino y en origen.

```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes %>%
  left_join(airports %>% select(faa, lat, lon),
            by = c("origin" = "faa")) |> 
  rename(lat_origin = lat, lon_origin = lon) |> 
  left_join(airports %>% select(faa, lat, lon),
            by = c("dest" = "faa")) |> 
  rename(lat_dest = lat, lon_dest = lon)
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Filtra de `airports` solo aquellos aeropuertos de los que salgan vuelos. Repite el proceso filtrado solo aquellos a los que lleguen vuelos

```{r}
#| eval: false
#| code-fold: true
airports |> 
  semi_join(flights, by = c("faa" = "origin"))
airports |> 
  semi_join(flights, by = c("faa" = "dest"))
```


### [**Ejercicio 6**]{.hl-yellow}

📝 ¿De cuántos vuelos no disponemos información del avión? Elimina antes los vuelos que no tengan identificar (diferente a NA) del avión


```{r}
#| eval: false
#| code-fold: true
flights |> 
  drop_na(tailnum) |>
  anti_join(planes, by = "tailnum") |>
  count(tailnum, sort = TRUE) # de mayor a menor ya de paso
```

:::


---

## Estructuras de control

Una [**estructura de control**]{.hl-yellow} se compone de una serie de comandos orientados a  [**decidir el camino**]{.hl-yellow} que tu código debe recorrer

* Si se cumple la condición A, ¿qué sucede?

* ¿Y si sucede B?

* ¿Cómo puedo repetir una misma expresión (dependiendo de una variable)?

. . .

Si has programado antes, quizás te sea familiar las conocidas como [**estructuras condicionales**]{.hl-yellow} tales como `if (blabla) {...} else {...}`  o [**bucles**]{.hl-yellow} `for/while` (a evitar siempre que podamos).

---

## Estructura If

Una de las estructuras de control más famosas son las conocidas como [**estructuras condicionales**]{.hl-yellow} `if`.

> SI (IF) un conjunto de condiciones se cumple (TRUE), entonces ejecuta lo que haya dentro de las llaves

Por ejemplo, la estructura `if (x == 1) { código A }` lo que hará será [**ejecutar el código A entre llaves**]{.hl-yellow} pero [**SOLO SI**]{.hl-purple} la [**condición entre paréntesis es cierta**]{.hl-purple} (solo si `x` es 1). En cualquier otro caso, no hará nada.

. . .

Por ejemplo, definamos un vector de edades de 8 personas

```{r}
edad <- c(14, 17, 24, 56, 31, 20, 87, 73)
edad < 18
```

---

## Estructura If


Nuestra estructura condicional hará lo siguiente: [**si existe algún menor de edad, imprimirá**]{.hl-yellow} por pantalla un mensaje.

```{r}
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```

---

## Estructura If

```{r}
#| eval: false
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```


En caso de que las [**condiciones no sean ciertas**]{.hl-yellow} dentro de `if()` (`FALSE`), no sucede nada


```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
}
```

**No obtenemos ningún mensaje** porque la condición `all(edad >= 18)` no es `TRUE`, así que bno ejecuta nada.

---

## Estructura If-else

La estructura `if (condicion) { código A }` puede combinarse con un `else { código B }`: cuando la [**condición no está verificada**]{.hl-yellow}, se [**ejecutará el código alternativo B**]{.hl-yellow} dentro de `else { }`, permitiéndonos decidir que sucede cuando se cumple y cuando no.
. . .

Por ejemplo, `if (x == 1) { código A } else { código B }` ejecutará A si `x` es igual a 1 y B en cualquier otro caso.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else {
  
  print("Existe alguna persona menor de edad")
}
```

---

## Estructura If-else

Esta estructura `if - else` puede ser [**anidada**]{.hl-yellow}: imagina que queremos ejecutar un código si todos son menores; si no sucede, pero todos son mayores de 16, hacer otra cosa; en cualquier otra cosa, otra acción.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else if (all(edad >= 16)) {
  
  print("Hay algún menor de edad pero todos con 16 años o más")
  
} else { print("Hay alguna persona con menos de 16 años") }
```

::: callout-note
## Truco

Puedes **colapsar las estructuras** haciendo click en la flecha a la izquierda que aparece en tu script.

:::


---

## If-else vectorizado


Esta estructura condicional se puede [**vectorizar**]{.hl-yellow} (en una sola línea) con `if_else()` (del paquete `{dplyr}`), cuyos argumentos son

* la condición a evaluar
* lo que sucede cuando se cumple
* lo que sucede cuando no
* un argumento opcional para cuando la condición a evaluar es `NA`

Por ejemplo, vamos a etiquetar sin son mayores/menores de edad y un "desconocido" cuando no conocemos la edad

```{r}
library(dplyr)
edad <- c(NA, edad)
if_else(edad >= 18, "mayor", "menor", missing = "desconocido")
```



---

## Bucles

Aunque en la mayoría de ocasiones se pueden reemplazar por otras estructuras más eficientes y legibles, es importante conocer una de las expresiones de control más famosas: los [**bucles**]{.hl-yellow}.

* `for { }`: permite [**repetir el mismo código**]{.hl-yellow} en un [**número prefijado y conocido**]{.hl-purple} de veces.

* `while { }`: permite [**repetir el mismo código**]{.hl-yellow} pero en un [**número indeterminado de veces**]{.hl-purple} (hasta que una **condición** deje de cumplirse).

---

## Bucles for

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de órdenes un número [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de índices.

. . .

Por ejemplo, vamos a definir un vector `x` y vamos a imprimir sus elementos al cuadrado: definireos un índice `i` para imprimir, en cada paso, el valor i-ésimo `x[i]^2`. Esos índices irán dentro de `for (indice in conjunto) { code }` (por ejemplo, `i in 1:4`)

```{r}
x <- c(0, -7, 1, 4)
for (i in 1:4) {
  
  print(x[i]^2)
  
}
```

---

## Bucles for

```{r}
#| eval: false
for (i in 1:4) { 
  print(x[i]^2) 
}
```

Dentro del paréntesis del `for ()` debemos tener una  [**secuencia de índices**]{.hl-yellow} (en este caso, números). Si queremos hacer lo mismo pero excluyendo el segundo elemento simplemente definimos el conjunto de valores `c(1, 3, 4)` entre los que `i` puede moverse.

```{r}
for (i in c(1, 3, 4)) {
  
  print(x[i]^2)
  
}
```

---

## Bucles for

Otra forma de usar un bucle es definir de cero un vector: primer inicializamos en ceros `y <- rep(0, 4)` para después modificar cada [**elemento i-ésimo**]{.hl-yellow} definidos como `x[i]^2`.

```{r}
y <- rep(0, 4)
for (i in 1:4) {
  
  y[i] <- x[i]^2
  
}
y
```

. . .

Lo anterior es equivalente vectorialmente a

```{r}
y <- x^2
y
```

---

## Evitando bucles


Como ya hemos aprendido con el paquete`{microbenchmark}` podemos chequear como [**los bucles suelen ser muy ineficientes**]{.hl-yellow} (de ahí que debamos evitarlos en la mayoría de ocasiones

```{r}
library(microbenchmark)
x <- 1:1000
microbenchmark(y <- x^2, 
               for (i in 1:100) { y[i] <- x[i]^2 },
               times = 500)
```

---
 
## Bucles for


Podemos ver otro ejemplo  [**combinando números y textos**]{.hl-yellow}: definimos un vector de edades y de nombres, e imprimimos el nomber y edad i-ésima.

```{r}
nombres <- c("Javi", "Sandra", "Carlos", "Marcos", "Marta")
edades <- c(33, 27, 18, 43, 29)

for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} años")) 
  
}
```

---

## Bucles for


Fíjate que [**si no queremos estar pendientes de cuantos valores**]{.hl-yellow} tenemos, podemos hacer uso de `length()` para acceder a la [**última posición**]{.hl-yellow} (sea cual sea).

```{r}
for (i in 1:length(nombres)) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} años")) 
  
}
```

---

## Bucles for

Aunque normalmente se suelen indexar con vectors numéricos, los bucles pueden ser [**indexados sobre cualquier estructura vectorial**]{.hl-yellow}

```{r}
library(stringr)
week_days <- c("monday", "tuesday", "wednesday", "thursday",
               "friday", "saturday", "sunday")

for (days in week_days) {
  
  print(str_to_upper(days))
}
```

---

## Bucles for

Vamos a combinar las estructuras condicionales y los bucles: usando el conjunto `swiss` del paquete `{datasets}`, vamos a asignar `NA`  si los valores de fertilidad son mayores de 80.

```{r}
for (i in 1:nrow(swiss)) {
  
  if (swiss$Fertility[i] > 80) { 
    
    swiss$Fertility[i] <- NA
    
  }
}
```

. . .

Esto es exactamente igual a un `if_else()` vectorizado

```{r}
data("swiss")
swiss$Fertility <- if_else(swiss$Fertility > 80, NA, swiss$Fertility)
```


---

## Bucles while

Otra forma de crear un bucle es con la estructura `while { }`, que nos ejecutará un bucle [**un número desconocido de veces**]{.hl-yellow}, hasta que una condición [**deje de cumplirse**]{.hl-yellow} (de hecho puede que nunca termine). Por ejemplo, vamos a inializar una variable `ciclos <- 1`, que incrementaremos en cada paso, y no saldremos del bucle hasta que `ciclos > 4`.

```{r}
ciclos <- 1
while(ciclos <= 4) {
  
  print(glue("No todavía, vamos por el ciclo {ciclos}")) 
  ciclos <- ciclos + 1
  
}
```


---
  
## Bucles while


¿Qué sucede cuando la [**condición nunca es FALSE**]{.hl-yellow}? Pruébalo tu mismo

```{r}
#| eval: false
while (1 > 0) {
  
  print("Presiona ESC para salir del bucle")
  
}
```

&nbsp;

::: callout-warning
## Cuidado

Un bucle `while { }` puede ser bastante «peligroso» sino controlamos bien cómo pararlo.

:::

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `break`: permite [**abortar un bucle**]{.hl-yellow} incluso si no se ha llegado a su final

```{r}
for(i in 1:10) {
  if (i == 3) {
    
    break # si i = 3, abortamos bucle
    
  }
  print(i)
}
```

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `next`: [**fuerza un bucle a avanzar a la siguiente iteración**]{.hl-yellow} 

```{r}
for(i in 1:5) {
  if (i == 3) {
    
    next # si i = 3, la obvia y continua al siguiente
    
  }
  print(i)
}
```

---

## Bucles repeat

Aunque no es tan usado como las opciones anteriores, también contamos con `repeat { }` que ejecuta un [**bucle de manera infinita hasta que se indique abortar**]{.hl-yellow} con un break

```{r}
count <- 0
repeat { 
  
  count <- count + 1
  if (count >= 100) { break }
  
}
count
```


---

## Replicate

Por último, otra forma de [**repetir código un número de veces**]{.hl-yellow} es hacer uso de `replicate()`: simplemente permite repetir lo mismo [**n veces**]{.hl-yellow}

```{r}
x <- 1:3
replicate(n = 3, x^2)
```

---

## 💻 Tu turno {#tu-turno-n-1}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 Modifica el código inferior para que se imprima un mensaje por pantalla si y solo si todos los datos de `airquality` son con mes distinto a enero

```{r}
#| eval: false
library(datasets)
months <- airquality$Month

if (months == 2) {
  print("No hay datos de enero")
}
```

```{r}
#| code-fold: true
#| eval: false
library(datasets)
months <- airquality$Month

if (all(months != 1)) {
  print("No hay datos de enero")
}
```


### [**Ejercicio 2**]{.hl-yellow}

📝 Modifica el código inferior para guardar en una variable llamada `temp_alta` un `TRUE` si alguno de los registros tiene una temperatura superior a 90 grados Farenheit y `FALSE` en cualquier otro caso
 
```{r}
#| eval: false
temp <- airquality$Temp

if (temp == 100) {
  print("Algunos de los registros tienen temperaturas superiores a 90 grados Farenheit")
}
```

 
```{r}
#| eval: false
#| code-fold: true
# Option 1
temp <- airquality$Temp
temp_alta <- FALSE
if (any(temp > 90)) {
   temp_alta <- TRUE
}

# Option 2
temp_alta <- any(airquality$Temp > 90)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Modifica el código inferior para diseñar un bucle `for` de 5 iteraciones que solo recorra los primeros 5 impares (y en cada paso del bucle los imprima)

```{r}
#| eval: false
for (i in 1:5) {
  
  print(i)
}
```

```{r}
#| eval: false
#| code-fold: true
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i)
}
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Modifica el código inferior para diseñar un bucle `while` que empiece con un contador `count <- 1` y pare cuando llegue a 6

```{r}
#| eval: false
count <- 1
while (count == 2) {
  
  print(count)
}
```

```{r}
#| eval: false
#| code-fold: true
count <- 1
while (count < 6) {
  
  print(count)
  count <- count + 1
  
}
```


:::

# Clase n + 2:  depuración y Github

[**Depurando datos. Manejo de listas. Github**]{style="color:#444442;"}

---

## Depuración

En la bioestadística, como en cualquier otro ámbito de aplicación, [**no siempre los datos los tendremos en el formato deseado**]{.hl-yellow}.

Ya hemos aprendido como pivotar nuestros datos para tenerlos en [**formato tidydata**]{.hl-yellow}, algo indispensable para una correcta depuración y visualización. También hemos aprendido algunas operaciones básicas de [**filtrado**]{.hl-yellow}, [**muestreo**]{.hl-yellow}, [**selección de variables**]{.hl-yellow} y [**recategorización**]{.hl-yellow}

. . .

Veamos un nuevo paquete llamado `{skimr}`, cuya función `skim()` nos permitirá tener un [**primer análisis exploratorio**]{.hl-yellow} de nuestros datos


```{r}
#| echo: false
library(skimr)
```

```{r}
#| eval: false
install.packages("skimr")
library(skimr)
iris |> skim()
```


---

## Depuración

Con dicha función podemos [**comprobar de manera rápida**]{.hl-yellow} si nuestros datos presentan [**alguno de los siguientes problemas**]{.hl-red}

* [**Problemas de codificación o rango**]{.hl-red}: los valores parecen valores permitidos según lo que representa la variable (por ejemplo, no hay edades negativas)

* [**No tenemos datos ausentes**]{.hl-red}: no hace falta decidir, de momento, que hacemos con ellos, ya que `complete_rate` sale en todas 1 (`n_missing` está a cero).

* [**No parece que tengamos excesivos valores atípicos**]{.hl-red}: a la vista de los pequeños histogramas y los percentiles, no parece que tengamos excesivos outliers (al menos muy evidentes)

* [**Todas las salvo Species son numéricas**]{.hl-red}: si tuviésemos que montar un modelo predictivo todas las variables predictoras son numéricas.


* [**Casi todas parecen simétricas**]{.hl-red}: salvo `Petal.Length` las variables parecen más o menos simétricas (media se parece a mediana).

---

## Depuración

En general dado un dataset desde un punto de vista predictivo debemos preguntarnos

* [**1. Tipología**]{.hl-yellow} de las variables. ¿Todas mis variables predictoras son numéricas o debo? ¿Mi variable objetivo es categórica? ¿Tienen la tipología adecuada para mi metodología?

. . .

* [**2. Codificación/rango**]{.hl-yellow} de las variables. ¿Todas mis variables tienen un rango coherente (por ejemplo, que una variable de peso no sea negativa)? ¿Están bien codificadas?

. . .

* [**3. Atípicos y ausentes**]{.hl-yellow}. ¿Tengo valores atípicos (outliers)? En caso afirmativo, ¿cómo tratarlos? Tras tratar atípicos, ¿tengo datos ausentes?

---

## Depuración


* [**4. Selección de variables**]{.hl-yellow}. ¿Necesito seleccionar variables? ¿Tengo alguna de **varianza cero** (es decir, sin información)? ¿Tengo problemas de **dependencia o colinealidad**? ¿Puedo resumir mi info con un conjunto nuevo de variables incorreladas (componentes principales)?

. . .

* [**5. Variables dummy**]{.hl-yellow}. ¿Debo recategorizar variables que no sean numéricas? 

. . .

* [**6. Añadir info**]{.hl-yellow}. ¿Debo crear nuevas variables que nos aporte info extra?

. . .

* [**7. Normalizar variables**]{.hl-yellow}. ¿Tengo ya mis variables preparadas (tras tratar lo anterior) para el algoritmo que vaya usar (estandarizadas por rango o tipificadas por media-varianza, por ejemplo)?


---


## Depuración

Vamos a realizar un ejemplo sobre el dataset `starwars` del paquete `{dplyr}` dentro de tidyverse

```{r}
#| warning: false
#| message: false
library(tidyverse)
starwars
```

. . .

El objetivo será [**predecir el peso**]{.hl-yellow} (variable objetivo continua) mediante una [**regresión lineal**]{.hl-yellow}.

---

## Depuración

Para simplificarlo vamos primero a [**seleccionar solo las columnas**]{.hl-yellow} de estatura, peso, edad y sexo.

```{r}
starwars_lm <- 
  starwars |>
  select(height:mass, birth_year:sex)
starwars_lm
```

---

## 1. Tipología

* [**Tipología**]{.hl-yellow} de las variables. Al ser una regresión, ¿todas mis variables predictoras y objetivo son numéricas?

. . .

En este caso [**no todas las predictoras son numéricas**]{.hl-red} ya que tenemos una variable categórica como `sex` que, de momento, [**vamos a eliminar**]{.hl-yellow}

```{r}
starwars_lm <- 
  starwars_lm |>
  select(where(is.numeric))
starwars_lm
```

---

## 2. Codificación/rango


* [**Codificación/rango**]{.hl-yellow} de las variables. ¿Todas mis variables tienen un rango coherente (por ejemplo, que una variable de peso no sea negativa)? ¿Están bien codificadas?

. . .

En este caso [**todas tienen rangos permitidos**]{.hl-green} (eso no significa que no tengamos outliers)

```{r}
#| eval: false
starwars_lm |> skim()
```

---

## 3. Atípicos/ausentes

* [**Atípicos y ausentes**]{.hl-yellow}. ¿Tengo valores atípicos (outliers)? En caso afirmativo, ¿cómo tratarlos? Tras tratar atípicos, ¿tengo datos ausentes? (puedes probar distintos métodos en <https://odds.cs.stonybrook.edu/#table1>)

. . .


```{r}
#| eval: false
starwars_lm |> skim()
```

En este caso parece obvio que debemos [**tratar ausentes y atípicos**]{.hl-red}

---

## 3. Atípicos (media)

Una de las partes más importantes de la fase de exploración y modificación es la [**detección de outliers**]{.hl-yellow}, pudiendo tener **diferentes definiciones de valor atípico**:

* [**Atípico respecto a media**]{.hl-yellow}: será un dato muy alejado de la media de la variable. [**¿Cuánto de alejado?**]{.hl-purple} Una definición habitual es definir un [**dato atípico**]{.hl-yellow} como aquel que se [**aleja de la media  $k$ veces la desviación típica**]{.hl-yellow} (un valor habitual es $k = 2.5$)

$$\left| x_i - \overline{x} \right| > k*s_{x}$$

. . .

Dicha definición de atípico [**solo tendrá sentido cuando la media sea representativa**]{.hl-yellow} de tu distribución, es decir, siempre y cuando tengamos [**cierta simetría**]{.hl-yellow} (en caos contrario la media, al ser poco robusta, se perturbará fácilmente).

---

## 3. Atípicos (media)

Para detectarlos usaremos el paquete `{outliers}` y su función `scores()`, que nos dará en cada caso una [**"puntuación" de cada observación**]{.hl-yellow} (lo que se aleja). En caso de que queramos detectarlos **respecto a la media**, le indicaremos que `type = "z"` y nos devolverá precisamente el valor  $k$

```{r}
# install.packages("outliers")
library(outliers)
abs(scores(c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8), type = "z"))
```

. . .

De esta forma podemos detectar muy fácil los outliers en función de los estrictos que queramos ser con ese  $k$ (si supera un umbral, outlier). El tipo `type = "chisq"` nos hace algo parecido pero elevando las desviaciones al cuadrado y diviendo por la varianza.

---

## 3. Atípicos (media)

Vamos a aplicarlo a nuestro dataset de starwars (de momento quitando ausentes)

```{r}
library(outliers)
k <- 2.5
starwars_outliers_mean <-
  starwars_lm |>
  drop_na() |> 
  mutate(across(everything(),
                function(x) {
                  if_else(abs(scores(x, type = "z")) > k, NA, x) }))
starwars_outliers_mean
```

---

## 3. Atípicos (media)

Con `if_any()` dentro del `filter()` podemos mostrar todo los registros detectados como outlier en alguna variable.

```{r}
starwars_outliers_mean |>
  filter(if_any(everything(), is.na))
```


---

## 3. Atípicos (mediana)


* [**Atípico respecto a mediana**]{.hl-yellow}: será un dato muy alejado de la mediana de la variable. [**¿Cuánto de alejado?**]{.hl-purple} Una definición habitual (conocido como **filtro de Hampel**) es definir un dato atípico como aquel que se [**aleja de la mediana $k$ veces la mediana de las desviaciones absolutas**]{.hl-yellow} (un valor habitual es $k=3$), conocida como $MAD = Me \left(|x_i - Me_x| \right)$

$$\left| x_i - Me_x \right| > k*MAD$$

. . .


Para ello nos bastará usar `scores()` con `type = "mad"` (y nos devolverá de nuevo ese $k$).

```{r}
abs(scores(c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8), type = "mad"))
```


El [**valor a imputar sería la mediana**]{.hl-yellow}



---

## 3. Atípicos (percentiles)


* [**Atípico respecto a percentiles**]{.hl-yellow}: será un dato muy alejado de los cuartiles de la variable. [**¿Cuánto de alejado?**]{.hl-purple}. Una definición habitual es definir un [**dato atípico como aquel que se aleja de cuartiles 1 y 3 (percentiles 25 y 75)  $k$ veces el rango intercuartílico**]{.hl-yellow} ($IQR = Q_3 - Q_1$). Un valor habitual es $k=1.5$

$$x_i > Q_3 + k*IQR \quad \text{ o bien } \quad x_i < Q_1 - k*IQR$$

. . .

Para ello nos bastará usar `scores()` con `type = "iqr"` (y nos devolverá de nuevo ese $k$, siendo $k = 0$ para lo que esté dentro del IQR).

```{r}

abs(scores(c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8), type = "iqr"))
```

El [**valor a imputar sería la mediana**]{.hl-yellow}

---

## 3. Atípicos (inferencia)

Existen otros [**procedimientos basados en inferencia estadística**]{.hl-yellow}  (muchos de ellos en el paquete  `{outliers}`)

* [**Tests de Grubbs y Dixon**]{.hl-yellow}: ambos test nos permiten detectar si el valor más alto (o bajo) de una variable es un outlier, pudiendo detectar [**un solo outlier en cada iteración**]{.hl-yellow} (en caso de detectarlo, deberíamos tratarlo y volver a ejecutar el test)

$H_0$: valor más alto/bajo no es outlier

$H_1$: valor más alto/bajo sí es outlier
 
. . .

El [**test de Dixon**]{.hl-yellow} (basado en una ordenación) suele funcionar mejor cuando tenemos poca muestra que el test de Grubbs (basado en la media).

Ver más documentación de su funcionamiento en <https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h1.htm> y <https://www.statisticshowto.com/dixons-q-test/>

---


## 3. Atípicos (inferencia)

```{r}
x <- c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8)
dixon.test(x, opposite = TRUE) # valor más bajo
x <- c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8)
dixon.test(x, opposite = FALSE) # valor más alto
```

---

## 3. Atípicos (inferencia)

* [**Test de Rosner**]{.hl-yellow}: al contrario que los anteriores, nos permite detectar varios outliers a la vez, especialmente diseñado para evitar que un valor atípico nos perturbe tanto que nos enmascare otro (basado en la media). Podemos ejecutarlo con la función `rosnerTest()` del paquete `{EnvStats}`.
 

---

## 3. Atípicos (isolation trees)


También existen [**técnicas de Machine Learning**]{.hl-yellow} para la identificación de outliers, como los conocidos como [**Isolation Forest**]{.hl-yellow}.

. . .

La idea es un poco similar a la de un [**Random Forest**]{.hl-yellow}, mediante la [**combinación de muchos árboles**]{.hl-yellow} de clasificación/regresión conocidos como **isolation trees**, aunque en este caso los puntos de corte se hace de manera totalmente aleatoria.

. . .

De esta manera, aquellos individuos con características diferentes al resto quedarán aislados rápidamente, de manera que los [**outliers serán aquellos aislados a los que se llega más rápido**]{.hl-yellow} que al resto

---


## 3. Atípicos (isolation trees)

El algoritmo se puede resumir con sigue:

1. Se crea un [**nodo raíz**]{.hl-yellow} con una submuestra de N observaciones.

2. Se [**selecciona una variable aleatoriamente**]{.hl-yellow} y un [**corte (valor) aleatorio a**]{.hl-yellow} dentro de su rango

3. Se crean [**dos nodos nuevos**]{.hl-yellow} separando los observaciones ($x_i \leq a$ vs $x_i > a$)

4. Se [**repiten los pasos 2 y 3**]{.hl-yellow} hasta que 
[**todas las observaciones quedan aisladas**]{.hl-yellow} de forma individual.

5. Se repite el proceso tomando otra submuestra (bootstrap), de manera que el output de cada observación será el [**promedio de divisiones necesarias para aislarla**]{.hl-yellow}: cuanto más pequeño sea, más anómalo será.

---

## 3. Atípicos (isolation trees)

Es un [**algoritmo no supervisado**]{.hl-yellow}, lo que significa que [**no hay un criterio óptimo objetivo**]{.hl-yellow} para decidir que a partir de dicho valor una observación es un outlier (idea: usar percentiles de dicha distancia, por ejemplo el 5-10% con menor distancia)

. . .

En casos donde el tamaño muestral sea elevado, aislar cada observación puede ser [**costoso computacionalmente**]{.hl-red} por lo que a veces se asume una [**profundidad máxima**]{.hl-yellow} hasta donde puede crecer: las observaciones que sigan sin dividirse se les [**añade el número de divisiones teóricas promedio**]{.hl-yellow} $c(r)$
 que se necesitarían para aislarlos mediante un [**árbol binario de búsqueda (BST)**]{.hl-yellow} (con $r$ observaciones).
 
$$c(r) = 2H(r-1)-{\frac {2(r-1)}{r}}, \quad H(i) = \ln(i) + \gamma, \quad \gamma = 0.577216$$
 
---


## 3. Atípicos (isolation trees)

Es importante que el dataset haya sido ya tratado por ausentes.

```{r}
library(solitude)
# Modelo isolation forest
m <- as.integer(nrow(starwars_lm |> drop_na())/2)
isoforest <-
  isolationForest$new(sample_size = m, num_trees = 500,
                      replace = TRUE, seed = 1234567,
                      max_depth = 7)
isoforest$fit(dataset = starwars_lm |> drop_na())

```

---

## 3. Atípicos (isolation trees)

Con el modelo entrenado, se predicen las distancias de aislamiento promedio de cada observación. Los resultados que calcula `isoforest$predict()` son la [**distancia promedio `average_depth`**]{.hl-yellow} y una métrica que mide el [**grado de anomalía**]{.hl-yellow} `anomaly_score` (valores próximos a 1 para outliers)

```{r}
predicciones <-
  isoforest$predict(data =
                      starwars_lm |> drop_na())
predicciones |> arrange(average_depth)
```

---

## 3. Atípicos (isolation trees)

```{r}
#| code-fold: true
ggplot(data = predicciones, aes(x = average_depth)) +
  geom_density(fill = "#6D98ED", alpha = 0.5) +
  geom_vline(xintercept =
               quantile(predicciones$average_depth,
                        seq(0, 1, 0.1)),
             color = "#DC5B49", linetype = "dashed") +
  labs(title = "Distribución de distancias medias del Isolation Forest",
    subtitle = "Deciles marcados en rojo") +
  theme_minimal()
```


---


## 3. Ausentes

Tras marcar los outliers tenemos dos opciones

* [**eliminar dichas observaciones**]{.hl-yellow} (pasamos a NA y luego con `drop_na()`; problema: eliminas TODA la fila)

* [**imputar**]{.hl-yellow} (sin contar con los ausentes)

---

## 3. Ausentes

Antes de decidir podemos hacer uso del paquete `{naniar}` (ver <https://naniar.njtierney.com/>)

. . .

:::: columns
::: {.column width="50%"}

Por ejemplo con `geom_miss_point()` nos permite visualizar los valores ausentes (que por defecto ggplot los retira)

```{r}
#| eval: false
library(naniar)
ggplot(starwars_lm, 
       aes(x = height, y = mass)) + 
  geom_miss_point()
```
:::

::: {.column width="50%"}

```{r}
#| echo: false
library(naniar)
ggplot(starwars_lm, 
       aes(x = height, y = mass)) + 
  geom_miss_point()
```
:::

::::

---

## 3. Ausentes

También podemos hacer uso de `gg_miss_var` para [**visualizar la cantidad de ausentes para cada variable**]{.hl-yellow}.

```{r}
gg_miss_var(starwars)
```

---

## 3. Ausentes

En `gg_miss_var` tenemos un argumento para facetar por una cualitativa.

```{r}
gg_miss_var(starwars, facet = sex)
```



---

## 3. Ausentes

Una forma de [**representar los ausentes**]{.hl-yellow} en un formato tidy es con la conocida como [**shadow matrix**]{.hl-purple}: una tabla con la misma dimensión que los datos pero con [**indicadores binarios**]{.hl-yellow} sobre si tenemos (`NA`) o no missing (`!NA`), cuyas variables tiene de sufijo `_NA`

. . .

Esto lo podemos hacer con `as_shadow()`

```{r}
as_shadow(starwars_lm)
```

---

## 3. Ausentes

Con `bind_shadow()` podemos [**añadir la shadow matrix**]{.hl-yellow} al dataset original.

```{r}
bind_shadow(starwars_lm)
```

--- 

## 3. Ausentes

Lo anterior es equivalente a  construirlo con `nabular()` (tabular + NA)

```{r}
nabular(starwars) |> 
  summarise(media_peso = mean(mass, na.rm = ), .by = sex_NA)
```

---


## 3. Ausentes

También podemos hacer uso de `add_prop_miss()` para añadir la [**proporción de ausentes en cada registro**]{.hl-yellow}

```{r}
starwars_lm |>
  add_prop_miss()
```

---

## 3. Ausentes

Para [**imputar datos ausentes**]{.hl-yellow} podemos hacer uso de diferentes paquetes, entre ellos `{simpute}` y `{mice}` (ver <https://amices.org/mice/>)

. . .

Por ejemplo en el segundo paquete contamos con la función `md.pattern()` podemos [**visualizar la distribución de los ausentes**]{.hl-yellow}

```{r}
mice::md.pattern(starwars_lm)
```

---

## 3. Ausentes/atípicos

En el caso de starwars vamos a [**imputar ausentes iniciales**]{.hl-yellow} con Random Forest (`mice::mice.impute.rf()`)...

```{r}
#| code-fold: true
#| message: false
starwars_lm_NA_init <-
  starwars_lm |> 
  # Imputamos NA iniciales
  mice::mice(ntree = 100, meth = "rf") |> 
  # Completamos NA
  complete()
```

---

## 3. Ausentes/atípicos

... después [**detectar outliers**]{.hl-yellow} con isolation tree (por ejemplo el 5% con distancia más baja)...

```{r}
#| code-fold: true
#| message: false
m <- as.integer(nrow(starwars_lm_NA_init)/2)
isoforest <-
    isolationForest$new(sample_size = m, num_trees = 500,
                        replace = TRUE, seed = 1234567,
                        max_depth = 9)
isoforest$fit(dataset = starwars_lm_NA_init)

predicciones <-
    isoforest$predict(data = starwars_lm_NA_init)

id_outliers <- 
  predicciones |>
  slice_min(average_depth, prop = 0.05) |> 
  pull(id)

starwars_lm_sin_outliers <-
  starwars_lm_NA_init |> 
  rowid_to_column() |> 
  mutate(across(-rowid,
                function(x, y, z) {
                  if_else(y %in% z, NA, x) }, rowid, id_outliers)) |> 
  select(-rowid)
```

---

## 3. Ausentes/atípicos

... y luego de nuevo [**imputar outliers (pasados a ausentes)**]{.hl-yellow} con Random Forest (`mice::mice.impute.rf()`).

```{r}
#| code-fold: true
#| message: false
starwars_lm_depurado <-
  starwars_lm_sin_outliers |> 
  # Imputamos NA iniciales
  mice::mice(ntree = 100, meth = "rf") |> 
  # Completamos NA
  complete()
starwars_lm_depurado
```




---

## 4. Selección de variables

* [**Selección de variables**]{.hl-yellow}. ¿Necesito seleccionar variables? ¿Tengo alguna de **varianza cero** (es decir, sin información)? ¿Tengo problemas de **dependencia o colinealidad**? ¿Puedo resumir mi info con un conjunto nuevo de variables incorreladas (componentes principales)?

. . .

En este caso [**no tenemos altas correlaciones entre las variables predictoras**]{.hl-yellow}: nos interesa predictoras lo más incorreladas posibles entre sí y lo más correladas con la objetivo (por ejemplo, altura alta correlación con peso)

```{r}
starwars_lm_depurado |> corrr::correlate()
```

---


## 4. Selección de variables

El paquete `{corrr}` y `{corrrplot`} nos permite visualizar dichas correlaciones


```{r}
corrplot::corrplot(starwars_lm_depurado |> cor())
```

---

## 5.6.7. Depuración

* [**Variables dummy**]{.hl-yellow}. ¿Debo recategorizar variables que no sean numéricas? (ver `{fastDummies}`)

* [**Añadir info**]{.hl-yellow}. ¿Debo crear nuevas variables que nos aporte info extra?

* [**Normalizar variables**]{.hl-yellow}. ¿Tengo ya mis variables preparadas (tras tratar lo anterior) para el algoritmo que vaya usar (estandarizadas por rango o tipificadas por media-varianza, por ejemplo)?



En este caso [**no es necesario dummificar**]{.hl-green} ya que hemos considerado solo las numéricas. Al no tener que seleccionar variables y aplicar una regresión lineal [**tampoco es indispensable normalizar**]{.hl-green} y [**no vamos añadir info nueva**]{.hl-green}

---


## Regresión lineal

Vamos a comparar 3 modelos de regresión: [**sin tratar nada**]{.hl-yellow}, eliminando ausentes, y el tratamiento de ausentes/atípicos realizados.

```{r}
starwars_lm |> lm(formula = mass ~ .) |> summary()
```

---

## Regresión lineal

Vamos a comparar 3 modelos de regresión: sin tratar nada, [**eliminando ausentes**]{.hl-yellow}, y el tratamiento de ausentes/atípicos realizados.


```{r}
starwars_lm |> drop_na() |> lm(formula = mass ~ .) |> summary()
```


---

## Regresión lineal

Vamos a comparar 3 modelos de regresión: sin tratar nada, eliminando ausentes, y el [**tratamiento de ausentes/atípicos realizados**]{.hl-yellow}.

```{r}
starwars_lm_depurado |> lm(formula = mass ~ .) |> summary()
```

---

## Regresión lineal

Vamos a comparar 3 modelos de regresión: sin tratar nada, eliminando ausentes, y el tratamiento de ausentes/atípicos realizados.

* [**sin tratar nada**]{.hl-yellow}: obtenemos $R^2 = 0.3367$ con el intercepto no significativo

* [**eliminando ausentes**]{.hl-yellow}: obtenemos lo mismo (por defecto `lm()` se carga los ausentes)

* [**tratamiento de ausentes/atípicos**]{.hl-yellow}: obtenemos $R^2 = 0.5551$ con edad no significativa

---

## 5. Variables dummies

Otra opción a veces es añadir información extra de manera los outliers nos ayuden mejor a predecir, y en este caso añadiremos la variable sexo haciéndola dummy (**one-hot encoding**): creamos $k-1$ variables binarias con `dummy_cols()` del paquete `fastDummies`


```{r}
#| code-fold: true
#| message: false
library(fastDummies)
starwars_lm_sex <- 
  starwars |>
  select(height:mass, birth_year:sex) |> 
  drop_na(sex) |> 
  # Imputamos NA iniciales
  mice::mice(ntree = 100, meth = "rf") |> 
  # Completamos NA
  complete()
```

---

## 5. Variables dummies

Otra opción a veces es añadir información extra de manera los outliers nos ayuden mejor a predecir, y en este caso añadiremos la variable sexo haciéndola dummy (**one-hot encoding**): creamos $k-1$ variables binarias con `dummy_cols()` del paquete `fastDummies`

Obtenemos un $R^2 = 0.5498$ (similar a haber tratado de outliers)

```{r}
starwars_lm_sex_depurado <-
  starwars_lm_sex |>
  dummy_cols(select_columns = "sex", remove_first_dummy = TRUE,
             remove_selected_columns = TRUE)

starwars_lm_sex_depurado |> lm(formula = mass ~ .) |> summary()
```

---

## La imputación importa


El [**método de imputación será crucial**]{.hl-yellow}: si imputamos los ausentes de las numéricas por la media, esto es lo que obtenemos (sobreajuste).

```{r}
#| code-fold: true
#| message: false
library(fastDummies)
starwars_lm_sex <- 
  starwars |>
  select(height:mass, birth_year:sex) |> 
  drop_na(sex) |> 
  # Imputamos NA iniciales
  mice::mice(meth = "mean") |> 
  # Completamos NA
  complete()
```

---

## La imputación importa


El [**método de imputación será crucial**]{.hl-yellow}: si imputamos los ausentes de las numéricas por la media, esto es lo que obtenemos (sobreajuste).

```{r}
starwars_lm_sex_depurado <-
  starwars_lm_sex |>
  dummy_cols(select_columns = "sex", remove_first_dummy = TRUE,
             remove_selected_columns = TRUE)

starwars_lm_sex_depurado |>
  lm(formula = mass ~ height + birth_year) |>
  summary()
```

---

## La imputación importa

El [**método de imputación será crucial**]{.hl-yellow}: si imputamos los ausentes de las numéricas por la media, esto es lo que obtenemos (sobreajuste).

```{r}
#| code-fold: true
starwars_lm_sex_depurado |>
  lm(formula = mass ~ .) |>
  summary()
```


# El mundo Github

[**Trabajar ordenados, publicar resultados, replicabilidad de lo realizado**]{style="color:#444442;"}

---

## ¿Qué es Github?

[**GitHub**]{.hl-yellow} es la plataforma colaborativa más conocida basada en el [**sistema de control de versiones Git**]{.hl-yellow}

. . .

-   [**¿Qué es Git?**]{.hl-purple} Git es un sistema de [**control de versiones**]{.hl-yellow}: una especie de [**Dropbox**]{.hl-yellow} para facilitar la [**programación colaborativa**]{.hl-yellow} entre un grupo de personas, permitiendo llevar la [**trazabilidad de los cambios**]{.hl-yellow} realizados.

. . .

-   [**¿Qué es Github?**]{.hl-purple} Nuestra [**plataforma/interfaz**]{.hl-yellow} para ejecutar el control de versiones: nos servirá no solo para trabajar colaborativamente sino para [**hacer transparente**]{.hl-yellow} el proceso de construcción de nuestros proyectos de código.

. . .

::: callout-important
## Importante

Desde el 4 de junio de 2018 Github es de Microsoft (ergo el código que subas también)
:::

---

## Visión general

Tras hacernos una cuenta en Github, [**arriba a la derecha**]{.hl-purple} tendremos un círculo, y haciendo click en [**Your Profile**]{.hl-purple}, veremos algo similar a esto

::: columns
::: {.column width="55%"}
![](img/github_1.png)
:::

::: {.column width="45%"}
-   [**Edit profile**]{.hl-purple}: nos permite añadir una [**descripción y foto de perfil**]{.hl-yellow}.

-   [**Overview**]{.hl-purple}: en ese panel de cuadrados se [**visualizará nuestra actividad**]{.hl-yellow} a lo largo del tiempo.

-   [**Repositories**]{.hl-purple}: el códugo será subido a [**repositorios**]{.hl-yellow}, el equivalente a nuestras carpetas compartidas en Dropbox.
:::
:::

---

## Primer uso: consumidor

Antes de aprender como crear repositorios, Github también nos servirá para

-   [**Acceder a código**]{.hl-purple} ajeno
-   [**Proponer mejoras**]{.hl-purple} a otros usuarios, e incluso proponer [**correcciones de error que detectemos**]{.hl-yellow} de software que usemos

. . .

-   [**Instalar paquetes de R**]{.hl-purple}. En muchas ocasiones los desarrolladores de paquetes suben las actualizaciones a CRAN cada cierto tiempo, y en otras el software no es suficientemente «amplio» para poder ser subido como paquete.

El código de paquetes que no tengamos subido en CRAN podremos [**instalarlo como código desde Github**]{.hl-yellow}

---

## Instalar desde Github

Por ejemplo, vamos a instalar un paquete llamado [`{peRReo}`](https://github.com/jbgb13/peRReo), cuya única función es darnos [**paletas de colores**]{.hl-yellow} basadas en portadas de [**álbumes de música urbana**]{.hl-yellow}

::: columns
::: {.column width="50%"}
![](img/perrreo.png)
:::

::: {.column width="50%"}
![](img/rosalia.png){width="360"}
:::
:::

. . .

Para ello antes tendremos que instalar un [**conjunto de paquetes para desarrolladores**]{.hl-yellow} llamado `{devtools}`, que nos permitirá la instalación desde Github

```{r}
#| eval: false
install.packages("devtools")
```

---

## Instalar desde Github

Las [**instrucciones de instalación**]{.hl-yellow} suelen venir detalladas en la portada del repositorio

::: columns
::: {.column width="50%"}
![](img/install_perreo.png)
:::

::: {.column width="50%"}
![](img/rosalia.png){width="310"}
:::
:::

. . .

En la mayoría de casos bastará con la función `install_github()` (del paquete que acabamos de instalar), pasándole como argumento la [**ruta del repositorio**]{.hl-yellow} (sin "github.com/").

```{r}
#| eval: false
devtools::install_github("jbgb13/peRReo")
```

Ya puedes perrear con ggplot ;)

---

## Descargar desde Github

La mayoría de veces lo que subamos no será un paquete de R como tal sino que [**subiremos un código más o menos organizado**]{.hl-yellow} y comentado. En ese caso podremos [**descargar el repo entero**]{.hl-yellow} haciendo click [**Code**]{.hl-green} y luego Download ZIP.

Por ejemplo, vamos a descargarnos los scripts de dataviz que han subido desde el [Centre d'Estudis d'Opinió](https://github.com/ceopinio/bop-grafics)

![](img/ceo_github.png)

---

## Ideal

![](img/abogados_simpson.jpeg){width="600"}

[**¿Lo ideal en caso de RTVE?**]{.hl-purple} Tener dos tipos de repositorios

-   Una [**colección de repositorios públicos (producción)**]{.hl-yellow} donde hacer transparente el código y los datos ([**ya validados**]{.hl-purple}), coordinado por un nº reducido de personas.

-   Una [**colección de repositorios privados (desarrollo)**]{.hl-yellow} donde esté todo el equipo colaborando y donde se haga el [**trabajo del día**]{.hl-purple}, con trazabilidad interna.

---

## Nuestro primer repositorio

Vamos a [**crear nuestro primero repositorio**]{.hl-yellow} que servirá además como [**carta de presentación**]{.hl-yellow} de nuestro perfil en Github.

1.  [**Repositories**]{.hl-purple}: hacemos click en las pestaña de Repositories.

2.  [**New**]{.hl-purple}: hacemos click en el [**botón verde New**]{.hl-green} para crear un nuevo repositorio

![](img/new_repo.png)

---

## Nuestro primer repositorio

-   [**Repository name**]{.hl-purple}: el [**nombre del repositorio**]{.hl-yellow}. En este caso vamos a crear un repositorio muy concreto: el nombre debe [**coincidir exactamente con tu nombre de usuario**]{.hl-yellow}

-   [**Description**]{.hl-purple}: descripción de tu repositorio. En este caso será un repo de presentación.

![](img/repo_init_1.png)

---

## Nuestro primer repositorio

-   [**Public vs private**]{.hl-purple}: con cada repositorio tendremos la opción de hacer el repositorio

    -   [**público**]{.hl-purple}: todos los usuarios podrán ver el código así cómo la trazabilidad de su desarrollo (qué se añade y cuándo). Es para mí la opción más recomendable cuando quieres darle [**visibilidad y transparencia**]{.hl-yellow} a tu trabajo
    -   [**privado**]{.hl-purple}: solo tendrán acceso al repositorio aquellos usuarios a los que se lo permitas. No se podrá visualizar ni instalar nada de él fuera de Github.

![](img/repo_init_2.png)

En este caso concreto, dado que será un repositorio de presentación, lo [**haremos público**]{.hl-yellow}.

---

## Nuestro primer repositorio

-   [**Add a README file**]{.hl-purple}: un README file será el archivo donde incluiremos las [**instrucciones y detalles de uso**]{.hl-yellow} a los demás (en el caso de `{peRReo}` era el archivo que contenía los detalles de instalación)

![](img/repo_init_3.png)

De momento [**ignoraremos los demás campos**]{.hl-red} para este primer repositorio.

---

## Nuestro primer repositorio

![](img/repo_init_1.png)

Por defecto Github asume que este repositorio, con el [**mismo nombre que nuestro usuario**]{.hl-yellow} será el repositorio que querremos que se presente de inicio cuando alguien entra en nuestro perfil, y será el repositorio donde \[**incluir en el README.md**\] una presentación de nosotros y un índice de tu trabajo (si quieres).

---

## Nuestro primer repositorio

![](img/profile_github_md.png)

Fíjate que ahora en nuestra [**portada tenemos dicho README.md**]{.hl-yellow} que podemos personalizar a nuestro gusto haciendo uso de [**html y markdown**]{.hl-yellow}.

Aquí puedes ver [**algunos ejemplos de README.MD**](https://github.com/matiassingers/awesome-readme)

---

## Repo de código

Una vez que tenemos nuestro README de presentación (recuerda que puedes [**personalizar a tu gusto con html y markdown**]{.hl-yellow}) vamos a crear un [**repositorio de código**]{.hl-yellow}.

. . .

Si ya era importante [**trabajar con proyectos**]{.hl-yellow} en `RStudio`, cuando lo combinamos con Github es aún más crucial que creemos un proyecto antes de subir el código, así que vamos a crear uno de prueba que se llame `repo-github-1`.

. . .

En dicho proyecto vamos a [**crear un script**]{.hl-yellow} (en mi caso llamado **codigo.R**) en el que deberás hacer los siguientes pasos:

---

## Repo de código

1.  [**Carga**]{.hl-yellow} directamente desde la página del [ISCIII](https://cnecovid.isciii.es/covid19/resources) el archivo llamado `casos_hosp_uci_def_sexo_edad_provres.csv`

```{r}
#| eval: false
#| code-fold: true
# Carga de datos desde ISCIII
datos_covid <- read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
```

. . .

2.  [**Filtra**]{.hl-yellow} datos de Madrid (`"M"`), de 2020 y con sexo conocido (hombre/mujer). Tras ello quédate con las columnas `fecha`, `sexo`, `grupo_edad`, `num_casos` (ese orden). Por último obtén la suma de casos diarios por fecha y sexo.

```{r}
#| eval: false
#| code-fold: true
# Depuración
datos_madrid <-
  datos_covid |>
  # Filtrado por Madrid y fecha
  filter(provincia_iso == "M" & fecha <= "2020-12-31" & sexo != "NC") |> 
  # Selección de columnas
  select(provincia_iso:fecha, num_casos) |> 
  # Resumen de casos diarios por fecha y sexo
  summarise(num_casos = sum(num_casos), .by = c(fecha, sexo))
  
```

---

## Repo de código

3.  [**Exporta el dataset a un csv**]{.hl-yellow} en una carpeta que se llame `exportado`

```{r}
#| eval: false
#| code-fold: true
# Exportamos datos
write_csv(datos_madrid, file = "./exportado/datos_madrid.csv")
```

. . .

::: columns
::: {.column width="40%"}
4.  Crea una [**gráfica de líneas**]{.hl-yellow} que tenga en el eje x fecha, en el eje y casos, con una curva por sexo (gráficas separadas).

```{r}
#| eval: false
#| code-fold: true
# Gráfica
ggplot(datos_madrid) +
  geom_line(aes(x = fecha, y = num_casos, color = sexo),
            alpha = 0.6, linewidth = 0.7) +
  scale_color_manual(values = c("#85519D", "#278862")) +
  facet_wrap(~sexo) +
  theme_minimal() +
  theme(legend.position = "bottom")
```
:::

::: {.column width="60%"}
![](./img/ggplot.png){width="380"}
:::
:::

. . .

5.  Tras ello [**exportamos la gráfica**]{.hl-yellow}

```{r}
#| eval: false
ggsave(filename = "./exportado/ggplot.png", plot = last_plot(),
       bg = "white", width = 12, height = 8)
```

---

## Repo de código

¿Cómo [**subimos el proyecto**]{.hl-yellow}? Vamos de nuevo a [**crear un proyecto de cero**]{.hl-yellow}. Antes no hemos hablado de dos campos importantes:

::: columns
::: {.column width="50%"}
![](./img/repo-1.png){width="460"}
:::

::: {.column width="50%"}
-   `Add .gitignore` nos permitirá [**seleccionar el lenguaje**]{.hl-yellow} en el que estará nuestro proyecto para que Github lo entienda al sincronizar (y no actualice cosas que no deba).

-   `Choose a license` nos permitirá [**seleccionar la licencia**]{.hl-yellow} que determinará las condiciones en las que otros podrán reusar tu código.
:::
:::

---

## Repo de código

::: columns
::: {.column width="50%"}
![](./img/repo-1-1.png)
:::

::: {.column width="50%"}
Si te fijas traer crearlo tenemos solo 3 archivos: el de licencia, el .gitignore y el readme.md (donde deberíamos escribir una guía de uso de lo que hayamos subido)
:::
:::

Para subir los archivos vamos a clickar en [**Add file \< Upload File**]{.hl-purple} y [**arrastraremos TODOS los archivos**]{.hl-yellow} de la carpeta de nuestro proyecto.

---

## Repo de código

Tras la subida de archivos tendremos un cuadro llamado [**Commit changes**]{.hl-purple}

![](./img/commit-1.png)

Un [**commit**]{.hl-purple} es una [**modificación del repositorio**]{.hl-yellow} con algo que se añade/elimine/modifique, y dicho cuadro es recomendable usarlo para [**resumir en qué consiste la modificación**]{.hl-yellow}, de manera que quede trazado el cambio.

---

## Repo de código

Haciendo click en el reloj donde indica el [**número de commits**]{.hl-yellow} accedemos al [**histórico de commits (cambios)**]{.hl-yellow} con hora, día, autor, comentarios, etc.

![](./img/commit-reloj.png)

---

## Repo de código

Vamos a realizar un [**cambio en nuestro código**]{.hl-yellow}: en tu código local (local --\> tu ordenador), en lugar de filtrar por Madrid haz el [**filtro por Barcelona**]{.hl-yellow}, guarda el código y sube en el repositorio el nuevo archivo (con el mismo nombre, Github hará la sobrescritura)

```{r}
#| eval: false
#| code-line-numbers: "3"
datos_bcn <-
  datos_covid |>
  filter(provincia_iso == "B" & fecha <= "2020-12-31" & sexo != "NC") |> 
  select(fecha, sexo, grupo_edad, num_casos) |> 
  summarise(num_casos = sum(num_casos), .by = c(fecha, sexo))
```

---

## Consulta de commits

![](./img/barcelona_covid.png){width="550"}

::: columns
::: {.column width="40%"}
Si ahora [**consultamos el commit**]{.hl-yellow}, al lado hay un número que lo identifica, y clickando en él nos resume los cambios: no solo [**almacena todas las versiones pasadas**]{.hl-yellow} sino que además nos [**muestra las diferencias entre los archivos cambiados**]{.hl-yellow}
:::

::: {.column width="60%"}
![](./img/commit_cambio.png)
:::
:::

---

## Trazabilidad de cambios

::: columns
::: {.column width="72%"}
![](./img/commit_split.png) ![](./img/commit_unified.png)
:::

::: {.column width="28%"}
Tenemos [**dos modos de visualización**]{.hl-yellow} de los cambios: el modo split nos muestra el antiguo y el nuevo, con las inclusiones en verde y lo que ya no está en rojo; y el modo unified nos muestra todo en un mismo documento.
:::
:::

---

## Recuperación de commits

![](./img/browse-repo.png)

Github nos permite incluso [**recuperar una versión del pasado**]{.hl-yellow} de nuestro repositorio, haciendo click en el tercer icono del commit.

---

## Recuperación de commits

![](./img/branch-commit.png)

Si te fijas ahora al lado de `1 branch` tenemos un [**menú desplegable**]{.hl-yellow} en el que antes ponía `main` y ahora un número identificador del commit. Ya hablaremos de la idea de [**rama (branch)**]{.hl-yellow}

---

## Repo con rmd/qmd

::: columns
::: {.column width="60%"}
Vamos a poner en práctica lo aprendido:

1.  Crea un nuevo repositorio en Github (llamado `repo-github-2`) donde habrá alojado con proyecto de R.

2.  Crea un proyecto en `RStudio` que se llame (por ejemplo) `proyecto-qmd`

3.  Una vez dentro del proyecto en `RStudio` haz click en `File < New File < Quarto Document`
:::

::: {.column width="40%"}
![](./img/primer-qmd.png)
:::
:::

Deberás tener un documento similar a este: un [**quarto markdown (.qmd)**]{.hl-yellow}, un documento que nos permitirá incluir [**markdown + código**]{.hl-yellow} (puede ser `R` o puede ser `Observable`, `D3`, etc).

---

## Repo con rmd/qmd

Este formato es ideal para:

-   [**Trabajar en equipo**]{.hl-yellow} construyendo el borrador de una pieza.
-   Tomar [**apuntes o informes**]{.hl-yellow} para uno mismo.
-   [**Presentar**]{.hl-yellow} tu trabajo a tus compañeros.

::: columns
::: {.column width="50%"}
![](./img/prueba-qmd-html.png)
:::

::: {.column width="50%"}
Si te fijas ahora nuestro repositorio tiene un archivo con formato `.html`...es decir...

[**¡Es una web!**]{.hl-yellow}
:::
:::

---

## Github pages

¿Cómo [**convertir nuestro repositorio en una web**]{.hl-yellow}?

![](./img/github-pages.png)

1.  Haz click en `Settings`
2.  Ve al apartado `Pages`
3.  En el subapartado `branch` selecciona la única rama que tenemos ahora (`main`)
4.  Selecciona la carpeta donde tengas el `.html` (en web complejas estará como en cualquier web en `docs`, en algo simple estará en la ruta raiz del repositorio)
5.  Haz click en `Save`

---

## Github pages

Si te fijas en la [**parte superior del repositorio**]{.hl-yellow} ahora tenemos un icono naranja, que nos indica que la [**web está en proceso de ser desplegada (deploy)**]{.hl-orange}

![](./img/github-naranja.png)

---

## Github pages

Pasados unos segundos (dependiendo del tamaño de la web y tu conexión a internet) ese [**icono pasará a ser un check verde**]{.hl-green}: habemus web

![](./img/github-verde.png)

El [**link de la web por defecto**]{.hl-yellow} será `{nombre_usuario}.github.io/{nombre_repo}`

---

## Github pages

![](./img/github-pages-deploy.png)

¡Un momento! Ahora mismo nuestra web [**no nos está mostrando nuestro .qmd**]{.hl-red}, sino por defecto el [**README.md**]{.hl-yellow}.

. . .

Para que Github entienda que queremos visualizar ese `.html` que hemos generado a partir del `.qmd` vamos en nuestro proyecto local a [**borrar**]{.hl-yellow} todo lo que no sea nuestro archivo `.Rproj` y nuestro archivo `.qmd`, y vamos a [**cambiar el nombre**]{.hl-yellow} a este último llamándolo `index.qmd`, y volvemos a compilarlo para [**generar un index.html**]{.hl-yellow}

---

## Github pages

Vamos a [**subir a Github ese nuevo proyecto**]{.hl-yellow} con el cambio de nombre (llamado `repo-github-3`) para ver luego las diferencias entre uno y otro

![](./img/repo-index-html.png)

---

## Github pages

Si [**repetimos el proceso para hacer una Page**]{.hl-yellow} y esperamos al tick verde...

::: columns
::: {.column width="50%"}
![](./img/index-html-qmd.png)
:::

::: {.column width="50%"}
Si a tu `.qmd` ya le llamas de inicio `index.qmd`, automáticamente, al detectar Github un `index.html`, interpreta que ese [**archivo index.html**]{.hl-yellow} es el que define la web (y puedes personalizar añadiendo un archivo `css` de estilos)

[**Habemus web**]{.hl-green} simplemente clickando en Pages :)
:::
:::

---

## Repo con diapositivas

Vamos a crear el último repositorio que se llamará `repo-diapos`, y crear un proyecto en `RStudio` del mismo nombre (por ejemplo). Una vez creado le daremos a `File < New File < Quarto Presentation`.

::: columns
::: {.column width="45%"}
![](img/quarto-slides.png)
:::

::: {.column width="55%"}
La forma de escribir será igual que un `.qmd` normal solo que ahora [**cada diapositiva la separaremos**]{.hl-yellow} con un `---` (usando archivos de estilos podemos personalizar lo que queramos)

Llama al archivo directamente `index.qmd`, súbelo a Github y con un click en Pages tienes una [**web con tus diapositivas**]{.hl-yellow}
:::
:::

---

## Uso de Gitkraken

La forma más [**sencilla para trabajar de manera colaborativa**]{.hl-yellow} en Github, y tenerlo sincronizado con nuestro local, es hacer uso de [Gitkraken](https://www.gitkraken.com/download)

::: columns
::: {.column width="50%"}
![](img/gitkraken-repo.png)
:::

::: {.column width="50%"}
Una vez dentro clickamos en el icono de la carpeta (`Repo Management`) y si ya tenemos el repositorio en Github seleccionamos `Clone`, indicando donde queremos clonar (en nuestro local) y que [**repositorio de Github queremos clonar**]{.hl-yellow}.
:::
:::

---

## Uso de Gitkraken

::: columns
::: {.column width="50%"}
![](img/view-change.png)
:::

::: {.column width="50%"}
Una vez clonado, la idea es que cada [**cambio que hagamos en local nos aparecerá en Gitkraken**]{.hl-yellow} como `View changes`.
:::
:::

---

## Uso de Gitkraken

Cuando tengas suficientes cambios como para [**actualizar el repositorio**]{.hl-yellow} (tampoco tiene sentido actualizar con cada edición), verás algo similar a esto con todos los [**commits realizados**]{.hl-yellow}

::: columns
::: {.column width="50%"}
![](img/stage-all-changes.png)
:::

::: {.column width="50%"}
Podrás decidir cuáles de los [**commits locales quieres incluir en remoto**]{.hl-yellow}, bien uno a uno o en `Stage all changes` (para todos)
:::
:::

---

## Uso de Gitkraken

Tras incluir los commits deberás incluir un [**título y descripción del commit**]{.hl-yellow}

![](img/titulo-commit.png)

---

## Uso de Gitkraken

Tras hacerlo verás que ahora tenemos [**dos iconos separados en una especie de árbol**]{.hl-yellow} (¿te acuerdas de la `branch` o rama?):

-   [**Ordenador**]{.hl-purple}: la versión del repositorio que tienes en tu [**ordenador**]{.hl-yellow}.

-   [**Logo**]{.hl-purple}: la versión del repositorio que tienes [**subida en remoto**]{.hl-yellow}

![](img/split-gitkraken.png)

---

## Uso de Gitkraken

Mientras eso suceda solo tendrás sincronizado tu ordenador con Gitkraken, pero no con Github. Para ello haremos [**click en Push**]{.hl-yellow} (con `Pull` podrás forzar a tener en local lo mismo que en remoto).

![](img/push-gitkraken.png)

---

## Branchs

Como hemos mencionado ya en varias ocasiones, hay un elefante en la habitación que aún no hemos mentado: las [**ramas o branchs**]{.hl-yellow} de un repositorio.

. . .

Imagina que estáis trabajando varios en un proyecto y teneís una versión que funciona pero que queréis [**modificar en paralelo a partir del estado actual**]{.hl-yellow} del repositorio.

. . .

Las [**ramas**]{.hl-yellow} nos permiten partir de una versión común del repositorio y hacer cambios que [**no afecten a los demás**]{.hl-yellow}

---

## Branchs

Para [**crear una rama**]{.hl-yellow} a partir del estado actual de repositorio haremos click en `Branch` y le pondremos un nombre

![](img/branch-button.png)

Una vez creada verás [**dos iconos**]{.hl-yellow} y un [**menú desplegable**]{.hl-yellow} con las distintas ramas en las que quieres hacer el commit. Imagina que realizas un cambio pero [**no quieres añadirlo a la rama principal**]{.hl-yellow}: puedes hacer el [**commit en tu rama propia en LOCAL**]{.hl-yellow} (lo harás en la rama activa de tu menú de branchs).

---

## Branchs

La primera vez te pedirá que escribas la [**rama en REMOTO**]{.hl-yellow} con la quieres sincronizar tu rama en local. [**Consejo**]{.hl-green}: ponle el mismo nombre en remoto que en local.

![](img/name-branch.png)

---

## Branchs

Fíjate que ahora tenemos el ordenador y el logo en el mismo sitio. Esto no significa que tengas ambas ramas en tu local, solo que [**Gitkraken tiene ambas sincronizadas**]{.hl-yellow}: clickando en cualquiera de ellas, tus archivos en tu ordenador cambiarán.

![](img/both-branchs.png)

---

## Pull request

Lo más recomendable es que [**solo se incorpore de una rama secundaria**]{.hl-yellow} a la rama principal aquello que está [**validado por un/a coordinador/a**]{.hl-yellow} del repositorio, asegurándose que todo funciona correctamente.

Cuando queramos incluirlo haremos [**click con botón derecho**]{.hl-yellow} en el icono de la rama secundaria y seleccionamos `Start a pull request to origin from...`

![](img/pull-request-menu.png)

. . .

Una [**pull request**]{.hl-yellow} será una [**petición al responsable de la rama principal**]{.hl-yellow} para incluir los cambios

---

## Pull request

::: columns
::: {.column width="60%"}
![](img/create-pull-request.png)
:::

::: {.column width="40%"}
En el cuadro que no se abre deberemos escribir:

-   La [**rama**]{.hl-yellow} a la que hacer el `merge` (normalmente la `main`)
-   Título y resumen de los cambios
-   Puedes incluso asignar un [**revisor**]{.hl-yellow} entre los colaboradores del repo.
-   Puedes asignar [**etiquetas**]{.hl-yellow}
:::
:::

---

## Pull request

Mientras no se acepte aparecerá un [**icono de rama**]{.hl-yellow} y un +1 en Pull Requests

![](img/pending-branch.png){width="500"}

. . .

Si somos al mantenedor del repositorio, haciendo click en el menú nos saldrán las ramas que nos quieren hacer hacer `merge`

![](img/menu-pr.png){width="500"}

---

## Pull request

Al hacer click se abrirá un [**cuadro de Pull Request**]{.hl-yellow} para decidir si

-   [**Revisar**]{.hl-yellow} los cambios
-   [**Aprobar**]{.hl-yellow} el `merge`
-   [**Añadir comentarios**]{.hl-yellow} al que ha solicitado el `merge` por si queremos solicitar algún cambio [**antes de ser aprobado**]{.hl-yellow}

## ![](img/menu-pr-2.png)

## Pull request

Tras revisar todo y aprobarlo clickaremos en `Confirm merge`, y tras ello podremos decidir si esa rama que era paralela a la principal la queremos [**eliminar**]{.hl-yellow} o dejar visible a todos (consejo: dejar visible para tene [**trazabilidad**]{.hl-yellow} del proyecto de trabajo)

::: columns
::: {.column width="50%"}
![](img/merge-branch.png)
:::

::: {.column width="50%"}
![](img/delete-branch.png)
:::
:::

# Recursos extras

[**Algunos paquetes o recursos curiosos**]{style="color:#444442;"}

---

## Paletas de colores

-   [**{ggthemes}**]{.hl-purple}: [**temas y paletas extras**]{.hl-yellow} para ggplot (por ejemplo para **daltónicos**) <https://jrnold.github.io/ggthemes/> y <https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/>

-   [**{peRReo}**]{.hl-purple}: paletas inspiradas en [**portadas de música urbana y latina**]{.hl-yellow} <https://github.com/jbgb13/peRReo>

-   [**Paletas inspiradas en el Metropolitan Museum**]{.hl-purple}: de Blake Robert Mills <https://github.com/BlakeRMills/MetBrewer/tree/main>

-   [**Paletas inspiradas Taylor Swift**]{.hl-purple}: <https://github.com/asteves/tayloRswift>

-   [**Paletas inspiradas en Harry Potter**]{.hl-purple}: de Alejandro Jiménez <https://github.com/aljrico/harrypotter>

-   [**{colorblindcheck}**]{.hl-purple}: detectar paletas de colores aptas [**daltónicos/as**]{.hl-yellow}. De Jakub Nowosad <https://github.com/Nowosad/colorblindcheck>

---

## Dataviz

-   [**R Graph Gallery**]{.hl-purple}: colección de dataviz en R <https://www.r-graph-gallery.com/>

-   [**{patchwork}**]{.hl-purple}: agregar y [**componer gráficas**]{.hl-yellow}. De Thomas Lin Pedersen. <https://patchwork.data-imaginist.com>

-   [**ggplotly**]{.hl-purple}: función de `{plotly}`, para convertir ggplot a plotly ([**interactiva**]{.hl-yellow}) <https://www.rdocumentation.org/packages/plotly/versions/4.10.0/topics/ggplotly>.

Tras convertirlo a plotly se puede [**guardar automáticamente en html**]{.hl-yellow} con <https://plotly-r.com/saving.html> y generar el [**código del iframe responsive**]{.hl-yellow} con <https://bhaskarvk.github.io/widgetframe/articles/Using_widgetframe.html>

---

## Dataviz

-   [**{ggiraph}**]{.hl-purple}: gráficas interactivas al [**estilo D3**]{.hl-yellow}. <https://davidgohel.github.io/ggiraph/>

-   [**Aprender a usar {ggiraph}**]{.hl-purple}: para gráficas interactivas al [**estilo D3**]{.hl-yellow} <https://albert-rapp.de/posts/ggplot2-tips/17_ggiraph/17_ggiraph.html>

-   [**Gráficas interactivas**]{.hl-purple}: <https://www.tanyashapiro.com/interactive-visuals>

-   [**{geomtextpath}**]{.hl-purple}: paquete para [**curvar el texto**]{.hl-yellow} ajustándose a una gráfica. De Allan Cameron y Teun van den Brand. <https://allancameron.github.io/geomtextpath/>

-   [**{ggstream}**]{.hl-purple}: visualización de [**datos en flujo**]{.hl-yellow}. De Z. Gu. <https://github.com/davidsjoberg/ggstream>

-   [**{ggpattern}**]{.hl-purple}: rellenos con [**patrones geométricos**]{.hl-yellow} en ggplot2. De coolbutuseless y Trevor L. Davis. <https://github.com/coolbutuseless/ggpattern>

---

## Mapas

-   [**{mapSpain}**]{.hl-purple}: visualización de [**datos en mapas de España**]{.hl-yellow} en R. De Diego Hernangómez <https://dieghernan.github.io/rpubs/mapSpain_RMadrid/#1>

-   [**{rasterpic}**]{.hl-purple}: visualización de [**mapas con imágenes rasterizados de fondo**]{.hl-yellow}. De Diego Hernangómez. <https://dieghernan.github.io/rasterpic/>


### Grafos y redes

-   [**{tidygraph}**]{.hl-purple}: paquete al estilo `{tidyverse}` para [**visualizar y manipular grafos**]{.hl-yellow} <https://tidygraph.data-imaginist.com/index.html>


---

## Text mining

-   [**Manual de text mining**]{.hl-purple}: d Julia Silge y David Robinson. Recurso: <https://tidytextmining.com>

-   [**Descarga de textos libres**]{.hl-purple}: de David Robinson. Recurso: <https://github.com/ropensci/gutenbergr>

-   [**Análisis de sentimientos de tweets**]{.hl-purple}: de Harshvardhan. Recurso: <https://www.harsh17.in/twitter-sentiments/>

---

## Datos curiosos

-   [**{fitbitr}**]{.hl-purple}: API para acceder a [**datos de pulseras fitbit**]{.hl-yellow}. De Matt Kaye <https://mrkaye97.github.io/fitbitr/index.html>

-   [**{rtweet}**]{.hl-purple}: API para acceder (al menos antes) a [**Twitter**]{.hl-yellow}. De Michael W. Kearney <https://docs.ropensci.org/rtweet/>

-   [**{owiDR}**]{.hl-purple}: API para acceder a datos de [**Our World in Data**]{.hl-yellow} <https://github.com/piersyork/owidR>

-   [**{wordle}**]{.hl-purple}: API para acceder a [**datos de WORDLE**]{.hl-yellow}. De coolbutuseless <https://coolbutuseless.github.io/2022/01/04/wordle-v0.1.5-a-package-for-playing-and-helping-solve-wordle-puzzles/>

-   [**Canciones de Taylor Swift**]{.hl-purple}: de W. Jake Thompson <https://taylor.wjakethompson.com/>

-   [**{chessR}**]{.hl-purple}: API para acceder a datos de [**partidas de ajedrez**]{.hl-yellow}. De Jason Zivkovic <https://github.com/JaseZiv/chessR>

---

## Informes, libros, diapositivas y webs

-   [**Manual de Quarto**]{.hl-purple}: el nuevo rmarkdown, más completo y sencillo para elaborar manuales, diapositivas, informes e incluso webs <https://quarto.org/docs/guide/>

-   [**Shiny**]{.hl-purple}: webs interactivas con R <https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/>

### Tablas

-   [**{gt}**]{.hl-purple}: tablas en R. De RStudio <https://gt.rstudio.com/>

-   [**{gtExtras}**]{.hl-purple}: visualización de datos en tablas. De Thomas Mock. <https://jthomasmock.github.io/gtExtras/index.html>

-   [**Tutorial de tablas**]{.hl-purple}: de Benjamin Nowak <https://bjnnowak.netlify.app/2021/10/04/r-beautiful-tables-with-gt-and-gtextras/>

# ¡GRACIAS!

[**Mi mail javalv09\@ucm.es, Twitter [@dadosdelaplace](https://twitter.com/DadosdeLaplace) e Instagram [@javieralvarezliebana](https://www.instagram.com/javieralvarezliebana/) para lo que queráis**]{style="color:#444442;"}