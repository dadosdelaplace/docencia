---
title: "SOFTWARE PARA GESTIÃ“N DE BASES DE DATOS"
subtitle: "IntroducciÃ³n al anÃ¡lisis de datos en R (y Stata)"
title-slide-attributes:
  data-background-image: img/covid19-genetics.webp
  data-background-size: cover
  data-background-opacity: "0.2"
author: "MÃ¡ster de BioestadÃ­stica â€¢ curso 2023-2024"
affiliation: Facultad de Estudios EstadÃ­sticos (UCM)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    chalkboard: true
    multiplex: true
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier Ãlvarez LiÃ©bana</strong>](...) â€¢ MÃ¡ster de bioestadÃ­stica (UCM) â€¢ curso 2023-2024"
    slide-number: c/t
execute:
  echo: true
---

# Â¡Bienvenidos a R!

[**Dejad vuestras hojas de cÃ¡lculo a un lado**]{style="color:#444442;"}

---

## Â¡Buenas!

[**Correo**]{.hl-green}: **<javalv09@ucm.es>**. [**Despacho**]{.hl-green}: 722 (3Âª planta). [**TutorÃ­as**]{.hl-green}: lunes (14:30-16:00), martes (12:00-13:00) y viernes (13:00-14:00).

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
-   [**Javier Ãlvarez LiÃ©bana**]{.hl-yellow}, de Carabanchel (Bajo).

-   Licenciado en MatemÃ¡ticas (UCM). [**Doctorado en estadÃ­stica**]{.hl-yellow} (UGR).

-   Encargado de la [**visualizaciÃ³n y anÃ¡lisis de datos covid**]{.hl-yellow} del Principado de Asturias (2021-2022).

-   Miembro de la [**Sociedad EspaÃ±ola de EstadÃ­stica e IO**]{.hl-yellow} y la [**Real Sociedad MatemÃ¡tica EspaÃ±ola**]{.hl-yellow}.
:::
:::
:::

. . .

Actualmente, [**investigador y docente en la Facultad de EstadÃ­stica de la UCM**]{.hl-yellow}. Divulgando por [**Twitter**](https://twitter.com/dadosdelaplace) e [**Instagram**](https://instagram.com/javieralvarezliebana)


---

## Objetivos

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
-   Quitarnos el [**miedo a los errores en programaciÃ³n**]{.hl-yellow} â†’ a programar se aprende programando

-   Entender los [**conceptos bÃ¡sicos de R**]{.hl-yellow} desde cero â†’ aprender a abstraer ideas y algoritmos

-   Utilidad de programar â†’ flujos de trabajo [**reproducibles**, **transparentes**]{.hl-yellow} y mantenibles

-   IntroducciÃ³n al [**anÃ¡lisis y preprocesamiento**]{.hl-yellow} de datos â†’ `{tidyverse}`

-   Adquirir habilidades en la [**visualizaciÃ³n de datos**]{.hl-yellow} â†’ `{ggplot2}`
:::
:::
:::

---

## EvaluaciÃ³n

-   [**Asistencia**]{.hl-yellow}. La asistencia no serÃ¡ obligatoria pero si se [**valorarÃ¡ muy positivamente**]{.hl-purple} la participaciÃ³n en clase (nunca penalizando).

. . .

-   [**EvaluaciÃ³n**]{.hl-yellow}. A lo largo del curso se han planteado [**4 entregas individuales**]{.hl-purple}, asÃ­ como una [**entrega final grupal**]{.hl-purple} (entre 2 y 4 personas) donde se deberÃ¡ presentar el anÃ¡lisis realizado de un caso real.

. . .

-   [**Nota mÃ­nima**]{.hl-yellow}. Para no ir al examen final se [**deberÃ¡ obtener al menos un 4/10**]{.hl-purple} en cada entrega o una [**media ponderada superior al 6/10**]{.hl-purple}. Se deberÃ¡ obtener ademÃ¡s en la [**entrega grupal una nota superior a 6-6.5-7/10**]{.hl-purple} (segÃºn 2-3-4 personas)

. . .

-   [**Examen final**]{.hl-yellow}. Cualquier alumno podrÃ¡ presentarse a un examen final, siendo la valoraciÃ³n del mismo el 100% de su nota (perdiendo la evaluaciÃ³n continua).

---

## PlanificaciÃ³n I

::: column-screen-inset-right
::: {style="font-size:20px"}
|  CLASE | SEMANA | FECHAS | TOPIC | SCRIPTS | EJ. | CASO PRÃCTICO | ENTREGA | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
|     [1](#clase-1-primeros-pasos)      | S1     | 11 sep |                  Primeros pasos en R                   | [ğŸ“](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  |                 [ğŸ’»](#tu-turno)                 |                        |         | 
|     [2](#clase-2-primeros-datos)      | S1     | 13 sep |                 Tipos bÃ¡sicos de datos                 | [ğŸ“](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  |       [ğŸ’»](#tu-turno-1) [ğŸ’»](#tu-turno-2)  [ğŸ’»]{#tu-turno-matrices}     |  [ğŸ£](#caso-prÃ¡ctico-2)  |         |     
| [3](#clase-3-primeras-bases-de-datos) | S2     | 18 sep |                Primeras bases de datos. R base vs Tidyverse                   | [ğŸ“](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  | [ğŸ’»](#tu-turno-tibble)  [ğŸ’»](#tu-turno-3) | [ğŸ£](#caso-prÃ¡ctico-3a) [ğŸ£](#caso-prÃ¡ctico-3b)  |         |    
|   [4](#clase-5-importexport-comunicar)   | S2     | 19 sep |                  Importar/exportar e intro a Quarto/rmd                  | [ğŸ“](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  |                [ğŸ’»](#tu-turno-4)                |        [ğŸ£](#caso-prÃ¡ctico-4a)  [ğŸ£](#caso-prÃ¡ctico-4b)             |         |    
|   [5](#clase-5-tidyverse-filas)   | S3     | 25 sep |                  Tidyverse (filas)                  | [ğŸ“](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  |                [ğŸ’»](#tu-turno-7a) [ğŸ’»](#tu-turno-7b)                |        [ğŸ£](#caso-prÃ¡ctico-5)          |         | 
|   [6](#entrega-i)   | S3 | 27 sep | Entrega I |  |  [ğŸ’»](#entrega-i)   |  |  ğŸ¯ 10%  |
|   [7](#clase-7-tidyverse-columnas)   | S3     | 2 oct |                  Tidyverse (columnas)                  | [ğŸ“](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  |                [ğŸ’»](#tu-turno-7d) [ğŸ’»](#tu-turno-7e)                |   [ğŸ£]{#caso-7a} |
|   [8](#clase-8)   | S4     | 4 oct |                  Tidyverse (crear/modificar variables)                  | [ğŸ“](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  |                [ğŸ’»](#tu-turno-8a)  [ğŸ’»](#tu-turno-8b)               |   [ğŸ£]{#caso8a} |
|   [9](#clase-9-funciones)   | S5     | 9 oct |                  Funciones                 | [ğŸ“](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material/scripts)  |                [ğŸ’»](#tu-turno-9)         |   [ğŸ£] [ğŸ£]|
:::
:::

---

## Materiales

* [**Diapositivas**]{.hl-yellow}: las diapositivas que usaremos en el aula a lo largo del curso, estructuradas por clases, estarÃ¡n disponibles y actualizadas en **<https://javieralvarezliebana.es/docencia-R-master-bio-2324/diapos>** 

En el menÃº de las diapositivas (abajo a la izquierda) tienes una [**opciÃ³n para descargarlas en pdf**]{.hl-yellow} en `Tools` (consejo: hazlo el final del curso ya que irÃ¡n modificÃ¡ndose)
  
&nbsp;

* [**Material**]{.hl-yellow}: [**scripts de cada tema**](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material) y materiales extras

* [**ResÃºmenes de paquetes**]{.hl-yellow}: [**chuletas de los paquetes**](https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/fichas%20paquetes) en formato .pdf

* [**Datos**]{.hl-yellow}: <https://drive.google.com/drive/folders/1iH3UCMDBNS_TJYKm7wx3-_120_3wmBdQ?usp=sharing>

# Clase 1: primeros pasos {#clase-1-primeros-pasos}

[**Instalando R y RStudio. Primeros pasos. Scripts y proyectos**]{style="color:#444442;"}

---

## Requisitos

Para el curso los Ãºnicos requisitos serÃ¡n:

1.  [**ConexiÃ³n a internet**]{.hl-yellow} (para la descarga de algunos datos y paquetes).

2.  [**Instalar R**]{.hl-yellow}[: serÃ¡ nuestro lenguaje. La descarga la haremos (gratuitamente) desde <https://cran.r-project.org/>]{.fragment .fade-in}

::: {.fragment .fade-in}
3.  [**Instalar RStudio**]{.hl-yellow} desde <https://posit.co/download/rstudio-desktop/>
:::

::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="420"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="420"}
:::
:::

---

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="400"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="470"}
:::
:::

::: {.fragment .fade-in-then-out}
Programaremos como escribimos (castellano, por ejemplo) â†’ `R` es [**lenguaje**]{.hl-yellow}
:::

::: {.fragment .fade-up}
-   Necesitaremos una [**gramÃ¡tica**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}
-   Y un entorno, por ejemplo un [**Word**]{.hl-yellow} (`RStudio`), para escribirlo
:::
:::

---

## InstalaciÃ³n de R

El lenguaje `R` serÃ¡ nuestra [**gramÃ¡tica y ortografÃ­a**]{.hl-yellow} (nuestras reglas de juego)

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra en <https://cran.r-project.org/> y selecciona tu sistema operativo.

-   [**Paso 2**]{.hl-yellow}: para Mac basta con que hacer click en el **archivo .pkg**, y abrirlo una vez descargado. Para sistemas Windows, debemos clickar en **install R for the first time** y despuÃ©s en **Download R for Windows**. Una vez descargado, abrirlo como cualquier archivo de instalaciÃ³n.

-   [**Paso 3**]{.hl-yellow}: abrir el ejecutable de instalaciÃ³n.
:::

. . .

::: callout-warning
Siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), [**asegÃºrate de tener conexiÃ³n a internet**]{.hl-orange}.
:::

---

## Primera operaciÃ³n

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deberÃ­as ver una **pantalla blanca** similar a esta.

Esa Â«pantalla blancaÂ» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**Idea**]{.hl-yellow}: a una variable llamada `a` le asignaremos el valor `1` (escribiremos el cÃ³digo de abajo en la consola y daremos Â«enterÂ»)

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## Primera operaciÃ³n

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deberÃ­as ver una **pantalla blanca** similar a esta.

Esa Â«pantalla blancaÂ» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Idea**]{.hl-yellow}: definiremos otra variable llamada `b` y le asignaremos el valor `2`

```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

. . .

::: callout-note
## FÃ­jate que...

En `R` usaremos `<-` como una flecha: la variable a la izquierda de dicha flecha le asignamos el valor que hay a la derecha (por ejemplo, `a <- 1`)
:::

---

## Primera operaciÃ³n

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deberÃ­as ver una **pantalla blanca** similar a esta.

Esa Â«pantalla blancaÂ» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="270"}
:::
:::

[**Idea**]{.hl-yellow}: haremos la suma `a + b` y nos devolverÃ¡ su resultado

```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

---

## InstalaciÃ³n de R Studio

`RStudio` serÃ¡ el [**Word**]{.hl-yellow} que usaremos para escribir (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra la [web oficial de RStudio](https://posit.co/download/rstudio-desktop/) (ahora llamado Posit) y selecciona la descarga gratuita.

-   [**Paso 2**]{.hl-yellow}: selecciona el ejecutable que te aparezca acorde a tu sistema operativo.

-   [**Paso 3**]{.hl-yellow}: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro y dejar que termine la instalaciÃ³n.
:::

---

## OrganizaciÃ³n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo cÃ³digo que antes (la suma de las variables) en ella. La consola serÃ¡ donde **ejecutaremos Ã³rdenes y mostraremos resultados**.

![](img/consola_rstudio.jpg){width="420"}

---

## OrganizaciÃ³n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Environment**]{.hl-yellow}: la pantalla pequeÃ±a (puedes ajustar los mÃ¡rgenes con el ratÃ³n a tu gusto) que tenemos en la parte superior derecha. Nos mostrarÃ¡ las **variables que tenemos definidas**.

![](img/environment.jpg){width="420"}

---

## OrganizaciÃ³n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha no servirÃ¡ para buscar **ayuda de funciones**, ademÃ¡s de para **visualizar grÃ¡ficos**.

![](img/multiusos.jpg){width="420"}

---

## Â¿QuÃ© es R? Â¿Por quÃ© R?

![](img/meme_barco.jpg)

---

## Â¿QuÃ© es R? Â¿Por quÃ© R?

`R` es el [**lenguaje estadÃ­stico por excelencia**]{.hl-yellow}, creado por y para estadÃ­sticos/as, con 5 ventajas fundamentales [**frente a Excel**]{.hl-red}:

::: incremental
-   [**Lenguaje de programaciÃ³n**]{.hl-yellow}: la obviedad [â†’ anÃ¡lisis]{.fragment .fade-in}[**replicables**]{.hl-purple}

-   [**Gratuito**]{.hl-yellow}: la filosofÃ­a de la comunidad de `R` es el compartir cÃ³digo bajo **copyleft** [â†’]{.fragment .fade-in}[**uso Ã©tico de dinero pÃºblico**]{.hl-purple}

-   [**Software libre**]{.hl-yellow}: no solo es gratis sino que permite acceder libremente a cÃ³digo ajeno, incluso al **propio cÃ³digo fuente** [â†’]{.fragment .fade-in}[**flexibilidad y transparencia**]{.hl-purple}

-   [**Lenguaje modular**]{.hl-yellow}: hemos instalado lo mÃ­nimo, pero existen cÃ³digos de otras personas que podemos reusar (casi 20 000 [**paquetes**]{.hl-yellow}) [â†’]{.fragment .fade-in}[**ahorro de tiempo**]{.hl-purple}

-   [**Lenguaje de alto nivel**]{.hl-yellow}: facilita la programaciÃ³n (como Python) [â†’]{.fragment .fade-in}[**menor curva de aprendizaje**]{.hl-purple}
:::

---

## Â¿QuÃ© es R? Â¿Por quÃ© R?

![](img/incel_excel.png)

---

## Â¿Por quÃ© programar?

-   [**Automatizar**]{.hl-yellow} â†’ te permitirÃ¡ automatizar tareas recurrentes.

-   [**Replicabilidad**]{.hl-yellow} â†’ podrÃ¡s replicar tu anÃ¡lisis siempre de la misma manera.

-   [**Flexibilidad**]{.hl-yellow} â†’ podrÃ¡s adaptar el software a tus necesidades.

-   [**Transparencia**]{.hl-yellow} â†’ ser auditado por la comunidad.

![](img/the_general_problem.png)

---

## Idea fundamental: paquetes

Una de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: cÃ³digos que otras personas han implementado para **resolver un problema**

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}
-   [**InstalaciÃ³n**]{.hl-yellow}: descargamos los cÃ³digos de la web (necesitamos internet) â†’ [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)

```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}
-   [**Carga**]{.hl-yellow}: con el paquete descargado, indicamos quÃ© paquetes queremos usar cada vez que abramos `RStudio` â†’ [**traer el libro de la estanterÃ­a**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::
:::
:::

---

## Idea fundamental: paquetes

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
Una vez instalado, hay dos manera de usar un paquete (traerlo de la estanterÃ­a)

::: {.fragment fragment-index="1"}
-   [**Paquete entero**]{.hl-yellow}: con `library()`, usando el nombre del paquete sin comillas, cargamos en la sesiÃ³n [**todo el libro**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}
-   [**Funciones concretas**]{.hl-yellow} usando `paquete::funcion` le Ã­ndicamos que solo queremos una [**pÃ¡gina concreta de ese libro**]{.hl-purple}

```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## Te vas equivocar

Durante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera â†’ [**te vas equivocar**]{.hl-yellow}. No solo serÃ¡ importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.

. . .

-   [**Mensajes de error**]{.hl-red}: precedidos de **Â«Error in...Â»** y serÃ¡n aquellos fallos que [**impidan la ejecuciÃ³n**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Mensajes de warning**]{.hl-orange}: precedidos de **Â«Warning in...Â»** son los (posibles) fallos mÃ¡s delicados ya que son incoherencias que [**no impiden la ejecuciÃ³n**]{.hl-orange}

```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```

---

## Scripts (documentos .R)

::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}
Un [**script**]{.hl-yellow} serÃ¡ el documento en el que programamos, nuestro archivo `.doc` (aquÃ­ con extensiÃ³n `.R`) donde escribiremos las Ã³rdenes. Para **abrir nuestro primero script**, haz click en el menÃº en `File < New File < R Script`.
:::
:::

::: callout-warning
## Cuidado

Es importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habrÃ¡s perdido**]{.hl-orange}.
:::

---

## Ejecutando el primer script

Ahora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros cÃ³digos**]{.hl-yellow}. Â¿CÃ³mo ejecutarlo?

. . .

1.  **Escribimos** el cÃ³digo a ejecutar.

. . .

2.  **Guardamos** el archivo .R haciendo click en `Save current document`.

. . .

3.  El cÃ³digo no se ejecuta salvo que se lo indiquemos. Tenemos tres opciones:

-   [**Copiar y pegar**]{.hl-yellow} en consola.
-   [**Seleccionar lÃ­neas**]{.hl-yellow} y `Ctrl+Enter`
-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el cÃ³digo **completo**.

---

## ğŸ’» Tu turno {#tu-turno}

[**Ejecuta tu primer script**: crea un script de cero, programa lo indicado debajo y ejecÃºtalo (de las 3 maneras posibles)]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Define una variable de nombre `a` y cuyo valor sea -1

```{r}
#| code-fold: true
a <- -1
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ AÃ±ade debajo otra lÃ­nea para definir una variable `b` con el valor 5. Tras ello mÃºltiplica ambas variables

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # sin guardar
multiplicacion <- a * b # guardado
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables.

```{r}
#| eval: false
c <- # deberÃ­as asignarle el valor 3
d <- # deberÃ­as asignarle el valor -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d # sin guardar
division <- c / d # guardado
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Asigna un valor positivo a `x` y calcula su raÃ­z cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la funciÃ³n `abs()`.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Usando la variable `x` ya definida, completa/modifica el cÃ³digo inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.

```{r}
#| eval: false
z <- ? - ? # completa el cÃ³digo
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```
:::

::: callout-note
## Toma nota

Comandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: lÃ­neas de cÃ³digo que hemos Â«encapsuladoÂ» bajo un nombre, y dado unos argumentos de entrada, ejecuta las Ã³rdenes (una especie de atajo).
:::

---

## SÃ© organizado: proyectos

De la misma manera que en el ordenador solemos trabajar de manera [**ordenada por carpetas**]{.hl-yellow}, en `RStudio` podemos hacer lo mismo para trabajar de [**manera eficaz creando proyectos**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
Un [**proyecto serÃ¡ una Â«carpetaÂ»**]{.hl-yellow} dentro de `RStudio`, de manera que nuestro directorio raÃ­z automÃ¡ticamente serÃ¡ la propia carpeta de proyecto (pudiendo pasar de un proyecto a otro con el menu superior derecho).

Podemos crear uno en una carpeta nueva o en una carpeta ya existente.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::

---

## FilosofÃ­a: de la CELDA a la TABLA

Â¿QuÃ© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg){fig-align="middle"}

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenaciÃ³n** de valores del mismo tipo ([**vectores**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenaciÃ³n de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenaciÃ³n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenaciÃ³n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

# Clase 2: primeros datos {#clase-2-primeros-datos}

[**Â¿QuÃ© tipos de celdas (datos) existen? Concatenando celdas: vectores**]{style="color:#444442;"}

---

## De la CELDA a la TABLA

Â¿QuÃ© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg){fig-align="middle"}

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenaciÃ³n** de valores del mismo tipo ([**vectores**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenaciÃ³n de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenaciÃ³n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenaciÃ³n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

---

## Celdas: tipos de datos

Â¿Existen [**variables mÃ¡s allÃ¡ de los nÃºmeros**]{.hl-yellow}?

. . .

Piensa por ejemplo en los datos guardados de una persona:

::: {.fragment .fade-up}
-   La edad o el peso serÃ¡ un [**nÃºmero**]{.hl-yellow}.

```{r}
edad <- 33
```
:::

::: {.fragment .fade-up}
-   Su nombre serÃ¡ una cadena de [**texto (string o char)**]{.hl-yellow}.

```{r}
nombre <- "javi"
```
:::

::: {.fragment .fade-up}
-   A la pregunta Â«Â¿estÃ¡ usted soltero/a?Â» la respuesta serÃ¡ lo que llamamos una [**variable lÃ³gica**]{.hl-yellow} (`TRUE` si estÃ¡ soltero/a o `FALSE` en otro caso).

```{r}
soltero <- FALSE
```
:::

::: {.fragment .fade-up}
-   Su fecha de nacimiento serÃ¡ precisamente eso, una [**fecha**]{.hl-yellow}.
:::

---

## Variables numÃ©ricos

El dato mÃ¡s sencillo (ya lo hemos usado) serÃ¡n las [**variables numÃ©ricas**]{.hl-yellow}

```{r}
#| eval: false
a <- 5
b <- 2
a + b
```

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

. . .

Para saber el tipo de una variable tenemos la funciÃ³n `class()`

```{r}
class(a)
```

. . .

Con las variables numÃ©ricas podemos realizar las [**operaciones aritmÃ©ticas**]{.hl-yellow} de una calculadora: sumar (`+`), raÃ­z cuadrada (`sqrt()`), cuadrado (`^2`), etc.

```{r}
a^2
abs(a)
```

---

## Variables de texto

Imagina que ademÃ¡s de la edad de una persona queremos guardar su nombre: ahora la variable serÃ¡ de tipo `character`

```{r}
nombre <- "Javier"
class(nombre)
```

. . .

Las [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones aritmÃ©ticas**]{.hl-red} (sÃ­ otras operaciones como pegar o localizar patrones).

```{r}
#| error: true
nombre + 1 # error al sumar nÃºmero a texto
```

. . .

::: callout-warning
## Recuerda que...

Las variables de tipo texto (character o string) van [**SIEMPRE entre comillas**]{.hl-orange}: no es lo mismo `TRUE` (valor lÃ³gico, binario) que `"TRUE"` (texto).
:::

---

## Primera funciÃ³n: paste

En `R` llamaremos [**funciÃ³n**]{.hl-yellow} a un trozo de [**cÃ³digo encapsulado**]{.hl-yellow} bajo un nombre, y que depende de unos [**argumentos**]{.hl-yellow} de entrada. Nuestra primera funciÃ³n serÃ¡ `paste()`: dadas dos cadenas de texto nos permite pegarlas.

```{r}
paste("Javier", "Ãlvarez")
```

. . .

FÃ­jate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos aÃ±adir un [**argumento opcional**]{.hl-yellow} para indicarle el separador (en `sep = ...`).

```{r}
paste("Javier", "Ãlvarez", sep = "*")
```

---

## Primera funciÃ³n: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}
Â¿CÃ³mo saber [**quÃ© argumentos necesita una funciÃ³n**]{.hl-yellow}? Escribiendo en consola `? paste` te aparecerÃ¡ una [**ayuda**]{.hl-yellow} en el panel multiusos.

En dicha ayuda podrÃ¡s ver en su cabecera que argumentos ya tiene [**asignados por defecto**]{.hl-yellow} la funciÃ³n
:::
:::

. . .

Existe una funciÃ³n similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).

```{r}
paste0("Javier", "Ãlvarez")
```

---

## Primer paquete: glue

Una forma mÃ¡s intuitiva de trabajar con textos es usar el paquete `{glue}`: lo primero que haremos serÃ¡ Â«comprar el libroÂ» (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue") # solo la primra vez
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

Con dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, Â«la edad es de ... aÃ±osÂ», donde la edad estÃ¡ guardada en una variable.

```{r}
edad <- 33
glue("La edad es de {edad} aÃ±os")
```

. . .

Dentro de las llaves tambiÃ©n podemos ejecutar operaciones

```{r}
unidades <- "dÃ­as"
glue("La edad es de {edad * 365} {unidades}")
```

---

## Variables lÃ³gicas

Otro tipo fundamental serÃ¡n las [**variables lÃ³gicas o binarias**]{.hl-yellow} (**dos valores**):

-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.
-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.

```{r}
soltero <- FALSE # Â¿EstÃ¡ soltero? --> NO
class(soltero)
```

. . .

Puede tomar un tercer valor, `NA` o [**dato ausente**]{.hl-yellow}, representando las siglas de *not available*.

. . .

::: callout-important
## Importante

Las variables lÃ³gicas [**NO son variables de texto**]{.hl-red}: `"TRUE"` es un texto, `TRUE` es un valor lÃ³gico.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Condiciones lÃ³gicas

Los valores lÃ³gicos suelen ser resultado de [**evaluar condiciones lÃ³gicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos comprobar si una persona se llama Javi.

```{r}
nombre <- "MarÃ­a"
```

. . .

Con el [**operador lÃ³gico**]{.hl-yellow} `==` preguntamos sÃ­ a la izquierda es igual a la derecha

```{r}
nombre == "Javi"
```

. . .

Con su opuesto `!=` preguntamos si es distinto.

```{r}
nombre != "Javi"
```

. . .

::: callout-note
## FÃ­jate que...

No es lo mismo `<-` ([**asignaciÃ³n**]{.hl-yellow}) que `==` (estamos [**preguntando**]{.hl-yellow}, es una comparaciÃ³n lÃ³gica).
:::

---

## Condiciones lÃ³gicas

AdemÃ¡s de las comparaciones Â«igual aÂ» frente Â«distintoÂ», tambiÃ©n comparaciones de orden como `<, <=, > o >=`.

**Â¿Tiene la persona menos de 32 aÃ±os?**

```{r}
edad <- 38
edad < 32 # Â¿Es la edad menor de 32 aÃ±os?
```

**Â¿La edad es mayor o igual que 38 aÃ±os?**

```{r}
edad >= 38
```


---

## Variables de fecha

Un tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.

```{r}
fecha_char <- "2021-04-21"
```

. . .

Parece una simple cadena de texto pero [**representa un instante en el tiempo**]{.hl-yellow}. Â¿QuÃ© deberÃ­a suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?

```{r}
#| error: true
fecha_char + 1
```

. . .

Las fechas [**no pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha con `as_date()` del paquete `{lubridate}`

```{r}
library(lubridate) # instala si no lo has hecho
fecha <- as_date("2023-03-28")
fecha + 1
class(fecha)
```

---

## Variables de fecha

En dicho paquete tenemos funciones muy Ãºtiles para [**manejar fechas**]{.hl-yellow}:

-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.

```{r}
today()
```

. . .

-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}

```{r}
now()
```

. . .

-   Con `year()`, `month()` o `day()` podemos [**extraer el aÃ±o, mes y dÃ­a**]{.hl-purple}

```{r}
fecha <- today()
year(fecha)
month(fecha)
```

---

## ResÃºmenes de paquetes

![](img/lubridate.png)

::: callout-note
## Amplia contenido

Tienes un resumen en pdf de los paquetes mÃ¡s importantes en la [**carpeta correspondiente en el campus**]{.hl-green}
:::

---

## ğŸ’» Tu turno {#tu-turno-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Define una variable que guarde tu edad (llamada `edad`) y otra con tu nombre (llamada `nombre`)

```{r}
#| code-fold: true
edad <- 33
nombre <- "Javi"
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Define otra variable llamada `hermanos` que responda la pregunta Â«Â¿tienes hermanos?Â» y otra con la fecha de tu nacimiento (llamada `fecha_nacimiento`).

```{r}
#| code-fold: true
hermanos <- TRUE

library(lubridate)
fecha_nacimiento <- as_date("1989-09-10")
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Define otra variable con tus apellidos (llamada `apellidos`) y usa `glue()` para tener una sola variable `nombre_completo` (separando nombre y apellido por una coma)

```{r}
#| code-fold: true
#| eval: false
apellidos <- "Ãlvarez LiÃ©bana"
glue("{nombre}, {apellidos}")
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Calcula los dÃ­as que han pasado desde la fecha de tu nacimiento hasta hoy (con la fecha de nacimiento definida en el ejercicio 2).

```{r}
#| code-fold: true
#| eval: false
today() - fecha_nacimiento
```
:::

---

## Vectores: concatenar

Cuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenaciÃ³n**]{.hl-purple} de celdas (valores) del [**mismo tipo**]{.hl-purple}

. . .

La forma mÃ¡s sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus **elementos entre parÃ©ntesis y separados por comas**

```{r}
edades <- c(33, 27, 60, 61)
edades
```

. . .

::: callout-tip
Un nÃºmero individual `x <- 1` (o bien `x <- c(1)`) es en realidad un vector de longitud uno.
:::

---

## Vectores: concatenar

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}
Como ves ahora en el `environment` tenemos una **colecciÃ³n de elementos** guardada

```{r}
edades
```
:::
:::

. . .

Â 

La [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`

```{r}
length(edades)
```

. . .

TambiÃ©n podemos [**concatenar vectores**]{.hl-yellow}

```{r}
c(edades, edades, 8)
```

---

## Secuencias numÃ©ricas

En muchas ocasiones querremos crear [**secuencias numÃ©ricas**]{.hl-yellow} (por ejemplo, los dÃ­as del mes). El comando `seq(inicio, fin)` nos permite crear una **secuencia** desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.

```{r}
seq(1, 31)
```

. . .

El comando `1:n` nos devuelve lo mismo que `seq(1, n)` (si el elemento inicial es mayor que el final, entenderÃ¡ que la secuencia es [**decreciente**]{.hl-purple})

```{r}
1:5
7:-3
```

---

## Secuencias numÃ©ricas

TambiÃ©n podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

. . .

Otras veces nos interesarÃ¡ definir una [**secuencia con una longitud concreta**]{.hl-yellow}

```{r}
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```

. . .

Incluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}

```{r}
rep(0, 7) # vector de 7 ceros
```

---

## Vectores de caracteres

Un vector es una **concatenaciÃ³n** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente nÃºmeros. Vamos a crear una frase de ejemplo.

```{r}
frase <- "Me llamo Javi"
frase
length(frase)
```

. . .

En el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas

```{r}
vector <- c("Me", "llamo", "Javi")
vector
length(vector)
```

---

## Vectores de caracteres

Â¿QuÃ© sucederÃ¡ si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

FÃ­jate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}

. . .

```{r}
c(3, 4, TRUE, FALSE)
```

Es importante entender que los valores lÃ³gicos en realidad estÃ¡n [**almacenados internamente como 0/1**]{.hl-yellow}

---

## Operaciones con vectores

Con los vectores numÃ©ricos podemos hacer las mismas [**operaciones aritmÃ©ticas**]{.hl-yellow} que con los nÃºmeros â†’ un [**nÃºmero es un vector**]{.hl-purple} (de longitud uno)

. . .

Â¿QuÃ© sucederÃ¡ si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Cuidado

Salvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}
:::

---

## Operaciones con vectores

Los vectores tambiÃ©n pueden interactuar entre ellos, asÃ­ que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)

```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Dado que la operaciÃ³n (por ejemplo, una suma) se realiza elemento a elemento, Â¿quÃ© sucederÃ¡ si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?

. . .

```{r}
z <- c(1, 3, 5, 7)
x + z
```

Lo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que harÃ¡ serÃ¡ reciclar del vector con menor longitud.

---

## Operaciones con vectores

Una operaciÃ³n muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones lÃ³gicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...

[**Â¿QuÃ© dÃ­as hizo menos de 22 grados?**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

Nos devolverÃ¡ un [**vector lÃ³gico**]{.hl-yellow}, en funciÃ³n de si **cada elemento** cumple o no la condiciÃ³n pedida (de **igual longitud** que el vector preguntado)

. . .

Si tuviÃ©ramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese dÃ­a), la condiciÃ³n evaluada tambiÃ©n serÃ­a `NA`

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Operaciones con vectores

Las [**condiciones lÃ³gicas pueden ser combinadas**]{.hl-yellow} de dos maneras:

-   [**IntersecciÃ³n**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunciÃ³n y**]{.hl-purple} con `&`) para devolver un `TRUE`

```{r}
x < 30 & x > 15
```

-   [**UniÃ³n**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunciÃ³n o**]{.hl-purple} con `|`)

```{r}
x < 30 | x > 15
```

. . .

Con `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen

```{r}
any(x < 30)
all(x < 30)
```

---

## Operaciones con vectores

TambiÃ©n podemos hacer uso de [**operaciones estadÃ­sticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**Â¿QuÃ© sucede cuando falta un dato (ausente)?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

Por defecto, si tenemos un dato ausente, la [**operaciÃ³n tambiÃ©n serÃ¡ ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`

```{r}
sum(x, na.rm = TRUE)
```

---

## Operaciones con vectores

Como hemos comentado que los valores lÃ³gicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritmÃ©ticas.

Â 

Por ejemplo, si queremos [**averiguar el nÃºmero de elementos que cumplen una condiciÃ³n**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendrÃ¡n asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar dicho vector lÃ³gico para obtener el nÃºmero de elementos que cumplen

```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Operaciones con vectores

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

Â 

-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La mÃ¡s conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores atÃ­picos o outliers (valores muy grandes o muy pequeÃ±os), la media se perturba con mucha facilidad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Operaciones con vectores

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

Â 

-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Percentiles**]{.hl-yellow}: medidas de posiciÃ³n (nos dividen en partes iguales los datos).

```{r}
quantile(x) # por defecto percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

---

## Operaciones con vectores

Otra operaciÃ³n muy habitual es la de [**acceder a elementos**]{.hl-yellow} del mismo. La forma mÃ¡s sencilla es usar el operador `[i]` (acceder al elemento i-Ã©simo)

```{r}
edades <- c(20, 30, 33, NA, 61) 
edades[3] # accedemos a la edad de la tercera persona 
```

. . .

Â 

Dado que un nÃºmero no es mÃ¡s que un vector de longitud uno, esta operaciÃ³n tambiÃ©n la podemos aplicar usando un [**vector de Ã­ndices a seleccionar**]{.hl-yellow}

```{r}
y <- c("hola", "quÃ©", "tal", "estÃ¡s", "?")
y[c(1:2, 4)] # primer, segundo y cuarto elemento
```

::: callout-tip
Para acceder al Ãºltimo, sin preocuparnos de cuÃ¡l, podemos pasarle como Ã­ndice la longitud `x[length(x)]`
:::

---

## Operaciones con vectores

Otras veces no querremos seleccionar sino [**eliminar algunos elementos**]{.hl-yellow}. Deberemos repetir la misma operaciÃ³n pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-Ã©simo del vector sino que lo Â«des-seleccionaÂ»

```{r}
y
y[-2]
```

Â 

. . .

En muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones lÃ³gicas**]{.hl-yellow}, en funciÃ³n de los valores, asÃ­ que pasaremos como Ã­ndice la propia condiciÃ³n (recuerda, `x < 2` nos devuelve un vector lÃ³gico)

```{r}
edades <- c(15, 21, 30, 17, 45)
nombres <- c("javi", "marÃ­a", "laura", "carla", "luis")
nombres[edades < 18] # nombres de los menores de edad
```

---

## Operaciones con vectores

Por Ãºltimo, una acciÃ³n habitual es saber [**ordenar valores**]{.hl-yellow}:

-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(edades)
sort(edades, decreasing = TRUE)
```

. . .

-   `order()`: devuelve el [**vector de Ã­ndices**]{.hl-yellow} que tendrÃ­amos que usar para tener el vector ordenado

```{r}
order(x)
x[order(x)]
```

---

## ğŸ’» Tu turno {#tu-turno-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Define el vector `x` como la concatenaciÃ³n de los 5 primeros nÃºmeros impares, y calcula su suma.

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

sum(x)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ ObtÃ©n los elementos de `x` mayores que 4. Calcula el nÃºmero de elementos de `x` mayores que 4.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
sum(x > 4)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Calcula el vector `1/x` y obtÃ©n la versiÃ³n ordenada (de menor a mayor).

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Encuentra el mÃ¡ximo y el mÃ­nimo del vector `x`

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6. Elimina del vector el segundo elemento. Tras eliminarlo determina su suma y su media

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
y <- x[-2]
sum(y, na.rm = TRUE)
mean(y, na.rm = TRUE)
```
:::

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-2}

En el paquete `{datasets}` tenemos diversos conjuntos de datos y uno de ellos es `airquality`. Debajo te he extraÃ­do 3 variables de dicho dataset

```{r}
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

1. Â¿QuÃ© [**representan los datos**]{.hl-yellow}? Â¿CÃ³mo averiguarlo?

```{r}
#| code-fold: true
#| eval: false
? airquality
```

Haciendo uso de `? ...` podemos consultar en el panel de ayuda lo que significa el objeto.

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-2-2}

2. Â¿CuÃ¡ntos [**registros tenemos de mayo**]{.hl-yellow}? Â¿Y de abril? Construye una nueva variable `date` con la [**fecha**]{.hl-yellow} de cada registro (combinando aÃ±o, mes y dÃ­a)

```{r}
#| code-fold: true
# Una forma para registros de mayo
sum(month == 5)
# Otra forma
length(month[month == 5])

# Ã­dem en abril
sum(month == 4)

# variable date
dates <- lubridate::as_date(glue("{1973}-{month}-{day}"))
```

. . .

3. Crea una nueva variable `temp_celsius` con la [**temperatura en ÂºC**]{.hl-yellow}

```{r}
#| code-fold: true
# Temperatura en celsius
temp_celsius <- (temperature - 32) * (5/9)
```

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-2-3}

4. Â¿CuÃ¡l fue la [**media de temperatura**]{.hl-yellow} del mes de agosto? Extrae los dÃ­as en los que la [**temperatura superÃ³ los 30 grados**]{.hl-yellow} y calcula la cantidad de dÃ­as en los que lo hizo.

```{r}
#| code-fold: true
# media en agosto
mean(temperature[month == 8], na.rm = TRUE)
mean(temp_celsius[month == 8], na.rm = TRUE)

# Extremos dÃ­as > 30
dates[temp_celsius > 30]
length(dates[temp_celsius > 30]) # n dÃ­as
sum(temp_celsius > 30) # n dÃ­as (otra forma)
```

---


## Antes de seguir: microbenchmark

Hay un paquete muy Ãºtil para [**medir tiempos de distintas Ã³rdenes que hacen lo mismo**]{.hl-yellow} (el paquete `{microbenchmark}`) para intentar ser con nuestro cÃ³digo lo mÃ¡s eficientes posible. Vamos a comparar por ejemplo `order()` y `sort()`.

```{r}
library(microbenchmark) # instalar primera vez
x <- rnorm(2e3) # 2000 elementos aleatorias
microbenchmark(sort(x), x[order(x)], times = 5e2) # 500 veces
```

---

## Primer intento: matrices

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una Â«tablaÂ» que las recopile. La opciÃ³n mÃ¡s inmediata son las [**matrices**]{.hl-yellow}: concatenaciÃ³n de variables del [**mismo tipo e igual longitud**]{.hl-purple}.

. . .

Imagina que tenemos estaturas y pesos de 4 personas. Â¿CÃ³mo [**crear un dataset con las dos variables**]{.hl-yellow}?

-   Con `cbind()` [**concatenamos vectores en forma de columnas**]{.hl-yellow}

```{r}
estaturas <- c(150, 160, 170, 180)
pesos <- c(63, 70, 85, 95)
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

---

## Primer intento: matrices

-   TambiÃ©n podemos [**construir la matriz por filas**]{.hl-yellow} con la funciÃ³n `rbind()` (aunque lo recomendable es tener cada variable en columna e individuo en fila).

```{r}
# Construimos la matriz por filas
rbind(estaturas, pesos)
```

-   Podemos [**visualizar la matriz**]{.hl-yellow} con la funciÃ³n `View()`.

. . .

-   Podemos [**comprobar las dimensiones**]{.hl-yellow} con `dim()`, `nrow()` y `ncol()`: nuestros datos estÃ¡n tabulados:

```{r}
dim(datos_matriz)
nrow(datos_matriz)
```

---

## Primer intento: matrices

-   TambiÃ©n podemos [**Â«darle vueltaÂ» (matriz transpuesta)**]{.hl-yellow} con `t()`.

```{r}
t(datos_matriz)
```

. . .

-   Dado que ahora tenemos dos dimensiones, para [**acceder a elementos**]{.hl-yellow} deberemos proporcionar el Ã­ndice de la fila y de la columna (si quedan libres implica todos de esa dimensiÃ³n)

```{r}
datos_matriz[2, 1]
datos_matriz[, 2]
```

---

## Primer intento: matrices

-   TambiÃ©n podemos definir una [**matriz a partir de un vector numÃ©rico**]{.hl-yellow}, reorganizando los valores en forma de matriz (sabiendo que los elementos se van **colocando por columnas**).

```{r}
z <- matrix(1:15, ncol = 5) 
z
```

. . .

Con las matrices sucede como con los vectores: cuando aplicamos una [**operaciÃ³n aritmÃ©tica lo hacemos elemento a elemento**]{.hl-yellow}

```{r}
z/5
```

---

## Primer intento: matrices

TambiÃ©n podemos [**realizar operaciones por columnas/filas**]{.hl-yellow} sin recurrir a bucles con la funciÃ³n `apply()`, y le indicaremos como **argumentos**

-   la matriz
-   el sentido de la operaciÃ³n (MARGIN = 1 por filas, MARGIN = 2 por columnas)
-   la funciÃ³n a aplicar

. . .

```{r}
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")

# (Cuasi)varianza (var) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "var")
```

. . .

[**No profundizaremos**]{.hl-red} mÃ¡s ya que nuestro objetivo es tener variables de misma longitud pero [**tipos diferentes**]{.hl-yellow} (pero que sepas que existen).

---

## ğŸ’» Tu turno (matrices) {#tu-turno-matrices}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo para definir una matriz `x` de ceros de 3 filas y 7 columnas de unos.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ A la matriz anterior, suma un 1 a cada nÃºmero de la matriz y divide el resultado entre 5. Tras ello calcula su transpuesta y obtÃ©n sus dimensiones

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
dim(new_matrix)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Define la matriz `x <- matrix(1:12, nrow = 4)`. ObtÃ©n la primera fila, la tercera columna, y el elemento (4, 1).

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # primera fila
x[, 3] # tercera columna
x[4, 1] # elemento (4, 1)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Con la matriz anterior definida como `x <- matrix(1:12, nrow = 4)`, calcula la media de todos los elementos, la media de cada fila y la media de cada columna. Calcula la suma de de cada fila y de cada columna

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
mean(x) # de todos
apply(x, MARGIN = 1, FUN = "mean") # media por filas
apply(x, MARGIN = 2, FUN = "mean") # media por columnas
apply(x, MARGIN = 1, FUN = "sum") # suma por filas
apply(x, MARGIN = 2, FUN = "sum") # suma por columnas

```

:::

---

## Segundo intento: data.frame

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte

```{r}
#| code-line-numbers: "4-5"
edades <- c(34, 24, NA)
soltero <- c(FALSE, NA, TRUE)
nombres <- c("javi", "carlos", "lucÃ­a")
matriz <- cbind(edades, soltero, nombres)
matriz
```

. . .

Al ya no ser nÃºmeros no podemos realizar operaciones aritmÃ©ticas

```{r}
#| error: true
matriz + 1
```

---

## Segundo intento: data.frame

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos lo que se conoce como [**data.frame**]{.hl-yellow}: concatenaciÃ³n de variables de igual longitud pero pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
#| code-line-numbers: "1"
tabla <- data.frame(edades, soltero, nombres)
class(tabla)
tabla
```

---

## Segundo intento: data.frame

Dado que un `data.frame` es ya una Â«base de datosÂ» las variables no son meros vectores matemÃ¡ticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple}

```{r}
library(lubridate)
tabla <- data.frame("edad" = edades, "estado" = soltero, "nombre" = nombres,
             "f_nacimiento" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
tabla
```

---

## Segundo intento: data.frame

[**Â¡TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

![](img/view_tabla.jpg)

---

## Segundo intento: data.frame

Si queremos acceder a sus elementos, podemos como en las matrices (aunque no es recomendable): ahora [**tenemos dos Ã­ndices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera caracterÃ­stica de la segunda persona
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
TambiÃ©n tiene ventajas de una [**Â«baseÂ» de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} (**recomendable** ya que las variables pueden cambiar de posiciÃ³n), poniendo el nombre de la tabla seguido del sÃ­mbolo `$` (con el **tabulador**, nos aparecerÃ¡ un menÃº de columnas a elegir)
:::
:::

---

## Segundo intento: data.frame

-   `names()`: nos muestra los nombres de las variables

```{r}
names(tabla)
```

. . .

-   `dim()`: nos muestra las dimensiones (tambiÃ©n `nrow()` y `ncol()`)

```{r}
dim(tabla)
```

. . .

-   Podemos acceder a las variables por su nombre

```{r}
tabla[c(1, 3), "nombre"]
```

---

## Segundo intento: data.frame

Si tenemos uno ya creado y queremos [**aÃ±adir una columna**]{.hl-yellow} es tan simple como usar la funciÃ³n `data.frame()` que ya hemos visto para concatenar la columna. Vamos aÃ±adir por ejemplo una nueva variable, el nÃºmero de hermanos de cada individuo.

```{r}
# AÃ±adimos una nueva columna con nÂº de hermanos/as
hermanos <- c(0, 2, 3)
tabla <- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

# Clase 3: primeras bases de datos. R base vs Tidyverse {#clase-3-primeras-bases-de-datos}

[**Nuestra base de datos: tibble. Tidydata: un multiverso de datos limpios**]{style="color:#444442;"}

---

## Intento final: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}

La principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```

. . .

Â 

De ahora en adelante usaremos el formato `tibble` (un [**data.frame mejorado**]{.hl-yellow})

```{r}
library(tibble)
tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
       "IMC" = peso / (estatura^2))
```

---

## Intento final: tibble

```{r}
tabla <- tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
                "IMC" = peso / (estatura^2))
tabla
```

Las tablas en formato `tibble` nos permitirÃ¡ una [**gestiÃ³n mÃ¡s Ã¡gil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

-   [**MetainformaciÃ³n**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya automÃ¡ticamente el nÃºmero de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

---

## Intento final: tibble

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
tabla$invent
```

. . .

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de pÃ¡ginas web y documentos sencillos
:::


---

## ğŸ’» Tu turno (tibble) {#tu-turno-tibble}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Carga del paquete `{datasets}` el conjunto de datos `airquality` (variables de la calidad del aire de Nueva York desde mayo hasta septiembre de 1973). Â¿Es el conjunto de datos airquality de tipo tibble? En caso negativo, conviÃ©rtelo a tibble (busca en la documentaciÃ³n del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Una vez convertido a `tibble` obtÃ©n el nombre de las variables y las dimensiones del conjunto de datos. Â¿CuÃ¡ntas variables hay? Â¿CuÃ¡ntos dÃ­as se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Filtra solo los datos del mes de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, ]
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Selecciona aquellos datos que no sean ni de julio ni de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[!(airquality_tb$Month %in% c(7, 8)), ]
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Modifica el siguiente cÃ³digo para quedarte solo con las variable de ozono y temperatura.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[, c("Ozone", "Temp")]
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Selecciona los datos de temperatura y viento de agosto. Traduce a castellano el nombre de las columnas del conjunto filtrado.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, c("Temp", "Wind")]
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```
:::

---

## Resumen hasta ahora

-   Cada [**celda puede ser de un tipo diverso**]{.hl-yellow}: nÃºmeros, texto, fechas, valores lÃ³gicos, etc

. . .

-   Un [**vector es una concatenaciÃ³n de celdas**]{.hl-yellow} (las futuras columnas de nuestras tablas) --\> En `R` por defecto las operaciones se hacen [**elemento a elemento**]{.hl-yellow}

. . .

-   Una [**matriz**]{.hl-yellow} nos permite concatenar [**variables del MISMO tipo y MISMA longitud**]{.hl-yellow} --\> objeto bidimensional (dos Ã­ndices)

. . .

-   Un [**data.frame**]{.hl-yellow} nos permite concatenar [**variables de DISTINTO tipo y MISMA longitud**]{.hl-yellow} --\> usaremos [**tibble**]{.hl-yellow} como una opciÃ³n mejorada de base de datos

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-3a}

Del paquete `Biostatistics` usaremos el conunto de datos `pinniped`

```{r}
#| eval: false
Biostatistics::pinniped
```


1. Â¿QuÃ© [**representan**]{.hl-yellow} los datos? Â¿QuÃ© [**tipo de dato**]{.hl-yellow} es? En caso de que no lo sea, convierte la base de datos a un `tibble` (renombra con `pinniped_tb`)

```{r}
#| code-fold: true
#| eval: false
? Biostatistics::pinniped
```

```{r}
#| code-fold: true
class(Biostatistics::pinniped) # no es un tibble
pinniped_tb <- as_tibble(Biostatistics::pinniped)
```

. . .

2. Â¿CuÃ¡ntos registros hay? Â¿Y variables? Â¿De quÃ© tipo es cada una?


```{r}
#| code-fold: true
nrow(pinniped_tb)
ncol(pinniped_tb)
```


---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-3a-2}


3. Incorpora una [**variable extra llamada phoca**]{.hl-yellow} que sea de tipo lÃ³gico y que nos diga si una especie es de la categorÃ­a `Phoca` o no.

```{r}
#| code-fold: true
pinniped_tb$phoca <- pinniped_tb$Species == "Phoca"
```

. . .

4. Â¿A quÃ© sexo le [**pesa mÃ¡s el cerebro**]{.hl-yellow}: a las hembras o a los machos? Â¿A quienes les [**pesa mÃ¡s el cuerpo**]{.hl-yellow}: a los monÃ³gamos o a los polÃ­gamos?

```{r}
#| code-fold: true
# Â¿a quiÃ©n le pesa mÃ¡s el cerebro?
mean(pinniped_tb$Male_brain_g, na.rm = TRUE) >
  mean(pinniped_tb$Female_brain_g, na.rm = TRUE)

# Â¿a quiÃ©n le pesa mÃ¡s el cerebro?
mean(c(pinniped_tb$Male_mass_Kg[pinniped_tb$Mate_type == "mono"],
       pinniped_tb$Female_mass_Kg[pinniped_tb$Mate_type == "mono"])) >
  mean(c(pinniped_tb$Male_mass_Kg[pinniped_tb$Mate_type == "poly"],
         pinniped_tb$Female_mass_Kg[pinniped_tb$Mate_type == "poly"]))
```

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-3a-3}


5. Incopora una nueva variable que represente la [**diferencia entre el peso del cerebro entre machos y hembras**]{.hl-yellow} (machos - hembras) para cada especie.

```{r}
#| code-fold: true
pinniped_tb$dif_m_f <- pinniped_tb$Male_brain_g - pinniped_tb$Female_brain_g
pinniped_tb
```

---

## R base vs Tidyverse

Si conoces algÃºn otro lenguaje de programaciÃ³n (o tienes gente cercana que programa) te extraÃ±arÃ¡ que aÃºn no hayamos hablado de conceptos habituales como

-   [**Bucles for**]{.hl-yellow}: repetir un cÃ³digo un nÃºmero fijo de iteraciones.

-   [**Bucles while**]{.hl-yellow}: repetir un cÃ³digo hasta que se cumpla una condiciÃ³n

-   [**Estructuras if-else**]{.hl-yellow}: estructuras de control para decidir por donde camina el cÃ³digo en funciÃ³n del valor de las variables.

. . .

Y aunque conocer dichas estructuras puede sernos en algÃºn momento interesante, en la [**mayorÃ­a de ocasiones vamos a poder evitarlas**]{.hl-red} (en especial los bucles)

---

## Â¿QuÃ© es tidyverse?

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

`{tidyverse}` es un [**Â«universoÂ» de paquetes**]{.hl-yellow} para garanatizar un flujo de trabajo (de inicio a fin) eficiente, coherente y lexicogrÃ¡ficamente sencillo de entender, basado en la idea de que [**nuestros datos estÃ¡n limpios y ordenados (tidy)**]{.hl-purple}

---

## Â¿QuÃ© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: optimizando data.frame
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: gramÃ¡tica para depurar
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualizaciÃ³n de datos
-   `{tidymodels}`: modelizaciÃ³n/predicciÃ³n
:::
:::

TambiÃ©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.

---

## Â¿QuÃ© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: gramÃ¡tica para depurar
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualizaciÃ³n de datos
-   `{tidymodels}`: modelizaciÃ³n/predicciÃ³n
:::
:::

TambiÃ©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.

---

## FilosofÃ­a base: tidy data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

El [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducido por **Hadley Wickham** (el Dios al que rezo) de [**estandarizar**]{.hl-yellow} el formato los datos para

::: incremental
-   [**sistematizar**]{.hl-green} la depuraciÃ³n
-   hacer mÃ¡s [**sencillo**]{.hl-green} su manipulaciÃ³n.
-   cÃ³digo [**legible**]{.hl-green}
:::

---

## Reglas del tidy data

Lo primero por tanto serÃ¡ entender quÃ© son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos estÃ¡n estandarizados.

::: columns
::: {.column width="50%"}
::: {.fragment .fade-in}
1.  Cada [**variable**]{.hl-yellow} en una [**Ãºnica columna**]{.hl-purple}
:::

::: {.fragment .fade-in}
2.  Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}
:::

::: {.fragment .fade-in}
3.  Cada [**celda**]{.hl-yellow} con un [**Ãºnico valor**]{.hl-purple}
:::

::: {.fragment .fade-in}
4.  Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5.  Si queremos cruzar [**mÃºltiples tablas**]{.hl-yellow} debemos tener una [**columna comÃºn**]{.hl-purple}
:::
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
:::

---

## TuberÃ­a (pipe)

En `{tidyverse}` serÃ¡ clave el [**operador pipe (tuberÃ­a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): serÃ¡ una [**tuberÃ­a que recorre los datos**]{.hl-yellow} y los transforma.

. . .

::: columns
::: {.column width="50%"}
En R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, serÃ­a

```{r}
#| eval: false
third(second(first(datos)))
```
:::

::: {.column width="50%"}
En `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones

```{r}
#| eval: false
datos |> first() |> second() |> third()
```
:::
:::

Â 

. . .

::: callout-caution
## Apunte importante

Desde la versiÃ³n 4.1.0 de `R` disponemos de `|>`, un pipe **nativo** disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `|>` que dependÃ­a del paquete `{magrittr}` (bastante problemÃ¡tico).
:::

---

## TuberÃ­a (pipe)

La principal ventaja es que el [**cÃ³digo sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas cÃ³digo.

Â 

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::

::: {.column width="50%"}
<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
:::

---

## Datos SUCIOS: messy data

Â¿Pero quÃ© aspecto tienen los [**datos no tidy**]{.hl-yellow}? Vamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).

Â 

```{r}
library(tidyr)
table4a
```

Â 

[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="40%"}
```{r}
table4a
```
:::

::: {.column width="60%"}
â Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) â†’ las columnas `1999` y `2000` en realidad deberÃ­an ser en sÃ­ [**valores de una variable**]{.hl-yellow} y no nombres de columnas.
:::
:::

. . .

Incluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el aÃ±o y otra que guarde el valor de la variable de interÃ©s en cada uno de esos aÃ±os. Y lo haremos con la funciÃ³n `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="50%"}
```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
               values_to = "cases")
```
:::

::: {.column width="50%"}
![](img/table4a.jpg)
:::
:::

Â 

-   `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}
-   `names_to`: nombre de la nueva variable a la quemandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).
-   `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table2`

Â 

```{r}
table2
```

Â 

[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_wider()

::: columns
::: {.column width="60%"}
```{r}
#| echo: false
table2
```
:::

::: {.column width="40%"}
â Cada [**observaciÃ³n estÃ¡ dividido en dos filas**]{.hl-red} â†’ los [**registros con el mismo aÃ±o deberÃ­an ser el mismo**]{.hl-yellow}
:::
:::

. . .

Lo que haremos serÃ¡ lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table3`


```{r}
table3
```


[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Separar: separate()

::: columns
::: {.column width="60%"}
```{r}
table3
```
:::

::: {.column width="40%"}
â Cada [**celda contiene varios valores**]{.hl-red}
:::
:::

. . .

Lo que haremos serÃ¡ hacer uso de la funciÃ³n `separate()` para mandar [**separar cada valor**]{.hl-yellow} a una columna diferente.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

---

## Separar: separate()

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

FÃ­jate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deberÃ­an ser variables numÃ©ricas. Para ello podemos aÃ±adir el argumento opcional `convert = TRUE`

. . .

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

---

## Datos SUCIOS: messy data

Veamos el Ãºltimo ejemplo con la tabla `table5`


```{r}
table5
```


[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Unir unite()

::: columns
::: {.column width="50%"}
```{r}
table5
```
:::

::: {.column width="50%"}
â Tenemos [**mismos valores divididos en dos columnas**]{.hl-red}
:::
:::

. . .

Usaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y aÃ±o en una misma columna

```{r}
table5 |> unite(col = year_completo, century, year, sep = "")
```

---

## ğŸ’» Tu turno {#tu-turno-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. Â¿Es tidydata? En caso negativo, Â¿quÃ© falla? Â¿CÃ³mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Echa un vistazo a la tabla `relig_income` del paquete `{tidyr}`. Â¿Es tidydata? En caso negativo, Â¿quÃ© falla? Â¿CÃ³mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused",
               names_to = "income",
               values_to = "people")
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. Â¿Es tidydata? En caso negativo, Â¿quÃ© falla? Â¿CÃ³mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```

:::

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-3b}

En el paquete `{tidyr}` contamos con el dataset `who` (dataset de la OrganizaciÃ³n Mundial de la Salud)

```{r}
#| eval: false
library(tidyr)
who
```


1. Â¿QuÃ© [**significan los datos**]{.hl-yellow}? Â¿CuÃ¡ntas [**variables y observaciones**]{.hl-yellow} tenemos?

```{r}
#| code-fold: true
# ? who
nrow(who)
ncol(who)
```


2. Â¿CuÃ¡ntos [**tipos de variables**]{.hl-yellow} tenemos?

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-3b-1}

3. Â¿Todas las variables son necesarias? [**Elimina la informaciÃ³n redundante**]{.hl-yellow}.

```{r}
#| code-fold: true
who$iso2 <- NULL
```

Solo necesitamos uno de los cÃ³digos ISO

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-3b-2}

4. [**Convierte a tidydata**]{.hl-yellow} la base de datos realizando todas las opciones que consideres (consejo: usa papel y boli para bocetar como deberÃ­a quedar la base de datos).

Todos empiezan por `new_` (y no hay otro tipo) asÃ­ que le indicamos al pivotar que los nombres tienen un prefijo a quitar. AdemÃ¡s separamos ya entre tipo y sexo-edad (separados por _) y eliminamos ausentes. Tras ello separamos sexo de edad

```{r}
#| code-fold: true
who |>
  pivot_longer(cols = "new_sp_m014":"newrel_f65",
               names_to = c("type", "sex-age"),
               values_to = "cases",
               names_prefix = "new_",
               names_sep = "_",
               values_drop_na = TRUE) |> 
  separate(col = "sex-age", into = c("sex", "age"),
           sep = 1)
```

# Clase 4: import/export, comunicar

[**Importar/exportar datos en R. Comunicar resultados: rmd y Quarto**]{style="color:#444442;"}

---

## Comunicar: rmd y Quarto

Una de las [**principales fortalezas**]{.hl-yellow} de `R` es la [**facilidad para generar informes, libros, webs, apuntes y hasta diapositivas**]{.hl-yellow} (este mismo material por ejemplo). Para ello [**instalaremos**]{.hl-purple} antes

::: columns
::: {.column width="40%"}
-   el paquete `{rmarkdown}` (para generar archivos `.rmd`)

```{r}
#| eval: false
install.packages("rmarkdown")
```

-   instalar [**Quarto**](https://quarto.org/docs/get-started/) (el Â«nuevoÂ» `.rmd` ahora como `.qmd`)
:::

::: {.column width="60%"}
![](img/quarto.png)
:::
:::

---

## Comunicar: rmd y Quarto

Hasta ahora solo hemos programado en scripts (archivos `.R`) dentro de proyectos, pero en muchas ocasiones [**no trabajaremos solos**]{.hl-yellow} y necesitaremos [**comunicar los resultados**]{.hl-yellow} en diferentes formatos:

-   apuntes (para nosotros mismos)
-   diapositivas
-   web
-   informes

. . .
 
Para todo ello usaremos [**Quarto (nuevo rmarkdown)**]{.hl-yellow}


---

## Comunicar: rmd y Quarto

Los archivos de extensiÃ³n `.qmd` (o `.rmd`) nos permitirÃ¡n fÃ¡cilmente combinar:

-   [**Markdown**]{.hl-yellow}: [**lenguaje tipado**]{.hl-purple} que nos permite crear contenido simple (tipo wordpress, con texto, **negritas**, _cursivas_, etc) con un diseÃ±o legible.

. . .

-   [**MatemÃ¡ticas (latex)**]{.hl-yellow}: lenguaje para escribir notaciÃ³n matemÃ¡tica como $x^2$ o $\sqrt{y}$ o $\int_{a}^{b} f(x) dx$

. . .

-   [**CÃ³digo y salidas**]{.hl-yellow}: podremos no solo mostrar el paso final sino el cÃ³digo que has ido realizando (no solo en `R`), con [**cajitas de cÃ³digo llamadas chunks**]{.hl-purple}.

. . .

-   ImÃ¡genes, [**grÃ¡ficas**]{.hl-yellow}, tablas, estilos (css, js), etc.

---

## Comunicar: rmd y Quarto

La principal ventaja de realizar este tipo de material en Quarto/Rmarkdown es que, al hacerlo desde `RStudio`, puedes generar un [**informe o una presentaciÃ³n sin salirte del entorno de programaciÃ³n**]{.hl-yellow} en el que estÃ¡s trabajando

De esta forma podrÃ¡s analizar los datos, resumirlos y a la vez comunicarlos con la misma herramienta.

. . .

Recientemente el equipo de `RStudio` desarrollÃ³ [**Quarto**]{.hl-yellow}, una versiÃ³n mejorada de Rmarkdown (archivos `.qmd`), con un formato un poco mÃ¡s estÃ©tico y simple. Tienes toda la documentaciÃ³n y ejemplos en [**https://quarto.org/**](https://quarto.org/)

---

## Nuestro primer informe

::: columns
::: {.column width="55%"}
![](img/quarto-create.png)
:::

::: {.column width="45%"}
Vamos a crear el [**primer fichero rmarkdown con Quarto**]{.hl-yellow} con extensiÃ³n `.qmd`. Para ello solo necesitaremos hacer click en

`File << New File << Quarto Document`
:::
:::

---

## Nuestro primer informe

:::: columns
::: {.column width="45%"}
![](img/quarto-format.png)
:::

::: {.column width="55%"}
Tras hacerlo nos aparecerÃ¡n varias [**opciones de formatos de salida**]{.hl-yellow}:

-   archivo `.pdf`
-   archivo `.html` ([**recomendable**]{.hl-yellow}): documento dinÃ¡mico, permite la interacciÃ³n con el usuario, como una Â«pÃ¡gina webÂ».
-   archivo `.doc` (nada recomendable)
:::
::::

. . .

De momento dejaremos marcado el [**formato HTML que viene por defecto**]{.hl-yellow}, y escribiremos el [**tÃ­tulo**]{.hl-yellow} de nuestro documento. Tras ello tendremos nuestro [**archivo .qmd**]{.hl-yellow} (ya no es un script .R como los que hemos abierto hasta ahora).

---

## Nuestro primer informe

:::: columns
::: {.column width="60%"}
![](img/quarto-example.png)
:::

::: {.column width="40%"}

DeberÃ­as tener algo similar a la captura de la imagen con [**dos modos de ediciÃ³n**]{.hl-yellow}: `Source` (con cÃ³digo, la opciÃ³n recomendada hasta que lo domines) y `Visual` (mÃ¡s parecido a un blog)

:::
::::

Para [**ejecutar TODO el documento**]{.hl-yellow} debes clickar `Render on Save` y darle a guardar.

## Cabecera de un qmd

![](img/quarto-prueba-html.png)

DeberÃ­as haber obtenido una [**salida en html similar a esta**]{.hl-yellow} (y se te ha generado en tu ordenador un [**archivo html**]{.hl-yellow})

---

## Nuestro primer informe

:::: columns
::: {.column width="50%"}
![](img/quarto-example.png)

:::

::: {.column width="50%"}

Un fichero `.qmd` se [**divide bÃ¡sicamente en tres partes**]{.hl-yellow}:

* [**Cabecera**]{.hl-yellow}: la parte que tienes al inicio entre `---`.

* [**Texto**]{.hl-yellow}: que podremos formatear y mejorar con negritas (escrito como **negritas**, con doble astÃ©risco al inicio y final), cursivas (_cursivas_, con barra baja al inicio y final) o destacar nombres de funciones o variables de R. Puedes aÃ±adir ecuaciones como $x^2$ (he escrito `$x^2$`, entre dÃ³lares).

* [**CÃ³digo R**]{.hl-yellow}

:::
::::

---

## Cabecera de un qmd

La [**cabecera estÃ¡n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento:

:::: columns
::: {.column width="30%"}
![](img/quarto-cabecera.png)
:::

::: {.column width="70%"}

* `title` y `subtitle`: el tÃ­tulo/subtÃ­tulo del documento
* `author`: autor del mismo
* `date`: fecha
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes algÃºn archivo de estilos
  * `toc`: si quieres Ã­ndice o no
  * `toc-location`: posiciÃ³n del Ã­ndice
  * `toc-title`: tÃ­tulo del Ã­ndice
  * `toc-depth`: profundidad del Ã­ndice
* `editor`: si estÃ¡s en modo visual o source.

:::
::::

---

## Texto de un qmd

Respecto a la escritura solo hay una [**cosa importante**]{.hl-yellow}: salvo que indiquemos lo contrario, [**TODO lo que vamos a escribir es texto (normal)**]{.hl-yellow}. No cÃ³digo R.

:::: columns
::: {.column width="35%"}
![](img/quarto-prueba-qmd2.png){width=350}
![](img/quarto-prueba-html2.png){width=320}
:::

::: {.column width="65%"}
Vamos a empezar escribiendo una secciÃ³n al inicio (`# Intro` y detrÃ¡s por ej. la frase

> Este material ha sido diseÃ±ado por el profesor Javier Ãlvarez LiÃ©bana, docente en la Universidad Complutense de Madrid

AdemÃ¡s al `Running Code` le aÃ±adiremos una almohadilla `#`: las [**almohadillas FUERA DE CHUNKS**]{.hl-yellow} nos servirÃ¡n para crear [**epÃ­grafes (secciones)**]{.hl-yellow} en el documento


:::
::::


---

## Ãndice de un qmd

:::: columns
::: {.column width="40%"}
![](img/quarto-indice-qmd-2.png){width=370}
![](img/quarto-indice-html2.png){width=370}
:::

::: {.column width="60%"}
Para que el [**Ã­ndice capture dichas secciones**]{.hl-yellow} modificaremos la cabecera del archivo como se observa en la imagen (puedes cambiar la localizaciÃ³n del Ã­ndice y el tÃ­tulo si quieres para probar).

:::
::::

---

## Texto en un qmd

Vamos a [**personalizar un poco el texto**]{.hl-yellow} haciendo lo siguiente:


:::: columns
::: {.column width="50%"}
![](img/quarto-texto-mejorado-qmd.png){width=370}
![](img/quarto-texto-mejorado-html.png){width=370}
:::

::: {.column width="50%"}
* Vamos a aÃ±adir [**negrita al nombre**]{.hl-yellow} (poniendo ** al inicio y al final).

* Vamos aÃ±adir [**cursiva**]{.hl-yellow} a la palabra material (poniendo _ al inicio y al final).

* Vamos aÃ±adir un [**enlace**]{.hl-yellow} <https://www.ucm.es>, asociÃ¡ndolo al nombre de la Universidad. Para ello el tÃ­tulo lo ponemos entre corchetes y justo detrÃ¡s el enlace entre parÃ©ntesis `[Â«Universidad Complutense de MadridÂ»](https://www.ucm.es)`

:::
::::

---

## CÃ³digo en un qmd

Para [**aÃ±adir cÃ³digo R**]{.hl-yellow} debemos crear nuestras [**cajas de cÃ³digo llamadas chunks**]{.hl-yellow}: altos en el camino en nuestro texto markdown donde podremos incluir cÃ³digo de casi cualquier lenguaje (y sus salidas).

&nbsp;

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-qmd.png){width=470}
:::

::: {.column width="50%"}

Para incluir uno deberÃ¡ de ir [**encabezado**]{.hl-yellow} de la siguiente forma tienes un atajo `Command + Option + I` (Mac) o `Ctrl + Shift + I` (Windows)
:::

::::

---

## CÃ³digo en un qmd

Dentro de dicha cajita (que tiene ahora otro color en el documento) [**escribiremos cÃ³digo R**]{.hl-yellow} como lo venÃ­amos haciendo hasta ahora en los scripts.

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-1-qmd.png){width=410}
![](img/quarto-chunk-1-html.png){width=410}
:::

::: {.column width="50%"}

 Vamos por ejemplo a definir dos variables y su suma de la siguiente manera, escribiendo dicho cÃ³digo en nuestro `.qmd` (dentro de ese chunk)

```{r}
# CÃ³digo R
x <- 1
y <- 2
x + y
```

:::

::::


---

## Etiquetando chunks


:::: columns
::: {.column width="50%"}
![](img/quarto-tag-chunks-qmd.png){width=400}
![](img/quarto-tag-chunks-html.png){width=400}
:::

::: {.column width="50%"}
Los chunks pueden tener un [**nombre o etiqueta**]{.hl-yellow}, de forma que podamos referenciarlos de nuevo para no repetir cÃ³digo.
:::
::::


---

## Ejecutando chunks

:::: columns
::: {.column width="40%"}
![](img/quarto-inline-qmd.png){width=400}
![](img/quarto-inline-html.png){width=380}
:::

::: {.column width="60%"}
En cada chunk aparecen [**dos botones**]{.hl-yellow}:

* botÃ³n de [**play**]{.hl-yellow}: activa la [**ejecuciÃ³n y salida de ese chunk particular**]{.hl-yellow} (lo puedes visualizar dentro de tu propio `RStudio`)

* botÃ³n de [**rebobinar**]{.hl-yellow}: activa la [**ejecuciÃ³n y salida de todos los chunk hasta ese**]{.hl-yellow} (sin llegar a Ã©l)

&nbsp;

AdemÃ¡s podemos [**incluir cÃ³digo R dentro de la lÃ­nea de texto**]{.hl-yellow} (en lugar de mostrar el texto x ejecuta el cÃ³digo R mostrando la variable).
:::
::::



---

## PersonalizaciÃ³n de chunks

Los [**chunks podemos personalizarlos**]{.hl-yellow} con opciones al inicio del chunk precedido de `#|`:

* `#| echo: false`: [**ejecuta cÃ³digo**]{.hl-green} y se [**muestra resultado**]{.hl-green} pero [**no visualiza cÃ³digo**]{.hl-red} en la salida.

* `#| include: false`: [**ejecuta cÃ³digo**]{.hl-green} pero [**no muestra resultado**]{.hl-red} y [**no visualiza cÃ³digo**]{.hl-red} en la salida.

* `#| eval: false`: [**no ejecuta cÃ³digo**]{.hl-red}, [**no muestra resultado**]{.hl-red} pero [**sÃ­ visualiza cÃ³digo**]{.hl-green} en la salida.

* `#| message: false`: [**ejecuta cÃ³digo**]{.hl-green} pero [**no muestra mensajes de salida**]{.hl-red}.

* `#| warning: false`: [**ejecuta cÃ³digo**]{.hl-green} pero [**no muestra mensajes de warning**]{.hl-red}.

* `#| error: true`: [**ejecuta cÃ³digo**]{.hl-green} y [**permite que haya errores**]{.hl-green} mostrando el mensaje de error en la salida.


![](img/quarto-options-chunk.png){width=380}

Estas opciones podemos aplicarlas chunk a chunk o fijar los parÃ¡metros de forma global con `knitr::opts_chunk$set()` al inicio del documento (dentro de un chunk).

---

## Organizando qmd

AdemÃ¡s de texto y cÃ³digo podemos introducir lo siguiente:

* [**Ecuaciones**]{.hl-yellow}: puedes aÃ±adir ademÃ¡s ecuaciones como $x^2$ (he escrito `$x^2$`, la ecuaciÃ³n entre dÃ³lares).

* [**Listas**]{.hl-yellow}: puedes itemizar elementos poniendo `*`

`* Paso 1: ...`

`* Paso 2: ...`

* [**Cross-references**]{.hl-yellow}: puedes etiquetar partes del documento (la etiqueta se construye con `{#nombre-seccion}`) y llamarlas luego con `[SecciÃ³n](@nombre-seccion)`

---

## GrÃ¡ficas/imÃ¡genes en qmd

:::: columns
::: {.column width="50%"}
![](img/quarto-fig-qmd.png){width=340}
![](img/quarto-fig-html.png){width=390}
:::

::: {.column width="50%"}
Por Ãºltimo, tambiÃ©n podemos [**aÃ±adir pies de grÃ¡ficas o imÃ¡genes**]{.hl-yellow} aÃ±adiendo `#| fig-cap: "..."`
:::
::::

. . .

:::: columns
::: {.column width="65%"}
FÃ­jate que el [**caption estÃ¡ en el margen**]{.hl-yellow} (por ejemplo). Puedes cambiarlo introduciendo [**ajustes en la cabecera**]{.hl-yellow} (todo lo relativo a figuras empieza por `fig-`, y puedes ver las opciones tabulando). Tienes mÃ¡s informaciÃ³n en **<https://quarto.org/>**
:::

::: {.column width="35%"}
![](img/quarto-cabecera-desplegable.png){width=400}
:::
::::

---

## AÃ±adir estilos

:::: columns
::: {.column width="50%"}
![](img/quarto-estilos-qmd.png){width=400}
![](img/quarto-estilos-html.png){width=400}
:::

::: {.column width="50%"}
Por Ãºltimo puedes aÃ±adir un [**tema personalizado**]{.hl-yellow} incluyendo un [**archivo de estilos**]{.hl-yellow} (archivo en formato `.scss` o `.css`). Te he dejado uno en <https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material>.

::: callout-important
## Importante

El archivo de estilos debe estar en la misma carpeta que el archivo `.qmd`
:::
:::
::::

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-4a}

Elabora 3 informes `.qmd` tal que


* Crea un archivo por cada uno de los [**3 casos prÃ¡cticos de los anteriores temas**]{.hl-yellow}, uno por tema

. . .

* En cada uno de ellos haz [**una secciÃ³n por ejercicio**]{.hl-yellow}

. . .

* [**Detalla todos los pasos**]{.hl-yellow} que consideres mezclando texto, cÃ³digo y salidas

. . .

* Si aparecen medidas estadÃ­sticas como la media, [**prueba a meter fÃ³rmulas**]{.hl-yellow} con `$$` (busca informaciÃ³n de cÃ³mo introducir ecuaciones en latex)

. . .

* Para avanzados: investiga las opciones del paquete `{DT}` (con la funciÃ³n `datatable()`) que nos permite [**introducir dentro de los `.qmd` los datos en formato de tabla dinÃ¡mica**]{.hl-yellow}, permitiendo ordenar y filtrar.


---


## Importar/exportar datos

Hasta ahora solo hemos usado datos cargados ya en paquetes pero muchas veces [**necesitaremos importar datos de manera externa**]{.hl-yellow}. Una de las principales [**fortalezas**]{.hl-yellow} de `R` es que podemos importar datos de manera muy sencilla en distintos formatos:


* [**Formatos nativos de R**]{.hl-yellow}: formatos `.rda`, `.RData` y `.rds`

* [**Datos rectangulares (tabulados)**]{.hl-yellow}: formatos `.csv` y `.tsv`

* [**Datos sin tabular**]{.hl-yellow}: formato `.txt`

* [**Datos en excel**]{.hl-yellow}: formatos `.xls` y `.xlsx`

* [**Datos desde SAS/Stata/SPSS**]{.hl-yellow}: formatos `.sas7bdat`, `.sav` y `.dat`

* [**Datos Google Drive**]{.hl-yellow}

* [**Datos desde API**]{.hl-yellow}: aemet, catastro, twitter, spotify, etc


---

## Formatos nativos de R

Los [**ficheros mÃ¡s simples**]{.hl-yellow} para importar en `R` (y que suele ocupar menos espacio en disco) son sus propias [**extensiones nativas**]{.hl-yellow}: archivos con formatos `.RData`, `.rda` y `.rds`. Para cargar los primeros simplemente necesitamos [**usar la funciÃ³n nativa**]{.hl-yellow} `load()` indicÃ¡ndole la ruta del archivo.

* Archivo `.RData`: vamos a importar un dataset con las distintas caracterÃ­sticas de los [**viajeros del Titanic**]{.hl-purple}, incluyendo quiÃ©n sobreviviÃ³ y quiÃ©n muriÃ³.


```{r}
#| eval: false
load("./datos/titanic.RData")
as_tibble(titanic)
```

```{r}
#| echo: false
library(tidyverse)
load("./datos/titanic.RData")
as_tibble(titanic) |> slice(1:5)
```


---

## Formatos nativos de R


* Archivo `.rda`: vamos a importar un dataset con [**datos de cÃ¡ncer de pecho**]{.hl-purple} de [**Royston and Altman (2013)**](https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/1471-2288-13-33), incluyendo 2982 pacientes y sus caracterÃ­sticas


```{r}
#| eval: false
load("./datos/rotterdam_breast_cancer.rda")
as_tibble(rotterdam)
```

```{r}
#| echo: false
library(tidyverse)
load("./datos/rotterdam_breast_cancer.rda")
as_tibble(rotterdam) |> slice(1:7)
```


---

## Formatos nativos de R

* Archivo `.rds`: para este tipo debemos usar `readRDS()`, y necesitamos incorporar un [**argumento `file`**]{.hl-yellow} con la ruta. En este caso vamos a importar [**datos de cÃ¡ncer de pulmÃ³n**]{.hl-purple} del North Central Cancer Treatment Group.

```{r}
#| eval: false
lung_cancer <-
  readRDS(file = "./datos/NCCTG_lung_cancer.rds") |> as_tibble()
```

```{r}
#| echo: false
lung_cancer <-
  readRDS(survival::cancer, file = "./datos/NCCTG_lung_cancer.rds") |> 
  as_tibble()
lung_cancer |> slice(1:5)
```

::: callout-important

## Importante

Las [**rutas**]{.hl-yellow} deben ir siempre [**sin espacios, ni eÃ±es, ni tildes**]{.hl-yellow}. Y fÃ­jate que los archivos cargados con `load()` se cargan automÃ¡ticamente en el environment (con el nombre guardado originalmente), pero las funciones `read()` solo se carga de manera local (sino se guarda, no existe a futuro)

:::

---

## Datos rectangulares: readr

El paquete `{readr}` dentro del entorno `{tidyverse}` contiene distintas funciones Ãºtiles para la [**carga de datos rectangulares (sin formatear)**]{.hl-yellow}.

:::: columns
::: {.column width="50%"}

* `read_csv()`: archivos `.csv` cuyo [**separador sea la coma**]{.hl-purple}
* `read_csv2()`: [**punto y coma**]{.hl-purple}
* `read_tsv()`: [**tabulador**]{.hl-purple}.
* `read_table()`: [**espacio**]{.hl-purple}.
* `read_delim()`: funciÃ³n genÃ©rica para [**archivos delimitados por caracteres**]{.hl-purple}.


:::

::: {.column width="50%"}

![](img/data-import-readr.png)
:::
::::

Todos necesitan como **argumento la ruta del archivo** amÃ©n de **otros opcionales** (saltar o no cabecera, decimales, etc). Ver mÃ¡s en <https://readr.tidyverse.org/>

---

## Datos tabulados (.csv, .tsv)

La principal ventaja de `{readr}` es que [**automatiza el formateo**]{.hl-yellow} para pasar de un archivo plano (sin formato) a un tibble (en filas y columnas, con formato).

. . .

* Archivo `.csv`: con `read_csv()` cargaremos archivos [**separados por coma**]{.hl-purple}, pasando como [**argumento la ruta**]{.hl-yellow} en `file = ...`. Vamos a importar el dataset `chickens.csv` (sobre pollos de dibujos animados, why not). Si te fijas en la salida nos proporciona el tipo de variables.

```{r}
library(readr)
chickens <- read_csv(file = "./datos/chickens.csv")
chickens
```

---

## Datos tabulados (.csv, .tsv)


El [**formato de las variables**]{.hl-yellow} normalmente lo harÃ¡ `read_csv()` de forma [**automÃ¡tica**]{.hl-yellow}, y podemos consultarlo con `spec()`

```{r}
spec(chickens)
```

---

## Datos tabulados (.csv, .tsv)

Aunque lo haga normalmente bien de forma automÃ¡tica podemos [**especificar el formato explÃ­citamente**]{.hl-yellow} en `col_types = list()` (en formato lista, con `col_xxx()` para cada tipo de variable, por ejemplo una la pondremos como cualitativa o factor). Incluso podemos indicar que [**variables que queremos seleccionar**]{.hl-yellow} (sin ocupar memoria), indicÃ¡ndoselo en `col_select = ...`


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_types = list(col_character(), col_factor(), col_double(), col_character()),
           col_select = c(chicken, sex, eggs_laid))
chickens
```



---


## Datos sin tabular (.txt)

Â¿QuÃ© sucede cuando el [**separador no es el correcto**]{.hl-red}?

. . .

Si usamos `read_csv()` espera que el separador entre columnas sea una coma pero, como puedes ver con el siguiente `.txt`, nos interpreta todo como una sola columna: [**no tiene comas y no sabe por donde separar**]{.hl-yellow}

```{r}
datos_txt <- read_csv(file = "./datos/massey-rating.txt")
dim(datos_txt)
as_tibble(datos_txt)
```


---

## Datos sin tabular (.txt)

Para ello tenemos

* `read_csv2()` cuando el [**separador sea el punto y coma**]{.hl-yellow}, `read_tsv()` cuando el [**sea un tabulador**]{.hl-yellow} y `read_table()` cuando el [**sea un espacio**]{.hl-yellow}

* `read_delim()` en general

```{r}
datos_txt <- read_table(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```


---

## Datos en excel (.xls, .xlsx)

Otro de los paquetes fundamentales de importaciÃ³n serÃ¡ el paquete  `{readxl}` para [**importar datos desde una Excel**]{.hl-yellow}. Tres funciones serÃ¡n claves:

* `read_xls()` especÃ­fica para `.xls`, `read_xlsx()` especÃ­fica para `.xlsx`
* `read_excel()`: para ambas

. . .

Vamos a importar `deaths.xlsx` con registros de fallecimientos de famosos

```{r}
#| eval: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths |> slice(1:8)
```

---

## Datos en excel (.xls, .xlsx)


```{r}
#| eval: false
deaths
```

```{r}
#| echo: false
deaths |> slice(1:8)
```

Algo por [**desgracia muy habitual**]{.hl-yellow} es que haya algÃºn tipo de comentario o texto al inicio del archivo, teniendo que [**saltarnos dichas filas**]{.hl-yellow}.

---

## Datos en excel (.xls, .xlsx)

Podemos [**saltarnos dichas filas**]{.hl-yellow} directamente en la carga con `skip = ...` (indicando el nÃºmero de filas que nos saltamos)

```{r}
#| eval: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths |> slice(1:5)
```

---

## Datos en excel (.xls, .xlsx)

AdemÃ¡s con `col_names = ...` podemos renombrar ya las columnas en la importaciÃ³n (si [**proporcionamos nombres asume la 1Âª lÃ­nea ya como un dato**]{.hl-yellow})

```{r}
#| eval: false
#| code-line-numbers: "3"
deaths <-
  read_xlsx(path = "./datos/deaths.xlsx",
            skip = 5,
            col_names = c("name", "profession", "age", "kids", "birth", "death"))
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 5,
                    col_names = c("name", "profession", "age", "kids", "birth", "death"))
deaths |> slice(1:7)
```
        
---

## Datos en excel (.xls, .xlsx)


En ocasiones las [**fechas de Excel estÃ¡n mal formateadas**]{.hl-red} (sorpresa): podemos hacer uso de `convertToDate()` del paquete `{openxlsx}` para convertirlo


```{r}
#| eval: false
library(openxlsx)
deaths$death <- convertToDate(deaths$death)
deaths
```
   
```{r}
#| echo: false
library(openxlsx)
deaths$death <- convertToDate(deaths$death)
deaths |> slice(1:7)
```

---

## Datos en excel (.xls, .xlsx)

TambiÃ©n podemos [**cargar un Excel con varias hojas**]{.hl-yellow}: para [**indicarle la hoja**]{.hl-yellow} (bien por su nombre bien por su nÃºmero) usaremos el argumento `sheet = ...`

```{r}
#| eval: false
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars
```


```{r}
#| echo: false
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars |> slice(1:5)
```


. . .
 
Incluso podemos indicar el [**rango de celdas**]{.hl-yellow} a cargar con `range = ...`

```{r}
iris <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "iris", range = "C1:E4")
iris
```



---

## Desde SAS/STATA/SPSS

El paquete `{haven}` dentro de la Ã³rbita tidyverse nos permitirÃ¡ [**importar archivos de los 3 software de pago mÃ¡s importantes**]{.hl-yellow}: SAS, SPSS y Stata

```{r}
library(haven)

# SAS
iris_sas <- read_sas(data_file = "./datos/iris.sas7bdat")

# SPSS
iris_spss <- read_sav(file = "./datos/iris.sav")

# Stata
iris_stata <- read_dta(file = "./datos/iris.dta")
```

---

## Exportar

De la misma manera que podemos importar tambiÃ©n podemos [**exportar**]{.hl-yellow}

* exportado en `.RData` (opciÃ³n recomendada para variables guardadas en `R`). Recuerda que esta extensiÃ³n [**solo se podrÃ¡ usar en `R`**]{.hl-yellow}. Para ello nos basta con usar `save(objeto, file = ruta)`

```{r}
tabla <- tibble("a" = 1:4, "b" = 1:4)
save(tabla, file = "./datos/tabla_prueba.RData")
rm(tabla) # eliminar
load("./datos/tabla_prueba.RData")
tabla
```


---

## Exportar

De la misma manera que podemos importar tambiÃ©n podemos [**exportar**]{.hl-yellow}

* exportado en `.csv`. Para ello nos basta con usar `write_csv(objeto, file = ruta)`

```{r}
write_csv(tabla, file = "./datos/tabla_prueba.csv")
read_csv(file = "./datos/tabla_prueba.csv")
```

---

## Desde web

Una de las principales ventajas de `R` es que podemos hacer uso de todas las funciones anteriores de [**importar pero directamente desde una web**]{.hl-yellow}, sin necesidad de realizar la descarga manual: en lugar de pasarle la ruta local le indicaremos el [**enlace**]{.hl-yellow}. Por ejemplo, vamos a descargar los datos de covid del ISCIII (<https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>)


```{r}
#| eval: false
covid_datos <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv", n_max = 700)
covid_datos
```

---

## Desde google drive

Otra opciÃ³n disponible (sobre todo si trabajamos con otras personas que trabajan) es [**importar desde una hoja de cÃ¡lculo Google Drive**]{.hl-yellow}, haciendo uso de `read_sheet()` del paquete `{googlesheets4}`

La primera vez te pedirÃ¡ un permiso de tidyverse para interactuar con vuestro drive

```{r}
#| eval: false
library(googlesheets4)
google_sheet <-
  read_sheet("https://docs.google.com/spreadsheets/d/1n_UTbD93-oDJR2r-rsMNff5ro147NL_ZN_vYIA2eJ3Q/edit?usp=sharing")
google_sheet
```

---

## Desde API (owid)

Una opciÃ³n tambiÃ©n muy interesante es la [**carga de datos desde una API**]{.hl-yellow}: un intermediario entre una app o proveedor datos y nuestro `R`. Por ejemplo, vamos a cargar la librerÃ­a `{owidR}`, que nos permite la descarga de datos de la web <https://ourworldindata.org/>. La funciÃ³n `owid_covid()` nos carga sin darnos cuenta mÃ¡s de 300 000 registros con mÃ¡s de 50 variables de 238 paÃ­ses

```{r}
#| eval: false
library(owidR)
owid_covid()
```

```{r}
#| echo: false
#| eval: false
library(owidR)
owid_covid() |> slice(1:5)
```

---

## Desde API (owid)

Este paquete tiene la funciÃ³n `owid_search()` para buscar datasets por palabras clave, por ejemplo, `emissions`, dÃ¡ndonos un dataset con el tÃ­tulo de la base de datos y su id para luego usarla.

```{r}
#| eval: false
as_tibble(owid_search("emissions"))
```

```{r}
#| echo: false
#| eval: false
as_tibble(owid_search("emissions")) |> slice(1:4)
```

. . .

Vamos a pedirle por ejemplo las [**emisiones de la oecd**]{.hl-yellow}

```{r}
#| eval: false
owid("emissions-of-air-pollutants-oecd")
```

```{r}
#| echo: false
#| eval: false
owid("emissions-of-air-pollutants-oecd") |> slice(1:5)
```

---

## Desde API (aemet)

En muchas ocasiones para conectar con la API tendremos antes que [**registrarnos y obtener una clave**]{.hl-yellow}, es el caso del paquete `{climaemet}` para acceder a datos meteorolÃ³gicos (<https://opendata.aemet.es/centrodedescargas/inicio>)


Una vez que tenemos la clave de la API la registramos en nuestro RStudio para poder usarla a futuro


```{r}
#| eval: false
library(climaemet)

# Definir la clave
apikey <- "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqYXZhbHYwOUB1Y20uZXMiLCJqdGkiOiI4YTU1ODUxMS01MTE3LTQ4MTYtYmM4OS1hYmVkNDhiODBkYzkiLCJpc3MiOiJBRU1FVCIsImlhdCI6MTY2NjQ2OTcxNSwidXNlcklkIjoiOGE1NTg1MTEtNTExNy00ODE2LWJjODktYWJlZDQ4YjgwZGM5Iiwicm9sZSI6IiJ9.HEMR77lZy2ASjmOxJa8ppx2J8Za1IViurMX3p1reVBU"

aemet_api_key(apikey, install = TRUE)
```


```{r}
#| echo: false
library(climaemet)
```

--- 

## Desde API (aemet)


Con dicho paquete podemos hacer una [**bÃºsqueda de estaciones**]{.hl-yellow} para conocer tanto su cÃ³digo postal como su cÃ³digo identificador dentro de la red AEMET (por ejemplo, la estaciÃ³n del aeropuerto de El Prat, Barcelona, es el cÃ³digo `"0076"`)

```{r}
#| eval: false
stations <- aemet_stations()
stations
```

```{r}
#| echo: false
#| eval: false
stations <- aemet_stations()
stations |> slice(1:4)
```

```{r}
#| eval: false
aemet_last_obs("0076")
```

```{r}
#| echo: false
#| eval: false
aemet_last_obs("0076") |> slice(1:4)
```

---

## Desde API (catastro)

TambiÃ©n puedes conectar con la [**API del catrastro**]{.hl-yellow} y buscar por ejemplo por coordenadas

```{r}
#| eval: false
library(CatastRo)
catr_ovc_get_rccoor(lat = 38.61965, lon = -3.45624, srs = "4230")
```


---


## ğŸ’» Tu turno {#tu-turno-4}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ El dataset `who` que hemos usado en ejercicios anteriores, expÃ³rtalo a un formato nativo de `R` en la carpeta `datos` del proyecto

```{r}
#| code-fold: true
#| eval: false
library(tidyr)
save(who, file = "./datos/who.RData")
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Carga el dataset `who` pero desde la carpeta de datos (importa el archivo creado en el ejercicio anterior)

```{r}
#| code-fold: true
#| eval: false
load("./datos/who.RData")
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Repite lo mismo (exportar e importar) en 4 formatos: `.csv`, `.xlsx`, `.sav` (spss) y `.dta` (stata)

```{r}
#| code-fold: true
#| eval: false

# csv
library(readr)
write_csv(who, file = "./datos/who.csv")
who_data <- read_csv(file = "./datos/who.csv")

# excel
library(openxlsx)
write.xlsx(who, file = "./datos/who.xlsx")
who_data <- read_xlsx(path = "./datos/who.xlsx")

# sas y stata
library(haven)
write_sav(who, path = "./datos/who.sav")
who_data <- read_spss(path = "./datos/who.sav")

write_dta(who, path = "./datos/who.dta")
who_data <- read_dta(path = "./datos/who.dta")
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Repite la carga del `who.csv` pero solo selecciona ya en la carga las 4 primeras columnas

```{r}
#| code-fold: true
#| eval: false
who_select <-
  read_csv(file = "./datos/who.csv",
           col_select = c("country", "iso2", "iso3", "year"))
```


:::

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-4b}


En la carpeta de datos tienes el dataset `breast-cancer-wisconsin-data.csv`. Crea un archivo `.qmd` y personalÃ­zalo incluyendo lo siguiente:

1. Importa el archivo csv a un `tibble`. Â¿Es tidydata? Â¿CuÃ¡ntos pacientes y variables tenemos?

```{r}
#| code-fold: true
datos <- read_csv(file = "./datos/breast-cancer-wisconsin-data.csv")
datos
```

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-4b-1}


2. El dataset representa datos de cÃ¡ncer de pecho (`id` identificador, `diagnosis` el diagnÃ³stico maligno/benigno y el resto propiedades del tumor). Usando SOLO LO APRENDIDO, Â¿quÃ© % tenÃ­an un tumor maligno y quÃ© % uno benigno?

```{r}
#| code-fold: true
100 * sum(datos$diagnosis == "M") / nrow(datos)
100 * sum(datos$diagnosis == "B") / nrow(datos)
```

. . .

3. Â¿CuÃ¡l de los dos tipos de tumores tienen, de media, un radio mÃ¡s elevado? 

```{r}
#| code-fold: true
mean_M <- mean(datos$radius_mean[datos$diagnosis == "M"], na.rm = TRUE)
mean_B <- mean(datos$radius_mean[datos$diagnosis == "B"], na.rm = TRUE)
```

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-4b-1}


4. Busca la ayuda de la funciÃ³n `t.test()`. Dicha funciÃ³n nos permite contrastar si la media de dos distribuciones son o no iguales. Â¿Podemos rechazar la hipÃ³tesis nula de que la media del radio sea la misma, bajo una significancia de $\alpha = 0.05$?

```{r}
#| code-fold: true
datos_M <- datos$radius_mean[datos$diagnosis == "M"]
datos_B <- datos$radius_mean[datos$diagnosis == "B"]
t.test(datos_M, datos_B, conf.level = 0.95)
```

SÃ­, podemos rechazar.

# Clase 5: tidyverse (filas) {#clase-5-tidyverse-filas}

[**Operaciones con filas**]{style="color:#444442;"}

---

## Â¿QuÃ© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: [**gramÃ¡tica para depurar**]{.hl-yellow}
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualizaciÃ³n de datos
-   `{tidymodels}`: modelizaciÃ³n/predicciÃ³n
:::
:::

TambiÃ©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.


---

## Preprocesamiento: dplyr

Dentro de `{tidyverse}` usaremos el paquete `{dplyr}` para el [**preprocesamiento y depuraciÃ³n**]{.hl-yellow} de datos de datos.

::: columns
::: {.column width="60%"}
![](img/dplyr.png){width=450}
:::

::: {.column width="40%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::
:::

La idea es que el [**cÃ³digo sea legible**]{.hl-yellow}, como si fuese una lista de instrucciones que al leerla nos diga de manera muy evidente lo que estÃ¡ haciendo.

---

## HipÃ³tesis: tidydata

::: columns
::: {.column width="50%"}
Toda la depuraciÃ³n que vamos a realizar es sobre la [**hipÃ³tesis de que nuestros datos estÃ¡n en tidydata**]{.hl-yellow}
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
::::

Recuerda que en `{tidyverse}` serÃ¡ clave el [**operador pipe (tuberÃ­a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): serÃ¡ una [**tuberÃ­a que recorre los datos**]{.hl-yellow} y los transforma.

. . .

Vamos a practicar con el dataset `starwars` del paquete cargado `{dplyr}`

```{r}
#| eval: false
library(tidyverse)
starwars
```

---


## Muestreo

:::: columns
::: {.column width="60%"}

Una de las operaciones mÃ¡s comunes es lo que se conoce en estadÃ­stica como [**muestreo**]{.hl-yellow}: una [**selecciÃ³n o filtrado de registros**]{.hl-yellow} (una submuestra)

:::

::: {.column width="40%"}

![](img/muestreo.jpeg){width=500}
:::
::::

. . .


* [**No aleatorio (por cuotas)**]{.hl-purple}: en base a condiciones lÃ³gicas sobre los registros (`filter()`)

. . .

* [**No aleatorio (intencional/discreccional)**]{.hl-purple}: en base a posiciÃ³n (`slice()`)

. . .

* [**Aleatorio simple**]{.hl-purple} (`slice_sample()`)

. . .

* [**Aleatorio estratificado**]{.hl-purple} (`group_by()` + `slice_sample()`)


---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

El mÃ¡s simple es cuando [**filtramos registros**]{.hl-yellow} en base a alguna condiciÃ³n lÃ³gica: con `filter()` se seleccionarÃ¡n solo individuos que cumplan ciertas condiciones (muestreo no aleatorio por condiciones)


::: incremental
-   `==`, `!=`: [**igual**]{.hl-purple} o [**distinto**]{.hl-yellow} que (`|> filter(variable == "a")`)
-   `>`, `<`: [**mayor**]{.hl-purple} o [**menor**]{.hl-yellow} que (`|> filter(variable < 3)`)
-   `>=`, `<=`: [**mayor o igual**]{.hl-yellow} o [**menor o igual**]{.hl-purple} que (`|> filter(variable >= 5)`)
-   `%in%`: valores [**pertenencen**]{.hl-yellow} a un listado de opciones (`|> filter(variable %in% c("azul", "verde"))`)
-   `between(variable, val1, val2)`: si los valores (continuos) [**caen dentro de un rango**]{.hl-yellow} de valores (`|> filter(between(variable, 160, 180))`)
:::

---

## Filtrar filas: filter()

Dichas [**condiciones lÃ³gicas**]{.hl-yellow} las podemos [**combinar**]{.hl-yellow} de diferentes maneras (y, o, o excluyente)

![](img/tablas_verdad.png)

. . .


::: callout-tip
## Importante

Recuerda que dentro de `filter()` debe ir siempre algo que devuelva un [**vector de valores lÃ³gicos**]{.hl-green}.
:::

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para... [**filtrar**]{.hl-yellow} los personajes de [**ojos marrones**]{.hl-purple}?

. . .

[**Â¿QuÃ© tipo de variable es?**]{.hl-yellow} --> La variable `eye_color` es cualitativa asÃ­ que estÃ¡ representada por textos

. . .

```{r}
#| echo: false
#| include: false
library(tidyverse)
```

```{r}
starwars |>
  filter(eye_color == "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para... [**filtrar**]{.hl-yellow} los personajes que [**no tienen ojos marrones**]{.hl-purple}?

. . .


```{r}
starwars |>
  filter(eye_color != "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para ... [**filtrar**]{.hl-yellow} los personajes que [**tengan los ojos marrones o azules**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color %in% c("blue", "brown"))
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

FÃ­jate que `%in%` es equivalente a concatenar varios `==` con una conjunciÃ³n o (`|`)

```{r}
starwars |>
  filter(eye_color == "blue" | eye_color == "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para ... [**filtrar**]{.hl-yellow} los personajes que [**midan entre 120 y 160 cm**]{.hl-purple}?

. . .

[**Â¿QuÃ© tipo de variable es?**]{.hl-yellow} --> La variable `height` es cuantitativa continua asÃ­ que deberemos filtrar por rangos de valores (intervalos) --> usaremos `between()`

. . .

```{r}
starwars |>
  filter(between(height, 120, 160))
```


---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color == "brown" & species != "Human")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos, o que tengan mÃ¡s de 60 aÃ±os**]{.hl-purple}? PiÃ©nsalo bien: los [**parÃ©ntesis son importantes**]{.hl-yellow}: no es lo mismo $(a+b)*c$ que $a+(b*c)$

. . .

```{r}
starwars |>
  filter((eye_color == "brown" & species != "Human") | birth_year > 60)
```

---

## Eliminar ausentes: drop_na()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  retirar_ausentes(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(var1, var2, ...)
```
:::
:::

Hay un filtro especial para una de las operaciones mÃ¡s habituales en depuraciÃ³n: [**retirar los ausentes**]{.hl-yellow}. Para ello podemos usar dentro de un filtro `is.na()`, que nos devuelve `TRUE/FALSE` en funciÃ³n de si es ausente, o bien ...

. . .

Usar `drop_na()`: si no indicamos variable, elimina registros con ausente en cualquier variable. MÃ¡s adelante veremos como [**imputar esos ausentes**]{.hl-yellow} 

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(mass, height)
```

```{r}
#| echo: false
starwars |>
  drop_na(mass, height, sex) |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na()
```

```{r}
#| echo: false
starwars |>
  drop_na() |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::
:::

---

## ğŸ’» Tu turno {#tu-turno-7a}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Selecciona del conjunto de starwars solo los personajes que sean androides o cuyo valor en `species` sea desconocido

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Droid" | is.na(species))
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Selecciona del conjunto de starwars solo los personajes cuyo peso estÃ© entre 65 y 90 kg.

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(between(mass, 65, 90))
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Tras limpiar de ausentes en todas las variables, selecciona del conjunto de starwars solo los personajes que sean humanos y que vengan de Tatooine

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na() |> 
  filter(species == "Human" & homeworld == "Tatooine")
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Selecciona del conjunto original de starwars los personajes no humanos, `male` en el sexo y que midan entre 120 y 170 cm, o los personajes con ojos marrones o rojos.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter((species != "Human" & sex == "male" &
            between(height, 120, 170)) |
           eye_color %in% c("brown", "red"))
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Busca informaciÃ³n en la ayuda de la funciÃ³n `str_detect()` del paquete `{stringr}` (cargado en `{tidyverse}`). Consejo: prueba antes las funciones que vayas a usar con algÃºn vector de prueba para poder comprobar su funcionamiento. Tras saber lo que hace, filtra solo aquellos personajes con apellido `Skywalker`

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(str_detect(name, "Skywalker"))
```
:::

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice(posiciones)
```
:::
:::

A veces nos puede interesar realizar un [**muestreo no aleatorio discreccional**]{.hl-yellow}, o lo que es lo mismo, [**filtrar por posiciÃ³n**]{.hl-yellow}: con `slice(posiciones)` podremos seleccionar filas concretas pasando como argumento un [**vector de Ã­ndices**]{.hl-yellow}

. . .

::: columns
::: {.column width="50%"}
```{r}
#| eval: false

# fila 1
starwars |>
  slice(1)
```

```{r}
#| echo: false
starwars |> slice(1) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false

# filas de la 7 a la 9
starwars |>
  slice(7:9)
```

```{r}
#| echo: false
starwars |> slice(7:9) |> select(name:hair_color)
```
:::
:::

. . .

```{r}
#| eval: false

# filas 2, 7, 10 y 31
starwars |>
  slice(c(2, 7, 10, 31))
```

```{r}
#| echo: false
starwars |>
  slice(c(2, 7, 10, 31)) |> select(name:sex)
```

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(posiciones)
```
:::
:::

Disponemos de opciones por defecto:

* con `slice_head(n = ...)` y `slice_tail(n = ...)` podemos obtener la [**cabecera y cola**]{.hl-yellow} de la tabla

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_head(n = 2)
```

```{r}
#| echo: false
starwars |> slice_head(n = 2) |> select(name:hair_color)
```
:::

::: {.column width="\"50%"}
```{r}
#| eval: false
starwars |> slice_tail(n = 2)
```

```{r}
#| echo: false
starwars |> slice_tail(n = 2) |> select(name:hair_color)
```
:::
:::

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(posiciones)
```
:::
:::

Disponemos de opciones por defecto:

* con `slice_max()` y `slice_min()` obtenemos la [**filas con menor/mayor valor de una variable**]{.hl-yellow} (si empate, todas salvo que `with_ties = FALSE`) que indicamos en `order_by = ...`

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_min(mass, n = 2)
```

```{r}
#| echo: false
starwars |> slice_min(n = 2, order_by = mass) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_max(height, n = 2)
```

```{r}
#| echo: false
starwars |> slice_max(n = 2, order_by = height) |> select(name:hair_color)
```
:::
:::

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

El conocido como [**muestreo aleatorio simple**]{.hl-yellow} se basa en [**seleccionar individuos aleatoriamente**]{.hl-yellow}, de forma que cada uno tenga ciertas [**probabilidades**]{.hl-yellow} de ser seleccionado. Con `slice_sample(n = ...)` podemos extraer n registros aleatoriamente (a priori equiprobables).

```{r}
starwars |> slice_sample(n = 2)
```

. . .

::: callout-important
## Importante...

[**Â«AleatorioÂ» no implica equiprobable**]{.hl-yellow}: es igual de aleatorio un dado normal que uno trucado. No hay cosas Â«mÃ¡s aleatoriasÂ» que otras, simplemente tienen subyacente distintas leyes de probabilidad.

:::

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

TambiÃ©n podremos indicarle la [**proporciÃ³n de datos a samplear**]{.hl-yellow} (en lugar del nÃºmero) y si queremos que sea [**con reemplazamiento (que se puedan repetir)**]{.hl-yellow}.

```{r}
# 5% de registros aleatorios con reemplazamiento
starwars |> 
  slice_sample(prop = 0.05, replace = TRUE)

```


---


## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

Como decÃ­amos, Â«aleatorioÂ» no es igual que Â«equiprobableÂ», asÃ­ que podemos pasarle un [**vector de probabilidades**]{.hl-yellow}. Por ejemplo, vamos a forzar que sea muy improbable sacar una fila que no sean las dos primeras

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

. . .

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

---

## ParÃ©ntesis: sample()

La funciÃ³n `slice_sample()` es simplemente una integraciÃ³n de `{tidyverse}` de la funciÃ³n bÃ¡sica de `R` conocida como `sample()` que nos permite [**muestrear elementos**]{.hl-yellow}

. . .

Por ejemplo, vamos a [**muestrear 10 tiradas de un dado**]{.hl-yellow}, indicÃ¡ndole

- [**soporte**]{.hl-purple} de nuestra variable aleatorio (valores permitidos en `x`)
- [**tamaÃ±o**]{.hl-purple} muestral (`size`)
- [**reemplazamiento**]{.hl-purple} (si `TRUE` entonces pueden salir repetidas, como en el caso del dado)

```{r}
sample(x = 1:6, size = 10, replace = TRUE)
```

---

## ParÃ©ntesis: sample()

La opciÃ³n anterior lo que genera son sucesos de una variable aleatoria [**equiprobable**]{.hl-yellow} pero al igual que antes, podemos asignarle un vector de probabilidades o [**funciÃ³n de masa**]{.hl-yellow} concreta con el argumento  `prob = ...`

```{r}
sample(x = 1:6, size = 50, replace = TRUE,
       prob = c(0.5, 0.2, 0.1, 0.1, 0.05, 0.05))
```

---


## ParÃ©ntesis: sample()

**Â¿CÃ³mo harÃ­as el siguiente enunciado?**

&nbsp;

Supongamos que en una ciudad se han estudiado episodios de gripe estacional. Sean las variables aleatorias $X_m$ y $X_p$ tal que $X_m=1$ si la madre tiene gripe, $X_m=0$ si la madre no tiene gripe, $X_p=1$ si el padre tiene gripe y $X_p=0$ si el padre no tiene gripe. El modelo teÃ³rico asociado a este tipo de epidemias indica que la distribuciÃ³n conjunta viene dada por $P(X_m = 1, X_p=1)=0.02$, $P(X_m = 1, X_p=0)=0.08$, $P(X_m = 1, X_p=0)=0.1$ y $P(X_m = 0, X_p=0)=0.8$

**Genera una muestra** de tamaÃ±o $n = 1000$ (soporte `"10"`, `"01"`, `"00"` y `"11"`) haciendo uso de `runif()` y haciendo uso de `sample()`

---

## ğŸ’» Tu turno {#tu-turno-7b}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Selecciona solo los personajes que sean humanos y de ojos marrones, para despuÃ©s ordernarlos en altura descendente y peso ascendente.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(eye_color == "brown" & species == "Human") |> 
  arrange(height, desc(mass))
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Extrae 3 registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(n = 3)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Extrae el 10% de los registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(prop = 0.1)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Extrae aleatoriamente 10 personajes pero de forma que la probabilidad de que salga cada uno sea proporcional a su peso (mÃ¡s pesados, mÃ¡s probable)

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass) |> 
  slice_sample(n = 10, weight_by = mass)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Selecciona los 3 personajes mÃ¡s mayores.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_max(birth_year, n = 3)
```


:::



# Clase 6: entrega I {#entrega-i}

[**Primera entrega individual en clase**]{style="color:#444442;"}

---

## Ejercicios previos

[**Ejercicios recomendables para practicar antes de la prÃ¡ctica**]{.hl-yellow} y conocer el dataset en cuestiÃ³n.


Realiza la importaciÃ³n de los [datos de covid del ISCIII](https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv) directamente desde la web (archivo `casos_hosp_uci_def_sexo_edad_provres.csv`) incluyendo todas las filas pero cargando solo las columnas `provincia_iso`, `sexo`, `grupo_edad`, `fecha` y `num_casos`.

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Determina el tipo de dato es cada variable importada

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Â¿CuÃ¡ntas observaciones tenemos?

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Renombra el nombre de las variables al inglÃ©s

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Â¿Podemos convertir el dataset a una matriz? Argumenta e ilustra el por quÃ© sÃ­ o no.

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Crea una nueva variable (fuera de la base de datos) que nos diga el nÃºmero de dÃ­as que han pasado de cada registro respecto a hoy.

:::

---

## Entrega I (27/09/2023)

Se actualizarÃ¡ al inicio de la clase correspondiente.

::: callout-important

## Importante

Esta [**entrega ponderarÃ¡ un 10% en la nota final**]{.hl-green}

PodrÃ¡s [**usar todo el material del curso e internet**]{.hl-yellow} salvo cualquier aplicaciÃ³n de mensajerÃ­a o sistema de comunicaciÃ³n: en caso de tener alguna abierta a lo largo de la entrega, aunque no se estÃ© usando, deberÃ¡s [**abandonar la entrega y contarÃ¡ como un 0**]{.hl-red}.

ContarÃ¡s con aproximadamente 1 hora y 50 minutos, pero [**deberÃ¡s realizar la entrega**]{.hl-yellow}, como tarde, a las [**18:00**]{.hl-yellow}. SerÃ¡ [**obligatorio subir tanto el `.qmd` como el `.html`**]{.hl-yellow}: una entrega que no haya podido ser renderizada (es decir, con errores graves) serÃ¡ [**penalizada contando solo un 65% de la nota obtenida**]{.hl-red} (si la entrega es perfecta, la nota mÃ¡xima serÃ¡ un 6.5 sino se adjunta el `.html` generado).

Te recomiendo practicar bastante y preguntar dudas en clase y/o tutorÃ­a ya que [**irÃ¡s justo de tiempo**]{.hl-yellow}, asÃ­ que necesitas fluidez en los ejercicios.

Si usas un [**pc de la biblioteca**]{.hl-yellow} asegÃºrate de tomarlo con suficiente antelaciÃ³n para [**instalar todas las librerÃ­as necesarias antes de empezar**]{.hl-yellow} para no perder tiempo.

:::



# Clase 7: tidyverse (filas y columnas) {#clase-7-tidyverse-columnas}

[**Operaciones con columnas**]{style="color:#444442;"}

---


## Reordenar filas: arrange()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> ordenar(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(var1, var2, ...)
```
:::
:::

TambiÃ©n podemos [**ordenar filas**]{.hl-yellow} en funciÃ³n de alguna variable con `arrange()`

```{r}
#| eval: false
starwars |> arrange(mass)
```

```{r}
#| echo: false
starwars |> arrange(mass) |> select(name:eye_color) |> slice(1:5) 
```

. . .

Por [**defecto de menor a mayor**]{.hl-yellow} pero podemos [**invertir el orden**]{.hl-purple} con `desc()`

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(desc(height))
```

```{r}
#| echo: false
starwars |> arrange(desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(mass, desc(height))
```

```{r}
#| echo: false
starwars |> arrange(mass, desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::
:::

---

## Eliminar duplicados: distinct()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> sin_duplicados(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> distinct(var1, var2, ...)
```
:::
:::

Muchas veces necesitaremos asegurarnos que no hay duplicados en alguna variable (DNI) y podemos [**eliminar filas duplicadas**]{.hl-yellow} con `distinct()`.

```{r}
starwars |> distinct(sex)
```

. . .

Para mantener todas las columnas de la tabla usaremos `.keep_all = TRUE`.

```{r}
#| eval: false
starwars |> distinct(sex, .keep_all = TRUE)
```

```{r}
#| echo: false
starwars |> distinct(sex, .keep_all = TRUE) |> slice(1:3)
```

---

## AÃ±adir filas: bind_rows()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> encuadernar_filas(tibble2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> bind_rows(tibble2)
```
:::
:::

Por Ãºltimo, podemos [**concatenar nuevas filas**]{.hl-yellow} con `bind_rows()` con [**las nuevas observaciones en tabla**]{.hl-red} (si no cuadran columnas rellena con ausentes)

```{r}
datos <-
  tibble("nombre" = c("javi", "laura"), "edad" = c(33, 50))
datos
```

. . .

```{r}
datos |> bind_rows(tibble("nombre" = c("carlos", NA), "cp" = c(28045, 28019)))
```

---

## ğŸ’» Tu turno {#tu-turno-7c}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Para saber que valores Ãºnicos hay en el color de pelo, elimina duplicados de la variable `hair_color`, eliminando antes los ausentes de dicha variable.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(hair_color) |> 
  distinct(hair_color)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ De los personajes que son humanos y miden mÃ¡s de 160 cm, elimina duplicados en color de ojos, elimina ausentes en peso, selecciona los 3 mÃ¡s altos, y orden de mayor a menor peso. Devuelve la tabla.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Human" & height > 160) |> 
  distinct(eye_color, .keep_all = TRUE) |> 
  drop_na(mass) |> 
  slice_max(height, n = 3) |> 
  arrange(desc(mass))
```
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "2"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "2"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "3"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "3"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "4"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "4"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "5"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "5"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen

La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "6"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "6"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::


--- 

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-5}

Vamos a usar el dataset `biopsy` que podemos encontrar en el agregador de datasets <https://vincentarelbundock.github.io/Rdatasets/index.html>. El [**dataset contiene datos de 699 pacientes a lo que se les realizÃ³ una biopsia de pecho**]{.hl-yellow}, obteniendo 11 variables (una que hace de id y 10 escalas medidas de 1 a 10)

Puedes ver la documentaciÃ³n en <https://vincentarelbundock.github.io/Rdatasets/doc/MASS/biopsy.html>

. . .

1. Crea de cero un [**informe en Quarto**]{.hl-yellow} donde hagas los ejercicios posteriores (usa un archivo de estilos para que quede estÃ©tico)

. . .

2. [**Importa el `.csv` desde la propia web**]{.hl-yellow} (a travÃ©s del enlace del archivo)

. . .

3. HabrÃ¡s visto que hay 12 columnas en realidad importadas (la primera nos sobra ya que es solo un contador de filas). Vuelve a cargarlo [**seleccionando en la carga**]{.hl-yellow} solo desde `ID` hasta `class`

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-5-1}

4. La variable `ID` en realidad es un identificador (una cualitativa). Repite la carga [**especificando los tipos de datos**]{.hl-yellow}: cualitativa o factor para ID y class, nÃºmeros para el resto de variables)

. . .

5. La variable `ID` deberÃ­a ser identificador de cada registro: [**elimina duplicados**]{.hl-yellow} por dicha variable del dataset anterior.

. . .

6. Del dataset anterior [**filtra**]{.hl-yellow} solo los pacientes con tumor maligno y la variable `V9` con valor 4 o inferior, [**eliminando ademÃ¡s cualquier registro que contenga ausente**]{.hl-yellow} en cualquiera de la variables.

. . .

7. Del dataset anterior obtÃ©n una [**muestra del 20% de los datos**]{.hl-yellow} (cada registro puede ser elegido con la misma probabilidad), y [**Ã³rdenalos**]{.hl-yellow} por de mayor a menor por la variable `V1` y, en caso de empate, de menor a mayor por la variable `V2`

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

La opciÃ³n mÃ¡s sencilla para [**seleccionar variables por nombre**]{.hl-yellow} es `select()`, dando como argumentos los nombres de columnas [**sin comillas**]{.hl-purple}.

```{r}
starwars |> select(name, hair_color)
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

La funciÃ³n `select()` nos permite seleccionar varias variables a la vez, incluso [**concatenando sus nombres como si fuesen Ã­ndices numÃ©ricos**]{.hl-yellow}

```{r}
#| eval: false
starwars |> select(name:eye_color) 
```

```{r}
#| echo: false
starwars |> select(name:eye_color) |> slice(1:4)
```

. . .

Y podemos [**deseleccionar columnas**]{.hl-yellow} con `-` delante

```{r}
#| eval: false
starwars |>  select(-mass, -(eye_color:starships))
```

```{r}
#| echo: false
starwars |> select(-mass, -(eye_color:starships)) |> slice(1:4)
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Tenemos ademÃ¡s [**palabras reservadas**]{.hl-yellow}: `everything()` [**todas las variables**]{.hl-purple}...

```{r}
#| eval: false
starwars |> select(mass, homeworld, everything())
```

```{r}
#| echo: false
starwars |> select(mass, homeworld, everything()) |> slice(1:4)
```

. . .

...y `last_col()` para referirnos a [**la Ãºltima columna**]{.hl-purple}.

```{r}
#| eval: false
starwars |> select(name:mass, homeworld, last_col())
```

```{r}
#| echo: false
starwars |> select(name:mass, homeworld, last_col()) |> slice(1:4)
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

TambiÃ©n podemos jugar con [**patrones**]{.hl-yellow} en el nombre, aquellas que [**comiencen por un prefijo**]{.hl-purple} (`starts_with()`), [**terminen con un sufijo**]{.hl-purple} (`ends_with()`), [**contengan un texto**]{.hl-purple} (`contains()`) o cumplan una [**expresiÃ³n regular**]{.hl-purple} (`matches()`).

```{r}
# variables cuyo nombre acaba en "color" y contengan sexo o gÃ©nero
starwars |> select(ends_with("color"), matches("sex|gender"))
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Incluso podemos [**seleccionar por rango numÃ©rico**]{.hl-yellow} si tenemos variables con un prefijo y nÃºmeros.

```{r}
datos <-
  tibble("semana1" = c(115, 141, 232), "semana2" = c(7, NA, 17),
         "semana3" = c(95, 162, NA), "semana4" = c(11, 19, 15),
         "semana5" = c(NA, 262, 190), "semana6" = c(21, 15, 23))
```

. . .

Con `num_range()` podemos seleccionar con un prefijo y una secuencia numÃ©rica.

```{r}
datos |> select(num_range("semana", 1:4))
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Por Ãºltimo, podemos seleccionar columnas por [**tipo de dato**]{.hl-yellow} haciendo uso de `where()` y dentro una funciÃ³n que devuelva un valor lÃ³gico de tipo de dato.

```{r}
# Solo columnas numÃ©ricas o de texto
starwars |> select(where(is.numeric) | where(is.character))
```

---

## Mover columnas: relocate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  recolocar(var1, despues_de = var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  relocate(var1, .after = var2)
```
:::
:::

Para facilitar la [**recolocaciÃ³n de variables**]{.hl-yellow} tenemos una funciÃ³n para ello, `relocate()`, indicÃ¡ndole en `.after` o `.before` [**detrÃ¡s**]{.hl-purple} o [**delante**]{.hl-purple} de quÃ© columnas queremos moverlas.

```{r}
starwars |> relocate(species, .before = name)
```

---

## Renombrar: rename()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> renombrar(nuevo = antiguo)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> rename(nuevo = antiguo)
```
:::
:::

A veces tambiÃ©n podemos querer [**modificar la Â«metainformaciÃ³nÂ»**]{.hl-yellow} de los datos, [**renombrando columnas**]{.hl-yellow}. Para ello usaremos de `rename()` poniendo [**primero el nombre nuevo**]{.hl-purple} y luego el [**antiguo**]{.hl-purple}.

```{r}
starwars |> rename(nombre = name, altura = height, peso = mass)
```

---

## Extraer columnas: pull()


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> retirar(var)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> pull(var)
```
:::
:::


Si observas la salida de los `select()` [**sigue siendo una tabla tibble**]{.hl-yellow}, ya que nos preserva la naturaleza de nuestros datos.

```{r}
starwars |> select(name)
```

---


## Extraer columnas: pull()


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> retirar(var)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> pull(var)
```
:::
:::


A veces no querremos dicha estructura sino [**extraer literalmente la columna en un vector**]{.hl-yellow}, algo que podemos hacer con `pull()`

```{r}
starwars |> pull(name)
```


---


## ğŸ’» Tu turno {#tu-turno-7d}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Filtra el conjunto de personajes y quÃ©date solo con aquellos que en la variable `height` no tengan un dato ausente. Con los datos obtenidos del filtro anterior, selecciona solo las variables name, height, asÃ­ como todas aquellas variables que CONTENGAN la palabra color en su nombre.

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detrÃ¡s de la variable de nombres.

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio anterior, comprueba cuÃ¡ntas modalidades Ãºnicas hay en la variable de color de pelo (sin usar `unique()`).

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Del conjunto de datos originales, elimina las columnas de tipo lista, y tras ello elimina duplicados en la variable `eye_color`. Tras eliminar duplicados extrae dicha columna en un vector.

:::

---


## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

En muchas ocasiones querremos [**modificar o crear variables**]{.hl-yellow} con `mutate()`. 


. . . 

Vamos a crear por ejemplo una nueva variable `height_m` con la altura en metros.

```{r}
starwars |> mutate(height_m = height / 100)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

AdemÃ¡s con los argumentos opcionales podemos [**recolocar la columna modificada**]{.hl-yellow}

```{r}
starwars |> 
  mutate(height_m = height / 100,
         IMC = mass / (height_m^2), .before = name)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

::: callout-important
## Importante...

Cuando aplicamos `mutate()`, debemos de acordarnos que las [**operaciones se realizan de manera vectorial**]{.hl-yellow}, elemento a elemento, por lo que la funciÃ³n que usemos dentro debe devolver un vector de igual longitud. En caso contrario, [**devolverÃ¡ una constante**]{.hl-red}
:::

. . .

```{r}
starwars |> 
  mutate(constante = mean(mass, na.rm = TRUE), .before = name)
```

# Clase 8: tidyverse (resÃºmenes) y recategorizar {#clase-8}

[**Summarise y group_by(). Contar y resumir: estadÃ­sticas desagregadas por factores/grupos**]{style="color:#444442;"}

---

## Recategorizar: if_else()

TambiÃ©n podemos combinar `mutate()` con la expresiÃ³n de control `if_else()` para [**recategorizar la variable**]{.hl-yellow}: si [**se cumple una condiciÃ³n**]{.hl-purple}, hace una cosa, en caso contrario otra.

```{r}
starwars |> 
  mutate(human = if_else(species == "Human", "Human", "Not Human"),
         .after = name) |> 
  select(name:mass)
```

---

## Recategorizar: case_when()

Para [**recategorizaciones mÃ¡s complejas**]{.hl-yellow} tenemos `case_when()`, por ejemplo, para crear una categorÃ­a de los personajes en funciÃ³n de su altura.

```{r}
starwars |> 
  drop_na(height) |> 
  mutate(altura = case_when(height < 120 ~ "enanos",
                            height < 160 ~ "bajito",
                            height < 180 ~ "normal",
                            height < 200 ~ "alto",
                            TRUE ~ "gigante"), .before = name)
```

---

## ğŸ’» Tu turno {#tu-turno-8a}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Selecciona solo las variables nombre, altura y asÃ­ como todas aquellas variables relacionadas con el color, a la vez que te quedas solo con aquellos que no tengan ausente en la altura.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(name, height, contains("color")) |> 
  drop_na(height)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(name, height, contains("color")) |> 
  drop_na(height) |> 
  rename(nombre = name, altura = height,
         color_pelo = eye_color, color_piel = skin_color,
         color_pelo = hair_color)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detrÃ¡s de la variable de nombres.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  select(name, height, contains("color")) |> 
  drop_na(height) |> 
  rename(nombre = name, altura = height,
         color_pelo = eye_color, color_piel = skin_color,
         color_pelo = hair_color) |> 
  relocate(color_pelo, .after = nombre)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Con los datos originales, comprueba cuÃ¡ntas modalidades Ãºnicas hay en la variable de color de pelo.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  distinct(hair_color) |> 
  nrow()
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Del dataset original, selecciona solo las variables numÃ©ricas y de tipo texto. Tras ello define una nueva variable llamada `under_18` que nos recategorice la variable de edad: `TRUE` si es menor de edad y `FALSE` en caso contrario

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(where(is.numeric) | where(is.character)) |> 
  mutate(under_18 = birth_year < 18)
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Del dataset original, crea una nueva columna llamada `auburn` (cobrizo/caoba) que nos diga TRUE si el color de pelo contiene dicha palabra y FALSE en caso contrario (reminder `str_detect()`).

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(auburn = str_detect(hair_color, "auburn"))
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Del dataset original, incluye una columna que calcule el IMC. Tras ello, crea una nueva variable que valga `NA` si no es humano, `delgadez` por debajo de 18, `normal` entre 18 y 30, `sobrepeso` por encima de 30.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(IMC = mass / ((height/100)^2),
         IMC_recat = case_when(species != "Human" ~ NA,
                               IMC < 18 ~ "delgadez",
                               IMC < 30 ~ "normal",
                               TRUE ~ "sobrepeso"),
         .after = name)
```

:::

---

## ğŸ£ Caso prÃ¡ctico 8 {#caso8}


Haciendo uso de todo lo aprendido, vamos a proceder a [**crear una tabla con datos de bebÃ©s**]{.hl-yellow} de tamaÃ±o `n = 20` en donde [**simulemos el sexo de los bebÃ©s y su peso**]{.hl-yellow}

. . .

1. Crea un `tibble` con dos columnas, una llamada `id_bebe` y otra llamada `sexo`. En el primer caso debe ir de 1 a 20. En el segundo caso, simula su sexo de manera que haya un 0.5 de probabilidad de `chico` y 0.5 de `chica`.

. . .

2. Conocido el sexo, crea una tercera columna llamada `peso` en la que simules dicho valor. Supondremos que para los chicos el peso sigue una distribuciÃ³n $N(\mu = 3.266kg, \sigma = 0.514)$ y que para las chicas sigue una distribuciÃ³n $N(\mu = 3.155kg, \sigma = 0.495)$.




---


## Contar: count()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
:::

Hasta ahora solo hemos transformado o consultado los datos pero no hemos generado estadÃ­sticas. Empecemos por lo sencillo: [**Â¿cÃ³mo contar (frecuencias)?**]{.hl-yellow}

. . .

Cuando lo usamos en solitario `count()` nos devolverÃ¡ simplemente el nÃºmero de registros , pero cuando lo usamos con variables `count()` calcula lo que se conoce como [**frecuencias**]{.hl-yellow}: [**nÃºmero de elementos de cada modalidad**]{.hl-purple}.

```{r}
starwars |> count(sex)
```

---

## Contar: count()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
:::

AdemÃ¡s si pasamos varias variables nos calcula lo que se conoce como una [**tabla de contigencia**]{.hl-yellow}. Con `sort = TRUE` nos devolverÃ¡ el [**conteo ordenado**]{.hl-purple} (mÃ¡s frecuentes primero).

```{r}
starwars |> count(sex, gender, sort = TRUE)
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Una de las [**funciones mÃ¡s potentes**]{.hl-yellow} a combinar con las acciones vistas es `group_by()`, que nos permitirÃ¡ [**agrupar nuestros registros**]{.hl-yellow} previamente

```{r}
starwars |> 
  group_by(sex) |>
  count() |>
  ungroup()
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Cuando apliquemos `group_by()` es importante entender que [**NO MODIFICA los datos**]{.hl-yellow}, sino que nos crea una [**variable de grupo**]{.hl-yellow} (subtablas por cada grupo) que modificarÃ¡ las acciones futuras: las [**operaciones se aplicarÃ¡n a cada subtabla por separado**]{.hl-purple}

. . .

Por ejemplo, imaginemos que queremos extraer el personaje mÃ¡s alto con `slice_max()`.

```{r}
starwars |> slice_max(height)
```


---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Â¿Y si queremos [**extraer el personaje mÃ¡s alto pero...de cada uno de los sexos**]{.hl-yellow}?

. . .

```{r}
starwars |>
  group_by(sex) |> 
  slice_max(height) |> 
  ungroup()
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

::: columns
::: {.column width="50%"}
![](img/tidydatatutor_1.jpg)
:::

::: {.column width="50%"}
![](img/tidydatatutor_2.jpg)
:::
:::

La web <https://tidydatatutor.com/> permite visualizar las operaciones de `{tidyverse}` (con el pipe antiguo)

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |>
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |>
  ungroup()
```
:::
:::

::: callout-important
## Importante

Recuerda siempre [**hacer ungroup**]{.hl-red} para eliminar la variable de grupo creada
:::

. . .

En la nueva versiÃ³n de `{dplyr}` ahora se [**permite incluir la variable de grupo**]{.hl-yellow} en la llamada a muchas funciones con el argumento `by = ...` o `.by = ...`

```{r}
#| eval: false
starwars |> slice_max(height, by = sex)
```

```{r}
#| echo: false
starwars |> slice_max(height, by = sex) |> select(name:eye_color)
```

---

## Fila-a-fila: rowwise()

Una opciÃ³n muy Ãºtil usada antes de una operaciÃ³n tambiÃ©n es `rowwise()`: toda [**operaciÃ³n que venga despuÃ©s se aplicarÃ¡ en cada fila por separado**]{.hl-yellow}. Por ejemplo, vamos a definir un conjunto dummy de notas.

```{r}
notas <- tibble("mates" = c(7.5, 8, 9.1, 3),
                "lengua" = c(8, 6, 6.5, 9.2))
```

. . .

Si aplicamos la media directamente el valor serÃ¡ idÃ©ntico ya que nos ha hecho la media global, pero nos gustarÃ­a sacar una [**media por registro**]{.hl-yellow}. Para eso usaremos `rowwise()`

```{r}
notas |> 
  rowwise() |> 
  mutate(media_curso = mean(c(mates, lengua)))
```

---

## Resumir: summarise()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
:::

Por Ãºltimo tenemos `summarise()`, que nos permitirÃ¡ sacar resÃºmenes estadÃ­sticos. Por ejemplo, vamos a [**calcular la media de las alturas**]{.hl-yellow}.

```{r}
starwars |> 
  drop_na(height) |> 
  summarise(media_altura = mean(height))
```

. . .

::: callout-warning
## Cuidado

FÃ­jate que `mutate()` devuelve [**tantas filas como registros originales**]{.hl-yellow}, mientras que con `summarise()` calcula un [**nuevo dataset de resumen**]{.hl-purple}, solo incluyendo aquello que estÃ© indicado.
:::

---

## Resumir: summarise()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
:::

Si ademÃ¡s esto lo [**combinamos con la agrupaciÃ³n**]{.hl-yellow} de `group_by()` o `.by = ...`, en pocas lÃ­neas de cÃ³digo puedes obtener [**estadÃ­sticas desagreagadas**]{.hl-purple}

```{r}
starwars |> 
  drop_na(sex, height, mass) |> 
  summarise(media_altura = mean(height),
            media_peso = mean(mass),
            .by = sex)
```

---

## Resumir: reframe()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> reframe()
```
:::
:::

En el nuevo `{dplyr}` han incluido `reframe()` para evitar problemas de `summarise()` cuando [**devolvemos mÃ¡s de un valor por variable**]{.hl-yellow}.

::: columns
::: {.column width="50%"}
```{r}
#| warning: true
starwars |>
  drop_na(mass) |>
  summarise(quantile(mass))
```
:::

::: {.column width="50%"}
```{r}
starwars |>
  drop_na(mass) |>
  reframe(quantile(mass))
```
:::
:::

---

## Selectores: across()

Un truco es [**hacer uso de selectores**]{.hl-yellow} `across()` y `where()`. El primero nos permite [**actuar sobre varias columnas por nombre**]{.hl-purple} (con `mutate()` o `summarise()`)

```{r}
starwars |> summarise(medias = across(height:mass, mean, na.rm = TRUE), .by = sex)
```

. . .

El segundo, `where()`, nos permite hacer lo mismo pero [**seleccionando por tipo**]{.hl-yellow}.

```{r}
starwars |> 
  summarise(across(where(is.numeric), mean, na.rm = TRUE), .by = c(sex, gender))
```

---

## ğŸ’» Tu turno {#tu-turno-8b}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Calcula cuÃ¡ntos personajes hay de cada especie, ordenados de mÃ¡s a menor frecuencia.

```{r}
#| code-fold: true
#| eval: false
starwars |> count(species, sort = TRUE)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Tras eliminar ausentes en las variables de peso y estatura, aÃ±ade una nueva variable que nos calcule el IMC de cada personaje, y determina el IMC medio de nuestros personajes desagregada por sexo

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass, height) |> 
  mutate(IMC = mass / ((height/100)^2)) |> 
  summarise(IMC_medio = mean(IMC), .by = sex)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ ObtÃ©n el personaje mÃ¡s joven por cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  slice_min(birth_year, by = sex)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ ObtÃ©n la edad del personaje mÃ¡s joven y mÃ¡s viejo de cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(birth_year) |>
  summarise(min(birth_year), max(birth_year), .by = sex)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Determina la cantidad de personajes en cada dÃ©cada (echa un vistazo a `round()`, primero sin desagregar y luego desagregado por sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  count(birth_decade = round(birth_year, -1))
```
:::

# Clase 9: repaso e intro a funciones {#clase-9-funciones}

[**Â¿QuÃ© es una funciÃ³n? Â¿CÃ³mo se definen?**]{style="color:#444442;"}

## ğŸ£ Caso prÃ¡ctico 9 {#caso9}

Vamos antes a hacer un [**repaso de lo aprendido**]{.hl-yellow} en `{tidyverse}`

1. Carga la tabla billboard del paquete `{tidyr}`.

```{r}
#| code-fold: true
#| eval: false
billboard
```

. . .

2. Antes de nada, selecciona solo las [**primeras 52 semanas**]{.hl-yellow}. Tras ello convierte el dataset a [**tidydata**]{.hl-yellow} con los formatos y tipos adecuados para cada variable

```{r}
#| code-fold: true
#| eval: false
billboard_tidy <-
  billboard |> 
  select(artist:date.entered, wk1:wk52) |> 
  pivot_longer(cols = wk1:wk52,
               names_to = "week",
               values_to = "rank",
               values_drop_na = TRUE,
               names_prefix = "wk") |> 
  mutate(week = as.numeric(week))
```

. . .

3. Extrae la [**lista de artistas distintos**]{.hl-yellow} que aparecen en la tabla, incluyendo [**cuÃ¡ntas veces**]{.hl-yellow} aparece cada uno.

```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  count(artist)
```

---

## ğŸ£ Caso prÃ¡ctico 9


4. Determina [**cuÃ¡ntas canciones tiene cada artistal**]{.hl-yellow}

```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  distinct(artist, track) |> 
  count(artist)
```

. . .

5. Determina las [**5 canciones que mÃ¡s semanas**]{.hl-yellow} aparecen en la lista de Ã©xitos. 
```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  count(track) |> 
  slice_max(n = 5, n)
```

. . .

6. Determina [**para cada artista la canciÃ³n que mÃ¡s semanas**]{.hl-yellow} aparece en la lista de Ã©xitos. 

```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  count(artist, track) |> 
  slice_max(n = 1, n, by = artist)
```


---

## ğŸ£ Caso prÃ¡ctico 9

7. Determina el [**artista con mÃ¡s canciones**]{.hl-yellow} en la lista


```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  distinct(artist, track) |> 
  count(artist) |> 
  slice_max(n = 1, n)
```

. . .

8. Calcula la [**posiciÃ³n mÃ¡s alta**]{.hl-yellow} en la que ha estado cada canciÃ³n. Calcula la posiciÃ³n mÃ¡s alta en la que ha estado un artista


```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  slice_min(rank, n = 1, with_ties = FALSE, by = track)
```

```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  slice_min(rank, n = 1, with_ties = FALSE, by = artist)
```

---

## ğŸ£ Caso prÃ¡ctico 9

9. ObtÃ©n una [**tabla resumen**]{.hl-yellow} con el ranking medio de cada artista (contando solo el ranking mÃ¡s alto alcanzado por sus canciones), asÃ­ como el nÃºmero de canciones (distintas) que ha colocado en el top 100.


```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  slice_min(rank, n = 1, with_ties = FALSE, by = track) |> 
  summarise(avg_rank = mean(rank), n_songs = n(), .by = artist)
```

. . .

10. Realiza un muestreo aleatorio estratificado, extrayendo el 50% de los datos pero manteniendo la proporciÃ³n de datos entre los distintos cuatrimestres.


```{r}
#| code-fold: true
#| eval: false
billboard_tidy |> 
  mutate(quarter = quarter(date.entered)) |> 
  slice_sample(prop = 0.5, by = quarter)
```


---

## Creando funciones

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, ademÃ¡s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**.

Â¿CÃ³mo [**crear nuestra propia funciÃ³n**]{.hl-purple}? Veamos su **esquema bÃ¡sico**:

. . .

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraÃ±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

. . .

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

. . .

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
}
```

---

## Creando funciones

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, ademÃ¡s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**.

Â¿CÃ³mo [**crear nuestra propia funciÃ³n**]{.hl-purple}? Veamos su **esquema bÃ¡sico**:


* [**Cuerpo**]{.hl-yellow} de la funciÃ³n dentro de `{ }`.

. . .

* Finalizamos la funciÃ³n con los [**argumentos de salida**]{.hl-yellow} con `return()`.


```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # CÃ³digo que queramos ejecutar
  cÃ³digo
  
  # Salida
  return(var_salida)
}
```


---

## Creando funciones

* `arg1, arg2, ...`: serÃ¡n los [**argumentos de entrada**]{.hl-yellow}, los argumentos que toma la funciÃ³n para ejecutar el cÃ³digo que tiene dentro

* `cÃ³digo`: lÃ­neas de cÃ³digo que queramos que [**ejecute la funciÃ³n**]{.hl-yellow}. 

* `return(var_salida)`: se introducirÃ¡n los [**argumentos de salida**]{.hl-yellow}.


```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # CÃ³digo que queramos ejecutar
  cÃ³digo
  
  # Salida
  return(var_salida)
}
```

::: callout-important
## Importante

Todas las variables que definamos dentro de la funciÃ³n son [**variables locales: solo existirÃ¡n dentro de la funciÃ³n**]{.hl-yellow} salvo que especifiquemos lo contrario.

:::

---

## Creando funciones

Veamos un ejemplo muy simple de funciÃ³n para [**calcular el Ã¡rea de un rectÃ¡ngulo**]{.hl-yellow}.

. . .

Dado que el Ã¡rea de un rectÃ¡ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serÃ¡n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} serÃ¡ justo su **Ã¡rea** ($lado_1 * lado_2$).

. . .

```{r}
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  return(area)
  
}
```

---

## Creando funciones


TambiÃ©n podemos hacer una definiciÃ³n directa, **sin almacenar variables por el camino**.

```{r}
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  return(lado_1 * lado_2)
  
}
```


[**Â¿CÃ³mo aplicar la funciÃ³n?**]{.hl-yellow}

```{r}
calcular_area(5, 3) # Ã¡rea de un rectÃ¡ngulo 5 x 3 
calcular_area(1, 5) # Ã¡rea de un rectÃ¡ngulo 1 x 5
```

---

## Argumentos por defecto

Imagina ahora que nos damos cuenta que el 90% de las veces usamos dicha funciÃ³n para [**calcular por defecto el Ã¡rea de un cuadrado**]{.hl-yellow} (es decir, solo necesitamos un lado). Para ello, podemos definir [**argumentos por defecto**]{.hl-yellow} en la funciÃ³n: tomarÃ¡n dicho valor salvo que le asignemos otro.

Â¿Por quÃ© no asignar `lado_2 = lado_1` por defecto, para ahorrar lÃ­neas de cÃ³digo y tiempo?

. . .

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

---

## Argumentos por defecto


```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```


Ahora [**por defecto**]{.hl-yellow} el segundo lado serÃ¡ igual al primero (si se lo aÃ±adimos usarÃ¡ ambos).


```{r}
calcular_area(lado_1 = 5) # cuadrado
calcular_area(lado_1 = 5, lado_2 = 7) # rectÃ¡ngulo
```

---
 
## Salida mÃºltiple

Compliquemos un poco la funciÃ³n y aÃ±adamos en la salida los valores de cada lado, etiquetados como `lado_1` y `lado_2`, [**empaquetando la salida en una lista**]{.hl-yellow}.

```{r}
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```


# Clase 10: profundizando funciones {#clase-10}

[**Â¿QuÃ© es una funciÃ³n? Â¿CÃ³mo se definen? Variables locales vs globlales. IntroducciÃ³n a listas**]{style="color:#444442;"}


---

## Funciones en R

Repasando el Ãºltimo dÃ­a...

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

. . .

```{r}
salida <- calcular_area(5, 3)
salida["area"]
salida["lado_1"]
```

. . .

::: callout-important
## Importante

Todas las variables que definamos dentro de la funciÃ³n son [**variables locales: solo existirÃ¡n dentro**]{.hl-yellow}

:::

---

## IntroducciÃ³n a listas

Veamos un pequeÃ±o resumen de los datos que ya conocemos:

* [**vectores**]{.hl-yellow}: colecciÃ³n de elementos de igual tipo. Pueden ser nÃºmeros, caracteres o valores lÃ³gicos, entre otros.

* [**matrices**]{.hl-yellow}: colecciÃ³n BIDIMENSIONAL de elementos de igual tipo e igual longitud.

* [**data.frame / tibble**]{.hl-yellow}: colecciÃ³n BIDIMENSIONAL de elementos de igual longitud pero de cualquier tipo.

. . .

Las [**listas**]{.hl-yellow} serÃ¡n [**colecciones de variables de diferente tipo y diferente longitud**]{.hl-purple}, con estructuras totalmente heterÃ³geneas (incluso una lista puede tener dentro a su vez otra lista).

---

## IntroducciÃ³n a listas


Vamos a crear [**nuestra primera lista**]{.hl-yellow} con `list()` con tres elementos: el nombre de nuestros padres/madres, nuestro lugar de nacimiento y edades de nuestros hermanos.

```{r}
variable_1 <- c("Paloma", "Gregorio")
variable_2 <- "Madrid"
variable_3 <- c(25, 30, 26)

lista <- list("progenitores" = variable_1, "lugar_nacimiento" = variable_2,
              "edades_hermanos" = variable_3)
lista
```

---

## IntroducciÃ³n a listas

```{r}
length(lista)
```

Si observas el objeto que hemos definido como lista, su [**longitud**]{.hl-yellow} del es de 3 ya que tenemos **guardados tres elementos**: un vector de caracteres (de longitud 2), un caracter (vector de longitud 1), y un vector de nÃºmeros (de longitud 3)

. . .

Tenemos guardados elementos de [**distinto tipo**]{.hl-yellow} (algo que ya podÃ­amos hacer) pero, ademÃ¡s, de **longitudes dispares**.

```{r}
dim(lista) # devolverÃ¡ NULL al no tener dos dimensiones
class(lista) # de tipo lista
```

---

## IntroducciÃ³n a listas

Si los juntÃ¡semos con un `tibble()`, al tener distinta longitud, obtendrÃ­amos un [**error**]{.hl-red}.

```{r}
#| error: true
library(tibble)
tibble("progenitores" = variable_1,
       "lugar_nacimiento" = variable_2,
       "edades_hermanos" = variable_3)
```

---


## IntroducciÃ³n a listas

* [**Acceder por Ã­ndice**]{.hl-yellow}: con el operador `[[i]]` accedemos al **elemento i-Ã©simo** de la lista.

```{r}
lista[[1]]
```

. . .

* [**Acceder por nombre**]{.hl-yellow}: con el operador `$nombre_elemento` accedemos por su nombre.

```{r}
lista$progenitores
```

. . .

En contraposiciÃ³n, el [**corchete simple**]{.hl-yellow} nos permite acceder a [**varios elementos**]{.hl-yellow} a la vez

```{r}
# Varios elementos
lista[1:2]
```

---

## Salida mÃºltiple

Antes nos daba igual el orden de los argumentos pero ahora el [**orden de los argumentos de entrada importa**]{.hl-yellow}, ya que en la salida incluimos `lado_1` y `lado_2`. 

. . .

::: callout-note
## RecomendaciÃ³n

Es altamente recomendable hacer la llamada a la funciÃ³n [**indicando explÃ­citamente los argumentos**]{.hl-yellow} para mejorar la **legibilidad e interpretabilidad**.

```{r}
# Equivalente a calcular_area(5, 3)
calcular_area(lado_1 = 5, lado_2 = 3)
```

:::

---

## Funciones: generando conocimiento

Parece una tonterÃ­a lo que hemos hecho pero hemos cruzado una frontera importante: hemos pasado de [**consumir conocimiento**]{.hl-yellow} (cÃ³digo de otros paquetes, elaborado por otros/as), a [**generar conocimiento**]{.hl-purple}, creando nuestras propias funciones.

---

## Variables locales vs globales

Un aspecto importante sobre el que reflexionar con las funciones: Â¿quÃ© sucede si [**nombramos a una variable dentro**]{.hl-yellow} de una funciÃ³n a la que se nos ha **olvidado asignar** un valor dentro de la misma?

. . .

Debemos ser cautos al usar funciones en `R`, ya que debido a la [**Â«regla lexicogrÃ¡ficaÂ»**]{.hl-yellow}, si una variable no se define dentro de la funciÃ³n, `R` [**buscarÃ¡ dicha variable en el entorno**]{.hl-purple} de variables.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  print(x) # No devuelve nada, solo realiza la acciÃ³n 
}
funcion_ejemplo()
```

---

## Variables locales vs globales

Si una variable  [**ya estÃ¡ definida fuera de la funciÃ³n (entorno global)**]{.hl-yellow}, y ademÃ¡s es usada dentro de cambiando su valor, el valor [**solo cambia dentro**]{.hl-yellow} pero [**no en el entorno global**]{.hl-red}.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  x <- 2
  print(x) # lo que vale dentro
}
```

```{r}
# lo que vale dentro
funcion_ejemplo() #<<
# lo que vale fuera
print(x) #<<
```

---

## Variables locales vs globales


Si queremos que ademÃ¡s de cambiar localmente lo haga [**globalmente**]{.hl-yellow} deberemos usar la [**doble asignaciÃ³n**]{.hl-yellow} (`<<-`).

```{r}
x <- 1
y <- 2
funcion_ejemplo <- function() {
  
  # no cambia globalmente, solo localmente
  x <- 3 
  # cambia globalmente
  y <<- 0 #<<
  
  print(x)
  print(y)
}

funcion_ejemplo() # lo que vale dentro
x # lo que vale fuera
y # lo que vale fuera
```

---


## ğŸ’» Tu turno {#tu-turno-9}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para definir una funciÃ³n llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.

```{r}
#| eval: false
nombre <- function(x, y) {
  suma <- # cÃ³digo a ejecutar
  return()
}
# Aplicamos la funciÃ³n
suma(3, 7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_suma <- function(x, y) {
  suma <- x + y
  return(suma)
}
funcion_suma(3, 7)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para definir una funciÃ³n llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado

```{r}
#| eval: false
nombre <- function(x, y) {
  producto <- # cÃ³digo de la multiplicaciÃ³n
  return()
}
producto(3)
producto(3, -7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_producto <- function(x, y = x) {
  producto <- x * y
  return(producto)
}
funcion_producto(3)
funcion_producto(3, -7)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Define una funciÃ³n llamada `igualdad_nombres` que, dados dos nombres, nos diga si son iguales o no. Hazlo considerando importantes las mayÃºsculas, y sin que importen las mayÃºsculas. Echa un vistazo al paquete `{stringr}`.

```{r}
#| code-fold: true
#| eval: false
# Distinguiendo mayÃºsculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "LucÃ­a")

# Sin importar mayÃºsculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(toupper(persona_1) == toupper(persona_2))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "LucÃ­a")
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Crea una funciÃ³n llamada `calculo_IMC` que, dados dos argumentos (peso y estatura en metros) y un nombre, devuelva una lista con el IMC y el nombre.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura) {
  
  return(list("nombre" = nombre, "IMC" = peso/(estatura^2)))
}
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Repite el ejercicio anterior pero con otro argumento opcional que se llame unidades (por defecto, `unidades = "metros"`). Desarrolla la funciÃ³n de forma que haga lo correcto si `unidades = "metros"` y si `unidades = "centÃ­metros"`.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  
  return(list("nombre" = nombre,
              "IMC" = peso/(if_else(unidades == "metros", estatura, estatura/100)^2)))
}
```

 
### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Crea un tibble ficticio de 7 personas, con tres variables (inventa nombre, y simula peso, estatura en centÃ­metros), y aplica la funciÃ³n definida de forma que obtengamos una cuarta columna con su IMC.

```{r}
#| code-fold: true
#| eval: false
datos <-
  tibble("nombres" = c("javi", "sandra", "laura",
                       "ana", "carlos", "leo", NA),
         "peso" = rnorm(n = 7, mean = 70, sd = 1),
         "estatura" = rnorm(n = 7, mean = 168, sd = 5))

datos |> 
  mutate(IMC = calculo_IMC(nombres, peso, estatura, unidades = "centÃ­metros")$IMC)
```


:::


---

## ğŸ£ Caso prÃ¡ctico 10: funciones {#caso10a}

Define una funciÃ³n llamada `conversor_temperatura` que, dada una temperatura en Fahrenheit, Celsius o Kelvin, la convierta a cualquiera de las otras (piensa que argumentos necesita el usuario). Aplica la funciÃ³n a la columna `Temp` del conjunto `airquality`, e incorpÃ³rala al fichero en una nueva columna `Temp_Celsius`.

---

## ğŸ£ Caso prÃ¡ctico 10: tidyverse {#caso10b}


Acude a <https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos> e importa  `casos_hosp_uci_def_sexo_edad_provres.csv`. DocumentaciÃ³n en <https://cnecovid.isciii.es/covid19/resources/metadata_casos_hosp_uci_def_sexo_edad_provres.pdf>

. . .

1. Â¿CuÃ¡ntos casos hay notificados para edad desconocida? Â¿Y desagregado por sexo? Recodifica adecuadamente las provincias

. . .

2. Dado su escaso peso en el total, genera una nueva base de datos en la que borremos aquellos registros con franja de edad desconocida. 

. . .


3. Con la base de datos generada en el ejercicio anterior, calcula la proporciÃ³n de casos con sexo desconocido. Haz lo mismo con provincia desconocida. Elimina dichos registros si el nÃºmero de casos representa menos del 1% (para cada una).


---

## ğŸ£ Caso prÃ¡ctico 10: tidyverse


4. Del dataset anterior, elimina la variables de hospitalizados y UCI. Tras ello renombra las columnas de casos y fallecidos por `casos_diarios` y `fallec_diarios`, respectivamente. Tras ello crea dos nuevas variables llamadas `casos_acum` y otra `fallec_acum`, que contengan los casos acumulados y fallecidos acumulados para cada fecha, desagregados por provincia, tramo etario y sexo.

. . .

5. Â¿CuÃ¡les fueron las 7 provincias con mÃ¡s casos a lo largo de toda la pandemia? Â¿Y las 5 provincias con menos fallecidos? Â¿Y si lo desagregamos por sexo?

---

## ğŸ£ Caso prÃ¡ctico 10: tidyverse

6. Define una funciÃ³n llamada `calculo_letalidad()` que, dados como argumentos un vector ordenado (por fecha) de casos y otro de fallecidos, devuelva el % de casos que han fallecido, de manera acumulada en cada fecha. Haz uso de dicha funciÃ³n y crea una nueva variable que represente la letalidad, en cada grupo de edad, sexo y provincia.

Tras ello, determina las 5 provincias con mayor letalidad en mujeres mayores de 80 aÃ±os a fecha 01 de marzo de 2022.


# Clase 11: entrega II

[**Segunda entrega individual en clase**]{style="color:#444442;"}

---

## Entrega II

Se actualizarÃ¡ al inicio de la clase correspondiente.

::: callout-important

## Importante

Esta [**entrega ponderarÃ¡ un 15% en la nota final**]{.hl-green}

PodrÃ¡s [**usar todo el material del curso e internet**]{.hl-yellow} salvo cualquier aplicaciÃ³n de mensajerÃ­a o sistema de comunicaciÃ³n: en caso de tener alguna abierta a lo largo de la entrega, aunque no se estÃ© usando, deberÃ¡s [**abandonar la entrega y contarÃ¡ como un 0**]{.hl-red}.

ContarÃ¡s en clase con aproximadamente 1 hora y 50 minutos, pero [**podrÃ¡s realizar la entrega**]{.hl-yellow}, como tarde, hasta las [**18:00**]{.hl-yellow}. SerÃ¡ [**obligatorio subir tanto el `.qmd` como el `.html`**]{.hl-yellow}: una entrega que no haya podido ser renderizada (es decir, con errores graves) serÃ¡ [**penalizada contando solo un 65% de la nota obtenida**]{.hl-red} (si la entrega es perfecta, la nota mÃ¡xima serÃ¡ un 6.5 sino se adjunta el `.html` generado).

Te recomiendo practicar bastante y preguntar dudas en clase y/o tutorÃ­a ya que [**irÃ¡s justo de tiempo**]{.hl-yellow}, asÃ­ que necesitas fluidez en los ejercicios.

Si usas un [**pc de la biblioteca**]{.hl-yellow} asegÃºrate de tomarlo con suficiente antelaciÃ³n para [**instalar todas las librerÃ­as necesarias antes de empezar**]{.hl-yellow} para no perder tiempo.

[**Evita copiar**]{.hl-red}: la IA detecta bastante bien el plagio :)

:::

# Clase 12: inicio a la visualizaciÃ³n {#clase-12-dataviz}

[**VisualizaciÃ³n de datos**]{style="color:#444442;"}


---

## Dataviz: historia


La apariciÃ³n de grÃ¡ficos estadÃ­sticos es [**relativamente reciente en la ciencia**]{.hl-yellow} ya que hasta la Edad Media la Ãºnica visualizaciÃ³n estaba en los [**mapas**]{.hl-yellow}. [^1] Las propias palabras _chart_ y _cartography_ derivan del mismo origen latino, _charta_, aunque el primer uso de coordenadas viene de los egipcios. [^2] [^3]

. . .

:::: columns
::: {.column width="55%"}

No es hasta la Edad Media, cuando la [**navegaciÃ³n y la astronomÃ­a**]{.hl-yellow} empezaban a tomar relevancia, cuando aparece la primera grÃ¡fica (no propiamente estadÃ­stica), del **movimiento cÃ­clico de los planetas** (siglos X y XI)

:::

::: {.column width="45%"}
![](img/dataviz_historico_1.png){width="370"}
:::
::::
 

[^1]: [Â«GramÃ¡tica de las grÃ¡ficas: pistas para mejorar las representaciones de datosÂ» de JoaquÃ­n Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)

[^2]: [Â«Presentation GraphicsÂ» de Leland Wilkinson. International Encyclopedia of the Social & Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

[^3]: [Â«Quantitative Graphics in Statistics: A Brief HistoryÂ» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)]


---

## NavegaciÃ³n y astronomÃ­a


Con una motivaciÃ³n similar, en torno a 1360 el matemÃ¡tico **Nicole Oresme** diseÃ±Ã³ el [**primer grÃ¡fico de barras**]{.hl-yellow} (pero no estadÃ­stico), con la idea de visualizar a la vez dos **magnitudes fÃ­sicas teÃ³ricas**. [^4]


![](img/dataviz_historico_2.jpeg){width="300"}


[^4]: [Â«The First (Known) Statistical Graph: Michael Florent van Langren and the 'Secret' of LongitudeÂ» de M. Friendly y P. M. Valero-Mora. The American Statistician (2010)](https://www.researchgate.net/publication/227369016_The_First_Known_Statistical_Graph_Michael_Florent_van_Langren_and_the_Secret_of_Longitude)

 
---

## Primer grÃ¡fico estadÃ­stico

La mayorÃ­a de expertos, como Tufte [^5] [^6], consideran este grÃ¡fico casi longitudinal como la [**primera visualizaciÃ³n de datos**]{.hl-yellow} de la historia, hecha por **Van Langren** en 1644, representando la [**distancia entre Toledo y Roma**]{.hl-yellow}.


```{r}
#| echo: false
knitr::include_graphics("./img/longitud_dataviz.jpg")
``` 

```{r}
#| echo: false
knitr::include_graphics("./img/dataviz_historico_3.jpeg")
``` 


[^5]: [Â«Visual explanations: images and quantities, evidence and narrativeÂ» de E. Tufte](https://archive.org/details/visualexplanatio00tuft)

[^6]: [Â«PowerPoint is evilÂ» de E. Tufte](https://www.wired.com/2003/09/ppt2/)

---

## Â¿QuÃ© es una dataviz?


Â¿Es una grÃ¡fica estadÃ­stica? Â¿Por quÃ© sÃ­ o por quÃ© no?


![](img/cuadro_dataviz.jpg)


. . .

No hay [**ninguna INFORMACIÃ“N**]{.hl-red} representada


---

## Â¿QuÃ© es una dataviz?


Â¿Es una grÃ¡fica estadÃ­stica? Â¿Por quÃ© sÃ­ o por quÃ© no?

![](img/horoscopo_dataviz.jpg)

. . .

No hay [**ningÃºn PROCESO DE MEDIDA**]{.hl-red} representado, no cuantifica nada (real).


---

## Â¿QuÃ© es una dataviz?

Â¿Es una grÃ¡fica estadÃ­stica? Â¿Por quÃ© sÃ­ o por quÃ© no?

![](img/celsius_dataviz.jpg)

. . .

No hay [**ningÃºn DATO**]{.hl-red} representado en Ã©l, es una magnitud fÃ­sica teÃ³rica, no un dato (medido empÃ­ricamente o simulado).


---

## Â¿QuÃ© es una dataviz?

Esas mismas preguntas se hizo **JoaquÃ­n Sevilla** [^1], proporcionando [**3 requisitos**]{.hl-yellow}:

. . .

1. Que se base en el esquema de composiciÃ³n de [**eje mÃ©trico**]{.hl-yellow} (proceso de medida): debe [**medir algo**]{.hl-yellow}.

. . .

2. Debe incluir [**informaciÃ³n estadÃ­stica (datos)**]{.hl-yellow}

. . .
 
3. La  [**relaciÃ³n de representatividad**]{.hl-yellow} debe ser [**reversible**]{.hl-purple}: los datos deberÃ­an poder Â«recuperarseÂ» a partir de la grÃ¡fica .



[^1]: [Â«GramÃ¡tica de las grÃ¡ficas: pistas para mejorar las representaciones de datosÂ» de JoaquÃ­n Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)

---

## AboliciÃ³n de tartas

Hay muchas formas de hacer una grÃ¡fica estadÃ­stica, y no suele pasar por un [**grÃ¡fico de tartas**]{.hl-yellow} ya que tienen un grave [**problema de reversibilidad**]{.hl-red}:

. . .

:::: columns
::: {.column width="50%"}
* Si hay **muchas variables**: salvo que tengas transportador de Ã¡ngulos...

* Si hay **pocas variables**: Â¿aporta algo distinto (y/o mejor) que una tabla?

:::

::: {.column width="50%"}
![](img/sectores_muchas_categoriÌas.png)
:::
::::

---

## AboliciÃ³n de tartas


El principal problema de un diagrama de sectores es que la posible informaciÃ³n estÃ¡ [**contenida en los Ã¡ngulos**]{.hl-yellow}, pero nuestra interpretaciÃ³n la realizamos a travÃ©s de la [**comparaciÃ³n de Ã¡reas**]{.hl-yellow} (nuestros ojos no miden bien Ã¡ngulos), las cuales dependen no solo del Ã¡ngulo sino del radio.

&nbsp;

Algo similar sucede con los mal llamados [**grÃ¡ficos tridimensionales**]{.hl-yellow} (son bidimensionales con perspectiva en realidad): los valores mÃ¡s cercanos aparecen sobredimensionados, siendo prÃ¡cticamente imposible la reversibilidad por la [**distorsiÃ³n**]{.hl-yellow}.


---

## Vizfails

::: columns
::: {.column width="55%"}
![](img/persona_dataviz.jpg)
:::

::: {.column width="45%"}
* La figura elegida (persona caminando) sin relaciÃ³n con lo visualizado: [**mala metÃ¡fora**]{.hl-red}.

* Los [**sectores seÃ±alados sin relaciÃ³n con el Ã­tem**]{.hl-red} a representar, lo que dificulta su interpretaciÃ³n.

* Los [**colores sin codificar**]{.hl-red}: no dan informaciÃ³n de ningÃºn tipo.

* Las [**formas irregulares impiden la comparaciÃ³n**]{.hl-red} de las Ã¡reas (amÃ©n de que la suma total supera el 100%).

* **Sin fuente**

:::
::::


---

## Vizfails

![](img/viz_fail_covid.jpg)

---

## Vizfails

![](img/viz_fail_uk.jpg)

---

## La importancia del CONTEXTO

Una **buena idea** puede estar mal ejecutada: la forma de llevarla a cabo es importante

![](img/semaforos.jpg)

---

## Dataviz: historia

En el siglo XVII hubo un boom de la estadÃ­stica al empezar a aplicarse en [**demografÃ­a**]{.hl-yellow}. Uno de los autores mÃ¡s importantes fue [**J. Graunt**]{.hl-purple}, autor de Â«Natural and Political Observations Made upon the Bills of MortalityÂ» (1662), estimando la poblaciÃ³n de Londres con las [**primeras tablas de natalidad y mortalidad**]{.hl-yellow}.

. . .

::: columns
::: {.column width="50%"}

Son precisamente las tablas de Graunt las que usÃ³ [**Christiaan Huygens**]{.hl-yellow} para generar la [**primera grÃ¡fica de densidad**]{.hl-yellow} de una distribuciÃ³n continua (esperanza de vida vs edad).

:::

::: {.column width="50%"}

```{r echo = FALSE,  out.width = "100%", fig.align = "center", fig.cap = "Primera funciÃ³n de densidad, extraÃ­da de https://omeka.lehigh.edu/exhibits/show/data_visualization/vital_statistics/huygen"}
knitr::include_graphics("./img/primera_densidad.jpg")
``` 

:::
::::

---

## GrÃ¡ficos de Playfair

La figura que cambiÃ³ el dataviz fue, sin lugar a dudas, el economista y polÃ­tico [**William Playfair (1759-1823)**]{.hl-yellow}, publicando en 1786 el **Â«Atlas polÃ­tico y comercialÂ»** [^11] [^12] con 44 grÃ¡ficas (43 series temporales y el diagrama de barras mÃ¡s famoso de la historia).

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "70%", fig.align = "center", fig.cap = "ExtraÃ­das de Funkhouser y Walker (1935)"}
knitr::include_graphics("./img/playfair_1.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "25%", fig.align = "center", fig.cap = "ExtraÃ­das de Funkhouser y Walker (1935)"}
knitr::include_graphics("./img/playfair_2.jpg")
``` 

:::
::::

[^10]: [Â«Atlas polÃ­tico y comercialÂ» de William Playfair (1786)](https://www.amazon.es/Playfairs-Commercial-Political-Statistical-Breviary/dp/0521855543)

[^11]: [Â«Playfair and his chartsÂ» de H. Gray Funkhouser and  Helen M. Walker (1935)](https://www.jstor.org/stable/45366440)

---


## GrÃ¡ficos de Playfair

Playfair no solo fue el primero en usar el dataviz para entender (y no solo describir): fue el primero en usar [**conceptos modernos**]{.hl-yellow} como _grid_, tema o color

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "ExtraÃ­da de https://friendly.github.io/HistDataVis"}
knitr::include_graphics("./img/playfair_3.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "ExtraÃ­da de la wikipedia."}
knitr::include_graphics("./img/playfair_4.png")
``` 

:::
::::

---

## GrÃ¡ficos de Playfair

Playfair es ademÃ¡s el autor del [**grÃ¡fico de barras mÃ¡s famoso**]{.hl-yellow} (no fue el primero pero sÃ­ quien lo hizo _mainstream_).

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "GrÃ¡ficas de Playfair de importaciones (barras grises) y exportaciones (negras) de Escocia en 1781, extraÃ­das de la wikipedia."}
knitr::include_graphics("./img/playfair_5.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "Primer diagrama de barras (P. Buache y G. de Lâ€™Isle), visualizando los niveles del Sena (1732 - 1766), extraÃ­da de https://friendly.github.io/HistDataVis"}
knitr::include_graphics("./img/playfair_6.jpg")
``` 
:::
::::

---

## GrÃ¡ficos de Playfair


Playfair ademÃ¡s fue el primero en [**combinar grÃ¡ficos en la misma visualizaciÃ³n**]{.hl-yellow} [^12] [^13]

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "85%", fig.align = "center", fig.cap = "Visualiza 3 series temporales: precios (barras) del trigo, salarios (lÃ­nea) y time-line con reinados, extraÃ­da de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/playfair_7.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "85%", fig.align = "center", fig.cap = "Time-line histÃ³rico, extraÃ­da de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/playfair_8.png")
``` 

:::
::::

[^12]: [Â«A Letter on Our Agricultural Distresses, Their Causes and RemediesÂ» de W. Playfair (1821)](http://onlinebooks.library.upenn.edu/webbin/book/lookupid?key=ha009726110)

[^13]: [Â«An Inquiry Into the Permanent Causes of the Decline and Fall of Powerful and Wealthy NationsÂ» de William Playfair (1821)](https://www.amazon.com/Permanent-Powerful-Nations-Prosperity-Prolonged/dp/140691830X)

---

## Mapas de Minard

Otro pionero en [**combinar visualizaciones**]{.hl-yellow} fue Minard, autor del famoso Â«Carte figurative des pertes successives en hommes de l'ArmÃ©e FranÃ§aise dans la campagne de Russie 1812-1813Â», segÃºn Tufte [**Â«el mejor grÃ¡fico estadÃ­stico jamÃ¡s dibujadoÂ»**]{.hl-yellow}, publicado en 1869 sobre la desastrosa campaÃ±a rusa de NapoleÃ³n en 1812 (3 variables en un grÃ¡fico bidimensional)

```{r echo = FALSE, out.width = "60%", fig.align = "center", fig.cap = "ExtraÃ­da de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/minard_2.png")
```

---

## Primer scatter plot

SegÃºn J. Sevilla, se considera al astrÃ³nomo britÃ¡nico **John Frederick William Herschel** el autor del [**primer diagrama de dispersiÃ³n o scatterplot**]{.hl-yellow} en 1833, visualizando el movimiento de la estrella doble Virginis (tiempo en el eje horizontal, posiciÃ³n angular en el eje vertical)


```{r echo = FALSE, out.width = "35%", fig.align = "center", fig.cap = "ExtraÃ­do de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/herschel.jpg")
``` 

---

## Primera pirÃ¡mide poblacional

La [**primera pirÃ¡mide de poblaciÃ³n**]{.hl-yellow} (doble histograma de poblaciÃ³n), fue publicada por **Francis Amasa Walker**, superintendente del censo de EE.UU., en 1874.

```{r echo = FALSE, out.width = "45%", fig.align = "center", fig.cap = "ExtraÃ­da de https://www.depauw.edu/learn/dew/wpaper/workingpapers/DePauw2016-02-Barreto-DemographyEconomics.pdf"}
knitr::include_graphics("./img/walker_piramide.jpg")
``` 

---

## Florence Nigthingale

::: columns
::: {.column width="65%"}


* El 21 de octubre de 1854 [**Florence Nigthingale**]{.hl-yellow} fue enviada para mejorar las **condiciones sanitarias** de los soldados britÃ¡nicos en la guerra de Crimea. 

* A su regreso demostrÃ³ que los [**soldados fallecÃ­an por las condiciones sanitarias**]{.hl-yellow}. Nigthingale es la creadora del famoso [**diagrama de rosa**]{.hl-yellow}, visualizando tres variables a la vez y su estacionalidad.

* El 8 de febrero de 1955, The Times la describiÃ³ como la **Â«Ã¡ngel guardiÃ¡nÂ» de los hospitales**, y acabÃ³ siendo conocida como [**Â«The Lady with the LampÂ»**]{.hl-yellow} tras un poema de H. W. Longfellow (1857).

* AÃ±os despuÃ©s se convirtiÃ³ en la [**primera mujer en la Royal Statistical Society**]{.hl-yellow}.

:::

::: {.column width="35%"}

```{r echo = FALSE, out.width = "95%", fig.align = "center"}
knitr::include_graphics("./img/the_lady_with_the_lamp.png")
``` 

:::
::::

---

## Diagrama de rosa

Florence Nigthingale es la creadora del famoso [**diagrama de rosa**]{.hl-yellow}, permitiendo pintar [**tres variables a la vez y su estacionalidad**]{.hl-yellow}: **tiempo** (cada **gajo** es un mes), **nÂº de muertes** (**Ã¡rea** del gajo) y **causa** de la muerte (**color** del gajo: azules enfermedades infecciosas, rojas por heridas, negras otras causas).


```{r echo = FALSE, out.width = "75%", fig.align = "center"}
knitr::include_graphics("./img/rosa_nightingale.jpg")
``` 

---


## Recursos de dataviz


ğŸ“š [Â«The Functional Art: an introduction to information graphics and visualizationÂ» de Alberto Cairo](https://www.amazon.es/Functional-Art-Voices-That-Matter/dp/0321834739)


ğŸ“š [Â«GramÃ¡tica de las grÃ¡ficas: pistas para mejorar las representaciones de datosÂ» de JoaquÃ­n Sevilla](https://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)


ğŸ“š [Â«A Brief History of VisualizationÂ» de Friendly et al. (2008)](https://www.researchgate.net/publication/226400313_A_Brief_History_of_Data_Visualization)

ğŸ“š [Â«Quantitative Graphics in Statistics: A Brief HistoryÂ» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)]

ğŸ“š [Â«Presentation GraphicsÂ» de Leland Wilkinson. International Encyclopedia of the Social & Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

ğŸ“š [Â«The Grammar of GraphicsÂ» de Leland Wilkinson](https://www.amazon.es/Grammar-Graphics-Statistics-Computing/dp/0387245448)


ğŸ“š [Â«The Minard System: The Graphical Works of Charles-Joseph MinardÂ» de Sandra Rendgen](https://www.amazon.es/gp/product/1616896337/ref=sw_img_1?smid=A1AT7YVPFBWXBL&psc=1)

ğŸ“š [Â«The Visual Display of Quantitative InformationÂ» de E. W. Tufte](https://www.amazon.es/Visual-Display-Quantitative-Information/dp/0961392142)

---

## Dataviz en R: ggplot2

:::: columns
::: {.column width="50%"}

El paquete `{ggplot2}` se basa en la idea de Wilkinson en [**Â«Grammar of graphicsÂ»**]{.hl-yellow}: dotar a los grÃ¡ficos de una gramÃ¡tica propia. Una de las principales fortalezas de `R` es la [**visualizaciÃ³n**]{.hl-yellow} con `{ggplot2}`.

```{r}
library(ggplot2)
```

La [**visualizaciÃ³n de datos**]{.hl-yellow} deberÃ­a ser una parte fundamental de todo anÃ¡lisis de datos. No es solo una cuestiÃ³n estÃ©tica.
:::

::: {.column width="50%"}
![](img/telling_dataviz.jpg){width="400"}
:::
::::

---

## Dataviz en R: ggplot2

La filosofÃ­a detrÃ¡s de `{ggplot2}` es entender los [**grÃ¡ficos como parte del flujo**]{.hl-yellow} de trabajo, dotÃ¡ndoles de una [**gramÃ¡tica**]{.hl-yellow}. El objetivo es empezar con un lienzo en blanco e ir [**aÃ±adiendo capas a tu grÃ¡fico**]{.hl-yellow}. La ventaja de `{ggplot2}` es poder [**mapear atributos estÃ©ticos**]{.hl-purple} (color, forma, tamaÃ±o) de objetos geomÃ©tricos (puntos, barras, lÃ­neas) en funciÃ³n de los datos.

&nbsp;


La **documentaciÃ³n** del paquete puedes consultarla en <https://ggplot2-book.org/introduction.html> 

![](img/grammar_ggplot2.jpg)


---

## Dataviz en R: ggplot2

![](img/tarta_ggplot2.png)

---

## Dataviz en R: ggplot2

:::: columns
::: {.column width="40%"}
![](img/tarta_recortada_ggplot2.jpg)
:::

::: {.column width="60%"}
Un grÃ¡fico se podrÃ¡ componer de [**capas**]{.hl-yellow}

* [**Datos (data)**]{.hl-purple}
* [**Mapeado (aesthetics)**]{.hl-purple} de elementos estÃ©ticos: ejes, color, forma, etc (en funciÃ³n de los datos)
* [**GeometrÃ­a (geom)**]{.hl-purple}: puntos, lÃ­neas, barras, polÃ­gonos, etc.
* [**Componer grÃ¡ficas (facet)**]{.hl-purple}
* [**Transformaciones (stat)**]{.hl-purple}: ordenar, resumir, etc.
* [**Coordenadas (coord)**]{.hl-purple}: coordenadas cartesianas, polares, grids, etc.
* [**Temas (theme)**]{.hl-purple}: fuente, tamaÃ±o de letra, subtÃ­tulos, captions, leyenda, ejes, etc.

:::
::::

---

## Primer intento: scatter plot

Veamos un **primer intento** para entender la filosofÃ­a ggplot. Imagina que queremos dibujar un [**scatter plot**]{.hl-yellow} (diagrama de dispersiÃ³n de puntos). Para ello vamos a usar el conjunto de datos `gapminder`, del paquete homÃ³nimo: un fichero con **datos de esperanzas de vida, poblaciones y renta per cÃ¡pita** de distintos paÃ­ses en distintos momentos temporales.

```{r}
library(gapminder)
gapminder
```

---

## Primer intento: scatter plot

El fichero consta de 1704 registros y 6 variables: `country`, `continent`, `year`, `lifeExp` (esperanza de vida), `pop` (poblaciÃ³n)  y `gdpPercap` (renta per cÃ¡pita).

```{r}
glimpse(gapminder)
```

Para empezar con algo sencillo [**filtraremos solo los datos de 1997**]{.hl-yellow}

```{r}
gapminder_1997 <-
  gapminder |>
  filter(year == 1997) |> 
  drop_na(gdpPercap, lifeExp, pop)
```

---

## Ingredientes: (x, y)


Â¿QuÃ© [**elementos necesitamos**]{.hl-yellow} para realizar un diagrama de puntos? Para [**iniciar el lienzo**]{.hl-pÃ¹rple} necesitamos una base de datos y dos variables a representar.

. . .

:::: columns
::: {.column width="45%"}

* [**Datos (data)**]{.hl-yellow}: conjunto `gapminder_1997`.

* [**Mapeado**]{.hl-yellow}: indicar dentro de `aes()` (aesthetics) las variables en cada coordenada. Todo [**dentro de aes() serÃ¡ mapeado de los datos**]{.hl-purple}

```{r}
#| eval: false
ggplot(data = gapminder_1997,
       aes(x = gdpPercap, y = pop))
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop))
```

:::
::::

---


## Primera geometrÃ­a: geom_point()

:::: columns
::: {.column width="45%"}

* [**GeometrÃ­a (geom)**]{.hl-yellow}: optaremos por **puntos** usando `geom_point()`.

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop)) +
  geom_point()
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(x = gdpPercap, y = pop)) +
  geom_point()
```

:::
::::

---

## Rol de os ejes: (x, y)


:::: columns
::: {.column width="45%"}

Vamos a profundizar en ese mapeado: Â¿cÃ³mo [**cambiar el rol**]{.hl-yellow} de los ejes (poblaciÃ³n en el eje X y renta per cÃ¡pita en el eje Y)? 

* **Eje X**: poblaciÃ³n (variable `pop`)
* **Eje Y**: renta per cÃ¡pita (variable `gdpPercap`)


```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = pop)) +
  geom_point() 
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop)) +
  geom_point() 
```
:::
::::

---

## Rol de os ejes: (x, y)


:::: columns
::: {.column width="45%"}

Â¿Y un scatter plot con **esperanza de vida** en eje X frente a **renta per cÃ¡pita**?


* **Eje X**: esperanza de vida (variable `lifeExp`)
* **Eje Y**: renta per cÃ¡pita (variable `gdpPercap`)


```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point()
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point()
```

:::
::::

---

## Color, size, shape: fijos

Dentro de `geom_point()` tenemos varios argumentos a usar:


* `na.rm = ...`: si queremos que nos quite ausentes.

* `color = ...`: color (si tiene dimensiÃ³n, color del contorno)

* `fill = ...`: color del relleno.

. . .

:::: columns
::: {.column width="45%"}

Empezaremos por un [**color fijo**]{.hl-yellow}, por ejemplo `"red"` (existen otros como `"blue"`, `"black"`, `"yellow"`, etc)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red")
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red")
```

:::
::::

---

## Color, size, shape: fijos

:::: columns
::: {.column width="45%"}

* `size = ...`: tamaÃ±o  de la geometrÃ­a (en este caso el [**tamaÃ±o de los puntos**]{.hl-yellow}), cuanto mayor sea el nÃºmero, mayor serÃ¡ el tamaÃ±o de la geometrÃ­a.

  
```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7) 
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7)
```

:::
::::

---

## Color, size, shape: fijos


:::: columns
::: {.column width="45%"}

* `alpha = ...`: grado de opacidad del color (1 totalmente opaco, 0 totalmente transparente)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7,
             alpha = 0.4)
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7, alpha = 0.4)
```

:::
::::

---

## Color, size, shape: fijos


:::: columns
::: {.column width="45%"}

* `shape = ...`: forma de la geometrÃ­a, en este caso del Â«puntoÂ» (ver todas las opciones en `vignette("ggplot2-specs")`)


```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red",
             fill = "black",
             size = 7,
             alpha = 0.4,
             shape = 23)
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", fill = "black",
             size = 7, alpha = 0.4, shape = 23)
```

:::
::::

---

## Color, size, shape: fijos


:::: columns
::: {.column width="45%"}

* `stroke = ...`: tamaÃ±o del contorno

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7,
             alpha = 0.4, stroke = 3)
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", alpha = 0.4,
             size = 7, stroke = 3)
```

:::
::::


---

## Color, size, shape: fijos


:::: columns
::: {.column width="45%"}

Los colores tambiÃ©n podemos asignÃ¡rselos por su **cÃ³digo hexadecimal**, consultando en <https://htmlcolorcodes.com/es/>, eligiendo el color que queramos. El cÃ³digo hexadecimal siempre comenzarÃ¡ con `#`


```{r}
#| eval: false
# Color en hexadecimal
# https://htmlcolorcodes.com/es/
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "#A02B85",
             alpha = 0.4, size = 7) 
```


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "#A02B85", alpha = 0.4, size = 7)
```

:::
::::

  
---

## Mapeado estÃ©tico: aes()


Hasta ahora los **atributos estÃ©ticos** se los hemos pasado fijos y [**constantes**]{.hl-yellow}.  Pero la verdadera potencia y versatilidad de `ggplot` es que podemos [**mapear los atributos estÃ©ticos en funciÃ³n de los datos**]{.hl-yellow} en `aes()` para que dependan de variables de los datos.

. . .

:::: columns
::: {.column width="45%"}

Por ejemplo, vamos a asignar un [**color a cada dato en funciÃ³n de su continente**]{.hl-yellow} con `aes(color = continent)`

```{r}
#| eval: false
# TamaÃ±o fijo
# Color por continentes
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent)) +
  geom_point(size = 7)
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(size = 5)
```

:::
::::

---

## Mapeado estÃ©tico: aes()


:::: columns
::: {.column width="50%"}
  
Podemos combinarlo con lo que hemos hecho anteriormente:

* [**color**]{.hl-yellow} en funciÃ³n del [**continente**]{.hl-purple}.

* [**tamaÃ±o**]{.hl-yellow} en funciÃ³n de la [**poblaciÃ³n**]{.hl-purple}.

* [**transparencia**]{.hl-yellow} la fijamos [**constante**]{.hl-purple} del 50%.

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7)
```

A este scatter plot particular se le conoce **BUBBLE CHART**

:::

::: {.column width="50%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7)
```

:::
::::

---

## VisualizaciÃ³n multivariante
  
Reflexionemos sobre el grÃ¡fico anterior:

* **color** en funciÃ³n del **continente**.
* **tamaÃ±o** en funciÃ³n de la **poblaciÃ³n**
* **transparencia** fija del 50%

&nbsp;

Usando los datos hemos conseguido dibujar en un [**grÃ¡fico bidimensional 4 variables** ]{.hl-yellow}: `lifeExp` y `gdpPercap` en los ejes , `continent` como color y `pop` como tamaÃ±o de la geometrÃ­a, con muy pocas lÃ­neas de cÃ³digo.

---

## Etiquetas sencillas: labs()

Podemos [**personalizar de manera sencilla**]{.hl-yellow}  haciendo uso de la capa `labs()`:

:::: columns
::: {.column width="43%"}

* `title, subtitle`:  tÃ­tulo/subtÃ­tulo
* `caption`: pie de grÃ¡fica
* `x, y`: nombres de los ejes
* `size, color, fill, ...`: nombre en la leyenda de las variables que codifiquen los distintos atributos


:::

::: {.column width="57%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  labs(x = "Esperanza de vida",
       y = "Renta per cÃ¡pita",
       title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana",
       color = "continente",
       size = "poblaciÃ³n")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita",
       title = "Primer ggplot", subtitle = "Datos de gapminder",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente", size = "poblaciÃ³n")
```


---

## Eliminar de la leyenda

Podemos eliminar variables de la leyenda con `guides(atributo = "none")`

:::: columns

::: {.column width="45%"}

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, 
           x = lifeExp,
           color = continent, 
           size = pop)) +
  geom_point(alpha = 0.7) +
  guides(size = "none") +
  labs(x = "Esperanza de vida",
       y = "Renta per cÃ¡pita",
       title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana",
       color = "continente")
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  guides(size = "none") +
  labs(x = "Esperanza de vida",
       y = "Renta per cÃ¡pita",
       title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana",
       color = "continente")
```

:::
::::

---

## Escalas (scale): ejes

Una de las capas mÃ¡s importantes es la [**capa de escalas**]{.hl-yellow}: dentro de `aes()` solo le indicamos que variable mapeamos pero no sus ajustes.

. . .


:::: columns

::: {.column width="47%"}

Vamos a configurar el eje x para tener marcas cada 10 unidades (`scale_x_continuous()`)


:::

::: {.column width="53%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita",
       title = "Primer ggplot", caption = "J. Ãlvarez LiÃ©bana",
       color = "continente")
```

---

## Escalas (scale): colores

La misma idea la podemos aplicar a otro atrÃ­buto como los [**colores**]{.hl-yellow} con `scale_color_...()` y `scale_fill_...()`: hemos indicado que mapeÃ© dicho atributo por continente pero...Â¿quÃ© colores usar?

. . .

:::: columns

::: {.column width="50%"}

Con `scale_color_manual()` podemos indicar manualmente una [**paleta**]{.hl-yellow} (puedes buscar en <https://htmlcolorcodes.com/>)


         
:::

::: {.column width="50%"}

```{r}
#| echo: false
pal <- c("#A02B85", "#2DE86B", "#4FB2CA", "#E8DA2D", "#E84C2D")
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = pal) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita",
       title = "Primer ggplot", caption = "J. Ãlvarez LiÃ©bana",
       color = "continente")
```

:::
::::
      
```{r}
#| eval: false
pal <- c("#A02B85", "#2DE86B", "#4FB2CA", "#E8DA2D", "#E84C2D")
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = pal) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

---

## Escalas (scale): colores


Otra opciÃ³n es elegir alguna de las [**paletas de colores diseÃ±adas**]{.hl-yellow} en el paquete `{ggthemes}`:

:::: columns

::: {.column width="40%"}

* `scale_color_economist()`: paleta de colores basada en los colores de **The Economist**.

:::

::: {.column width="60%"}

```{r}
#| echo: false
library(ggthemes)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_economist() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_economist() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```


---

## Escalas (scale): colores

Otra opciÃ³n es elegir alguna de las [**paletas de colores diseÃ±adas**]{.hl-yellow} en el paquete `{ggthemes}`:

:::: columns

::: {.column width="40%"}


* `scale_color_colorblind()`: paleta de colores basada en los colores de  [**daltÃ³nicos/as**]{.hl-yellow}.

:::

::: {.column width="60%"}

```{r}
#| echo: false
library(ggthemes)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```


:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```



---

## Escalas (scale): colores


Incluso cargar [**paletas de colores diseÃ±adas en base a pelÃ­culas o arte**]{.hl-yellow}


:::: columns

::: {.column width="44%"}

* [**pelÃ­culas**]{.hl-yellow}: paquete `{harrypotter}` (repositorio de Github `aljrico/harrypotter`) usando `scale_color_hp_d()`.


```{r echo = FALSE,  out.width = "20%", fig.align = "center", fig.cap = "Paleta basada en la casa Ravenclaw"}
knitr::include_graphics("https://raw.githubusercontent.com/aljrico/harrypotter/master/readme_raw_files/palettes/ravenclaw.png")
``` 

:::

::: {.column width="55%"}

```{r}
#| echo: false
library(harrypotter)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_hp_d(option = "ravenclaw")+
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```



:::

::::

```{r}
#| eval: false
devtools::install_github(repo = "aljrico/harrypotter") 
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  harrypotter::scale_color_hp_d(option = "ravenclaw")+
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```


---

## Escalas (scale): colores

Incluso cargar [**paletas de colores diseÃ±adas en base a pelÃ­culas o arte**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* [**cuadros**]{.hl-yellow}: paquete `{MetBrewer}` (repositorio de Github `BlakeRMills/MetBrewer`) usando `scale_colour_manual(values = met.brewer(...))`.

:::


::: {.column width="55%"}

```{r}
#| echo: false
library(MetBrewer)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = met.brewer("Monet")) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

:::
::::

```{r}
#| eval: false
devtools::install_github(repo = "BlakeRMills/MetBrewer") 
library(MetBrewer)

ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = met.brewer("Monet")) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```


---


## Escalas (scale): colores

Incluso cargar [**paletas de colores diseÃ±adas en base a pelÃ­culas o arte**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* [**discos**]{.hl-yellow}: paquete `{peRReo}` (repositorio de Github `jbgb13/peRReo`) usando `scale_colour_manual(values = latin_palette())`.

:::

::: {.column width="55%"}

```{r}
#| echo: false
library(peRReo)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = latin_palette("rosalia")) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

:::
::::

```{r}
#| eval: false
devtools::install_github(repo = "jbgb13/peRReo") 
library(peRReo)

ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = latin_palette("rosalia")) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

---

## Escalas : otros atributos

Lo mismo que hemos hecho para los ejes o colores podemos hacer para el [**resto de atrÃ­butos estÃ©ticos**]{.hl-yellow}

:::: columns

::: {.column width="40%"}


Por ejemplo, vamos a indicarle que mapeÃ© el tamaÃ±o en funciÃ³n de poblaciÃ³n pero indicÃ¡ndole el [**rango de valores**]{.hl-yellow} (continuo en este caso) entre los que moverse con `scale_size_continuous()`

:::


::: {.column width="60%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  scale_size_continuous(range = c(3, 17)) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  scale_size_continuous(range = c(3, 15)) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

:::
::::

---

## Tema (bÃ¡sico)

Por Ãºltimo en este primer grÃ¡fico, vamos personalizar el tema con alguna de las capas `theme_...()`


:::: columns

::: {.column width="45%"}

Por ejemplo, vamos a usar `theme_minimal()` para tener un tema "austero" y minimalista (aprenderemos a definir cada detalle de nuestro tema).

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```



# Clase 13: profundizando en ggplot {#clase-13}

[**VisualizaciÃ³n de datos**]{style="color:#444442;"}


---

## Resumen de capas

Vamos a hacer un pequeÃ±o resumen de lo que llevamos aprendido hasta ahora respecto a `{ggplot2}`

. . .

* [**Capa de datos**]{.hl-yellow}: normalmente un grÃ¡fico en `{ggplot2}` empieza con `ggplot(datos)`.

. . .

* [**Mapeo de atributos estÃ©ticos**]{.hl-yellow}: todo lo que queramos que se [**codifique en funciÃ³n de los datos**]{.hl-purple} debe ir dentro de `aes()`

. . .

* [**Capa geomÃ©trica**]{.hl-yellow}: para decidir si queremos un scatter plot, un diagrama de barras, un histograma, etc

. . .

* [**Capas de escalas**]{.hl-yellow}: para decidir los ajustes personalizados de atributos estÃ©ticos (escala del alpha o size, paleta de colores, etc)

. . . 

* [**Tema**]{.hl-yellow}: tema para personalizar el grÃ¡fico (y etiquetas)

---

## Capa de escalas

Vamos a profundizar un poco dentro de nuestro scatter plot en  [**escalas**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* Â¿CÃ³mo [**fijar lÃ­mites en los ejes**]{.hl-purple}? En `scale_x_continuous()` y `scale_y_continuous()`, ademÃ¡s de "saltos" podemos indicar lÃ­mites con `limits = ...`

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(limits = c(50, 70),
                     breaks = seq(50, 70, by = 5)) +
  scale_y_continuous(limits = c(1000, 18000),
                      breaks = seq(0, 18000, by = 1000)) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(limits = c(50, 70), breaks = seq(50, 70, by = 5)) +
  scale_y_continuous(limits = c(1000, 18000), breaks = seq(0, 18000, by = 1000)) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---

## Capa de escalas


:::: columns

::: {.column width="45%"}

* Â¿CÃ³mo [**etiquetar las unidades de los ejes**]{.hl-purple}? Haciendo uso del paquete `{scales}` podemos aÃ±adir [**prefijos/sufijos**]{.hl-yellow} con `labels = label_number(...)`


:::

::: {.column width="55%"}

```{r}
#| echo: false
library(scales)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(limits = c(50, 70), breaks = seq(50, 70, by = 5),
                     labels = label_number(suffix = " aÃ±os")) +
  scale_y_continuous(limits = c(1000, 18000), breaks = seq(0, 18000, by = 1000),
                     labels = label_number(suffix = " $")) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
library(scales)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(limits = c(50, 70), breaks = seq(50, 70, by = 5),
                     labels = label_number(suffix = " aÃ±os")) +
  scale_y_continuous(limits = c(1000, 18000), breaks = seq(0, 18000, by = 1000),
                     labels = label_number(suffix = " $")) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---

## Capa de escalas

Vamos a profundizar un poco dentro de nuestro scatter plot en  [**escalas**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* Â¿CÃ³mo [**cambiar los ajustes de tamaÃ±o, alpha, etc**]{.hl-purple}? Igual que tenemos `scale_x_...()` o `scale_color_...()`, tenemos tambiÃ©n `scale_size_...()` y `scale_alpha_...()`


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(aes(alpha = pop)) +
  scale_size(range = c(4, 12)) +
  scale_alpha(range = c(0.1, 0.95)) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none", alpha = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(aes(alpha = pop)) +
  scale_size(range = c(4, 12)) +
  scale_alpha(range = c(0.1, 0.5)) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none", alpha = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---

## Capa de escalas

Vamos a profundizar un poco dentro de nuestro scatter plot en  [**escalas**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* Â¿CÃ³mo [**cambiar la escala (relaciÃ³n) lineal entre los ejes**]{.hl-purple}? Con `scale_x_sqrt()` o `scale_x_log10()` podemos cambiar la escala de los ejes.


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_y_log10() +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_y_log10() +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```


---

## scale_color: paleta Brewer

Una de las capas de escalas mÃ¡s importantes son las [**capas de color**]{.hl-yellow}. Ya vimos como definir paletas manuales, Â¿pero quÃ© [**opciones hay para escalas continuas de colores**]{.hl-purple}?

. . .

Existen unas [**paletas de colores conocidas como ColorBrewer**]{.hl-yellow} pudiendo definirse de manera **secuencial**, **divergente** o de manera **cualitativa** (ver info en <https://colorbrewer2.org>)

```{r}
RColorBrewer::brewer.pal.info
```

---

## scale_color: paleta Brewer

Con `RColorBrewer::brewer.pal()` podemos obtener el vector de n colores para una paleta dada

```{r}
RColorBrewer::brewer.pal(n = 5, name = "RdYlBu")
```

. . .

Con `RColorBrewer::display.brewer.pal()` podemos **visualizar los colores** de dicha paleta

```{r}
RColorBrewer::display.brewer.pal(n = 5, name = "RdYlBu")
```

---


## scale_color: paleta Brewer


:::: columns

::: {.column width="45%"}

Para incluirlo podemos usar `scale_colour_brewer()` o bien `scale_color_distiller()` si queremos crear una **escala continua** (interpolando entre los colores)


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.7, size = 3) +
  scale_x_log10() +
  scale_color_distiller(palette = "RdYlBu") +
  guides(size = "none") +
  labs(x = "PoblaciÃ³n", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "esperanza de vida") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.7, size = 3) +
  scale_x_log10() +
  scale_color_distiller(palette = "RdYlBu") +
  guides(size = "none") +
  labs(x = "PoblaciÃ³n", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "esperanza de vida") +
  theme_minimal()
```


---

## Gradiente de color manual


:::: columns

::: {.column width="45%"}

Tambien podemos crear un [**gradiente de color manual**]{.hl-yellow} son `scale_..._gradient()` para dos colores, `scale_..._gradient2()` para tres colores (bajo, medio y alto) y `scale_..._gradientn()` para n colores



:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.8, size = 3) +
  scale_x_log10() +
  scale_color_gradient2(low = "#E92745", mid = "#F4ED5B", high = "#56B1F7", midpoint = 60) +
  labs(x = "PoblaciÃ³n", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "esperanza de vida") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.8, size = 3) +
  scale_x_log10() +
  scale_color_gradient2(low = "#E92745", mid = "#F4ED5B", high = "#56B1F7", midpoint = 60) +
  labs(x = "PoblaciÃ³n", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "esperanza de vida") +
  theme_minimal()
```

---

## Capa de coordenadas


:::: columns

::: {.column width="45%"}


AdemÃ¡s de escalas tenemos una [**capa de coordenadas**]{.hl-yellow} con `coord_...` para indicar si queremos un sistema cartesiano (y sus lÃ­mites), coordenadas polares (`coord_polar()`), si queremos coordenadas iguales (`coord_equal()`) o invertir su rol (`coord_flip()`)


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.8, size = 3) +
  scale_x_log10() +
  scale_color_gradient2(low = "#E92745", mid = "#F4ED5B", high = "#56B1F7", midpoint = 60) +
  coord_flip() +
  labs(x = "PoblaciÃ³n", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "esperanza de vida") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.8, size = 3) +
  scale_x_log10() +
  scale_color_gradient2(low = "#E92745", mid = "#F4ED5B", high = "#56B1F7", midpoint = 60) +
  coord_flip() +
  labs(x = "PoblaciÃ³n", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "esperanza de vida") +
  theme_minimal()
```


---

## Capa de stats

Una capa importante es la [**capa de estadÃ­sticas**]{.hl-yellow}

:::: columns

::: {.column width="45%"}


* `stat_smooth()`: visualiza un [**ajuste suavizado**]{.hl-yellow} de los datos (reg. lineal, glm, loess, gam, etc).

Con `stat_smooth(method = "lm", se = FALSE)` una recta de regresiÃ³n (sin intervalos). 

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE, linewidth = 1.5) +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```
:::
::::


```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE, linewidth = 1.5) +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---

## Capa de stats

Una capa importante es la [**capa de estadÃ­sticas**]{.hl-yellow} que nos permite combinar en nuestro grÃ¡fico algunas funcionalidades

:::: columns

::: {.column width="45%"}

FÃ­jate que si usas en la [**primera capa parÃ¡metros estÃ©ticos**]{.hl-yellow} se acaban [**heredando a capas posteriores**]{.hl-purple}, en concreto al ajuste visualizado.

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE, linewidth = 1.5) +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```
:::
::::


```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE, linewidth = 1.5) +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---

## geom_text()

:::: columns

::: {.column width="45%"}


Podemos aÃ±adirle [**textos simples**]{.hl-yellow} con `geom_text(label = ...)`, por ejemplo, para aÃ±adir la correlaciÃ³n del ajuste.

:::


::: {.column width="55%"}

```{r}
#| echo: false
cor <- round(cor(gapminder_1997$gdpPercap, gapminder_1997$lifeExp), 3)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE) +
  geom_text(aes(x = 50, y = 20000), label = glue("CorrelaciÃ³n: {cor}"),
            size = 5, color = "darkcyan") +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```
:::
::::


```{r}
#| eval: false
cor <- round(cor(gapminder_1997$gdpPercap, gapminder_1997$lifeExp), 3)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE) +
  geom_text(aes(x = 50, y = 20000, label = glue("CorrelaciÃ³n: {cor}")),
                size = 5, color = "darkcyan") +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---


## Capa de stats


:::: columns

::: {.column width="45%"}

Dentro de `stat_smooth()` podemos especificarle otro [**ajuste polinÃ³mico**]{.hl-yellow} dÃ¡ndole expresiÃ³n en `formula = ...`
:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2) + I(x^3) + I(x^4) + I(x^5),
              color = "firebrick", se = FALSE, linewidth = 1.2) +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```
:::
::::


```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2) + I(x^3) + I(x^4) + I(x^5),
              color = "firebrick", se = FALSE, linewidth = 1.2) +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```


---

## Capa de stats


:::: columns

::: {.column width="45%"}

Sin `method` especificado ajuste por un LOESS (menos de 1000 puntos) o GAM (mÃ¡s de 1000 puntos)

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(color = "firebrick", se = FALSE, linewidth = 1.2) +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```
:::
::::


```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(color = "firebrick", se = FALSE, linewidth = 1.2) +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```


---

## Capa de stats


:::: columns

::: {.column width="45%"}

Con `stat_summary()` podemos incluso aÃ±adir [**estadÃ­sticas por grupos**]{.hl-yellow}, como la media o mediana.

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder, aes(y = gdpPercap, x = year)) +
  geom_point(size = 1.7, alpha = 0.2) +
  stat_summary(fun = "mean", size = 0.4, color = "coral") + 
  stat_summary(fun = "median", size = 0.4, color = "darkcyan") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::


```{r}
#| eval: false
ggplot(gapminder, aes(y = gdpPercap, x = year)) +
  geom_point(size = 1.7, alpha = 0.2) +
  stat_summary(fun = "mean", size = 0.4, color = "coral") + 
  stat_summary(fun = "median", size = 0.4, color = "darkcyan") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```



---

## Capa de stats

:::: columns

::: {.column width="45%"}

FÃ­jate que si no tenemos una variable cuali, la media la hace con `n = 1` (es decir, es el propio punto).
:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder, aes(y = gdpPercap, x = pop)) +
  geom_point(size = 1.7, alpha = 0.2) +
  stat_summary(fun = "mean", size = 0.4, color = "coral") + 
  stat_summary(fun = "median", size = 0.4, color = "darkcyan") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::


```{r}
#| eval: false
ggplot(gapminder, aes(y = gdpPercap, x = pop)) +
  geom_point(size = 1.7, alpha = 0.2) +
  stat_summary(fun = "mean", size = 0.4, color = "coral") + 
  stat_summary(fun = "median", size = 0.4, color = "darkcyan") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```


---

## Componiendo (facet)

TambiÃ©n podemos [**desagregar los grÃ¡ficos (facetar)**]{.hl-yellow} por grupos, equivalente al `group_by()` en tidyverse.


:::: columns

::: {.column width="45%"}

Por ejemplo, vamos a crear un [**grÃ¡fico por continente**]{.hl-yellow}, mostrando todos los grÃ¡ficos a la vez (pero por separado) con `facet_wrap(~continent)`.

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent)+
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent) +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---

## Componiendo (facet)

TambiÃ©n podemos [**desagregar los grÃ¡ficos (facetar)**]{.hl-yellow} por grupos, equivalente al `group_by()` en tidyverse.


:::: columns

::: {.column width="45%"}

Por defecto las escalas en los ejes son compartidas. Si queremos que la [**escala de los ejes**]{.hl-yellow} vaya por libre debemos usar `scales = "free_x"`, `scales = "free_y"` o `scales = "free"`


:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---

## Componiendo (facet)

TambiÃ©n podemos [**desagregar los grÃ¡ficos (facetar)**]{.hl-yellow} por grupos, equivalente al `group_by()` en tidyverse.


:::: columns

::: {.column width="45%"}

Con `nrow = ...` y `ncol = ...` podemos especificar cuantas columnas y filas tenemos en la cuadrÃ­cula de grÃ¡ficas

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent, scales = "free", nrow = 3) +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent, scales = "free", nrow = 3) +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```



---

## Componiendo (facet)



:::: columns

::: {.column width="45%"}

TambiÃ©n le podemos pasar dos argumentos (variables) para formar un [**grid de grÃ¡ficas**]{.hl-yellow}

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder |> filter(year >= 1962), aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  facet_grid(continent ~ year, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> filter(year >= 1962), aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  facet_grid(continent ~ year, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```


---

## Componiendo (facet)



:::: columns

::: {.column width="45%"}

Aprenderemos distintas personalizaciones del tema pero con `theme(legend.position = ...)` podemos [**decidir la posiciÃ³n de la leyenda**]{.hl-yellow}

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder |> filter(year >= 1962), aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  facet_grid(continent ~ year, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> filter(year >= 1962), aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  facet_grid(continent ~ year, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal() +
  theme(legend.position = "bottom")
```


# Clase 14: profundizando en ggplot {#clase-14}

[**VisualizaciÃ³n de datos**]{style="color:#444442;"}


---

## Variables continuas

Hemos aprendido a realizar uno de los grÃ¡ficos mÃ¡s famosos, un [**diagrama de dispersiÃ³n**]{.hl-yellow}, pero...Â¿quÃ© propiedades deben cumplir las variables?

. . .

Para visualizar dos variables con un [**diagrama de dispersiÃ³n**]{.hl-yellow} es necesario que ambas sean [**variables numÃ©ricas continuas**]{.hl-purple}

. . .

Â¿Se te ocurre algÃºna grÃ¡fico bÃ¡sico para [**variables discretas**]{.hl-yellow}?

---


## Cualis: barras


Â¿Y si tengo [**variables discretas o cualitativas**]{.hl-yellow}?

. . .

Vamos a usar el ya conocido conjunto `starwars` para visualizar en un [**diagrama de barras**]{.hl-yellow}: vamos a representar la [**frecuencia**]{.hl-yellow} de una [**variable cualitativa**]{.hl-yellow} como es `sex`.

```{r}
starwars |>  
  count(sex)
```


---

## Cualis: barras

La ventaja de ggplot es que, al trabajar por [**capas**]{.hl-yellow},  todo lo que hemos aprendido nos sirve: solo tenemos que [**cambiar la geometrÃ­a**]{.hl-purple}.

:::: columns

::: {.column width="40%"}

En este caso para realizar un [**diagrama de barras**]{.hl-yellow} usaremos `geom_bar()` en lugar de `geom_point()`, indicando [**solo la variable de grupo**]{.hl-purple} con `x = sex` (ggplot harÃ¡ solo el recuento)

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(starwars, aes(x = sex)) +
  geom_bar() +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(starwars, aes(x = sex)) +
  geom_bar()
  theme_minimal()
```


---

## Cualis: barras

:::: columns

::: {.column width="40%"}


Podemos aplicar lo aprendido sobre [**colores para codificar**]{.hl-yellow} la informaciÃ³n, en este caso vamos a usar las paletas ya cargadas en `scale_color_colorblind()` del paquete `{ggthemes}`

:::

::: {.column width="60%"}

```{r}
#| echo: false
library(ggthemes)
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(color = sex), alpha = 0.5) + 
  scale_color_colorblind() +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
library(ggthemes)
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(color = sex), alpha = 0.5) + 
  scale_color_colorblind() +
  theme_minimal()
```



---


## Cualis: barras

:::: columns

::: {.column width="40%"}

FÃ­jate que ahora [**solo nos ha coloreado el contorno**]{.hl-red}: en otras geometrÃ­as, como las barras, serÃ¡ importante distinguir entre `color` y `fill`


:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  theme_minimal()
```


---

## Cualis: barras




:::: columns

::: {.column width="40%"}

Podemos [**personalizar el grÃ¡fico**]{.hl-yellow} haciendo uso de las opciones ya vistas, por ejemplo, con escalas en ejes, tÃ­tulos de las variables, leyendas, etc

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  labs(x = "sexo", y = "frecuencia absoluta",
       fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana") +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana") +
  theme_minimal()
```


---


## Cualis: barras




:::: columns

::: {.column width="40%"}

Para cambiar el rol de los ejes, generando un diagrama de [**barras horizontales**]{.hl-yellow}, podemos dejar el grÃ¡fico igual y luego simplemente hacer `coord_flip()`
:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana") +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana") +
  theme_minimal()
```



---

## ParÃ©ntesis: temas


Vamos a hacer un parÃ©ntesis y aprender a [**personalizar mÃ¡s nuestras grÃ¡ficas**]{.hl-yellow}

:::: columns

::: {.column width="55%"}

* `theme_set(theme_minimal())` fija tema base

* `theme_update(...)` personaliza parÃ¡metros.

Por ejemplo, en `plot.title` vamos a indicarle el [**tamaÃ±o y negrita**]{.hl-yellow} en el tÃ­tulo, dentro de `element_text()`

:::


::: {.column width="45%"}

```{r}
#| echo: false
theme_set(theme_minimal())
theme_update(plot.title = element_text(size = 25, face = "bold"))
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```

:::
::::

```{r}
#| eval: false
theme_set(theme_minimal())
theme_update(plot.title = element_text(size = 25, face = "bold"))
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente", caption = "J. Ãlvarez LiÃ©bana")
```


---

## ParÃ©ntesis: temas

:::: columns

::: {.column width="40%"}

Podemos hacer lo mismo con otros textos con `plot.subtitle` o `plot.caption`

:::


::: {.column width="60%"}

```{r}
#| echo: false
theme_set(theme_minimal())
theme_update(
  plot.title =
    element_text(size = 25, face = "bold"),
  plot.subtitle = element_text(size = 13),
  plot.caption = element_text(size = 9))

starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```

:::
::::

```{r}
#| eval: false
theme_set(theme_minimal())
theme_update(
  plot.title =
    element_text(size = 25, face = "bold"),
  plot.subtitle = element_text(size = 13),
  plot.caption = element_text(size = 9))
```


---

## ParÃ©ntesis: temas

:::: columns

::: {.column width="50%"}

Vamos incluso a [**elegir fuente o el color**]{.hl-yellow}

* `sysfonts::font_add_google()`: le indicaremos la tipografÃ­a de <https://fonts.google.com/>

* `showtext_auto()` del paquete `{showtext}` nos permite su uso.

:::

::: {.column width="50%"}

```{r}
#| echo: false
library(showtext)
library(sysfonts)
font_add_google(name = "Roboto")
showtext_auto()
theme_set(theme_minimal(base_family = "Roboto")) 

# Configurar tema
theme_update(
  plot.title = element_text(color = "#C34539", face = "bold", size = 33),
  plot.subtitle = element_text(color = "#3E6FCB", face = "bold", size = 21),
  axis.title.x = element_text(size = 19),
  axis.title.y = element_text(size = 19))

starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```

:::
::::

```{r}
#| eval: false
library(showtext)
library(sysfonts)
font_add_google(name = "Roboto")
showtext_auto()
theme_set(theme_minimal(base_family = "Roboto")) 

# Configurar tema
theme_update(
  plot.title = element_text(color = "#C34539", face = "bold", size = 33),
  plot.subtitle = element_text(color = "#3E6FCB", face = "bold", size = 21),
  axis.title.x = element_text(size = 19),
  axis.title.y = element_text(size = 19))
```

---

## Cualis: barras apiladas

Â¿PodrÃ­amos visualizar [**dos variables discretas/cualis a la vez**]{.hl-yellow}?

. . .

:::: columns

::: {.column width="40%"}

Podemos incluir una en `x = ...` y otra en `fill = ...`, de manera que [**por defecto nos visualiza barras apiladas**]{.hl-yellow}, por ejemplo, para ver el reparto de sexos entre humanos y no humanos.

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  labs(x = "Â¿Humanos?", y = "frecuencia absoluta", fill = "sexo",  title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```
 
:::
::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  labs(x = "Â¿Humanos?", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```

---

## Cualis: barras solapas

:::: columns

::: {.column width="40%"}

Con `position = "dodge"` visualizamos las barras sin apilar, solapadas una al lado de otra

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5,
           position = "dodge") + 
  scale_fill_colorblind() +
  labs(x = "Â¿Humanos?", y = "frecuencia absoluta", fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```
 
:::
::::


```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5, position = "dodge") + 
  scale_fill_colorblind() +
  labs(x = "Â¿Humanos?", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```

---

## Cualis: barras fill


:::: columns

::: {.column width="40%"}

Con `position = "fill"` visualizamos las barras en forma de [**frecuencia relativa**]{.hl-yellow}, con las barras de la misma altura para facilitar la comparativa.

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5, position = "fill") + 
  scale_fill_colorblind() +
  labs(x = "Â¿Humanos?", y = "frecuencia relativa", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```
 
:::
::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5,  position = "fill") + 
  scale_fill_colorblind() +
  labs(x = "Â¿Humanos?", y = "frecuencia relativa", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```

---

## ParÃ©ntesis: factores

En el caso de las [**variables cualitativas**]{.hl-yellow}, llamaremos  **niveles o modalidades** a los **diferentes valores** que pueden tomar estos datos. Por ejemplo, en el caso de la variable `sex` del conjunto `starwars`, tenemos 4 niveles permitidos: `female`, `hermaphroditic`, `male` y `none` (amÃ©n de datos ausentes).

```{r}
starwars |> count(sex)
```


---

## ParÃ©ntesis: factores

Este tipo de variables se conocen en `R` como [**factores**]{.hl-yellow}. Y el paquete fundamental para tratarlos es `{forcats}` (del entorno `{tidyverse}`). 


![](./img/factors.jpg)

---

## ParÃ©ntesis: factores

Este paquete nos permite fijar los [**niveles**]{.hl-yellow} (guardados internamente como `levels`) que toma una determinada variable categÃ³rica, dÃ¡ndoles un [**tratamiento diferente a las cadena de texto normales**]{.hl-yellow}.

. . .

Veamos un ejempo sencillo definiendo una variable `estado` que tome los valores `"sano"`, `"leve"` y `"grave"` de la siguiente manera.

```{r}
estado <-
  c("leve", "grave", "sano", "sano", "leve", "sano", "sano", "grave",
    "grave", "leve", "grave", "sano", "sano")
estado
```

La variable `estado` actualmente es de [**tipo texto**]{.hl-yellow}, de tipo `chr`, algo que podemos comprobar con `class(estado)`.

```{r}
class(estado)
```

---

## ParÃ©ntesis: factores

Desde un punto de vista estadÃ­stico y computacional, para `R` esta variable ahora mismo serÃ­a equivalente una variable de nombres. Pero estadÃ­sticamente [**no es lo mismo una variable con nombres**]{.hl-yellow} (que identifican muchas veces el registro) que una variable categÃ³rica como estado que [**solo puede tomar esos 3 niveles**]{.hl-yellow}. Â¿CÃ³mo [**convertir a factor**]{.hl-yellow}?

. . .

Haciendo uso de la funciÃ³n `as_factor()` del paquete `{forcats}`.

```{r}
library(tidyverse)
estado_fct <- tibble(paciente = 1:length(estado),
                     estado = as_factor(estado))
estado_fct
```

---

## ParÃ©ntesis: factores


No solo ha cambiado la clase de la variable sino que ahora, debajo del valor guardado, nos aparece la frase `Levels: grave leve sano`: son las [**modalidades o niveles**]{.hl-yellow} de nuestra cualitativa. 

&nbsp;

Imagina que ese dÃ­a en el hospital no tuviÃ©semos a **nadie en estado grave**: aunque ese dÃ­a nuestra variable no tome dicho valor, el estado `grave` es un [**nivel permitido en la base de datos**]{.hl-yellow}, asÃ­ que aunque lo eliminemos, por ser un factor, el nivel permanece (no lo tenemos ahora pero es un nivel permitido).


```{r}
estado_fct |> 
  filter(estado %in% c("sano", "leve")) |> 
  pull(estado)
```

---

## ParÃ©ntesis: factores


Con `factor()` podemos [**especificar explÃ­citamente**]{.hl-yellow} los nombres de las modalidades, incluso si son nominales u [**ordinales**]{.hl-yellow}

```{r}
estado_fct <-
  tibble(paciente = 1:length(estado),
         estado = factor(estado, ordered = TRUE))
estado_fct |> pull(estado)
```

---

## ParÃ©ntesis: factores


Con  `levels = ...` podemos indicarle explÃ­citamente el [**orden de las modalidades**]{.hl-yellow}

```{r}
estado_fct <-
  tibble(paciente = 1:length(estado),
         estado = factor(estado,
                         levels = c("sano", "leve", "grave"),
                         ordered = TRUE))
estado_fct |> pull(estado)
```



---

## ParÃ©ntesis: factores


:::: columns

::: {.column width="50%"}

Si queremos indicarle que [**elimine un nivel no usado**]{.hl-yellow} en ese momento (y que queremos excluir de la definiciÃ³n) podemos hacerlo con `fct_drop()`

:::


::: {.column width="50%"}

![](img/drop_factor.jpg)

:::
::::

```{r}
estado_fct |> 
  filter(estado %in% c("sano", "leve")) |> 
  mutate(estado = fct_drop(estado)) |> 
  pull(estado)
```

---

## ParÃ©ntesis: factores

:::: columns

::: {.column width="50%"}

Al igual que podemos eliminar niveles podemos [**ampliar los niveles existentes**]{.hl-yellow} (aunque no existan datos de ese nivel en ese momento) con `fct_expand()`

:::

::: {.column width="50%"}

![](./img/factor_expand.jpg)

:::
::::

```{r}
estado_fct |> 
  mutate(estado = fct_expand(estado, c("UCI", "fallecido"))) |> 
  pull(estado)
```

---

## ParÃ©ntesis: factores

:::: columns

::: {.column width="50%"}

AdemÃ¡s con `fct_explicit_na()` podemos [**asignar un nivel a los valores**]{.hl-yellow} para que sea incluido dicho nivel en los anÃ¡lisis y visualizaciones.

:::

::: {.column width="50%"}

![](./img/factor_explicit.jpg)

:::
::::

```{r}
fct_explicit_na(factor(c("a", "b", NA)))
```

---

## ParÃ©ntesis: factores


Incluso una vez definidos podemos [**reordenar los nÃ­veles**]{.hl-yellow} con `fct_relevel()`


```{r}
estado_fct_expand <- 
  estado_fct |> 
  mutate(estado = fct_expand(estado, c("UCI", "fallecido"))) |> 
  pull(estado)

estado_fct_expand |>
  fct_relevel(c("fallecido", "leve", "sano", "grave", "UCI"))
  
```


---

## ParÃ©ntesis: factores

:::: columns

::: {.column width="50%"}

Esta forma de trabajar con variables cualitativas nos permite dar una [**definiciÃ³n teÃ³rica**]{.hl-yellow} de nuestra base de datos, pudiendo incluso contar valores que aÃºn no existen (pero que podrÃ­an), haciendo uso de `fct_count()`

:::

::: {.column width="50%"}

![](./img/fct_count.jpg)

:::
::::

```{r}
estado_fct |> 
  mutate(estado = fct_expand(estado, c("UCI", "fallecido"))) |> 
  pull(estado) |> 
  fct_count()
```


---

## ParÃ©ntesis: factores


Los nÃ­veles tambiÃ©n podemos [**ordenarlos por frecuencia**]{.hl-yellow} con `fct_infreq()`

```{r}
estado_fct |> 
  mutate(estado = fct_infreq(estado)) |> 
  pull(estado) |> 
  fct_count()
```

---

## ParÃ©ntesis: factores


A veces querremos [**agrupar niveles**]{.hl-yellow}, por ejemplo, no permitiendo niveles que [**no sucedan un mÃ­nimo de veces**]{.hl-yellow} con `fct_lump_min(.., min = ..)` (las observaciones que no lo cumplan irÃ¡n a un **nivel genÃ©rico** llamado `Other`, aunque se puede cambiar con el argumento `other_level`). 

:::: columns

::: {.column width="50%"}


```{r}
estado_fct |> 
  pull(estado) |> 
  fct_lump_min(min = 4)
```

:::

::: {.column width="50%"}


```{r}
estado_fct |> 
  pull(estado) |> 
  fct_lump_min(min = 4,
               other_level = "otros")
```

:::
::::

---

## ParÃ©ntesis: factores


Podemos hacer algo equivalente pero en funciÃ³n de su [**frecuencia relativa**]{.hl-yellow} con `fct_lump_prop()`.


```{r}
estado_fct |> 
  pull(estado) |> 
  fct_lump_prop(prop = 0.4,
                other_level = "otros")
```

---


## ParÃ©ntesis: factores

Esto lo podemos aplicar a nuestros conjuntos de datos para [**recategorizar variables**]{.hl-yellow} de forma muy rÃ¡pida.

```{r}
starwars |> 
  drop_na(species) |> 
  mutate(species =
           fct_lump_min(species, min = 3,
                        other_level = "Otras")) |> 
  count(species)
```

---

## ParÃ©ntesis: factores

Con `fct_reorder()` podemos tambiÃ©n indicar que queremos [**ordenar los factores**]{.hl-yellow} en funciÃ³n de una funciÃ³n aplicada a otra variable.


```{r}
starwars_factor <- 
  starwars |> 
  drop_na(height, species) |> 
  mutate(species =
           fct_lump_min(species, min = 3,
                        other_level = "Otras"))
```

:::: columns

::: {.column width="50%"}

```{r}
starwars_factor |> pull(species)
```

:::



::: {.column width="50%"}

```{r}
starwars_factor |>
  mutate(species = fct_reorder(species, height, mean)) |> 
  pull(species)
```

:::
::::

---

## ğŸ’» Tu turno {#tu-turno-14}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Dada la variable `meses` definida debajo (definida como un vector de caracteres), convierte dicha variable a factor (solo eso)

```{r}
meses <- c("Ene", "Feb", "Mar", "Abr")
```

```{r}
#| eval: false
#| code-fold: true
meses <- c("Ene", "Feb", "Mar", "Abr")
meses_fct <- as_factor(meses)
meses_fct
```
  
### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Dada la variable `meses` definida debajo convierte dicha variable a factor pero indicando los niveles de forma correcta.

```{r}
meses <- c(NA, "Abr", "Ene", "Oct", "Jul", "Ene", "Sep", NA, "Feb", "Dic",
           "Jul", "Mar", "Ene", "Mar", "Feb", "Abr", "May", "Oct", "Sep",  NA,
           "Dic", "Jul", "Nov", "Feb", "Oct", "Jun", "Sep", "Oct", "Oct", "Sep")
```

```{r}
#| eval: false
#| code-fold: true
meses <- c(NA, "Abr", "Ene", "Oct", "Jul", "Ene", "Sep", NA, "Feb", "Dic",
           "Jul", "Mar", "Ene", "Mar", "Feb", "Abr", "May", "Oct", "Sep",  NA,
           "Dic", "Jul", "Nov", "Feb", "Oct", "Jun", "Sep", "Oct", "Oct", "Sep")

# Orden de niveles correcto e incluimos agosto aunque no haya
meses_fct <-
  factor(meses,
         levels = c("Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"))
meses_fct
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Cuenta cuantos valores hay de cada mes pero teniendo en cuenta que son factores (quizÃ¡s haya niveles sin ser usados y de los que deberÃ­a obtener un 0).

```{r}
#| eval: false
#| code-fold: true
meses_fct |> fct_count()
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Dado que hay ausentes, indica que los ausentes sea un decimotercer nivel etiquetado como "ausente".

```{r}
#| eval: false
#| code-fold: true
meses_fct <- 
  meses_fct |>
  fct_explicit_na(na_level = "ausente")
meses_fct
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Elimina los niveles no usados.

```{r}
#| eval: false
#| code-fold: true
meses_fct <- 
  meses_fct |>
  fct_drop()
meses_fct
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Ordena los niveles por frecuencia de apariciÃ³n.
  
```{r}
#| eval: false
#| code-fold: true
meses_fct |> 
  fct_infreq()
```


### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Agrupa niveles de forma que todo nivel que no aparezca al menos el 7% de las veces se agrupe en un nivel llamado "otros meses"

```{r}
#| eval: false
#| code-fold: true
meses_fct <-
  meses_fct |> 
  fct_lump_prop(prop = 0.07, other_level = "otros")
meses_fct
```

:::

---


## Cualis: barras ordenadas

:::: columns

::: {.column width="40%"}

Haciendo uso de los que sabemos [**sobre factores**]{.hl-yellow} podemos indicarle que nos [**ordene las columnas de manera personalizada**]{.hl-purple} definiendo la variable cuali como un factor.

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
    drop_na(sex) |> mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |> 
    ggplot(aes(x = sex)) +
    geom_bar(aes(fill = sex), alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "frecuencia absoluta", fill = "sexo",
         title = "Primer diagrama de barras",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Ãlvarez LiÃ©bana")
```
:::
::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |> 
    ggplot(aes(x = sex)) +
    geom_bar(aes(fill = sex), alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Ãlvarez LiÃ©bana")
```
         
---



## Cualis: barras ordenadas

:::: columns

::: {.column width="40%"}

TambiÃ©n podemos indicarle que nos [**ordene las columnas de mayor a menor frecuencia**]{.hl-yellow} usando simplemente `fct_infreq()`

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
    drop_na(sex) |> mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |> 
    ggplot(aes(x = fct_infreq(sex))) +
    geom_bar(aes(fill = sex), alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "frecuencia absoluta", fill = "sexo",
         title = "Primer diagrama de barras",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Ãlvarez LiÃ©bana")
```
:::
::::

```{r}
#| eval: false
starwars |> 
    drop_na(sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |> 
    ggplot(aes(x = fct_infreq(sex))) +
    geom_bar(aes(fill = sex), alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Ãlvarez LiÃ©bana")
```


---


## Cualis: barras ordenadas

:::: columns

::: {.column width="40%"}

Para [**invertir el orden de los factores**]{.hl-yellow} basta usar `fct_rev()`

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
    drop_na(sex) |> mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |> 
    ggplot(aes(x = fct_rev(fct_infreq(sex)))) +
    geom_bar(aes(fill = sex), alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "frecuencia absoluta", fill = "sexo",
         title = "Primer diagrama de barras",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Ãlvarez LiÃ©bana")
```
:::
::::

```{r}
#| eval: false
starwars |> 
    drop_na(sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |> 
    ggplot(aes(x = fct_rev(fct_infreq(sex)))) +
    geom_bar(aes(fill = sex), alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Ãlvarez LiÃ©bana")
```



---

## Cualis: geom_col()

La capa `geom_bar()` estÃ¡ solo pensada para [**conteos de variables discretas o cualitativas**]{.hl-yellow}. Â¿Y si queremos visualizar en el peso por sexo?

. . .

:::: columns

::: {.column width="45%"}

Usaremos `geom_col()` (ahora si necesitamos `x,y`)

:::

::: {.column width="55%"}

```{r}
#| echo: false
starwars |> 
  drop_na(mass, sex) |>
    ggplot(aes(x = sex, y = mass)) +
    geom_col(aes(fill = sex), alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "Peso", fill = "sexo", title = "Primer diagrama de columnas",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Ãlvarez LiÃ©bana")
```

:::

::::


```{r}
#| eval: false
starwars |> 
  drop_na(mass, sex) |>
  ggplot(aes(x = sex, y = mass)) +
  geom_col(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  labs(x = "Sexo", y = "Peso", fill = "sexo", title = "Primer diagrama de columnas",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente", caption = "J. Ãlvarez LiÃ©bana")
```


---

## Cualis: geom_col()


FÃ­jate que [**por defecto**]{.hl-red} lo que hace es [**sumar la variable continua**]{.hl-yellow}. Â¿CÃ³mo pedir que visualice, por ejemplo, la [**media por grupos**]{.hl-purple}?

. . .

:::: columns

::: {.column width="45%"}

La forma mÃ¡s inmediata es hacer un `geom_col()` pero en lugar de a la tabla original a un resumen de la misma.

:::

::: {.column width="55%"}

```{r}
#| echo: false
starwars |> 
  drop_na(mass, sex) |> 
  summarise(mean_mass = mean(mass), .by = sex) |> 
  ggplot(aes(x = sex, y = mean_mass)) +
  geom_col(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  labs(x = "Sexo", y = "Peso (medio)", fill = "sexo", title = "Primer diagrama de columnas",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente", caption = "J. Ãlvarez LiÃ©bana")
```

:::

::::


```{r}
#| eval: false
starwars |> 
  drop_na(mass, sex) |> 
  summarise(mean_mass = mean(mass), .by = sex) |> 
  ggplot(aes(x = sex, y = mean_mass)) +
  geom_col(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  labs(x = "Sexo", y = "Peso (medio)", fill = "sexo", title = "Primer diagrama de columnas",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente", caption = "J. Ãlvarez LiÃ©bana")
```


---

## Cualis: geom_col()



:::: columns

::: {.column width="45%"}

Otra opciÃ³n es no usar la capa geomÃ©trica sino la capa estadÃ­stica, con `stat_summary()` e indicÃ¡ndole la funciÃ³n a visualizar y el geometrÃ­a

:::

::: {.column width="55%"}

```{r}
#| echo: false
starwars |> 
    drop_na(mass, sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |>
    ggplot(aes(x = sex, y = mass, fill = sex)) +
    stat_summary(geom = "col", fun = mean, alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "Peso (medio)", fill = "sexo",
         title = "Primer diagrama de columnas",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Ãlvarez LiÃ©bana")
```

:::

::::


```{r}
#| eval: false
starwars |> 
    drop_na(mass, sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |>
    ggplot(aes(x = sex, y = mass, fill = sex)) +
    stat_summary(geom = "col", fun = mean, alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "Peso (medio)", fill = "sexo",
         title = "Primer diagrama de columnas",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Ãlvarez LiÃ©bana")
```


---

## Cualis: geom_col()

:::: columns

::: {.column width="45%"}

FÃ­jate que ambas formas nos permiten visualizar cualquier otro estadÃ­stico, por ejempo, la mediana

:::

::: {.column width="55%"}

```{r}
#| echo: false
starwars |> 
    drop_na(mass, sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |>
    ggplot(aes(x = sex, y = mass, fill = sex)) +
    stat_summary(geom = "col", fun = median, alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "Peso (mediana)", fill = "sexo",
         title = "Primer diagrama de columnas",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Ãlvarez LiÃ©bana")
```

:::

::::


```{r}
#| eval: false
starwars |> 
    drop_na(mass, sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |>
    ggplot(aes(x = sex, y = mass, fill = sex)) +
    stat_summary(geom = "col", fun = median, alpha = 0.5) + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "Peso (mediana)", fill = "sexo",
         title = "Primer diagrama de columnas",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Ãlvarez LiÃ©bana")
```

---


## Cualis: geom_col()

:::: columns

::: {.column width="45%"}

La Ãºltima opciÃ³n es volver a nuestra conocida `geom_bar()`, indicÃ¡ndole `stat = "summary", fun = "mean"`, por ejemplo (por defecto `stat = "count"`) con ahora sÃ­ dos variables

:::

::: {.column width="55%"}

```{r}
#| echo: false
starwars |> 
    drop_na(mass, sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |>
    ggplot(aes(x = sex, y = mass)) +
    geom_bar(aes(fill = sex), alpha = 0.5,
             stat = "summary", fun = "mean") + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "Peso (media)", fill = "sexo",
         title = "Primer diagrama de columnas",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Ãlvarez LiÃ©bana")
```

:::

::::


```{r}
#| eval: false
starwars |> 
    drop_na(mass, sex) |>
  mutate(sex = factor(sex, levels = c("female", "male", "hermaphroditic", "none"))) |>
    ggplot(aes(x = sex, y = mass)) +
    geom_bar(aes(fill = sex), alpha = 0.5,
             stat = "summary", fun = "mean") + 
    scale_fill_colorblind() +
    labs(x = "Sexo", y = "Peso (media)", fill = "sexo",
         title = "Primer diagrama de columnas",
         subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
         caption = "J. Ãlvarez LiÃ©bana")
```

---

## Imitando a Nightingale

Vamos a intentar replicar el [**famoso grÃ¡fico de rosa o diagrama de Ã¡rea polar de Florence Nightingale**]{.hl-yellow}, cargando los datos de `{HistData}`. Los datos representan, por meses, las diferentes causas de mortalidad de los soldados ingleses en la Guerra de Crimea (busca en la ayuda para saber quÃ© es cada cosa)

```{r}
library(HistData)
datos <- as_tibble(Nightingale)
```

![](./img/rosa_nightingale.jpg)

---

## Imitando a Nightingale

1. Filtra solo las variables relativas a fecha y las relativadas a tasas de mortalidad (por cada 1000 habitantes), aquellas que acaban por `".rate"`. Tras ello prepara los datos de manera adecuada para su visualizaciÃ³n (todo en castellano)

```{r}
#| code-fold: true
datos_filtrados <-
  datos |> 
  select(Date:Year, contains("rate")) |> 
  pivot_longer(cols = contains("rate"),
               names_to = "causa",
               values_to = "tasa") |> 
  rename(fecha = Date, mes = Month, anno = Year) |> 
  mutate(causa =
           case_when(causa == "Disease.rate" ~ "infecciosas",
                     causa == "Wounds.rate" ~ "heridas",
                     TRUE ~ "otras"))
datos_filtrados
```

---

## Imitando a Nightingale

2. Realiza las transformaciones en los datos que consideres y replica el grÃ¡fico.

```{r}
#| code-fold: true
#| echo: false
#| fig-width: 11
datos_filtrados <-
  datos_filtrados |>
  mutate(periodo =
           ifelse(fecha >= "1855-04-01", "Abril 1855 - Marzo 1856", "Abril 1854 - Marzo 1855"),
         periodo =
           factor(periodo,
                  levels = c("Abril 1854 - Marzo 1855", "Abril 1855 - Marzo 1856"),
                  ordered = TRUE))

theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Ãlvarez LiÃ©bana | Data: {HistData}")
```



---

## Imitando a Nightingale


```{r}
#| code-fold: true
#| eval: false
datos_filtrados <-
  datos_filtrados |>
  mutate(periodo = ifelse(fecha >= "1855-04-01", "Abril 1855 - Marzo 1856", "Abril 1854 - Marzo 1855"),
         periodo =
           factor(periodo, levels = c("Abril 1854 - Marzo 1855", "Abril 1855 - Marzo 1856"),
                  ordered = TRUE))

theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Ãlvarez LiÃ©bana | Data: {HistData}")
```


        
---

## Imitando a Nightingale

3. Nuestros datos abarcan dos periodos: de abril 1854 a marzo 1855, y de abril 1855 a marzo 1856. Realiza los cambios necesarios  para obtener el siguiente grÃ¡fico.

```{r}
#| code-fold: true
#| echo: false
#| fig-width: 11
datos_filtrados <-
  datos_filtrados |>
  mutate(periodo = ifelse(fecha >= "1855-04-01", "Abril 1855 - Marzo 1856", "Abril 1854 - Marzo 1855"),
         periodo =
           factor(periodo, levels = c("Abril 1854 - Marzo 1855", "Abril 1855 - Marzo 1856"),
                  ordered = TRUE),
         mes = fct_relevel(mes, "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov",
                           "Dec", "Jan", "Feb", "Mar"))

theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Ãlvarez LiÃ©bana | Data: {HistData}")
```

---

## Imitando a Nightingale


```{r}
#| code-fold: true
#| eval: false
datos_filtrados <-
  datos_filtrados |>
  mutate(periodo = ifelse(fecha >= "1855-04-01", "Abril 1855 - Marzo 1856", "Abril 1854 - Marzo 1855"),
         periodo =
           factor(periodo, levels = c("Abril 1854 - Marzo 1855", "Abril 1855 - Marzo 1856"),
                  ordered = TRUE),
         mes = fct_relevel(mes, "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov",
                           "Dec", "Jan", "Feb", "Mar"))

theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Ãlvarez LiÃ©bana | Data: {HistData}")
```


---

## Imitando a Nightingale


4. Piensa que cambio hemos realizado en el siguiente grÃ¡fico. Â¿QuÃ© se ha cambiado en las coordenadas? Â¿Tenemos alguna capa que pueda ayudarnos a realizarlo? Investiga


```{r}
#| code-fold: true
#| echo: false
#| fig-width: 11
theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  coord_polar() +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Ãlvarez LiÃ©bana | Data: {HistData}")
```

---

## Imitando a Nightingale


```{r}
#| code-fold: true
#| eval: false
theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  coord_polar() +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Ãlvarez LiÃ©bana | Data: {HistData}")
```

---

## Imitando a Nightingale


5. Ahora mismo se notan mucho las diferencias entre gajos. Â¿CÃ³mo podrÃ­amos reducir esa diferencia? Â¿QuÃ© tipo de cambio deberÃ­amos realizar (quÃ© tipo de capa usar)?



```{r}
#| code-fold: true
#| echo: false
#| fig-width: 11
theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  coord_polar() +
  scale_y_sqrt() +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Ãlvarez LiÃ©bana | Data: {HistData}")
```

---

## Imitando a Nightingale


```{r}
#| code-fold: true
#| eval: false
theme_set(theme_minimal())
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  coord_polar() +
  scale_y_sqrt() +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Ãlvarez LiÃ©bana | Data: {HistData}")
```

---

## Imitando a Nightingale


6. Dado que en el grÃ¡fico original no hay marcas en el eje Y, vamos **eliminar el eje Y** (sin tÃ­tulo, sin textos, sin marcas). Â¿QuÃ© habrÃ­a que cambiar? Investiga en `theme()` Situa ademÃ¡s la leyenda en la parte inferior


```{r}
#| code-fold: true
#| echo: false
#| fig-width: 11
theme_set(theme_minimal())
theme_update(axis.title.y = element_blank(),
             axis.text.y = element_blank(),
             axis.ticks.y = element_blank(),
             legend.position = "bottom")
ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  coord_polar() +
  scale_y_sqrt() +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Ãlvarez LiÃ©bana | Data: {HistData}")
```

---

## Imitando a Nightingale

```{r}
#| code-fold: true
#| eval: false
theme_set(theme_minimal())
theme_update(axis.title.y = element_blank(),
             axis.text.y = element_blank(),
             axis.ticks.y = element_blank(),
             legend.position = "bottom")
```


---

## Imitando a Nightingale

7. Para que sea mÃ¡s legible vamos a **reducir el tamaÃ±o de las etiquetas de los meses** y vamos a darle **etiquetas correctas a los meses** (July en lugar de Jul, December en lugar de Dec, etc).


```{r}
#| code-fold: true
#| echo: false
#| fig-width: 11
theme_set(theme_minimal())
theme_update(axis.title.y = element_blank(), axis.text.y = element_blank(),
             axis.ticks.y = element_blank(), axis.text.x = element_text(size = 6, face = "bold"),
             legend.position = "bottom")

ggplot(datos_filtrados, aes(x = mes, y = tasa, fill = causa)) + 
  geom_col(alpha = 0.85) +
  scale_fill_manual(values = c("#e3aeae", "#a5acb0", "#594b4a")) +
  coord_polar() +
  scale_y_sqrt() +
  scale_x_discrete(labels =
                     c("JULY", "AUGUST", "SEPTEMBER", "OCTOBER", "NOVEMBER", "DECEMBER",
                       "JANUARY", "FEBRUARY", "MARCH", "APRIL", "MAY", "JUNE")) +
  facet_wrap(~periodo) +
  labs(fill = "Causas", title = "Causas de mortalidad",
       subtitle = "Periodos: Abril 1854 - Marzo 1855 y Abril 1855 - Marzo 1856",
       caption = "Autor: J. Ãlvarez LiÃ©bana | Data: {HistData}")
```

---

## Imitando a Nightingale

```{r}
#| code-fold: true
#| eval: false
theme_set(theme_minimal())
theme_update(axis.title.y = element_blank(), axis.text.y = element_blank(),
             axis.ticks.y = element_blank(), axis.text.x = element_text(size = 6, face = "bold"),
             legend.position = "bottom")

... + 
  scale_x_discrete(labels =
                     c("JULY", "AUGUST", "SEPTEMBER", "OCTOBER", "NOVEMBER", "DECEMBER",
                       "JANUARY", "FEBRUARY", "MARCH", "APRIL", "MAY", "JUNE"))
```



---

## ğŸ£ Caso prÃ¡ctico 14 a: ggplot 

Usa el dataset `gapminder` y visualiza en un grÃ¡fico la media de la variable `gdpPercap` por continente y aÃ±o mediante un diagrama de barras en 3 formas:

* barras solapadas
* barras apiladas
* barras fill

---

## ğŸ£ Caso prÃ¡ctico 14 b: ggplot 

El objetivo es analizar un conjunto de datos que contiene las respuestas a las pregunta [**Â«Â¿QuÃ© probabilidad (%) asignarÃ­as al tÃ©rmino (entre otros) ...**]{.hl-yellow}

* **Â«almost no chanceÂ»**
* **Â«probableÂ»**
* **Â«almost certainlyÂ»**

...con el objetivo de [**comprender cÃ³mo la gente percibe el vocabulario**]{.hl-yellow} de la probabilidad.

```{r}
datos <-
  read_csv("https://raw.githubusercontent.com/zonination/perceptions/master/probly.csv")
datos
```

---

## ğŸ£ Caso prÃ¡ctico 14 b: ggplot 

```{r}
datos <-
  read_csv("https://raw.githubusercontent.com/zonination/perceptions/master/probly.csv")
datos
```

Solo haciendo uso de los grÃ¡ficos aprendidos hasta ahora, Â¿cÃ³mo visualizarÃ­as dicho dataset? Realiza las tranformaciones que consideres para una correcta preparaciÃ³n de los datos.

# Clase 15: dataviz

[**VisualizaciÃ³n de datos**]{style="color:#444442;"}

---


## Variables continuas

> Solo haciendo uso de los grÃ¡ficos aprendidos hasta ahora, Â¿cÃ³mo visualizarÃ­as dicho dataset? Realiza las tranformaciones que consideres para una correcta preparaciÃ³n de los datos.

```{r}
datos <-
  read_csv("https://raw.githubusercontent.com/zonination/perceptions/master/probly.csv")
```

. . .

Lo primero que deberemos hacer es [**preparar nuestros datos**]{.hl-yellow} para la posterior visualizaciÃ³n en formato tidy

```{r}
datos_tidy <-
  datos |> 
  pivot_longer(cols = everything(),
               names_to = "termino", values_to = "prob")
datos_tidy
```

---


## Variables continuas

Â¿CÃ³mo podemos visualizar estos datos?

. . .

Tenemos dos variables:

* `termino`: [**cualitativa ordinal**]{.hl-yellow}
* `prob`: [**cuantitativa continua**]{.hl-yellow}

Por lo que de momento no tenemos herramienta para visualizarlo ya que

* [**scatter plot**]{.hl-purple}: dos variables continuas.
* [**diagrama de barras**]{.hl-purple}: variables discretas o cualitativas

. . .

La Ãºnica manera serÃ¡ [**realizar un resumen**]{.hl-yellow} de los datos visualizando, por ejemplo, la [**media de probabilidad**]{.hl-yellow} asignada

---

## Variables continuas

La Ãºnica manera serÃ¡ [**realizar un resumen**]{.hl-yellow} de los datos visualizando, por ejemplo, la [**media de probabilidad**]{.hl-yellow} asignada

. . .

```{r}
resumen <- 
  datos_tidy |>
  summarise(mean_prob = mean(prob), .by = termino)
resumen
```

---

## Variables continuas

::: columns
::: {.column width="40%"}

Con `scale_fill_gradient2()` vamos a crear un gradiente de color, y con `scale_y_continuous()` incorporamos % en el eje Y.

:::

::: {.column width="60%"}
```{r}
#| echo: false
ggplot(resumen, aes(x = termino, y = mean_prob, fill = mean_prob)) +
  geom_col(alpha = 0.8) +
  scale_fill_gradient2(low = "#DA4A4A", mid = "#FEFADF", high = "#144F8D", midpoint = 50) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  labs(fill = "Prob. media", x = "TÃ©rminos", y = "Probabilidad media",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(resumen, aes(x = termino, y = mean_prob, fill = mean_prob)) +
  geom_col(alpha = 0.8) +
  scale_fill_gradient2(low = "#DA4A4A", mid = "#FEFADF", high = "#144F8D", midpoint = 50) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  labs(fill = "Prob. media", x = "TÃ©rminos", y = "Probabilidad media",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```


---

## Variables continuas



::: columns
::: {.column width="40%"}

Para mejorar la legibilidad vamos a reducir el tamaÃ±o de las etiquetas del eje X.

:::

::: {.column width="60%"}
```{r}
#| echo: false
ggplot(resumen, aes(x = termino, y = mean_prob, fill = mean_prob)) +
  geom_col(alpha = 0.8) +
  scale_fill_gradient2(low = "#DA4A4A", mid = "#FEFADF", high = "#144F8D", midpoint = 50) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  labs(fill = "Prob. media", x = "TÃ©rminos", y = "Probabilidad media",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 6, angle = 30))
```

:::
::::

```{r}
#| eval: false
ggplot(resumen, aes(x = termino, y = mean_prob, fill = mean_prob)) +
  geom_col(alpha = 0.8) +
  scale_fill_gradient2(low = "#DA4A4A", mid = "#FEFADF", high = "#144F8D", midpoint = 50) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  labs(fill = "Prob. media", x = "TÃ©rminos", y = "Probabilidad media",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 6, angle = 30))
```

---

## Variables continuas


::: columns
::: {.column width="40%"}

Por Ãºltimo, vamos a ordenar las barras de mÃ¡s a menos

:::

::: {.column width="60%"}
```{r}
#| echo: false
ggplot(resumen |> mutate(termino = fct_reorder(termino, mean_prob)), aes(x = termino, y = mean_prob, fill = mean_prob)) +
  geom_col(alpha = 0.8) +
  scale_fill_gradient2(low = "#DA4A4A", mid = "#FEFADF", high = "#144F8D", midpoint = 50) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  labs(fill = "Prob. media", x = "TÃ©rminos", y = "Probabilidad media",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 6, angle = 30))
```

:::
::::

```{r}
#| eval: false
ggplot(resumen |> mutate(termino = fct_reorder(termino, mean_prob)), aes(x = termino, y = mean_prob, fill = mean_prob)) +
  geom_col(alpha = 0.8) +
  scale_fill_gradient2(low = "#DA4A4A", mid = "#FEFADF", high = "#144F8D", midpoint = 50) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  labs(fill = "Prob. media", x = "TÃ©rminos", y = "Probabilidad media",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 6, angle = 30))
```

---

## Variables continuas

Aun asÃ­ al haber sumarizado, estamos perdiendo informaciÃ³n...

Â¿QuÃ© otros grÃ¡ficos se te ocurren para hacer con [**variables continuas**]{.hl-yellow}?

. . .

Algunos de los mÃ¡s habituales son:


* [**Distribuciones**]{.hl-purple}: histogramas, densidades (ridgeline), boxplot (alternativas: violÃ­n, raincloud plots)

. . .

* [**EvoluciÃ³n**]{.hl-purple}: grÃ¡ficos de lÃ­neas, grÃ¡ficos de Ã¡rea, series temporales, etc

. . .

* [**Correlaciones**]{.hl-purple}: mapas de calor, correlograma, grafos, etc

---

## Distribuciones: histogramas

::: columns
::: {.column width="40%"}

Nuestra primera alternativa serÃ¡ el conocido como [**histograma**]{.hl-yellow} con `geom_histogram()`

:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy, aes(x = prob)) +
  geom_histogram(alpha = 0.8, fill = "#144F8D") +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::

FÃ­jate que estÃ¡ realizando el histograma de todo el dataset.

```{r}
#| eval: false
ggplot(datos_tidy, aes(x = prob)) +
  geom_histogram(alpha = 0.8, fill = "#144F8D") +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

---

## Distribuciones: histogramas

::: columns
::: {.column width="40%"}


El argumento `bins = ...` nos servirÃ¡ para personalizar el nÃ­mero de barras que queremos. FÃ­jate que el grÃ¡fico es una [**proximaciÃ³n discreta**]{.hl-yellow} de un grÃ¡fico de densidad.
:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy, aes(x = prob)) +
  geom_histogram(bins = 12, alpha = 0.8, fill = "#144F8D") +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy, aes(x = prob)) +
  geom_histogram(bins = 12, alpha = 0.8, fill = "#144F8D") +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

---

## Distribuciones: histogramas

::: columns
::: {.column width="40%"}


Si queremos hacer uno por tÃ©rmino, basta con aÃ±adir a nuestro grÃ¡fico un `facet_wrap()` para componer

:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy, aes(x = prob, fill = termino)) +
  geom_histogram(bins = 12, alpha = 0.8) +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy, aes(x = prob, fill = termino)) +
  geom_histogram(bins = 12, alpha = 0.8) +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

---


## Distribuciones: histogramas

::: columns
::: {.column width="40%"}

Vamos a filtrar solo algunos tÃ©rminos para poder usar la paleta `scale_fill_brewer()` 

:::

::: {.column width="60%"}

```{r}
#| echo: false
datos_tidy <-
  datos_tidy |> 
  filter(!(termino %in% c("Chances Are Slight", "Improbable", "Probably Not", "Probable", "Likely", "Very Good Chance")))

ggplot(datos_tidy, aes(x = prob, fill = termino)) +
  geom_histogram(bins = 12, alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
datos_tidy <-
  datos_tidy |> 
  filter(!(termino %in% c("Chances Are Slight", "Improbable", "Probably Not", "Probable", "Likely", "Very Good Chance")))

ggplot(datos_tidy, aes(x = prob, fill = termino)) +
  geom_histogram(bins = 12, alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

---


## Distribuciones: histogramas

::: columns
::: {.column width="40%"}

Nos aparecen desordenadas asÃ­ que de nuevo podemos hacer uso del paquete `{forcats}`


:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)), aes(x = prob, fill = termino)) +
  geom_histogram(bins = 12, alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)), aes(x = prob, fill = termino)) +
  geom_histogram(bins = 12, alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

---

## ParÃ©ntesis: tema y fuente

Vamos a aÃ±adir una fuente personaliza al grÃ¡fico anterior.

::: columns
::: {.column width="40%"}

Con el paquete `{showtext}` podemos cargar fuentes de <https://fonts.google.com/>: con `font_add_google()` aÃ±adimos la fuente y con `showtext_auto()` habilitamos su uso. 

Con `theme_set()` podemos fijar un tema base (en nuestro caso `theme_minimal(base_family = ...)`) y con `theme_update()` aÃ±adimos el resto de personalizaciones


:::

::: {.column width="60%"}

```{r}
#| echo: false
library(showtext)
font_add_google(family = "Roboto", name = "Roboto")
showtext_auto()
theme_set(theme_minimal(base_family = "Roboto"))
theme_update(
  plot.title = element_text(color = "black", face = "bold", size = 27),
  legend.position = "bottom")
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)), aes(x = prob, fill = termino)) +
  geom_histogram(bins = 12, alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
library(showtext)
font_add_google(family = "Roboto", name = "Roboto")
showtext_auto()

theme_set(theme_minimal(base_family = "Roboto"))
theme_update(
  plot.title = element_text(color = "black", face = "bold", size = 27),
  legend.position = "bottom")
```


---


## Distribuciones: densidades

Los histogramas en realidad son una [**aproximaciÃ³n discreta de los grÃ¡ficos de densidad**]{.hl-yellow} (asumiendo que los intervalos se pudieran ir haciendo tan pequeÃ±os como queramos). 

::: columns
::: {.column width="40%"}

Las densidades mejoran la robustez al histograma. Para ello usaremos `geom_density()`


:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)), aes(x = prob, fill = termino)) +
  geom_density(alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia relativa",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)), aes(x = prob, fill = termino)) +
  geom_density(alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  facet_wrap(~termino, scale = "free_y", ncol = 4) +
  labs(x = "Probabilidad", y = "Frecuencia relativa",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```


---


## Distribuciones: densidades

::: columns
::: {.column width="40%"}

A veces puede ser interesante [**superponer las densidades**], lo cual lo podemos hacer con `geom_density_ridges()` del paquete `{ggridges}` (ahora sÃ­ necesitamos indicarle un `y = ...`)

:::

::: {.column width="60%"}

```{r}
#| echo: false
library(ggridges)
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = prob, y = termino, fill = termino, color = termino)) +
  geom_density_ridges(alpha = 0.5) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Probabilidad", y = "TÃ©rminos",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
library(ggridges)
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = prob, y = termino, fill = termino, color = termino)) +
  geom_density_ridges(alpha = 0.5) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "Probabilidad", y = "TÃ©rminos",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```


---

## Distribuciones: boxplot

Una opciÃ³n muy habitual en variables continuas son los [**grÃ¡ficos de cajas y bigotes**]{.hl-yellow} o boxplots


::: columns
::: {.column width="40%"}

Para realizar estos grÃ¡ficos debemos usar la geometrÃ­a `geom_boxplot()`

:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "TÃ©rminos", y = "Probabilidad",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "TÃ©rminos", y = "Probabilidad",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

---

## Distribuciones: jitter


::: columns
::: {.column width="40%"}

Los boxplot a veces pueden ser insuficiente y podemos usar `geom_jitter()` que nos aÃ±adirÃ¡ puntos como un [**Â«gotelÃ© aleatorioÂ»**]{.hl-yellow} (ver <https://hausetutorials.netlify.app/posts/2019-02-22-why-we-should-never-use-barplots-use-geomquasirandom-instead/>)

:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8) +
  geom_jitter(alpha = 0.3, size = 2) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "TÃ©rminos", y = "Probabilidad",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8) +
  geom_jitter(alpha = 0.3, size = 2) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "TÃ©rminos", y = "Probabilidad",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

---

## Distribuciones: jitter



::: columns
::: {.column width="40%"}

Si te fijas los [**outliers**]{.hl-yellow} aparecen dos veces ya que el boxplot los marca. Dentro de `geom_boxplot()` podemos indicarle la forma, color y alpha de los atÃ­picos.


:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8, outlier.shape = 23) +
  geom_jitter(alpha = 0.3, size = 2) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "TÃ©rminos", y = "Probabilidad",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8, outlier.shape = 23) +
  geom_jitter(alpha = 0.3, size = 2) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "TÃ©rminos", y = "Probabilidad",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

---

## Distribuciones: jitter



::: columns
::: {.column width="40%"}

Si te fijas los [**outliers**]{.hl-yellow} aparecen dos veces ya que el boxplot los marca. Dentro de `geom_boxplot()` podemos indicarle la forma, color y alpha de los atÃ­picos.


:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8, outlier.alpha = 0) +
  geom_jitter(alpha = 0.3, size = 2) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "TÃ©rminos", y = "Probabilidad",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8, outlier.alpha = 0) +
  geom_jitter(alpha = 0.3, size = 2) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "TÃ©rminos", y = "Probabilidad",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

---

## Distribuciones: geom_quasirandom



::: columns
::: {.column width="40%"}

Podemos mejorar el [**Â«gotelÃ© aleatorioÂ»**]{.hl-yellow} con  `geom_quasirandom()` del paquete `{ggbeeswarm}` (con `width = ...` controlamos la anchura de lo aleatorio)


:::

::: {.column width="60%"}

```{r}
#| echo: false
library(ggbeeswarm)
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8, outlier.alpha = 0) +
  geom_quasirandom(size = 2, alpha = 0.4,  width = 0.7) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "TÃ©rminos", y = "Probabilidad",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_boxplot(alpha = 0.8, outlier.alpha = 0) +
  geom_quasirandom(size = 2, alpha = 0.4,  width = 0.7) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "TÃ©rminos", y = "Probabilidad",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```



---

## Distribuciones: violin




::: columns
::: {.column width="40%"}


Para solventar los problemas de los box-plots, una alternativa muy popular son los [**grÃ¡ficos de violÃ­n**]{.hl-yellow} (en realidad es una densidad reflejada)

:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_violin(alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "TÃ©rminos", y = "Probabilidad",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::



```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_violin(alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "TÃ©rminos", y = "Probabilidad",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```



---


## Distribuciones: violin




::: columns
::: {.column width="40%"}


Con el argumento `scale = "count"` las Ã reas son proporcionales al nÃºmero de observaciones en cada violÃ­n (por defecto `scale = "area"`, todos la misma Ã¡rea). Con `bw = ...` modulamos la suavidad del kernel usado (bandwidth).

:::

::: {.column width="60%"}

```{r}
#| echo: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_violin(alpha = 0.8, scale = "count", bw = 1.5) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "TÃ©rminos", y = "Probabilidad",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

:::
::::


```{r}
#| eval: false
ggplot(datos_tidy |> 
       mutate(termino = fct_reorder(termino, prob, .fun = mean)),
       aes(x = termino, y = prob, fill = termino, color = termino)) +
  geom_violin(alpha = 0.8, scale = "count", bw = 1.5) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(x = "TÃ©rminos", y = "Probabilidad",
       title = "PercepciÃ³n de la probabilidad") +
  theme_minimal()
```

# Clase 16: dataviz

[**VisualizaciÃ³n de datos**]{style="color:#444442;"}



## EvoluciÃ³n: grÃ¡ficos de lÃ­neas


Otra categorÃ­a muy comÃºn de grÃ¡ficos con variables continusa son los [**grÃ¡ficos de evoluciÃ³n**]{.hl-yellow}

::: columns
::: {.column width="40%"}

El mÃ¡s simple es el [**grÃ¡fico de lÃ­neas**]
{.hl-yellow}, que podemos construir con `geom_line()`, y para el que ahora sÃ­ necesitamos un `x = ...`  y un `y = ...`

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, color = continent)) +
  geom_line(alpha = 0.8, linewidth = 2) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_color_colorblind() +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita media",
       title = "EvoluciÃ³n en gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, color = continent)) +
  geom_line(alpha = 0.8, linewidth = 2) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_color_colorblind() +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita media",
       title = "EvoluciÃ³n en gapminder") +
  theme_minimal()
```

---

## EvoluciÃ³n: grÃ¡ficos de lÃ­neas


::: columns
::: {.column width="40%"}

FÃ­jate que dando `color = ...` nos hace solo una grÃ¡fica por variable de grupo. Si usamos `geom_step()` en su lugar obtenemos un [**grÃ¡fico de escalera**]{.hl-yellow}

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, color = continent)) +
  geom_step(alpha = 0.8, linewidth = 1.2) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_color_colorblind() +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita media",
       title = "EvoluciÃ³n en gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, color = continent)) +
  geom_step(alpha = 0.8, linewidth = 1.2) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_color_colorblind() +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita media",
       title = "EvoluciÃ³n en gapminder") +
  theme_minimal()
```

---

## EvoluciÃ³n: serie temporal

Un grÃ¡fico de lÃ­nea muy particular son las [**series temporales**]{.hl-yellow}, donde en el eje X hay una variable de [**fecha y/o hora**]{.hl-purple}

. . .

Por ejemplo, vamos a cargar el siguiente dataset de Github de la [**evoluciÃ³n del precio de bitcoins**]{.hl-yellow} cuyo separado es el espacio

```{r}
data <- read_table(file = "https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/3_TwoNumOrdered.csv")
data
```

---

## EvoluciÃ³n: serie temporal

::: columns
::: {.column width="40%"}

La forma mÃ¡s sencilla es de nuevo usar `geom_line()`. Con `scale_x_date(date_breaks = ...)` podemos indicarle los saltos en las fechas de manera sencilla.

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(data, aes(x = date, y = value)) +
  geom_line(alpha = 0.8, color = "#145412", linewidth = 1.2) +
  scale_x_date(date_breaks = "4 months") +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_color_colorblind() +
  labs(x = "Fecha", y = "Precio del bitcoin",
       title = "EvoluciÃ³n del precio del bitcoin") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30))
```

:::
::::

```{r}
#| eval: false
ggplot(data, aes(x = date, y = value)) +
  geom_line(alpha = 0.8, color = "#145412", linewidth = 1.2) +
  scale_x_date(date_breaks = "4 months") +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_color_colorblind() +
  labs(x = "Fecha", y = "Precio del bitcoin",
       title = "EvoluciÃ³n del precio del bitcoin") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30))
```

---


## EvoluciÃ³n: grÃ¡ficos de Ã¡rea

Una mejora de los grÃ¡ficos de lÃ­nea son los [**grÃ¡ficos de Ã¡rea**]{.hl-yellow} (visualizando la curva con rellena)

::: columns
::: {.column width="40%"}

La forma mÃ¡s sencilla es de nuevo usar `geom_line()` pero aÃ±adiendo la capa `geom_area()` (con `fill` en lugar de `color`)

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(data, aes(x = date, y = value)) +
  geom_line(color = "#145412", linewidth = 1) +
  geom_area(alpha = 0.4, fill = "#145412") +
  scale_x_date(date_breaks = "4 months") +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "Fecha", y = "Precio del bitcoin",
       title = "EvoluciÃ³n del precio del bitcoin") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30))
```

:::
::::

```{r}
#| eval: false
ggplot(data, aes(x = date, y = value)) +
  geom_line(color = "#145412", linewidth = 1) +
  geom_area(alpha = 0.4, fill = "#145412") +
  scale_x_date(date_breaks = "4 months") +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "Fecha", y = "Precio del bitcoin",
       title = "EvoluciÃ³n del precio del bitcoin") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30))
```


---

## ParÃ©ntesis: interactivos

::: columns
::: {.column width="40%"}

Todo grÃ¡fico ggplot podemos hacerlo [**interactivo**]{.hl-yellow} guardÃ¡ndonos la grÃ¡fico y haciendo uso de `{plotly}`

:::

::: {.column width="60%"}


```{r}
#| echo: false
gg <- 
  ggplot(data, aes(x = date, y = value)) +
  geom_line(color = "#145412", linewidth = 1) +
  geom_area(alpha = 0.4, fill = "#145412") +
  scale_x_date(date_breaks = "4 months") +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "Fecha", y = "Precio del bitcoin",
       title = "EvoluciÃ³n del precio del bitcoin") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30))
plotly::ggplotly(gg)
```

:::
::::

```{r}
#| eval: false
gg <-
  ggplot(data, aes(x = date, y = value)) +
  geom_line(color = "#145412", linewidth = 1) +
  geom_area(alpha = 0.4, fill = "#145412") +
  scale_x_date(date_breaks = "4 months") +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "Fecha", y = "Precio del bitcoin",
       title = "EvoluciÃ³n del precio del bitcoin") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30))
plotly::ggplotly(gg)
```


---

## EvoluciÃ³n: Ã¡reas apiladas


::: columns
::: {.column width="40%"}

Los grÃ¡ficas de Ã¡reas, al igual que sucedÃ­a con los diagrmaas de barras, pueden ser de [**Ã¡reas apiladas**]{.hl-yellow}, haciendo que `fill()` sea mapeado por `aes()`

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, fill = continent)) +
  geom_area(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_fill_colorblind() +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita media",
       title = "EvoluciÃ³n de gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, fill = continent)) +
  geom_area(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_fill_colorblind() +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita media",
       title = "EvoluciÃ³n de gapminder") +
  theme_minimal()
```

---

## EvoluciÃ³n: Ã¡reas apiladas


::: columns
::: {.column width="40%"}

Los grÃ¡ficas de Ã¡reas, al igual que sucedÃ­a con los diagrmaas de barras, pueden ser de [**Ã¡reas apiladas**]{.hl-yellow}, haciendo que `fill()` sea mapeado por `aes()`

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, fill = continent)) +
  geom_area(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_fill_colorblind() +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita media",
       title = "EvoluciÃ³n de gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)), aes(x = year, y = mean_gdp, fill = continent)) +
  geom_area(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_fill_colorblind() +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita media",
       title = "EvoluciÃ³n de gapminder") +
  theme_minimal()
```

---

## EvoluciÃ³n: Ã¡reas apiladas


::: columns
::: {.column width="40%"}

Haciendo una modificaciÃ³n en el preprocesamiento podemos hacer un [**grÃ¡fico de Ã¡reas apiladas**]{.hl-yellow} en relativo

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)) |> mutate(porc = 100 * mean_gdp/sum(mean_gdp), .by = year),
       aes(x = year, y = porc, fill = continent)) +
  geom_area(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  scale_fill_colorblind() +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita mundial",
       title = "EvoluciÃ³n de gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)) |> mutate(porc = 100 * mean_gdp/sum(mean_gdp), .by = year),
       aes(x = year, y = porc, fill = continent)) +
  geom_area(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_number(suffix = "%")) +
  scale_fill_colorblind() +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita mundial",
       title = "EvoluciÃ³n de gapminder") +
  theme_minimal()
```

---


## EvoluciÃ³n: streamcharts

Una modificaciÃ³n de los grÃ¡ficos de Ã¡reas apiladas son los conocidos como [**streamcharts**]{.hl-yellow}


::: columns
::: {.column width="40%"}

En ellos las formas son mÃ¡s suaves que en un grÃ¡fico de Ã¡rea al uso, con el paquete `{ggstream}` (y usando `geom_stream()`)


:::

::: {.column width="60%"}


```{r}
#| echo: false
library(ggstream)
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)),  aes(x = year, y = mean_gdp, fill = continent)) +
  geom_stream(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_fill_colorblind() +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita mundial",
       title = "EvoluciÃ³n de gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
library(ggstream)
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)),  aes(x = year, y = mean_gdp, fill = continent)) +
  geom_stream(alpha = 0.7) +
  scale_y_continuous(labels = scales::label_dollar()) +
  scale_fill_colorblind() +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita mundial",
       title = "EvoluciÃ³n de gapminder") +
  theme_minimal()
```

---


## EvoluciÃ³n: streamcharts

::: columns
::: {.column width="40%"}

FÃ­jate que por defecto lo hace [**en espejo**]{.hl-yellow}, usando el eje y de manera reflejada. Con `type = "ridge"` lo haemos de manera apilada.

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)),  aes(x = year, y = mean_gdp, fill = continent, color = continent)) +
  geom_stream(alpha = 0.7, type = "ridge") +
  scale_fill_colorblind() +
  scale_color_colorblind() +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita mundial",
       title = "EvoluciÃ³n de gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)),  aes(x = year, y = mean_gdp, fill = continent, color = continent)) +
  geom_stream(alpha = 0.75, type = "ridge") +
  scale_fill_colorblind() +
  scale_color_colorblind() +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita mundial",
       title = "EvoluciÃ³n de gapminder") +
  theme_minimal()
```

---

## EvoluciÃ³n: streamcharts

::: columns
::: {.column width="40%"}

 Con `type = "proportional"` lo haemos de manera relativa
:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)),  aes(x = year, y = mean_gdp, fill = continent, color = continent)) +
  geom_stream(alpha = 0.75, type = "proportional") +
  scale_fill_colorblind() +
  scale_color_colorblind() +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita mundial",
       title = "EvoluciÃ³n de gapminder") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> summarise(mean_gdp = mean(gdpPercap), .by = c(continent, year)),  aes(x = year, y = mean_gdp, fill = continent, color = continent)) +
  geom_stream(alpha = 0.75, type = "proportional") +
  scale_fill_colorblind() +
  scale_color_colorblind() +
  scale_y_continuous(labels = scales::label_dollar()) +
  labs(x = "AÃ±o", y = "Renta per cÃ¡pita mundial",
       title = "EvoluciÃ³n de gapminder") +
  theme_minimal()
```

---

## ğŸ£ Caso prÃ¡ctico 16: visualizando Netflix

Visualizaremos el nÃºmero de pelÃ­culas y series de instituto que se han estrenado en Netflix en cada aÃ±o. Los datos provienen originalmente de Kaggle, y contienen las pelÃ­culas y series de Netflix hasta enero de 2021. 

```{r}
netflix <-
  read_csv('https://raw.githubusercontent.com/elartedeldato/datasets/main/netflix_titles.csv')
netflix
```

---

## ğŸ£ Caso prÃ¡ctico 16: visualizando Netflix

* [**Paso 1**]{.hl-yellow}: piensa como filtrar las **pelÃ­culas y series que van sobre un instituto**.

. . .

* [**Paso 2**]{.hl-yellow}: tras dicho filtro, aÃ±ade el aÃ±o en el que se estrenÃ³ y elimina aquellas sin aÃ±o conocido.

. . .

* [**Paso 3**]{.hl-yellow}: obtÃ©n el nÃºmero de series por aÃ±o

---


## ğŸ£ Caso prÃ¡ctico 16: visualizando Netflix

* [**Paso 4**]{.hl-yellow}: replica el siguiente grÃ¡fico

```{r}
#| echo: false
netflix_resumen <-
  netflix |> 
  filter(str_detect(toupper(description), "HIGH SCHOOL")) |> 
  mutate(year_added = year(mdy(date_added))) |>
  drop_na(year_added) |> 
  group_by(year_added) |>
  count() |> ungroup()

ggplot(netflix_resumen, aes(x = year_added, y = n)) +
  geom_col(fill = "red") +
  scale_x_continuous(breaks = netflix_resumen$year_added) +
  labs(title = "NETFLIX",
       subtitle = "PelÃ­culas y series de instituto",
       x = "AÃ±o de estreno", y = "Cantidad")
```

---

## ğŸ£ Caso prÃ¡ctico 16: visualizando Netflix

* [**Paso 5**]{.hl-yellow}: replica el siguiente grÃ¡fico sabiendo que la fuente del tÃ­tulo es "Bebas Neue" y la del subtÃ­tulo "Permanent Marker"

```{r}
#| echo: false
library(sysfonts)
library(showtext)
font_add_google(family = "Bebas Neue",
                name = "Bebas Neue")
font_add_google(family = "Permanent Marker",
                name = "Permanent Marker")
showtext_auto()

ggplot(netflix_resumen, aes(x = year_added, y = n)) +
  geom_col(fill = "red") +
  scale_x_continuous(breaks = netflix_resumen$year_added) +
  labs(title = "NETFLIX",
       subtitle = "PelÃ­culas y series de instituto",
       x = "AÃ±o de estreno", y = "Cantidad") +
  theme_minimal() +
  theme(legend.position = "none",
        plot.title = element_text(family = "Bebas Neue",
                                  color = "red", size = 80),
        plot.subtitle = element_text(family = "Permanent Marker",
                                     size = 21, color = "black"))
```

---


## ğŸ£ Caso prÃ¡ctico 16: visualizando Netflix

* [**Paso 6**]{.hl-yellow}: replica el siguiente grÃ¡fico sabiendo que la fuente de los ejes es "Permanent Marker" y busca la funciÃ³n `annotate()`

```{r}
#| echo: false
ggplot(netflix_resumen, aes(x = year_added, y = n)) +
  geom_col(fill = "red") +
  scale_x_continuous(breaks = netflix_resumen$year_added) +
  labs(title = "NETFLIX",
       subtitle = "PelÃ­culas y series de instituto",
       x = "AÃ±o de estreno", y = "Cantidad") +
  theme_void() +
  theme(plot.margin = margin(t = 4, r = 4, b = 4, l = 8, "pt"),
        legend.position = "none",
        plot.title = element_text(family = "Bebas Neue",
                                  color = "red", size = 80),
        plot.subtitle = element_text(family = "Permanent Marker",
                                     size = 21, color = "white"),
        axis.text = 
          element_text(size = 15, family = "Permanent Marker",
                       color = "white"),
        panel.background = element_rect(fill = "black"),
        plot.background = element_rect(fill = "black", 
                                       color = "black"),
        panel.grid.major.y =
          element_line(linewidth = 0.1, color = "white")) +
  annotate("text", label = "(hasta enero)", 
           x = 2021, y = 11, hjust = 0.3, vjust = 0, family = "Permanent Marker", size = 5, color='white', angle = 20) +
  annotate("curve", x = 2021, y = 9, xend = 2021, yend = 5,
           color = "white")
```



# Clase n + 1: joins, expresiones de control, listas y depuraciÃ³n

[**Cruzando datos. Bucles**]{style="color:#444442;"}


## Relacionando datos

Al trabajar con datos [**no siempre tendremos la informaciÃ³n en una sola tabla**]{.hl-yellow} y a veces nos interesarÃ¡ cruzar la informaciÃ³n de distintas fuentes.

. . .

Para ello usaremos un clÃ¡sico de todo lenguaje que maneja datos: los famosos [**join**]{.hl-yellow}, una herramienta que nos va a permitir [**cruzar una o variables tablas**]{.hl-yellow}, haciendo uso de una [**columna identificadora**]{.hl-yellow} de cada una de ellas (por ejemplo, imagina que cruzamos datos de hacienda y de antecedentes penales, haciendo _join_ por la columna `DNI`).

---

## Relacionando datos


```{r}
#| eval: false
tabla_1 |>
  xxx_join(tabla_2, by = id)
```

* `inner_join()`: solo sobreviven los [**registros con id en ambas**]{.hl-yellow} tablas.

* `full_join()`: mantiene [**todos los registros de ambas**]{.hl-yellow} tablas.

* `left_join()`: mantiene [**todos los registros de la primera tabla**]{.hl-yellow}, y busca cuales tienen id tambiÃ©n en la segunda (en caso de [**no tenerlo se rellena con NA**]{.hl-yellow} los campos de la 2Âª tabla).

* `right_join()`: mantiene [**todos los registros de la segunda tabla**]{.hl-yellow}, y busca cuales tienen id tambiÃ©n en la primera.

![](img/sql-joins.jpg)


---

## Relacionando datos

Vamos a probar los distintos joins con un ejemplo sencillo

```{r}
tb_1 <- tibble("key" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```

:::: columns
::: {.column width="50%"}

```{r}
tb_1
```

:::

::: {.column width="50%"}

```{r}
tb_2
```

:::
::::

---

## Left join

Imagina que queremos [**incorporar**]{.hl-yellow} a `tb_1` la [**informaciÃ³n de la tabla_2**]{.hl-yellow}, identificando los registros por la columna key (indicando con `by = "key"` la columna por la que tiene que cruzar): queremos mantener todos los registros de la primera tabla y buscar cuales tienen id (mismo valor en `key`) tambiÃ©n en la segunda tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1  |> 
  left_join(tb_2, by = "key")
```

:::
::: {.column width="50%"}


![](img/left_join.jpg)


:::
::::

---

## Left join

```{r}
tb_1 |> 
  left_join(tb_2, by = "key")
```

FÃ­jate que los [**registros de la primera cuya key no ha encontrado en la segunda**]{.hl-yellow} les ha dado el valor de [**ausente**]{.hl-yellow}.

---

## Right join

El `right_join()` realizarÃ¡ la operaciÃ³n contraria: vamos ahora a [**incorporar**]{.hl-yellow} a `tb_2` la [**informaciÃ³n de la tabla_2**]{.hl-yellow}, identificando los registros por la columna key (indicando con `by = "key"` la columna por la que tiene que cruzar): queremos mantener todos los registros de la segunda y buscar cuales tienen id (mismo valor en `key`) tambiÃ©n en la primera tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

:::

::: {.column width="50%"}

![](img/right_join.jpg)

:::
::::


---

## Right join


```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

FÃ­jate que ahora los [**registros de la segunda cuya key no ha encontrado en la primera**]{.hl-yellow} son los que les ha dado el valor de [**ausente**]{.hl-yellow}.

---


## Claves y sufijos

Las columnas clave que usaremos para el cruce [**no siempre se llamarÃ¡n igual**]{.hl-yellow}.

```{r}
tb_1 <- tibble("key_1" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```

. . .

* `by = c("key_2" = "key_2")`: le indicaremos en quÃ© columna de cada tabla estÃ¡n las claves por las que vamos a cruzar.

:::: columns
::: {.column width="50%"}

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

```{r}
# Right
tb_1  |> 
  right_join(tb_2, by = c("key_1" = "key_2"))
```

:::
::::

---

## Claves y sufijos

AdemÃ¡s podemos [**cruzar por varias columnas a la vez**]{.hl-yellow} (interpretarÃ¡ como igual registro aquel que tenga el conjunto de claves igual), con `by = c("var1_t1" = "var1_t2", "var2_t1" = "var2_t2", ...)`. Modifiquemos el ejemplo anterior

```{r}
tb_1 <- tibble("k_11" = 1:3, "k_12" = c("a", "b", "c"),  "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("k_21" = c(1, 2, 4), "k_22" = c("a", "b", "e"), "val_y" = c("y1", "y2", "y3"))
```

. . .

```{r}
# Left
tb_1 |> 
  left_join(tb_2,
            by = c("k_11" = "k_21", "k_12" = "k_22"))
```


---

## Claves y sufijos

TambiÃ©n podrÃ­a suceder que al cruzar dos tablas, haya [**columnas de valores que se llamen igual**]{.hl-yellow}


```{r}
tb_1 <- tibble("key_1" = 1:3, "val" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val" = c("y1", "y2", "y3"))
```

. . .

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

FÃ­jate que [**por defecto nos aÃ±ade los sufijos**]{.hl-yellow} `.x` y `.y` para indicarnos de que tabla vienen.

---

## Claves y sufijos


Dicho [**sufijo podemos especificÃ¡rselo**]{.hl-yellow} en el argumento opcional `suffix = ...`, que nos permita [**distinguir las variables**]{.hl-yellow} de una tabla y de otra.


```{r}
# Left
tb_1 |>
  left_join(tb_2, by = c("key_1" = "key_2"), suffix = c("_tabla1", "_tabla2"))
```


---

## Full join

Los dos anteriores casos forman lo que se conoce como [**outer joins**]{.hl-yellow}: cruces donde se mantienen observaciones que salgan en al menos una tabla. El tercer outer join es el conocido como `full_join()` que nos [**mantendrÃ¡ las observaciones de ambas**]{.hl-yellow} tablas, [**aÃ±adiendo las filas**]{.hl-yellow} que no casen con la otra tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  full_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

![](img/full_join.jpg)

:::
::::


---

## Inner join

Frente a los outer join estÃ¡ lo que se conoce como [**inner join**]{.hl-yellow}, con `inner_join()`: un cruce en el que solo se mantienen las [**observaciones que salgan en ambas tablas**]{.hl-yellow}, solo mantiene aquellos registros matcheados.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

![](img/inner_join.png)


:::
::::

---

## Inner join

FÃ­jate que en tÃ©rminos de registros, `inner_join` si es conmutativa, **nos da igual el orden de las tablas**: lo Ãºnico que cambia es el orden de las columnas que aÃ±ade.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

:::

::: {.column width="50%"}


```{r}
tb_2 |> 
  inner_join(tb_1, by = c("key_2" = "key_1"))
```

:::
::::

---

## Anti/semi join

Por Ãºltimo tenemos dos herramientas interesantes para [**filtrar (no cruzar) registros**]{.hl-yellow}: `semi_join()` y `anti_join()`. El [**semi join**]{.hl-yellow} nos deja en la [**primera tabla los registros que cuya clave estÃ¡ tambiÃ©n en la segunda**]{.hl-yellow} (como un inner join pero sin aÃ±adir la info de la segunda tabla). Y el segundo, los anti join, hace justo lo contrario (aquellos que no estÃ¡n).


:::: columns
::: {.column width="50%"}

```{r}
# semijoin
tb_1 |> 
  semi_join(tb_2, by = c("key_1" = "key_2"))
```

:::

::: {.column width="50%"}

```{r}
# antijoin
tb_1 |> 
  anti_join(tb_2, by = c("key_1" = "key_2"))
```

:::
::::


---


## ğŸ’» Tu turno {#tu-turno-16}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

Para los ejercicios usaremos las tablas disponibles en el paquete `{nycflights13}` (echa un vistazo antes)

```{r}
library(nycflights13)
```

* [**airlines**]{.hl-yellow}: nombre de aerolÃ­neas (con su abreviatura).
* [**airports**]{.hl-yellow}: datos de aeropuertos (nombres, longitud, latitud, altitud, etc).
* [**flights**]{.hl-yellow}: datos de vuelos.
* [**planes**]{.hl-yellow}: datos de los aviones.
* [**weather**]{.hl-yellow}: datos meteorolÃ³gicos horarios de las estaciones LGA, JFK y EWR.

---

## ğŸ’» Tu turno {#tu-turno-16}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Del paquete `{nycflights13}` cruza la tabla `flights` con `airlines`. Queremos mantener todos los registros de vuelos, aÃ±adiendo la informaciÃ³n de las aerolÃ­neas a la tabla de aviones.

```{r}
#| eval: false
#| code-fold: true
flights_airlines <-
  flights |> 
  left_join(airlines, by = "carrier")
flights_airlines
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ A la tabla obtenida del cruce del apartado anterior, cruza despuÃ©s con los datos de los aviones en `planes`, pero incluyendo solo aquellos vuelos de los que tengamos informaciÃ³n de sus aviones (y viceversa). 


```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum")
flights_airlines_planes
```


### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Repite el ejercicio anterior pero conservando ambas variables `year` (en una es el aÃ±o del vuelo, en la otra es el aÃ±o de construcciÃ³n del aviÃ³n), y distinguiÃ©ndolas entre sÃ­



```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum",
             suffix = c("_flight", "_build_aircraft"))
flights_airlines_planes
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Al cruce obtenido del ejercicio anterior incluye la longitud y latitud de los aeropuertos en `airports`, distinguiendo entre la latitud/longitud del aeropuerto en destino y en origen.

```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes %>%
  left_join(airports %>% select(faa, lat, lon),
            by = c("origin" = "faa")) |> 
  rename(lat_origin = lat, lon_origin = lon) |> 
  left_join(airports %>% select(faa, lat, lon),
            by = c("dest" = "faa")) |> 
  rename(lat_dest = lat, lon_dest = lon)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Filtra de `airports` solo aquellos aeropuertos de los que salgan vuelos. Repite el proceso filtrado solo aquellos a los que lleguen vuelos

```{r}
#| eval: false
#| code-fold: true
airports |> 
  semi_join(flights, by = c("faa" = "origin"))
airports |> 
  semi_join(flights, by = c("faa" = "dest"))
```


### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Â¿De cuÃ¡ntos vuelos no disponemos informaciÃ³n del aviÃ³n? Elimina antes los vuelos que no tengan identificar (diferente a NA) del aviÃ³n


```{r}
#| eval: false
#| code-fold: true
flights |> 
  drop_na(tailnum) |>
  anti_join(planes, by = "tailnum") |>
  count(tailnum, sort = TRUE) # de mayor a menor ya de paso
```

:::


---

## Estructuras de control

Una [**estructura de control**]{.hl-yellow} se compone de una serie de comandos orientados a  [**decidir el camino**]{.hl-yellow} que tu cÃ³digo debe recorrer

* Si se cumple la condiciÃ³n A, Â¿quÃ© sucede?

* Â¿Y si sucede B?

* Â¿CÃ³mo puedo repetir una misma expresiÃ³n (dependiendo de una variable)?

. . .

Si has programado antes, quizÃ¡s te sea familiar las conocidas como [**estructuras condicionales**]{.hl-yellow} tales como `if (blabla) {...} else {...}`  o [**bucles**]{.hl-yellow} `for/while` (a evitar siempre que podamos).

---

## Estructura If

Una de las estructuras de control mÃ¡s famosas son las conocidas como [**estructuras condicionales**]{.hl-yellow} `if`.

> SI (IF) un conjunto de condiciones se cumple (TRUE), entonces ejecuta lo que haya dentro de las llaves

Por ejemplo, la estructura `if (x == 1) { cÃ³digo A }` lo que harÃ¡ serÃ¡ [**ejecutar el cÃ³digo A entre llaves**]{.hl-yellow} pero [**SOLO SI**]{.hl-purple} la [**condiciÃ³n entre parÃ©ntesis es cierta**]{.hl-purple} (solo si `x` es 1). En cualquier otro caso, no harÃ¡ nada.

. . .

Por ejemplo, definamos un vector de edades de 8 personas

```{r}
edad <- c(14, 17, 24, 56, 31, 20, 87, 73)
edad < 18
```

---

## Estructura If


Nuestra estructura condicional harÃ¡ lo siguiente: [**si existe algÃºn menor de edad, imprimirÃ¡**]{.hl-yellow} por pantalla un mensaje.

```{r}
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```

---

## Estructura If

```{r}
#| eval: false
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```


En caso de que las [**condiciones no sean ciertas**]{.hl-yellow} dentro de `if()` (`FALSE`), no sucede nada


```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
}
```

**No obtenemos ningÃºn mensaje** porque la condiciÃ³n `all(edad >= 18)` no es `TRUE`, asÃ­ que bno ejecuta nada.

---

## Estructura If-else

La estructura `if (condicion) { cÃ³digo A }` puede combinarse con un `else { cÃ³digo B }`: cuando la [**condiciÃ³n no estÃ¡ verificada**]{.hl-yellow}, se [**ejecutarÃ¡ el cÃ³digo alternativo B**]{.hl-yellow} dentro de `else { }`, permitiÃ©ndonos decidir que sucede cuando se cumple y cuando no.
. . .

Por ejemplo, `if (x == 1) { cÃ³digo A } else { cÃ³digo B }` ejecutarÃ¡ A si `x` es igual a 1 y B en cualquier otro caso.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else {
  
  print("Existe alguna persona menor de edad")
}
```

---

## Estructura If-else

Esta estructura `if - else` puede ser [**anidada**]{.hl-yellow}: imagina que queremos ejecutar un cÃ³digo si todos son menores; si no sucede, pero todos son mayores de 16, hacer otra cosa; en cualquier otra cosa, otra acciÃ³n.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else if (all(edad >= 16)) {
  
  print("Hay algÃºn menor de edad pero todos con 16 aÃ±os o mÃ¡s")
  
} else { print("Hay alguna persona con menos de 16 aÃ±os") }
```

::: callout-note
## Truco

Puedes **colapsar las estructuras** haciendo click en la flecha a la izquierda que aparece en tu script.

:::


---

## If-else vectorizado


Esta estructura condicional se puede [**vectorizar**]{.hl-yellow} (en una sola lÃ­nea) con `if_else()` (del paquete `{dplyr}`), cuyos argumentos son

* la condiciÃ³n a evaluar
* lo que sucede cuando se cumple
* lo que sucede cuando no
* un argumento opcional para cuando la condiciÃ³n a evaluar es `NA`

Por ejemplo, vamos a etiquetar sin son mayores/menores de edad y un "desconocido" cuando no conocemos la edad

```{r}
library(dplyr)
edad <- c(NA, edad)
if_else(edad >= 18, "mayor", "menor", missing = "desconocido")
```



---

## Bucles

Aunque en la mayorÃ­a de ocasiones se pueden reemplazar por otras estructuras mÃ¡s eficientes y legibles, es importante conocer una de las expresiones de control mÃ¡s famosas: los [**bucles**]{.hl-yellow}.

* `for { }`: permite [**repetir el mismo cÃ³digo**]{.hl-yellow} en un [**nÃºmero prefijado y conocido**]{.hl-purple} de veces.

* `while { }`: permite [**repetir el mismo cÃ³digo**]{.hl-yellow} pero en un [**nÃºmero indeterminado de veces**]{.hl-purple} (hasta que una **condiciÃ³n** deje de cumplirse).

---

## Bucles for

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de Ã³rdenes un nÃºmero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de Ã­ndices.

. . .

Por ejemplo, vamos a definir un vector `x` y vamos a imprimir sus elementos al cuadrado: definireos un Ã­ndice `i` para imprimir, en cada paso, el valor i-Ã©simo `x[i]^2`. Esos Ã­ndices irÃ¡n dentro de `for (indice in conjunto) { code }` (por ejemplo, `i in 1:4`)

```{r}
x <- c(0, -7, 1, 4)
for (i in 1:4) {
  
  print(x[i]^2)
  
}
```

---

## Bucles for

```{r}
#| eval: false
for (i in 1:4) { 
  print(x[i]^2) 
}
```

Dentro del parÃ©ntesis del `for ()` debemos tener una  [**secuencia de Ã­ndices**]{.hl-yellow} (en este caso, nÃºmeros). Si queremos hacer lo mismo pero excluyendo el segundo elemento simplemente definimos el conjunto de valores `c(1, 3, 4)` entre los que `i` puede moverse.

```{r}
for (i in c(1, 3, 4)) {
  
  print(x[i]^2)
  
}
```

---

## Bucles for

Otra forma de usar un bucle es definir de cero un vector: primer inicializamos en ceros `y <- rep(0, 4)` para despuÃ©s modificar cada [**elemento i-Ã©simo**]{.hl-yellow} definidos como `x[i]^2`.

```{r}
y <- rep(0, 4)
for (i in 1:4) {
  
  y[i] <- x[i]^2
  
}
y
```

. . .

Lo anterior es equivalente vectorialmente a

```{r}
y <- x^2
y
```

---

## Evitando bucles


Como ya hemos aprendido con el paquete`{microbenchmark}` podemos chequear como [**los bucles suelen ser muy ineficientes**]{.hl-yellow} (de ahÃ­ que debamos evitarlos en la mayorÃ­a de ocasiones

```{r}
library(microbenchmark)
x <- 1:1000
microbenchmark(y <- x^2, 
               for (i in 1:100) { y[i] <- x[i]^2 },
               times = 500)
```

---
 
## Bucles for


Podemos ver otro ejemplo  [**combinando nÃºmeros y textos**]{.hl-yellow}: definimos un vector de edades y de nombres, e imprimimos el nomber y edad i-Ã©sima.

```{r}
nombres <- c("Javi", "Sandra", "Carlos", "Marcos", "Marta")
edades <- c(33, 27, 18, 43, 29)

for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} aÃ±os")) 
  
}
```

---

## Bucles for


FÃ­jate que [**si no queremos estar pendientes de cuantos valores**]{.hl-yellow} tenemos, podemos hacer uso de `length()` para acceder a la [**Ãºltima posiciÃ³n**]{.hl-yellow} (sea cual sea).

```{r}
for (i in 1:length(nombres)) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} aÃ±os")) 
  
}
```

---

## Bucles for

Aunque normalmente se suelen indexar con vectors numÃ©ricos, los bucles pueden ser [**indexados sobre cualquier estructura vectorial**]{.hl-yellow}

```{r}
library(stringr)
week_days <- c("monday", "tuesday", "wednesday", "thursday",
               "friday", "saturday", "sunday")

for (days in week_days) {
  
  print(str_to_upper(days))
}
```

---

## Bucles for

Vamos a combinar las estructuras condicionales y los bucles: usando el conjunto `swiss` del paquete `{datasets}`, vamos a asignar `NA`  si los valores de fertilidad son mayores de 80.

```{r}
for (i in 1:nrow(swiss)) {
  
  if (swiss$Fertility[i] > 80) { 
    
    swiss$Fertility[i] <- NA
    
  }
}
```

. . .

Esto es exactamente igual a un `if_else()` vectorizado

```{r}
data("swiss")
swiss$Fertility <- if_else(swiss$Fertility > 80, NA, swiss$Fertility)
```


---

## Bucles while

Otra forma de crear un bucle es con la estructura `while { }`, que nos ejecutarÃ¡ un bucle [**un nÃºmero desconocido de veces**]{.hl-yellow}, hasta que una condiciÃ³n [**deje de cumplirse**]{.hl-yellow} (de hecho puede que nunca termine). Por ejemplo, vamos a inializar una variable `ciclos <- 1`, que incrementaremos en cada paso, y no saldremos del bucle hasta que `ciclos > 4`.

```{r}
ciclos <- 1
while(ciclos <= 4) {
  
  print(glue("No todavÃ­a, vamos por el ciclo {ciclos}")) 
  ciclos <- ciclos + 1
  
}
```


---
  
## Bucles while


Â¿QuÃ© sucede cuando la [**condiciÃ³n nunca es FALSE**]{.hl-yellow}? PruÃ©balo tu mismo

```{r}
#| eval: false
while (1 > 0) {
  
  print("Presiona ESC para salir del bucle")
  
}
```

&nbsp;

::: callout-warning
## Cuidado

Un bucle `while { }` puede ser bastante Â«peligrosoÂ» sino controlamos bien cÃ³mo pararlo.

:::

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `break`: permite [**abortar un bucle**]{.hl-yellow} incluso si no se ha llegado a su final

```{r}
for(i in 1:10) {
  if (i == 3) {
    
    break # si i = 3, abortamos bucle
    
  }
  print(i)
}
```

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `next`: [**fuerza un bucle a avanzar a la siguiente iteraciÃ³n**]{.hl-yellow} 

```{r}
for(i in 1:5) {
  if (i == 3) {
    
    next # si i = 3, la obvia y continua al siguiente
    
  }
  print(i)
}
```

---

## Bucles repeat

Aunque no es tan usado como las opciones anteriores, tambiÃ©n contamos con `repeat { }` que ejecuta un [**bucle de manera infinita hasta que se indique abortar**]{.hl-yellow} con un break

```{r}
count <- 0
repeat { 
  
  count <- count + 1
  if (count >= 100) { break }
  
}
count
```


---

## Replicate

Por Ãºltimo, otra forma de [**repetir cÃ³digo un nÃºmero de veces**]{.hl-yellow} es hacer uso de `replicate()`: simplemente permite repetir lo mismo [**n veces**]{.hl-yellow}

```{r}
x <- 1:3
replicate(n = 3, x^2)
```

---

## ğŸ’» Tu turno {#tu-turno-n-1}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para que se imprima un mensaje por pantalla si y solo si todos los datos de `airquality` son con mes distinto a enero

```{r}
#| eval: false
library(datasets)
months <- airquality$Month

if (months == 2) {
  print("No hay datos de enero")
}
```

```{r}
#| code-fold: true
#| eval: false
library(datasets)
months <- airquality$Month

if (all(months != 1)) {
  print("No hay datos de enero")
}
```


### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para guardar en una variable llamada `temp_alta` un `TRUE` si alguno de los registros tiene una temperatura superior a 90 grados Farenheit y `FALSE` en cualquier otro caso
 
```{r}
#| eval: false
temp <- airquality$Temp

if (temp == 100) {
  print("Algunos de los registros tienen temperaturas superiores a 90 grados Farenheit")
}
```

 
```{r}
#| eval: false
#| code-fold: true
# Option 1
temp <- airquality$Temp
temp_alta <- FALSE
if (any(temp > 90)) {
   temp_alta <- TRUE
}

# Option 2
temp_alta <- any(airquality$Temp > 90)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para diseÃ±ar un bucle `for` de 5 iteraciones que solo recorra los primeros 5 impares (y en cada paso del bucle los imprima)

```{r}
#| eval: false
for (i in 1:5) {
  
  print(i)
}
```

```{r}
#| eval: false
#| code-fold: true
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i)
}
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para diseÃ±ar un bucle `while` que empiece con un contador `count <- 1` y pare cuando llegue a 6

```{r}
#| eval: false
count <- 1
while (count == 2) {
  
  print(count)
}
```

```{r}
#| eval: false
#| code-fold: true
count <- 1
while (count < 6) {
  
  print(count)
  count <- count + 1
  
}
```


:::

# Clase n + 2:  depuraciÃ³n y Github

[**Depurando datos. Manejo de listas. Github**]{style="color:#444442;"}

---

## DepuraciÃ³n

En la bioestadÃ­stica, como en cualquier otro Ã¡mbito de aplicaciÃ³n, [**no siempre los datos los tendremos en el formato deseado**]{.hl-yellow}.

Ya hemos aprendido como pivotar nuestros datos para tenerlos en [**formato tidydata**]{.hl-yellow}, algo indispensable para una correcta depuraciÃ³n y visualizaciÃ³n. TambiÃ©n hemos aprendido algunas operaciones bÃ¡sicas de [**filtrado**]{.hl-yellow}, [**muestreo**]{.hl-yellow}, [**selecciÃ³n de variables**]{.hl-yellow} y [**recategorizaciÃ³n**]{.hl-yellow}

. . .

Veamos un nuevo paquete llamado `{skimr}`, cuya funciÃ³n `skim()` nos permitirÃ¡ tener un [**primer anÃ¡lisis exploratorio**]{.hl-yellow} de nuestros datos


```{r}
#| echo: false
library(skimr)
```

```{r}
#| eval: false
install.packages("skimr")
library(skimr)
iris |> skim()
```


---

## DepuraciÃ³n

Con dicha funciÃ³n podemos [**comprobar de manera rÃ¡pida**]{.hl-yellow} si nuestros datos presentan [**alguno de los siguientes problemas**]{.hl-red}

* [**Problemas de codificaciÃ³n o rango**]{.hl-red}: los valores parecen valores permitidos segÃºn lo que representa la variable (por ejemplo, no hay edades negativas)

* [**No tenemos datos ausentes**]{.hl-red}: no hace falta decidir, de momento, que hacemos con ellos, ya que `complete_rate` sale en todas 1 (`n_missing` estÃ¡ a cero).

* [**No parece que tengamos excesivos valores atÃ­picos**]{.hl-red}: a la vista de los pequeÃ±os histogramas y los percentiles, no parece que tengamos excesivos outliers (al menos muy evidentes)

* [**Todas las salvo Species son numÃ©ricas**]{.hl-red}: si tuviÃ©semos que montar un modelo predictivo todas las variables predictoras son numÃ©ricas.


* [**Casi todas parecen simÃ©tricas**]{.hl-red}: salvo `Petal.Length` las variables parecen mÃ¡s o menos simÃ©tricas (media se parece a mediana).

---

## DepuraciÃ³n

En general dado un dataset desde un punto de vista predictivo debemos preguntarnos

* [**1. TipologÃ­a**]{.hl-yellow} de las variables. Â¿Todas mis variables predictoras son numÃ©ricas o debo? Â¿Mi variable objetivo es categÃ³rica? Â¿Tienen la tipologÃ­a adecuada para mi metodologÃ­a?

. . .

* [**2. CodificaciÃ³n/rango**]{.hl-yellow} de las variables. Â¿Todas mis variables tienen un rango coherente (por ejemplo, que una variable de peso no sea negativa)? Â¿EstÃ¡n bien codificadas?

. . .

* [**3. AtÃ­picos y ausentes**]{.hl-yellow}. Â¿Tengo valores atÃ­picos (outliers)? En caso afirmativo, Â¿cÃ³mo tratarlos? Tras tratar atÃ­picos, Â¿tengo datos ausentes?

---

## DepuraciÃ³n


* [**4. SelecciÃ³n de variables**]{.hl-yellow}. Â¿Necesito seleccionar variables? Â¿Tengo alguna de **varianza cero** (es decir, sin informaciÃ³n)? Â¿Tengo problemas de **dependencia o colinealidad**? Â¿Puedo resumir mi info con un conjunto nuevo de variables incorreladas (componentes principales)?

. . .

* [**5. Variables dummy**]{.hl-yellow}. Â¿Debo recategorizar variables que no sean numÃ©ricas? 

. . .

* [**6. AÃ±adir info**]{.hl-yellow}. Â¿Debo crear nuevas variables que nos aporte info extra?

. . .

* [**7. Normalizar variables**]{.hl-yellow}. Â¿Tengo ya mis variables preparadas (tras tratar lo anterior) para el algoritmo que vaya usar (estandarizadas por rango o tipificadas por media-varianza, por ejemplo)?


---


## DepuraciÃ³n

Vamos a realizar un ejemplo sobre el dataset `starwars` del paquete `{dplyr}` dentro de tidyverse

```{r}
#| warning: false
#| message: false
library(tidyverse)
starwars
```

. . .

El objetivo serÃ¡ [**predecir el peso**]{.hl-yellow} (variable objetivo continua) mediante una [**regresiÃ³n lineal**]{.hl-yellow}.

---

## DepuraciÃ³n

Para simplificarlo vamos primero a [**seleccionar solo las columnas**]{.hl-yellow} de estatura, peso, edad y sexo.

```{r}
starwars_lm <- 
  starwars |>
  select(height:mass, birth_year:sex)
starwars_lm
```

---

## 1. TipologÃ­a

* [**TipologÃ­a**]{.hl-yellow} de las variables. Al ser una regresiÃ³n, Â¿todas mis variables predictoras y objetivo son numÃ©ricas?

. . .

En este caso [**no todas las predictoras son numÃ©ricas**]{.hl-red} ya que tenemos una variable categÃ³rica como `sex` que, de momento, [**vamos a eliminar**]{.hl-yellow}

```{r}
starwars_lm <- 
  starwars_lm |>
  select(where(is.numeric))
starwars_lm
```

---

## 2. CodificaciÃ³n/rango


* [**CodificaciÃ³n/rango**]{.hl-yellow} de las variables. Â¿Todas mis variables tienen un rango coherente (por ejemplo, que una variable de peso no sea negativa)? Â¿EstÃ¡n bien codificadas?

. . .

En este caso [**todas tienen rangos permitidos**]{.hl-green} (eso no significa que no tengamos outliers)

```{r}
#| eval: false
starwars_lm |> skim()
```

---

## 3. AtÃ­picos/ausentes

* [**AtÃ­picos y ausentes**]{.hl-yellow}. Â¿Tengo valores atÃ­picos (outliers)? En caso afirmativo, Â¿cÃ³mo tratarlos? Tras tratar atÃ­picos, Â¿tengo datos ausentes? (puedes probar distintos mÃ©todos en <https://odds.cs.stonybrook.edu/#table1>)

. . .


```{r}
#| eval: false
starwars_lm |> skim()
```

En este caso parece obvio que debemos [**tratar ausentes y atÃ­picos**]{.hl-red}

---

## 3. AtÃ­picos (media)

Una de las partes mÃ¡s importantes de la fase de exploraciÃ³n y modificaciÃ³n es la [**detecciÃ³n de outliers**]{.hl-yellow}, pudiendo tener **diferentes definiciones de valor atÃ­pico**:

* [**AtÃ­pico respecto a media**]{.hl-yellow}: serÃ¡ un dato muy alejado de la media de la variable. [**Â¿CuÃ¡nto de alejado?**]{.hl-purple} Una definiciÃ³n habitual es definir un [**dato atÃ­pico**]{.hl-yellow} como aquel que se [**aleja de la media  $k$ veces la desviaciÃ³n tÃ­pica**]{.hl-yellow} (un valor habitual es $k = 2.5$)

$$\left| x_i - \overline{x} \right| > k*s_{x}$$

. . .

Dicha definiciÃ³n de atÃ­pico [**solo tendrÃ¡ sentido cuando la media sea representativa**]{.hl-yellow} de tu distribuciÃ³n, es decir, siempre y cuando tengamos [**cierta simetrÃ­a**]{.hl-yellow} (en caos contrario la media, al ser poco robusta, se perturbarÃ¡ fÃ¡cilmente).

---

## 3. AtÃ­picos (media)

Para detectarlos usaremos el paquete `{outliers}` y su funciÃ³n `scores()`, que nos darÃ¡ en cada caso una [**"puntuaciÃ³n" de cada observaciÃ³n**]{.hl-yellow} (lo que se aleja). En caso de que queramos detectarlos **respecto a la media**, le indicaremos que `type = "z"` y nos devolverÃ¡ precisamente el valor  $k$

```{r}
# install.packages("outliers")
library(outliers)
abs(scores(c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8), type = "z"))
```

. . .

De esta forma podemos detectar muy fÃ¡cil los outliers en funciÃ³n de los estrictos que queramos ser con ese  $k$ (si supera un umbral, outlier). El tipo `type = "chisq"` nos hace algo parecido pero elevando las desviaciones al cuadrado y diviendo por la varianza.

---

## 3. AtÃ­picos (media)

Vamos a aplicarlo a nuestro dataset de starwars (de momento quitando ausentes)

```{r}
library(outliers)
k <- 2.5
starwars_outliers_mean <-
  starwars_lm |>
  drop_na() |> 
  mutate(across(everything(),
                function(x) {
                  if_else(abs(scores(x, type = "z")) > k, NA, x) }))
starwars_outliers_mean
```

---

## 3. AtÃ­picos (media)

Con `if_any()` dentro del `filter()` podemos mostrar todo los registros detectados como outlier en alguna variable.

```{r}
starwars_outliers_mean |>
  filter(if_any(everything(), is.na))
```


---

## 3. AtÃ­picos (mediana)


* [**AtÃ­pico respecto a mediana**]{.hl-yellow}: serÃ¡ un dato muy alejado de la mediana de la variable. [**Â¿CuÃ¡nto de alejado?**]{.hl-purple} Una definiciÃ³n habitual (conocido como **filtro de Hampel**) es definir un dato atÃ­pico como aquel que se [**aleja de la mediana $k$ veces la mediana de las desviaciones absolutas**]{.hl-yellow} (un valor habitual es $k=3$), conocida como $MAD = Me \left(|x_i - Me_x| \right)$

$$\left| x_i - Me_x \right| > k*MAD$$

. . .


Para ello nos bastarÃ¡ usar `scores()` con `type = "mad"` (y nos devolverÃ¡ de nuevo ese $k$).

```{r}
abs(scores(c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8), type = "mad"))
```


El [**valor a imputar serÃ­a la mediana**]{.hl-yellow}



---

## 3. AtÃ­picos (percentiles)


* [**AtÃ­pico respecto a percentiles**]{.hl-yellow}: serÃ¡ un dato muy alejado de los cuartiles de la variable. [**Â¿CuÃ¡nto de alejado?**]{.hl-purple}. Una definiciÃ³n habitual es definir un [**dato atÃ­pico como aquel que se aleja de cuartiles 1 y 3 (percentiles 25 y 75)  $k$ veces el rango intercuartÃ­lico**]{.hl-yellow} ($IQR = Q_3 - Q_1$). Un valor habitual es $k=1.5$

$$x_i > Q_3 + k*IQR \quad \text{ o bien } \quad x_i < Q_1 - k*IQR$$

. . .

Para ello nos bastarÃ¡ usar `scores()` con `type = "iqr"` (y nos devolverÃ¡ de nuevo ese $k$, siendo $k = 0$ para lo que estÃ© dentro del IQR).

```{r}

abs(scores(c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8), type = "iqr"))
```

El [**valor a imputar serÃ­a la mediana**]{.hl-yellow}

---

## 3. AtÃ­picos (inferencia)

Existen otros [**procedimientos basados en inferencia estadÃ­stica**]{.hl-yellow}  (muchos de ellos en el paquete  `{outliers}`)

* [**Tests de Grubbs y Dixon**]{.hl-yellow}: ambos test nos permiten detectar si el valor mÃ¡s alto (o bajo) de una variable es un outlier, pudiendo detectar [**un solo outlier en cada iteraciÃ³n**]{.hl-yellow} (en caso de detectarlo, deberÃ­amos tratarlo y volver a ejecutar el test)

$H_0$: valor mÃ¡s alto/bajo no es outlier

$H_1$: valor mÃ¡s alto/bajo sÃ­ es outlier
 
. . .

El [**test de Dixon**]{.hl-yellow} (basado en una ordenaciÃ³n) suele funcionar mejor cuando tenemos poca muestra que el test de Grubbs (basado en la media).

Ver mÃ¡s documentaciÃ³n de su funcionamiento en <https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h1.htm> y <https://www.statisticshowto.com/dixons-q-test/>

---


## 3. AtÃ­picos (inferencia)

```{r}
x <- c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8)
dixon.test(x, opposite = TRUE) # valor mÃ¡s bajo
x <- c(1, -1, 0, 5, 2, 1.5, 0.5, -0.3, 0, 2, 1.7, 0.2, -0.8)
dixon.test(x, opposite = FALSE) # valor mÃ¡s alto
```

---

## 3. AtÃ­picos (inferencia)

* [**Test de Rosner**]{.hl-yellow}: al contrario que los anteriores, nos permite detectar varios outliers a la vez, especialmente diseÃ±ado para evitar que un valor atÃ­pico nos perturbe tanto que nos enmascare otro (basado en la media). Podemos ejecutarlo con la funciÃ³n `rosnerTest()` del paquete `{EnvStats}`.
 

---

## 3. AtÃ­picos (isolation trees)


TambiÃ©n existen [**tÃ©cnicas de Machine Learning**]{.hl-yellow} para la identificaciÃ³n de outliers, como los conocidos como [**Isolation Forest**]{.hl-yellow}.

. . .

La idea es un poco similar a la de un [**Random Forest**]{.hl-yellow}, mediante la [**combinaciÃ³n de muchos Ã¡rboles**]{.hl-yellow} de clasificaciÃ³n/regresiÃ³n conocidos como **isolation trees**, aunque en este caso los puntos de corte se hace de manera totalmente aleatoria.

. . .

De esta manera, aquellos individuos con caracterÃ­sticas diferentes al resto quedarÃ¡n aislados rÃ¡pidamente, de manera que los [**outliers serÃ¡n aquellos aislados a los que se llega mÃ¡s rÃ¡pido**]{.hl-yellow} que al resto

---


## 3. AtÃ­picos (isolation trees)

El algoritmo se puede resumir con sigue:

1. Se crea un [**nodo raÃ­z**]{.hl-yellow} con una submuestra de N observaciones.

2. Se [**selecciona una variable aleatoriamente**]{.hl-yellow} y un [**corte (valor) aleatorio a**]{.hl-yellow} dentro de su rango

3. Se crean [**dos nodos nuevos**]{.hl-yellow} separando los observaciones ($x_i \leq a$ vs $x_i > a$)

4. Se [**repiten los pasos 2 y 3**]{.hl-yellow} hasta que 
[**todas las observaciones quedan aisladas**]{.hl-yellow} de forma individual.

5. Se repite el proceso tomando otra submuestra (bootstrap), de manera que el output de cada observaciÃ³n serÃ¡ el [**promedio de divisiones necesarias para aislarla**]{.hl-yellow}: cuanto mÃ¡s pequeÃ±o sea, mÃ¡s anÃ³malo serÃ¡.

---

## 3. AtÃ­picos (isolation trees)

Es un [**algoritmo no supervisado**]{.hl-yellow}, lo que significa que [**no hay un criterio Ã³ptimo objetivo**]{.hl-yellow} para decidir que a partir de dicho valor una observaciÃ³n es un outlier (idea: usar percentiles de dicha distancia, por ejemplo el 5-10% con menor distancia)

. . .

En casos donde el tamaÃ±o muestral sea elevado, aislar cada observaciÃ³n puede ser [**costoso computacionalmente**]{.hl-red} por lo que a veces se asume una [**profundidad mÃ¡xima**]{.hl-yellow} hasta donde puede crecer: las observaciones que sigan sin dividirse se les [**aÃ±ade el nÃºmero de divisiones teÃ³ricas promedio**]{.hl-yellow} $c(r)$
 que se necesitarÃ­an para aislarlos mediante un [**Ã¡rbol binario de bÃºsqueda (BST)**]{.hl-yellow} (con $r$ observaciones).
 
$$c(r) = 2H(r-1)-{\frac {2(r-1)}{r}}, \quad H(i) = \ln(i) + \gamma, \quad \gamma = 0.577216$$
 
---


## 3. AtÃ­picos (isolation trees)

Es importante que el dataset haya sido ya tratado por ausentes.

```{r}
library(solitude)
# Modelo isolation forest
m <- as.integer(nrow(starwars_lm |> drop_na())/2)
isoforest <-
  isolationForest$new(sample_size = m, num_trees = 500,
                      replace = TRUE, seed = 1234567,
                      max_depth = 7)
isoforest$fit(dataset = starwars_lm |> drop_na())

```

---

## 3. AtÃ­picos (isolation trees)

Con el modelo entrenado, se predicen las distancias de aislamiento promedio de cada observaciÃ³n. Los resultados que calcula `isoforest$predict()` son la [**distancia promedio `average_depth`**]{.hl-yellow} y una mÃ©trica que mide el [**grado de anomalÃ­a**]{.hl-yellow} `anomaly_score` (valores prÃ³ximos a 1 para outliers)

```{r}
predicciones <-
  isoforest$predict(data =
                      starwars_lm |> drop_na())
predicciones |> arrange(average_depth)
```

---

## 3. AtÃ­picos (isolation trees)

```{r}
#| code-fold: true
ggplot(data = predicciones, aes(x = average_depth)) +
  geom_density(fill = "#6D98ED", alpha = 0.5) +
  geom_vline(xintercept =
               quantile(predicciones$average_depth,
                        seq(0, 1, 0.1)),
             color = "#DC5B49", linetype = "dashed") +
  labs(title = "DistribuciÃ³n de distancias medias del Isolation Forest",
    subtitle = "Deciles marcados en rojo") +
  theme_minimal()
```


---


## 3. Ausentes

Tras marcar los outliers tenemos dos opciones

* [**eliminar dichas observaciones**]{.hl-yellow} (pasamos a NA y luego con `drop_na()`; problema: eliminas TODA la fila)

* [**imputar**]{.hl-yellow} (sin contar con los ausentes)

---

## 3. Ausentes

Antes de decidir podemos hacer uso del paquete `{naniar}` (ver <https://naniar.njtierney.com/>)

. . .

:::: columns
::: {.column width="50%"}

Por ejemplo con `geom_miss_point()` nos permite visualizar los valores ausentes (que por defecto ggplot los retira)

```{r}
#| eval: false
library(naniar)
ggplot(starwars_lm, 
       aes(x = height, y = mass)) + 
  geom_miss_point()
```
:::

::: {.column width="50%"}

```{r}
#| echo: false
library(naniar)
ggplot(starwars_lm, 
       aes(x = height, y = mass)) + 
  geom_miss_point()
```
:::

::::

---

## 3. Ausentes

TambiÃ©n podemos hacer uso de `gg_miss_var` para [**visualizar la cantidad de ausentes para cada variable**]{.hl-yellow}.

```{r}
gg_miss_var(starwars)
```

---

## 3. Ausentes

En `gg_miss_var` tenemos un argumento para facetar por una cualitativa.

```{r}
gg_miss_var(starwars, facet = sex)
```



---

## 3. Ausentes

Una forma de [**representar los ausentes**]{.hl-yellow} en un formato tidy es con la conocida como [**shadow matrix**]{.hl-purple}: una tabla con la misma dimensiÃ³n que los datos pero con [**indicadores binarios**]{.hl-yellow} sobre si tenemos (`NA`) o no missing (`!NA`), cuyas variables tiene de sufijo `_NA`

. . .

Esto lo podemos hacer con `as_shadow()`

```{r}
as_shadow(starwars_lm)
```

---

## 3. Ausentes

Con `bind_shadow()` podemos [**aÃ±adir la shadow matrix**]{.hl-yellow} al dataset original.

```{r}
bind_shadow(starwars_lm)
```

--- 

## 3. Ausentes

Lo anterior es equivalente a  construirlo con `nabular()` (tabular + NA)

```{r}
nabular(starwars) |> 
  summarise(media_peso = mean(mass, na.rm = ), .by = sex_NA)
```

---


## 3. Ausentes

TambiÃ©n podemos hacer uso de `add_prop_miss()` para aÃ±adir la [**proporciÃ³n de ausentes en cada registro**]{.hl-yellow}

```{r}
starwars_lm |>
  add_prop_miss()
```

---

## 3. Ausentes

Para [**imputar datos ausentes**]{.hl-yellow} podemos hacer uso de diferentes paquetes, entre ellos `{simpute}` y `{mice}` (ver <https://amices.org/mice/>)

. . .

Por ejemplo en el segundo paquete contamos con la funciÃ³n `md.pattern()` podemos [**visualizar la distribuciÃ³n de los ausentes**]{.hl-yellow}

```{r}
mice::md.pattern(starwars_lm)
```

---

## 3. Ausentes/atÃ­picos

En el caso de starwars vamos a [**imputar ausentes iniciales**]{.hl-yellow} con Random Forest (`mice::mice.impute.rf()`)...

```{r}
#| code-fold: true
#| message: false
starwars_lm_NA_init <-
  starwars_lm |> 
  # Imputamos NA iniciales
  mice::mice(ntree = 100, meth = "rf") |> 
  # Completamos NA
  complete()
```

---

## 3. Ausentes/atÃ­picos

... despuÃ©s [**detectar outliers**]{.hl-yellow} con isolation tree (por ejemplo el 5% con distancia mÃ¡s baja)...

```{r}
#| code-fold: true
#| message: false
m <- as.integer(nrow(starwars_lm_NA_init)/2)
isoforest <-
    isolationForest$new(sample_size = m, num_trees = 500,
                        replace = TRUE, seed = 1234567,
                        max_depth = 9)
isoforest$fit(dataset = starwars_lm_NA_init)

predicciones <-
    isoforest$predict(data = starwars_lm_NA_init)

id_outliers <- 
  predicciones |>
  slice_min(average_depth, prop = 0.05) |> 
  pull(id)

starwars_lm_sin_outliers <-
  starwars_lm_NA_init |> 
  rowid_to_column() |> 
  mutate(across(-rowid,
                function(x, y, z) {
                  if_else(y %in% z, NA, x) }, rowid, id_outliers)) |> 
  select(-rowid)
```

---

## 3. Ausentes/atÃ­picos

... y luego de nuevo [**imputar outliers (pasados a ausentes)**]{.hl-yellow} con Random Forest (`mice::mice.impute.rf()`).

```{r}
#| code-fold: true
#| message: false
starwars_lm_depurado <-
  starwars_lm_sin_outliers |> 
  # Imputamos NA iniciales
  mice::mice(ntree = 100, meth = "rf") |> 
  # Completamos NA
  complete()
starwars_lm_depurado
```




---

## 4. SelecciÃ³n de variables

* [**SelecciÃ³n de variables**]{.hl-yellow}. Â¿Necesito seleccionar variables? Â¿Tengo alguna de **varianza cero** (es decir, sin informaciÃ³n)? Â¿Tengo problemas de **dependencia o colinealidad**? Â¿Puedo resumir mi info con un conjunto nuevo de variables incorreladas (componentes principales)?

. . .

En este caso [**no tenemos altas correlaciones entre las variables predictoras**]{.hl-yellow}: nos interesa predictoras lo mÃ¡s incorreladas posibles entre sÃ­ y lo mÃ¡s correladas con la objetivo (por ejemplo, altura alta correlaciÃ³n con peso)

```{r}
starwars_lm_depurado |> corrr::correlate()
```

---


## 4. SelecciÃ³n de variables

El paquete `{corrr}` y `{corrrplot`} nos permite visualizar dichas correlaciones


```{r}
corrplot::corrplot(starwars_lm_depurado |> cor())
```

---

## 5.6.7. DepuraciÃ³n

* [**Variables dummy**]{.hl-yellow}. Â¿Debo recategorizar variables que no sean numÃ©ricas? (ver `{fastDummies}`)

* [**AÃ±adir info**]{.hl-yellow}. Â¿Debo crear nuevas variables que nos aporte info extra?

* [**Normalizar variables**]{.hl-yellow}. Â¿Tengo ya mis variables preparadas (tras tratar lo anterior) para el algoritmo que vaya usar (estandarizadas por rango o tipificadas por media-varianza, por ejemplo)?



En este caso [**no es necesario dummificar**]{.hl-green} ya que hemos considerado solo las numÃ©ricas. Al no tener que seleccionar variables y aplicar una regresiÃ³n lineal [**tampoco es indispensable normalizar**]{.hl-green} y [**no vamos aÃ±adir info nueva**]{.hl-green}

---


## RegresiÃ³n lineal

Vamos a comparar 3 modelos de regresiÃ³n: [**sin tratar nada**]{.hl-yellow}, eliminando ausentes, y el tratamiento de ausentes/atÃ­picos realizados.

```{r}
starwars_lm |> lm(formula = mass ~ .) |> summary()
```

---

## RegresiÃ³n lineal

Vamos a comparar 3 modelos de regresiÃ³n: sin tratar nada, [**eliminando ausentes**]{.hl-yellow}, y el tratamiento de ausentes/atÃ­picos realizados.


```{r}
starwars_lm |> drop_na() |> lm(formula = mass ~ .) |> summary()
```


---

## RegresiÃ³n lineal

Vamos a comparar 3 modelos de regresiÃ³n: sin tratar nada, eliminando ausentes, y el [**tratamiento de ausentes/atÃ­picos realizados**]{.hl-yellow}.

```{r}
starwars_lm_depurado |> lm(formula = mass ~ .) |> summary()
```

---

## RegresiÃ³n lineal

Vamos a comparar 3 modelos de regresiÃ³n: sin tratar nada, eliminando ausentes, y el tratamiento de ausentes/atÃ­picos realizados.

* [**sin tratar nada**]{.hl-yellow}: obtenemos $R^2 = 0.3367$ con el intercepto no significativo

* [**eliminando ausentes**]{.hl-yellow}: obtenemos lo mismo (por defecto `lm()` se carga los ausentes)

* [**tratamiento de ausentes/atÃ­picos**]{.hl-yellow}: obtenemos $R^2 = 0.5551$ con edad no significativa

---

## 5. Variables dummies

Otra opciÃ³n a veces es aÃ±adir informaciÃ³n extra de manera los outliers nos ayuden mejor a predecir, y en este caso aÃ±adiremos la variable sexo haciÃ©ndola dummy (**one-hot encoding**): creamos $k-1$ variables binarias con `dummy_cols()` del paquete `fastDummies`


```{r}
#| code-fold: true
#| message: false
library(fastDummies)
starwars_lm_sex <- 
  starwars |>
  select(height:mass, birth_year:sex) |> 
  drop_na(sex) |> 
  # Imputamos NA iniciales
  mice::mice(ntree = 100, meth = "rf") |> 
  # Completamos NA
  complete()
```

---

## 5. Variables dummies

Otra opciÃ³n a veces es aÃ±adir informaciÃ³n extra de manera los outliers nos ayuden mejor a predecir, y en este caso aÃ±adiremos la variable sexo haciÃ©ndola dummy (**one-hot encoding**): creamos $k-1$ variables binarias con `dummy_cols()` del paquete `fastDummies`

Obtenemos un $R^2 = 0.5498$ (similar a haber tratado de outliers)

```{r}
starwars_lm_sex_depurado <-
  starwars_lm_sex |>
  dummy_cols(select_columns = "sex", remove_first_dummy = TRUE,
             remove_selected_columns = TRUE)

starwars_lm_sex_depurado |> lm(formula = mass ~ .) |> summary()
```

---

## La imputaciÃ³n importa


El [**mÃ©todo de imputaciÃ³n serÃ¡ crucial**]{.hl-yellow}: si imputamos los ausentes de las numÃ©ricas por la media, esto es lo que obtenemos (sobreajuste).

```{r}
#| code-fold: true
#| message: false
library(fastDummies)
starwars_lm_sex <- 
  starwars |>
  select(height:mass, birth_year:sex) |> 
  drop_na(sex) |> 
  # Imputamos NA iniciales
  mice::mice(meth = "mean") |> 
  # Completamos NA
  complete()
```

---

## La imputaciÃ³n importa


El [**mÃ©todo de imputaciÃ³n serÃ¡ crucial**]{.hl-yellow}: si imputamos los ausentes de las numÃ©ricas por la media, esto es lo que obtenemos (sobreajuste).

```{r}
starwars_lm_sex_depurado <-
  starwars_lm_sex |>
  dummy_cols(select_columns = "sex", remove_first_dummy = TRUE,
             remove_selected_columns = TRUE)

starwars_lm_sex_depurado |>
  lm(formula = mass ~ height + birth_year) |>
  summary()
```

---

## La imputaciÃ³n importa

El [**mÃ©todo de imputaciÃ³n serÃ¡ crucial**]{.hl-yellow}: si imputamos los ausentes de las numÃ©ricas por la media, esto es lo que obtenemos (sobreajuste).

```{r}
#| code-fold: true
starwars_lm_sex_depurado |>
  lm(formula = mass ~ .) |>
  summary()
```


# El mundo Github

[**Trabajar ordenados, publicar resultados, replicabilidad de lo realizado**]{style="color:#444442;"}

---

## Â¿QuÃ© es Github?

[**GitHub**]{.hl-yellow} es la plataforma colaborativa mÃ¡s conocida basada en el [**sistema de control de versiones Git**]{.hl-yellow}

. . .

-   [**Â¿QuÃ© es Git?**]{.hl-purple} Git es un sistema de [**control de versiones**]{.hl-yellow}: una especie de [**Dropbox**]{.hl-yellow} para facilitar la [**programaciÃ³n colaborativa**]{.hl-yellow} entre un grupo de personas, permitiendo llevar la [**trazabilidad de los cambios**]{.hl-yellow} realizados.

. . .

-   [**Â¿QuÃ© es Github?**]{.hl-purple} Nuestra [**plataforma/interfaz**]{.hl-yellow} para ejecutar el control de versiones: nos servirÃ¡ no solo para trabajar colaborativamente sino para [**hacer transparente**]{.hl-yellow} el proceso de construcciÃ³n de nuestros proyectos de cÃ³digo.

. . .

::: callout-important
## Importante

Desde el 4 de junio de 2018 Github es de Microsoft (ergo el cÃ³digo que subas tambiÃ©n)
:::

---

## VisiÃ³n general

Tras hacernos una cuenta en Github, [**arriba a la derecha**]{.hl-purple} tendremos un cÃ­rculo, y haciendo click en [**Your Profile**]{.hl-purple}, veremos algo similar a esto

::: columns
::: {.column width="55%"}
![](img/github_1.png)
:::

::: {.column width="45%"}
-   [**Edit profile**]{.hl-purple}: nos permite aÃ±adir una [**descripciÃ³n y foto de perfil**]{.hl-yellow}.

-   [**Overview**]{.hl-purple}: en ese panel de cuadrados se [**visualizarÃ¡ nuestra actividad**]{.hl-yellow} a lo largo del tiempo.

-   [**Repositories**]{.hl-purple}: el cÃ³dugo serÃ¡ subido a [**repositorios**]{.hl-yellow}, el equivalente a nuestras carpetas compartidas en Dropbox.
:::
:::

---

## Primer uso: consumidor

Antes de aprender como crear repositorios, Github tambiÃ©n nos servirÃ¡ para

-   [**Acceder a cÃ³digo**]{.hl-purple} ajeno
-   [**Proponer mejoras**]{.hl-purple} a otros usuarios, e incluso proponer [**correcciones de error que detectemos**]{.hl-yellow} de software que usemos

. . .

-   [**Instalar paquetes de R**]{.hl-purple}. En muchas ocasiones los desarrolladores de paquetes suben las actualizaciones a CRAN cada cierto tiempo, y en otras el software no es suficientemente Â«amplioÂ» para poder ser subido como paquete.

El cÃ³digo de paquetes que no tengamos subido en CRAN podremos [**instalarlo como cÃ³digo desde Github**]{.hl-yellow}

---

## Instalar desde Github

Por ejemplo, vamos a instalar un paquete llamado [`{peRReo}`](https://github.com/jbgb13/peRReo), cuya Ãºnica funciÃ³n es darnos [**paletas de colores**]{.hl-yellow} basadas en portadas de [**Ã¡lbumes de mÃºsica urbana**]{.hl-yellow}

::: columns
::: {.column width="50%"}
![](img/perrreo.png)
:::

::: {.column width="50%"}
![](img/rosalia.png){width="360"}
:::
:::

. . .

Para ello antes tendremos que instalar un [**conjunto de paquetes para desarrolladores**]{.hl-yellow} llamado `{devtools}`, que nos permitirÃ¡ la instalaciÃ³n desde Github

```{r}
#| eval: false
install.packages("devtools")
```

---

## Instalar desde Github

Las [**instrucciones de instalaciÃ³n**]{.hl-yellow} suelen venir detalladas en la portada del repositorio

::: columns
::: {.column width="50%"}
![](img/install_perreo.png)
:::

::: {.column width="50%"}
![](img/rosalia.png){width="310"}
:::
:::

. . .

En la mayorÃ­a de casos bastarÃ¡ con la funciÃ³n `install_github()` (del paquete que acabamos de instalar), pasÃ¡ndole como argumento la [**ruta del repositorio**]{.hl-yellow} (sin "github.com/").

```{r}
#| eval: false
devtools::install_github("jbgb13/peRReo")
```

Ya puedes perrear con ggplot ;)

---

## Descargar desde Github

La mayorÃ­a de veces lo que subamos no serÃ¡ un paquete de R como tal sino que [**subiremos un cÃ³digo mÃ¡s o menos organizado**]{.hl-yellow} y comentado. En ese caso podremos [**descargar el repo entero**]{.hl-yellow} haciendo click [**Code**]{.hl-green} y luego Download ZIP.

Por ejemplo, vamos a descargarnos los scripts de dataviz que han subido desde el [Centre d'Estudis d'OpiniÃ³](https://github.com/ceopinio/bop-grafics)

![](img/ceo_github.png)

---

## Ideal

![](img/abogados_simpson.jpeg){width="600"}

[**Â¿Lo ideal en caso de RTVE?**]{.hl-purple} Tener dos tipos de repositorios

-   Una [**colecciÃ³n de repositorios pÃºblicos (producciÃ³n)**]{.hl-yellow} donde hacer transparente el cÃ³digo y los datos ([**ya validados**]{.hl-purple}), coordinado por un nÂº reducido de personas.

-   Una [**colecciÃ³n de repositorios privados (desarrollo)**]{.hl-yellow} donde estÃ© todo el equipo colaborando y donde se haga el [**trabajo del dÃ­a**]{.hl-purple}, con trazabilidad interna.

---

## Nuestro primer repositorio

Vamos a [**crear nuestro primero repositorio**]{.hl-yellow} que servirÃ¡ ademÃ¡s como [**carta de presentaciÃ³n**]{.hl-yellow} de nuestro perfil en Github.

1.  [**Repositories**]{.hl-purple}: hacemos click en las pestaÃ±a de Repositories.

2.  [**New**]{.hl-purple}: hacemos click en el [**botÃ³n verde New**]{.hl-green} para crear un nuevo repositorio

![](img/new_repo.png)

---

## Nuestro primer repositorio

-   [**Repository name**]{.hl-purple}: el [**nombre del repositorio**]{.hl-yellow}. En este caso vamos a crear un repositorio muy concreto: el nombre debe [**coincidir exactamente con tu nombre de usuario**]{.hl-yellow}

-   [**Description**]{.hl-purple}: descripciÃ³n de tu repositorio. En este caso serÃ¡ un repo de presentaciÃ³n.

![](img/repo_init_1.png)

---

## Nuestro primer repositorio

-   [**Public vs private**]{.hl-purple}: con cada repositorio tendremos la opciÃ³n de hacer el repositorio

    -   [**pÃºblico**]{.hl-purple}: todos los usuarios podrÃ¡n ver el cÃ³digo asÃ­ cÃ³mo la trazabilidad de su desarrollo (quÃ© se aÃ±ade y cuÃ¡ndo). Es para mÃ­ la opciÃ³n mÃ¡s recomendable cuando quieres darle [**visibilidad y transparencia**]{.hl-yellow} a tu trabajo
    -   [**privado**]{.hl-purple}: solo tendrÃ¡n acceso al repositorio aquellos usuarios a los que se lo permitas. No se podrÃ¡ visualizar ni instalar nada de Ã©l fuera de Github.

![](img/repo_init_2.png)

En este caso concreto, dado que serÃ¡ un repositorio de presentaciÃ³n, lo [**haremos pÃºblico**]{.hl-yellow}.

---

## Nuestro primer repositorio

-   [**Add a README file**]{.hl-purple}: un README file serÃ¡ el archivo donde incluiremos las [**instrucciones y detalles de uso**]{.hl-yellow} a los demÃ¡s (en el caso de `{peRReo}` era el archivo que contenÃ­a los detalles de instalaciÃ³n)

![](img/repo_init_3.png)

De momento [**ignoraremos los demÃ¡s campos**]{.hl-red} para este primer repositorio.

---

## Nuestro primer repositorio

![](img/repo_init_1.png)

Por defecto Github asume que este repositorio, con el [**mismo nombre que nuestro usuario**]{.hl-yellow} serÃ¡ el repositorio que querremos que se presente de inicio cuando alguien entra en nuestro perfil, y serÃ¡ el repositorio donde \[**incluir en el README.md**\] una presentaciÃ³n de nosotros y un Ã­ndice de tu trabajo (si quieres).

---

## Nuestro primer repositorio

![](img/profile_github_md.png)

FÃ­jate que ahora en nuestra [**portada tenemos dicho README.md**]{.hl-yellow} que podemos personalizar a nuestro gusto haciendo uso de [**html y markdown**]{.hl-yellow}.

AquÃ­ puedes ver [**algunos ejemplos de README.MD**](https://github.com/matiassingers/awesome-readme)

---

## Repo de cÃ³digo

Una vez que tenemos nuestro README de presentaciÃ³n (recuerda que puedes [**personalizar a tu gusto con html y markdown**]{.hl-yellow}) vamos a crear un [**repositorio de cÃ³digo**]{.hl-yellow}.

. . .

Si ya era importante [**trabajar con proyectos**]{.hl-yellow} en `RStudio`, cuando lo combinamos con Github es aÃºn mÃ¡s crucial que creemos un proyecto antes de subir el cÃ³digo, asÃ­ que vamos a crear uno de prueba que se llame `repo-github-1`.

. . .

En dicho proyecto vamos a [**crear un script**]{.hl-yellow} (en mi caso llamado **codigo.R**) en el que deberÃ¡s hacer los siguientes pasos:

---

## Repo de cÃ³digo

1.  [**Carga**]{.hl-yellow} directamente desde la pÃ¡gina del [ISCIII](https://cnecovid.isciii.es/covid19/resources) el archivo llamado `casos_hosp_uci_def_sexo_edad_provres.csv`

```{r}
#| eval: false
#| code-fold: true
# Carga de datos desde ISCIII
datos_covid <- read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
```

. . .

2.  [**Filtra**]{.hl-yellow} datos de Madrid (`"M"`), de 2020 y con sexo conocido (hombre/mujer). Tras ello quÃ©date con las columnas `fecha`, `sexo`, `grupo_edad`, `num_casos` (ese orden). Por Ãºltimo obtÃ©n la suma de casos diarios por fecha y sexo.

```{r}
#| eval: false
#| code-fold: true
# DepuraciÃ³n
datos_madrid <-
  datos_covid |>
  # Filtrado por Madrid y fecha
  filter(provincia_iso == "M" & fecha <= "2020-12-31" & sexo != "NC") |> 
  # SelecciÃ³n de columnas
  select(provincia_iso:fecha, num_casos) |> 
  # Resumen de casos diarios por fecha y sexo
  summarise(num_casos = sum(num_casos), .by = c(fecha, sexo))
  
```

---

## Repo de cÃ³digo

3.  [**Exporta el dataset a un csv**]{.hl-yellow} en una carpeta que se llame `exportado`

```{r}
#| eval: false
#| code-fold: true
# Exportamos datos
write_csv(datos_madrid, file = "./exportado/datos_madrid.csv")
```

. . .

::: columns
::: {.column width="40%"}
4.  Crea una [**grÃ¡fica de lÃ­neas**]{.hl-yellow} que tenga en el eje x fecha, en el eje y casos, con una curva por sexo (grÃ¡ficas separadas).

```{r}
#| eval: false
#| code-fold: true
# GrÃ¡fica
ggplot(datos_madrid) +
  geom_line(aes(x = fecha, y = num_casos, color = sexo),
            alpha = 0.6, linewidth = 0.7) +
  scale_color_manual(values = c("#85519D", "#278862")) +
  facet_wrap(~sexo) +
  theme_minimal() +
  theme(legend.position = "bottom")
```
:::

::: {.column width="60%"}
![](./img/ggplot.png){width="380"}
:::
:::

. . .

5.  Tras ello [**exportamos la grÃ¡fica**]{.hl-yellow}

```{r}
#| eval: false
ggsave(filename = "./exportado/ggplot.png", plot = last_plot(),
       bg = "white", width = 12, height = 8)
```

---

## Repo de cÃ³digo

Â¿CÃ³mo [**subimos el proyecto**]{.hl-yellow}? Vamos de nuevo a [**crear un proyecto de cero**]{.hl-yellow}. Antes no hemos hablado de dos campos importantes:

::: columns
::: {.column width="50%"}
![](./img/repo-1.png){width="460"}
:::

::: {.column width="50%"}
-   `Add .gitignore` nos permitirÃ¡ [**seleccionar el lenguaje**]{.hl-yellow} en el que estarÃ¡ nuestro proyecto para que Github lo entienda al sincronizar (y no actualice cosas que no deba).

-   `Choose a license` nos permitirÃ¡ [**seleccionar la licencia**]{.hl-yellow} que determinarÃ¡ las condiciones en las que otros podrÃ¡n reusar tu cÃ³digo.
:::
:::

---

## Repo de cÃ³digo

::: columns
::: {.column width="50%"}
![](./img/repo-1-1.png)
:::

::: {.column width="50%"}
Si te fijas traer crearlo tenemos solo 3 archivos: el de licencia, el .gitignore y el readme.md (donde deberÃ­amos escribir una guÃ­a de uso de lo que hayamos subido)
:::
:::

Para subir los archivos vamos a clickar en [**Add file \< Upload File**]{.hl-purple} y [**arrastraremos TODOS los archivos**]{.hl-yellow} de la carpeta de nuestro proyecto.

---

## Repo de cÃ³digo

Tras la subida de archivos tendremos un cuadro llamado [**Commit changes**]{.hl-purple}

![](./img/commit-1.png)

Un [**commit**]{.hl-purple} es una [**modificaciÃ³n del repositorio**]{.hl-yellow} con algo que se aÃ±ade/elimine/modifique, y dicho cuadro es recomendable usarlo para [**resumir en quÃ© consiste la modificaciÃ³n**]{.hl-yellow}, de manera que quede trazado el cambio.

---

## Repo de cÃ³digo

Haciendo click en el reloj donde indica el [**nÃºmero de commits**]{.hl-yellow} accedemos al [**histÃ³rico de commits (cambios)**]{.hl-yellow} con hora, dÃ­a, autor, comentarios, etc.

![](./img/commit-reloj.png)

---

## Repo de cÃ³digo

Vamos a realizar un [**cambio en nuestro cÃ³digo**]{.hl-yellow}: en tu cÃ³digo local (local --\> tu ordenador), en lugar de filtrar por Madrid haz el [**filtro por Barcelona**]{.hl-yellow}, guarda el cÃ³digo y sube en el repositorio el nuevo archivo (con el mismo nombre, Github harÃ¡ la sobrescritura)

```{r}
#| eval: false
#| code-line-numbers: "3"
datos_bcn <-
  datos_covid |>
  filter(provincia_iso == "B" & fecha <= "2020-12-31" & sexo != "NC") |> 
  select(fecha, sexo, grupo_edad, num_casos) |> 
  summarise(num_casos = sum(num_casos), .by = c(fecha, sexo))
```

---

## Consulta de commits

![](./img/barcelona_covid.png){width="550"}

::: columns
::: {.column width="40%"}
Si ahora [**consultamos el commit**]{.hl-yellow}, al lado hay un nÃºmero que lo identifica, y clickando en Ã©l nos resume los cambios: no solo [**almacena todas las versiones pasadas**]{.hl-yellow} sino que ademÃ¡s nos [**muestra las diferencias entre los archivos cambiados**]{.hl-yellow}
:::

::: {.column width="60%"}
![](./img/commit_cambio.png)
:::
:::

---

## Trazabilidad de cambios

::: columns
::: {.column width="72%"}
![](./img/commit_split.png) ![](./img/commit_unified.png)
:::

::: {.column width="28%"}
Tenemos [**dos modos de visualizaciÃ³n**]{.hl-yellow} de los cambios: el modo split nos muestra el antiguo y el nuevo, con las inclusiones en verde y lo que ya no estÃ¡ en rojo; y el modo unified nos muestra todo en un mismo documento.
:::
:::

---

## RecuperaciÃ³n de commits

![](./img/browse-repo.png)

Github nos permite incluso [**recuperar una versiÃ³n del pasado**]{.hl-yellow} de nuestro repositorio, haciendo click en el tercer icono del commit.

---

## RecuperaciÃ³n de commits

![](./img/branch-commit.png)

Si te fijas ahora al lado de `1 branch` tenemos un [**menÃº desplegable**]{.hl-yellow} en el que antes ponÃ­a `main` y ahora un nÃºmero identificador del commit. Ya hablaremos de la idea de [**rama (branch)**]{.hl-yellow}

---

## Repo con rmd/qmd

::: columns
::: {.column width="60%"}
Vamos a poner en prÃ¡ctica lo aprendido:

1.  Crea un nuevo repositorio en Github (llamado `repo-github-2`) donde habrÃ¡ alojado con proyecto de R.

2.  Crea un proyecto en `RStudio` que se llame (por ejemplo) `proyecto-qmd`

3.  Una vez dentro del proyecto en `RStudio` haz click en `File < New File < Quarto Document`
:::

::: {.column width="40%"}
![](./img/primer-qmd.png)
:::
:::

DeberÃ¡s tener un documento similar a este: un [**quarto markdown (.qmd)**]{.hl-yellow}, un documento que nos permitirÃ¡ incluir [**markdown + cÃ³digo**]{.hl-yellow} (puede ser `R` o puede ser `Observable`, `D3`, etc).

---

## Repo con rmd/qmd

Este formato es ideal para:

-   [**Trabajar en equipo**]{.hl-yellow} construyendo el borrador de una pieza.
-   Tomar [**apuntes o informes**]{.hl-yellow} para uno mismo.
-   [**Presentar**]{.hl-yellow} tu trabajo a tus compaÃ±eros.

::: columns
::: {.column width="50%"}
![](./img/prueba-qmd-html.png)
:::

::: {.column width="50%"}
Si te fijas ahora nuestro repositorio tiene un archivo con formato `.html`...es decir...

[**Â¡Es una web!**]{.hl-yellow}
:::
:::

---

## Github pages

Â¿CÃ³mo [**convertir nuestro repositorio en una web**]{.hl-yellow}?

![](./img/github-pages.png)

1.  Haz click en `Settings`
2.  Ve al apartado `Pages`
3.  En el subapartado `branch` selecciona la Ãºnica rama que tenemos ahora (`main`)
4.  Selecciona la carpeta donde tengas el `.html` (en web complejas estarÃ¡ como en cualquier web en `docs`, en algo simple estarÃ¡ en la ruta raiz del repositorio)
5.  Haz click en `Save`

---

## Github pages

Si te fijas en la [**parte superior del repositorio**]{.hl-yellow} ahora tenemos un icono naranja, que nos indica que la [**web estÃ¡ en proceso de ser desplegada (deploy)**]{.hl-orange}

![](./img/github-naranja.png)

---

## Github pages

Pasados unos segundos (dependiendo del tamaÃ±o de la web y tu conexiÃ³n a internet) ese [**icono pasarÃ¡ a ser un check verde**]{.hl-green}: habemus web

![](./img/github-verde.png)

El [**link de la web por defecto**]{.hl-yellow} serÃ¡ `{nombre_usuario}.github.io/{nombre_repo}`

---

## Github pages

![](./img/github-pages-deploy.png)

Â¡Un momento! Ahora mismo nuestra web [**no nos estÃ¡ mostrando nuestro .qmd**]{.hl-red}, sino por defecto el [**README.md**]{.hl-yellow}.

. . .

Para que Github entienda que queremos visualizar ese `.html` que hemos generado a partir del `.qmd` vamos en nuestro proyecto local a [**borrar**]{.hl-yellow} todo lo que no sea nuestro archivo `.Rproj` y nuestro archivo `.qmd`, y vamos a [**cambiar el nombre**]{.hl-yellow} a este Ãºltimo llamÃ¡ndolo `index.qmd`, y volvemos a compilarlo para [**generar un index.html**]{.hl-yellow}

---

## Github pages

Vamos a [**subir a Github ese nuevo proyecto**]{.hl-yellow} con el cambio de nombre (llamado `repo-github-3`) para ver luego las diferencias entre uno y otro

![](./img/repo-index-html.png)

---

## Github pages

Si [**repetimos el proceso para hacer una Page**]{.hl-yellow} y esperamos al tick verde...

::: columns
::: {.column width="50%"}
![](./img/index-html-qmd.png)
:::

::: {.column width="50%"}
Si a tu `.qmd` ya le llamas de inicio `index.qmd`, automÃ¡ticamente, al detectar Github un `index.html`, interpreta que ese [**archivo index.html**]{.hl-yellow} es el que define la web (y puedes personalizar aÃ±adiendo un archivo `css` de estilos)

[**Habemus web**]{.hl-green} simplemente clickando en Pages :)
:::
:::

---

## Repo con diapositivas

Vamos a crear el Ãºltimo repositorio que se llamarÃ¡ `repo-diapos`, y crear un proyecto en `RStudio` del mismo nombre (por ejemplo). Una vez creado le daremos a `File < New File < Quarto Presentation`.

::: columns
::: {.column width="45%"}
![](img/quarto-slides.png)
:::

::: {.column width="55%"}
La forma de escribir serÃ¡ igual que un `.qmd` normal solo que ahora [**cada diapositiva la separaremos**]{.hl-yellow} con un `---` (usando archivos de estilos podemos personalizar lo que queramos)

Llama al archivo directamente `index.qmd`, sÃºbelo a Github y con un click en Pages tienes una [**web con tus diapositivas**]{.hl-yellow}
:::
:::

---

## Uso de Gitkraken

La forma mÃ¡s [**sencilla para trabajar de manera colaborativa**]{.hl-yellow} en Github, y tenerlo sincronizado con nuestro local, es hacer uso de [Gitkraken](https://www.gitkraken.com/download)

::: columns
::: {.column width="50%"}
![](img/gitkraken-repo.png)
:::

::: {.column width="50%"}
Una vez dentro clickamos en el icono de la carpeta (`Repo Management`) y si ya tenemos el repositorio en Github seleccionamos `Clone`, indicando donde queremos clonar (en nuestro local) y que [**repositorio de Github queremos clonar**]{.hl-yellow}.
:::
:::

---

## Uso de Gitkraken

::: columns
::: {.column width="50%"}
![](img/view-change.png)
:::

::: {.column width="50%"}
Una vez clonado, la idea es que cada [**cambio que hagamos en local nos aparecerÃ¡ en Gitkraken**]{.hl-yellow} como `View changes`.
:::
:::

---

## Uso de Gitkraken

Cuando tengas suficientes cambios como para [**actualizar el repositorio**]{.hl-yellow} (tampoco tiene sentido actualizar con cada ediciÃ³n), verÃ¡s algo similar a esto con todos los [**commits realizados**]{.hl-yellow}

::: columns
::: {.column width="50%"}
![](img/stage-all-changes.png)
:::

::: {.column width="50%"}
PodrÃ¡s decidir cuÃ¡les de los [**commits locales quieres incluir en remoto**]{.hl-yellow}, bien uno a uno o en `Stage all changes` (para todos)
:::
:::

---

## Uso de Gitkraken

Tras incluir los commits deberÃ¡s incluir un [**tÃ­tulo y descripciÃ³n del commit**]{.hl-yellow}

![](img/titulo-commit.png)

---

## Uso de Gitkraken

Tras hacerlo verÃ¡s que ahora tenemos [**dos iconos separados en una especie de Ã¡rbol**]{.hl-yellow} (Â¿te acuerdas de la `branch` o rama?):

-   [**Ordenador**]{.hl-purple}: la versiÃ³n del repositorio que tienes en tu [**ordenador**]{.hl-yellow}.

-   [**Logo**]{.hl-purple}: la versiÃ³n del repositorio que tienes [**subida en remoto**]{.hl-yellow}

![](img/split-gitkraken.png)

---

## Uso de Gitkraken

Mientras eso suceda solo tendrÃ¡s sincronizado tu ordenador con Gitkraken, pero no con Github. Para ello haremos [**click en Push**]{.hl-yellow} (con `Pull` podrÃ¡s forzar a tener en local lo mismo que en remoto).

![](img/push-gitkraken.png)

---

## Branchs

Como hemos mencionado ya en varias ocasiones, hay un elefante en la habitaciÃ³n que aÃºn no hemos mentado: las [**ramas o branchs**]{.hl-yellow} de un repositorio.

. . .

Imagina que estÃ¡is trabajando varios en un proyecto y teneÃ­s una versiÃ³n que funciona pero que querÃ©is [**modificar en paralelo a partir del estado actual**]{.hl-yellow} del repositorio.

. . .

Las [**ramas**]{.hl-yellow} nos permiten partir de una versiÃ³n comÃºn del repositorio y hacer cambios que [**no afecten a los demÃ¡s**]{.hl-yellow}

---

## Branchs

Para [**crear una rama**]{.hl-yellow} a partir del estado actual de repositorio haremos click en `Branch` y le pondremos un nombre

![](img/branch-button.png)

Una vez creada verÃ¡s [**dos iconos**]{.hl-yellow} y un [**menÃº desplegable**]{.hl-yellow} con las distintas ramas en las que quieres hacer el commit. Imagina que realizas un cambio pero [**no quieres aÃ±adirlo a la rama principal**]{.hl-yellow}: puedes hacer el [**commit en tu rama propia en LOCAL**]{.hl-yellow} (lo harÃ¡s en la rama activa de tu menÃº de branchs).

---

## Branchs

La primera vez te pedirÃ¡ que escribas la [**rama en REMOTO**]{.hl-yellow} con la quieres sincronizar tu rama en local. [**Consejo**]{.hl-green}: ponle el mismo nombre en remoto que en local.

![](img/name-branch.png)

---

## Branchs

FÃ­jate que ahora tenemos el ordenador y el logo en el mismo sitio. Esto no significa que tengas ambas ramas en tu local, solo que [**Gitkraken tiene ambas sincronizadas**]{.hl-yellow}: clickando en cualquiera de ellas, tus archivos en tu ordenador cambiarÃ¡n.

![](img/both-branchs.png)

---

## Pull request

Lo mÃ¡s recomendable es que [**solo se incorpore de una rama secundaria**]{.hl-yellow} a la rama principal aquello que estÃ¡ [**validado por un/a coordinador/a**]{.hl-yellow} del repositorio, asegurÃ¡ndose que todo funciona correctamente.

Cuando queramos incluirlo haremos [**click con botÃ³n derecho**]{.hl-yellow} en el icono de la rama secundaria y seleccionamos `Start a pull request to origin from...`

![](img/pull-request-menu.png)

. . .

Una [**pull request**]{.hl-yellow} serÃ¡ una [**peticiÃ³n al responsable de la rama principal**]{.hl-yellow} para incluir los cambios

---

## Pull request

::: columns
::: {.column width="60%"}
![](img/create-pull-request.png)
:::

::: {.column width="40%"}
En el cuadro que no se abre deberemos escribir:

-   La [**rama**]{.hl-yellow} a la que hacer el `merge` (normalmente la `main`)
-   TÃ­tulo y resumen de los cambios
-   Puedes incluso asignar un [**revisor**]{.hl-yellow} entre los colaboradores del repo.
-   Puedes asignar [**etiquetas**]{.hl-yellow}
:::
:::

---

## Pull request

Mientras no se acepte aparecerÃ¡ un [**icono de rama**]{.hl-yellow} y un +1 en Pull Requests

![](img/pending-branch.png){width="500"}

. . .

Si somos al mantenedor del repositorio, haciendo click en el menÃº nos saldrÃ¡n las ramas que nos quieren hacer hacer `merge`

![](img/menu-pr.png){width="500"}

---

## Pull request

Al hacer click se abrirÃ¡ un [**cuadro de Pull Request**]{.hl-yellow} para decidir si

-   [**Revisar**]{.hl-yellow} los cambios
-   [**Aprobar**]{.hl-yellow} el `merge`
-   [**AÃ±adir comentarios**]{.hl-yellow} al que ha solicitado el `merge` por si queremos solicitar algÃºn cambio [**antes de ser aprobado**]{.hl-yellow}

## ![](img/menu-pr-2.png)

## Pull request

Tras revisar todo y aprobarlo clickaremos en `Confirm merge`, y tras ello podremos decidir si esa rama que era paralela a la principal la queremos [**eliminar**]{.hl-yellow} o dejar visible a todos (consejo: dejar visible para tene [**trazabilidad**]{.hl-yellow} del proyecto de trabajo)

::: columns
::: {.column width="50%"}
![](img/merge-branch.png)
:::

::: {.column width="50%"}
![](img/delete-branch.png)
:::
:::

# Recursos extras

[**Algunos paquetes o recursos curiosos**]{style="color:#444442;"}

---

## Paletas de colores

-   [**{ggthemes}**]{.hl-purple}: [**temas y paletas extras**]{.hl-yellow} para ggplot (por ejemplo para **daltÃ³nicos**) <https://jrnold.github.io/ggthemes/> y <https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/>

-   [**{peRReo}**]{.hl-purple}: paletas inspiradas en [**portadas de mÃºsica urbana y latina**]{.hl-yellow} <https://github.com/jbgb13/peRReo>

-   [**Paletas inspiradas en el Metropolitan Museum**]{.hl-purple}: de Blake Robert Mills <https://github.com/BlakeRMills/MetBrewer/tree/main>

-   [**Paletas inspiradas Taylor Swift**]{.hl-purple}: <https://github.com/asteves/tayloRswift>

-   [**Paletas inspiradas en Harry Potter**]{.hl-purple}: de Alejandro JimÃ©nez <https://github.com/aljrico/harrypotter>

-   [**{colorblindcheck}**]{.hl-purple}: detectar paletas de colores aptas [**daltÃ³nicos/as**]{.hl-yellow}. De Jakub Nowosad <https://github.com/Nowosad/colorblindcheck>

---

## Dataviz

-   [**R Graph Gallery**]{.hl-purple}: colecciÃ³n de dataviz en R <https://www.r-graph-gallery.com/>

-   [**{patchwork}**]{.hl-purple}: agregar y [**componer grÃ¡ficas**]{.hl-yellow}. De Thomas Lin Pedersen. <https://patchwork.data-imaginist.com>

-   [**ggplotly**]{.hl-purple}: funciÃ³n de `{plotly}`, para convertir ggplot a plotly ([**interactiva**]{.hl-yellow}) <https://www.rdocumentation.org/packages/plotly/versions/4.10.0/topics/ggplotly>.

Tras convertirlo a plotly se puede [**guardar automÃ¡ticamente en html**]{.hl-yellow} con <https://plotly-r.com/saving.html> y generar el [**cÃ³digo del iframe responsive**]{.hl-yellow} con <https://bhaskarvk.github.io/widgetframe/articles/Using_widgetframe.html>

---

## Dataviz

-   [**{ggiraph}**]{.hl-purple}: grÃ¡ficas interactivas al [**estilo D3**]{.hl-yellow}. <https://davidgohel.github.io/ggiraph/>

-   [**Aprender a usar {ggiraph}**]{.hl-purple}: para grÃ¡ficas interactivas al [**estilo D3**]{.hl-yellow} <https://albert-rapp.de/posts/ggplot2-tips/17_ggiraph/17_ggiraph.html>

-   [**GrÃ¡ficas interactivas**]{.hl-purple}: <https://www.tanyashapiro.com/interactive-visuals>

-   [**{geomtextpath}**]{.hl-purple}: paquete para [**curvar el texto**]{.hl-yellow} ajustÃ¡ndose a una grÃ¡fica. De Allan Cameron y Teun van den Brand. <https://allancameron.github.io/geomtextpath/>

-   [**{ggstream}**]{.hl-purple}: visualizaciÃ³n de [**datos en flujo**]{.hl-yellow}. De Z. Gu. <https://github.com/davidsjoberg/ggstream>

-   [**{ggpattern}**]{.hl-purple}: rellenos con [**patrones geomÃ©tricos**]{.hl-yellow} en ggplot2. De coolbutuseless y Trevor L. Davis. <https://github.com/coolbutuseless/ggpattern>

---

## Mapas

-   [**{mapSpain}**]{.hl-purple}: visualizaciÃ³n de [**datos en mapas de EspaÃ±a**]{.hl-yellow} en R. De Diego HernangÃ³mez <https://dieghernan.github.io/rpubs/mapSpain_RMadrid/#1>

-   [**{rasterpic}**]{.hl-purple}: visualizaciÃ³n de [**mapas con imÃ¡genes rasterizados de fondo**]{.hl-yellow}. De Diego HernangÃ³mez. <https://dieghernan.github.io/rasterpic/>


### Grafos y redes

-   [**{tidygraph}**]{.hl-purple}: paquete al estilo `{tidyverse}` para [**visualizar y manipular grafos**]{.hl-yellow} <https://tidygraph.data-imaginist.com/index.html>


---

## Text mining

-   [**Manual de text mining**]{.hl-purple}: d Julia Silge y David Robinson. Recurso: <https://tidytextmining.com>

-   [**Descarga de textos libres**]{.hl-purple}: de David Robinson. Recurso: <https://github.com/ropensci/gutenbergr>

-   [**AnÃ¡lisis de sentimientos de tweets**]{.hl-purple}: de Harshvardhan. Recurso: <https://www.harsh17.in/twitter-sentiments/>

---

## Datos curiosos

-   [**{fitbitr}**]{.hl-purple}: API para acceder a [**datos de pulseras fitbit**]{.hl-yellow}. De Matt Kaye <https://mrkaye97.github.io/fitbitr/index.html>

-   [**{rtweet}**]{.hl-purple}: API para acceder (al menos antes) a [**Twitter**]{.hl-yellow}. De Michael W. Kearney <https://docs.ropensci.org/rtweet/>

-   [**{owiDR}**]{.hl-purple}: API para acceder a datos de [**Our World in Data**]{.hl-yellow} <https://github.com/piersyork/owidR>

-   [**{wordle}**]{.hl-purple}: API para acceder a [**datos de WORDLE**]{.hl-yellow}. De coolbutuseless <https://coolbutuseless.github.io/2022/01/04/wordle-v0.1.5-a-package-for-playing-and-helping-solve-wordle-puzzles/>

-   [**Canciones de Taylor Swift**]{.hl-purple}: de W. Jake Thompson <https://taylor.wjakethompson.com/>

-   [**{chessR}**]{.hl-purple}: API para acceder a datos de [**partidas de ajedrez**]{.hl-yellow}. De Jason Zivkovic <https://github.com/JaseZiv/chessR>

---

## Informes, libros, diapositivas y webs

-   [**Manual de Quarto**]{.hl-purple}: el nuevo rmarkdown, mÃ¡s completo y sencillo para elaborar manuales, diapositivas, informes e incluso webs <https://quarto.org/docs/guide/>

-   [**Shiny**]{.hl-purple}: webs interactivas con R <https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/>

### Tablas

-   [**{gt}**]{.hl-purple}: tablas en R. De RStudio <https://gt.rstudio.com/>

-   [**{gtExtras}**]{.hl-purple}: visualizaciÃ³n de datos en tablas. De Thomas Mock. <https://jthomasmock.github.io/gtExtras/index.html>

-   [**Tutorial de tablas**]{.hl-purple}: de Benjamin Nowak <https://bjnnowak.netlify.app/2021/10/04/r-beautiful-tables-with-gt-and-gtextras/>

# Â¡GRACIAS!

[**Mi mail javalv09\@ucm.es, Twitter [@dadosdelaplace](https://twitter.com/DadosdeLaplace) e Instagram [@javieralvarezliebana](https://www.instagram.com/javieralvarezliebana/) para lo que querÃ¡is**]{style="color:#444442;"}