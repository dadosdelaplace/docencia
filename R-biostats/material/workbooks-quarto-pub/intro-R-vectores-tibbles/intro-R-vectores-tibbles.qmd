---
title: "Introducci√≥n a R base: de la celda a la tabla"
subtitle: "Cuadernos pr√°cticos de Software para la gesti√≥n de bases de datos del M√°ster de Bioestad√≠stica (curso 2024-2025)"
author: "Javier √Ålvarez Li√©bana"
format:
  html:
    theme: [default, style.scss]
    toc: true
    toc-title: √çndice
    toc-depth: 5
    toc-location: left
    number-sections: true
embed-resources: true
execute: 
  echo: true
---

```{r}
#| echo: false
setwd(dir = getwd())
```

## Introducci√≥n a R (base)

### Requisitos iniciales

#### R

Si es la primera vez que usas `R` (¬°bienvenido/a!) antes vas a necesitar, con [**conexi√≥n a internet**]{.hl-yellow} (tambi√©n lo necesitar√°s para la descarga de algunos datos y paquetes), [**instalar R**]{.hl-yellow}

![](img/cranR.jpg){width="420"}

Como sucede cuando escribimos un idioma (castellano, por ejemplo), `R` ser√° nuestro [**lenguaje**]{.hl-yellow} y nuestra [**gram√°tica**]{.hl-yellow}, en definitiva, nuestras reglas de juego.

Para su instalaci√≥n necesitar√°s seguir los siguientes pasos:

- [**Paso 1**]{.hl-yellow}: entra en <https://cran.r-project.org/> y selecciona tu sistema operativo.

-   [**Paso 2**]{.hl-yellow}: para Mac basta con que hacer click en el **archivo .pkg**, y abrirlo una vez descargado. Para sistemas Windows, debemos clickar en **install R for the first time** y despu√©s en **Download R for Windows**. Una vez descargado, abrirlo como cualquier archivo de instalaci√≥n.

-   [**Paso 3**]{.hl-yellow}: abrir el ejecutable de instalaci√≥n.

::: callout-warning

Siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), [**aseg√∫rate de tener conexi√≥n a internet**]{.hl-orange}.

:::


Para comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver el `R GUI`(Graphical User Interface), y en √©l, una **pantalla blanca** similar a esta: se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como una **calculadora**.

![](img/consola.jpg){width="260"}

Para empezar vamos a generar nuestro [**primer c√≥digo**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el c√≥digo de abajo en la consola y daremos ¬´enter¬ª)

```{r}
#| code-line-numbers: "1"
a <- 1
```

Tras ello definiremos otra variable llamada `b` y le **asignaremos** el valor `2`

```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

Tras definir ambas variables haremos la suma `a + b` y nos devolver√° su resultado

```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```


::: callout-note

## F√≠jate que...

En `R` [**asignaremos valores**]{.hl-yellow} con `<-` como una flecha: la variable a la izquierda de dicha flecha le asignamos el valor que hay a la derecha (por ejemplo, `a <- 1`)

:::

::: callout-note

## F√≠jate que...

En la consola aparece un n√∫mero `[1]`: simplemente es un contador de elementos (como contar filas en un Word)

:::


#### RStudio

No es obligatorio pero si recomendable trabajar en un IDE (entorno de desarrollo), algo parecido a un [**Word**]{.hl-yellow} para escribir castellano, y ese ser√° el `RStudio`. Para [**instalar RStudio**]{.hl-yellow} debes seguir los siguientes pasos

-   [**Paso 1**]{.hl-yellow}: entra la [web oficial de RStudio](https://posit.co/download/rstudio-desktop/) (ahora llamado Posit) y selecciona la descarga gratuita.

-   [**Paso 2**]{.hl-yellow}: selecciona el ejecutable que te aparezca acorde a tu sistema operativo.

-   [**Paso 3**]{.hl-yellow}: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro y dejar que termine la instalaci√≥n.


![](img/rstudio.jpg){width="420"}


Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo c√≥digo que antes (la suma de las variables) en ella. La consola ser√° donde **ejecutaremos √≥rdenes y mostraremos resultados**.

![](img/consola_rstudio.jpg){width="420"}


-   [**Environment**]{.hl-yellow}: la pantalla peque√±a (puedes ajustar los m√°rgenes con el rat√≥n a tu gusto) que tenemos en la parte superior derecha. Nos mostrar√° las **variables que tenemos definidas**.

![](img/environment.jpg){width="420"}

-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha no servir√° para buscar **ayuda de funciones**, adem√°s de para **visualizar gr√°ficos**.

![](img/multiusos.jpg){width="420"}


### Idea fundamental: paquetes

Una de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: c√≥digos que otras personas han implementado para **resolver un problema**


![](img/paquetes.png)

Con los paquetes podemos hacer dos cosas: instalarlos o usarlos.

-   [**Instalaci√≥n**]{.hl-yellow}: descargamos los c√≥digos de la web (necesitamos internet) ‚Üí [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)

```{r}
#| eval: false
install.packages("ggplot2")
```

-   [**Carga**]{.hl-yellow}: con el paquete descargado, indicamos qu√© paquetes queremos usar cada vez que abramos `RStudio` ‚Üí [**traer el libro de la estanter√≠a**]{.hl-purple} (usando el nombre del paquete sin comillas)

```{r}
#| eval: false
library(ggplot2)
```

Tambi√©n podemos hacer uso solo de [**funciones concretas**]{.hl-yellow}: usando `paquete::funcion` le √≠ndicamos que solo queremos una [**p√°gina concreta de ese libro**]{.hl-purple}

```{r}
#| eval: false
ggplot2::geom_point()
```

### Mensajes de error


Durante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera ‚Üí [**te vas equivocar**]{.hl-yellow}. No solo ser√° importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.

-   [**Mensajes de error**]{.hl-red}: precedidos de **¬´Error in...¬ª** y ser√°n aquellos fallos que [**impidan la ejecuci√≥n**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

-   [**Mensajes de warning**]{.hl-orange}: precedidos de **¬´Warning in...¬ª** son los (posibles) fallos m√°s delicados ya que son incoherencias que [**no impiden la ejecuci√≥n**]{.hl-orange}

```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```


### Scripts y proyectos


![](img/abrir_script.jpg){width="350"}

Por √∫ltimo, vamos a mencionar el concepto de [**script**]{.hl-yellow}: el documento en el que programamos, nuestro archivo `.doc` (aqu√≠ con extensi√≥n `.R`) donde escribiremos las √≥rdenes. Para **abrir nuestro primero script**, haz click en el men√∫ en `File < New File < R Script`.

::: callout-warning

## Cuidado

Es importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habr√°s perdido**]{.hl-orange}.

:::


::: callout-warning
## Cuidado

`R` es [**case-sensitive**]{.hl-orange}: es sensible a may√∫sculas y min√∫sculas por lo que `x` y `X` representa variables distintas.

:::



Una vez creado el script tenemos una **cuarta ventana** en `RStudio`: la ventana donde [**escribiremos nuestros c√≥digos**]{.hl-yellow}. ¬øC√≥mo ejecutarlo?


1.  **Escribimos** el c√≥digo a ejecutar.

2.  **Guardamos** el archivo .R haciendo click en `Save current document`.

3.  El c√≥digo no se ejecuta salvo que se lo indiquemos. Tenemos **tres opciones de ejecutar un script**:

-   [**Copiar y pegar**]{.hl-yellow} en consola.
-   [**Seleccionar l√≠neas**]{.hl-yellow} y `Ctrl+Enter`
-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el c√≥digo **completo**.

#### Proyectos

De la misma manera que en el ordenador solemos trabajar de manera [**ordenada por carpetas**]{.hl-yellow}, en `RStudio` podemos hacer lo mismo para trabajar de [**manera eficaz creando proyectos**]{.hl-yellow}.


Un [**proyecto ser√° una ¬´carpeta¬ª**]{.hl-yellow} dentro de `RStudio`, de manera que nuestro directorio ra√≠z autom√°ticamente ser√° la propia carpeta de proyecto (pudiendo pasar de un proyecto a otro con el menu superior derecho). Podemos crear uno en una carpeta nueva o en una carpeta ya existente.

![](img/rstudio_proyectos.png){width="370"}


### üíª Ejercicios

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Crea en tu ordenador una carpeta de la asignatura y crea dentro de ella el proyecto de `RStudio`: es ah√≠ donde vas a guardar todo lo que hagamos a lo largo de este curso.Tras crear el proyecto tendr√°s un archivo `R Project`. A continuaci√≥n crea en dicha carpeta dos subcarpetas: `datos` (es ah√≠ donde ir√°s guardando los distintos datasets que usaremos) y `scripts` (es ah√≠ donde ir√°s guardando los archivos `.R` de cada clase)

### [**Ejercicio 2**]{.hl-yellow}

üìù Dentro del proyecto crea un script `ejercicios-clase1.R` (dentro de la carpeta `scripts`). Una vez creado define en √©l una variable de nombre `a` y cuyo valor sea -1. Ejecuta el c√≥digo de las 3 maneras explicadas.

```{r}
#| code-fold: true
a <- -1
```

### [**Ejercicio 3**]{.hl-yellow}

üìù A√±ade debajo otra l√≠nea para definir una variable `b` con el valor 5. Tras ello guarda la multiplicaci√≥n de ambas variables. Ejecuta el c√≥digo como consideres.

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # sin guardar
multiplicacion <- a * b # guardado
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables y guarda el resultado.

```{r}
#| eval: false
c <- # deber√≠as asignarle el valor 3
d <- # deber√≠as asignarle el valor -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d # sin guardar
division <- c / d # guardado
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Asigna un valor positivo a `x` y calcula su ra√≠z cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la funci√≥n `abs()`.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

::: callout-note
## Toma nota

Comandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: l√≠neas de c√≥digo que hemos ¬´encapsulado¬ª bajo un nombre, y dado unos argumentos de entrada, ejecuta las √≥rdenes (una especie de atajo). En las funciones los [**argumentos ir√°n SIEMPRE entre par√©ntesis**]{.hl-yellow}
:::


### [**Ejercicio 6**]{.hl-yellow}

üìù Usando la variable `x` ya definida, completa/modifica el c√≥digo inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.

```{r}
#| eval: false
z <- ? - ? # completa el c√≥digo
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```

### [**Ejercicio 7**]{.hl-yellow}

üìù Define una variable `x` y as√≠gnale el valor `-1`. Define otra `y` y as√≠gnale el valor `0`. Tras ello realiza las operaciones a) `x` entre `y`; b) ra√≠z cuadrada de `x`. ¬øQu√© obtienes?



```{r}
#| code-fold: true
#| eval: false
x <- -1
y <- 0

x / y
sqrt(x)
```

### [**Ejercicio 8**]{.hl-yellow}

üìù Escribe el c√≥digo inferior en tu script. ¬øPor qu√© crees que no funciona?


```{r}
#| error: true
x <- -1
y <- 0

X + y
```

:::

## Primeros tipos de datos

Dado que es un curso de `R` orientado a ciencia de datos (normalmente con datos tabulados en tablas), la primera pregunta que quiz√°s nos hagamos es

> Dada una tabla, ¬øqu√© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda?

![](img/celdas.jpg)

La idea del curso es ir de lo concreto (celda individual) a lo general (tablas y listas)

-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenaci√≥n** de valores del mismo tipo ([**vectores en R**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenaci√≥n de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

### Tipos de datos individuales

Y aunque la mayor√≠a de veces tendemos a pensar que solo guardamos y trabajamos con n√∫meros, ¬øexisten [**variables m√°s all√° de los n√∫meros en la ciencia de datos**]{.hl-yellow}?

Piensa por ejemplo en los datos que podr√≠as guardar de una persona:

-   La edad o el peso ser√° un [**n√∫mero**]{.hl-yellow}.

```{r}
edad <- 33
```

-   Su nombre ser√° una cadena de [**texto (conocida como string o char)**]{.hl-yellow}.

```{r}
nombre <- "javi"
```

-   A la pregunta ¬´¬øest√°s matriculado en la Facultad?¬ª la respuesta ser√° lo que llamamos una [**variable l√≥gica**]{.hl-yellow} (`TRUE` si est√° matriculado o `FALSE` en otro caso).

```{r}
matriculado <- TRUE
```
 
-   Su fecha de nacimiento ser√° precisamente eso, una [**fecha**]{.hl-yellow} (veremos como definirlas un poco m√°s adelante).


#### Variables num√©ricas

El dato m√°s sencillo (ya lo hemos usado) ser√°n las [**variables num√©ricas**]{.hl-yellow}


```{r}
a <- 5
b <- 2
a + b
```

Para saber la [**clase de dato en R**]{.hl-yellow}  de una variable tenemos la funci√≥n `class()`

```{r}
class(a)
```

Para saber su [**tipolog√≠a (naturaleza o formato)**]{.hl-yellow} variable tenemos `typeof()`

```{r}
typeof(1) # 1 pero almacenado como un valor real (double, con decimales)
typeof(as.integer(1)) # 1 pero almacenado como un entero.
```

::: callout-note
## F√≠jate que...

En `R` tenemos una colecci√≥n de funciones que empiezan por `as.x()` y que sirven como [**funciones de conversi√≥n**]{.hl-yellow}: un dato que era de un tipo, lo convertimos a tipo `x`.

:::


Adem√°s de los n√∫meros ¬´normales¬ª tendremos el [**valor m√°s/menos infinito**]{.hl-yellow} codificado como `Inf` o `-Inf`

```{r}
1/0
```

```{r}
-1/0
```


Y tambi√©n aparecer√°n a menudo valores que [**no son n√∫meros reales**]{.hl-yellow}, definidos como _not a number_ (indeterminaciones, complejos, etc), y codificados como `NaN`

```{r}
0/0
```

```{r}
#| warning: true
sqrt(-2)
```


&nbsp;

Con las variables num√©ricas podemos realizar las [**operaciones aritm√©ticas**]{.hl-yellow} de una calculadora: sumar (`+`)...

```{r}
a + b
```

...ra√≠z cuadrada (`sqrt()`)...

```{r}
sqrt(a)
```


... potencias (`^2`, `^3`)...

```{r}
a^2
```


...valor absoluto (`abs()`), etc.

```{r}
abs(a)
```


#### Variables de texto

Imagina que adem√°s de la edad de una persona queremos guardar su nombre: ahora la variable ser√° de tipo `character`

```{r}
nombre <- "Javier"
class(nombre)
```

Las [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones aritm√©ticas**]{.hl-red} (s√≠ otras operaciones como pegar o localizar patrones).

```{r}
#| error: true
nombre + 1 # error al sumar n√∫mero a texto
```

::: callout-warning
## Recuerda que...

Las variables de tipo texto (character o string) van [**SIEMPRE entre comillas**]{.hl-orange}: no es lo mismo `TRUE` (valor l√≥gico, binario) que `"TRUE"` (texto).
:::

Y aunque no podamos aplicar a las cadenas de texto operaciones aritm√©ticas habituales si podremos aplicar otras operaciones, como por ejemplo, la funci√≥n `paste()`. Como hemos comentado `R` llamaremos [**funci√≥n**]{.hl-yellow} a un trozo de [**c√≥digo encapsulado**]{.hl-yellow} bajo un nombre, y que depende de unos [**argumentos**]{.hl-yellow} de entrada.

Nuestra primera funci√≥n `paste()` toma dos cadenas de texto y nos permite pegarlas.

```{r}
paste("Javier", "√Ålvarez")
```


F√≠jate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos a√±adir un [**argumento opcional**]{.hl-yellow} para indicarle el separador (en `sep = ...`). 

```{r}
paste("Javier", "√Ålvarez", sep = "*")
```


¬øC√≥mo saber [**qu√© argumentos necesita una funci√≥n**]{.hl-yellow}? Escribiendo en consola `? paste` te aparecer√° una [**ayuda**]{.hl-yellow} en el panel multiusos.


![](img/paste_help.jpg)

En dicha ayuda podr√°s ver en su cabecera que argumentos ya tiene [**asignados por defecto**]{.hl-yellow} la funci√≥n. Los argumentos (y su detalle) tambi√©n pueden ser consultado **tabulando (detr√°s de una coma)**.

![](img/tab-functions.png)


&nbsp;

Existe una funci√≥n similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).

```{r}
paste0("Javier", "√Ålvarez")
```


Es muy importante entender el concepto de [**argumento por defecto de una funci√≥n**]{.hl-yellow} en `R`: es un valor que la funci√≥n usa pero a veces podemos no ver porque [**ya tiene un valor asignado**]{.hl-yellow}. 

```{r}
# Hacen lo mismo
paste("Javier", "√Ålvarez")
paste("Javier", "√Ålvarez", sep = " ")
```


::: callout-note
## Toma nota

El operador `=` lo [**reservaremos para asignar argumentos**]{.hl-yellow} dentro de funciones. Para todas las dem√°s asignaciones usaremos `<-`
:::

Otra forma de concatenar cadenas de texto (m√°s intuitiva) es usar el paquete `{glue}`: lo primero que haremos ser√° ¬´comprar el libro¬ª (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue") # solo la primra vez
library(glue)
```

```{r}
#| echo: false
library(glue)
```


Con la funci√≥n `glue()` de dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, ¬´la edad es de ... a√±os¬ª, donde la edad est√° guardada en una variable.

```{r}
edad <- 33
glue("La edad es de {edad} a√±os")
```

Dentro de las llaves tambi√©n podemos [**ejecutar operaciones**]{.hl-yellow}

```{r}
unidades <- "d√≠as"
glue("La edad es de {edad * 365} {unidades}")
```

#### Variables l√≥gicas

Otro tipo fundamental ser√°n las [**variables l√≥gicas o binarias**]{.hl-yellow} (**dos valores**):

-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.
-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.

```{r}
soltero <- TRUE # ¬øEs soltero? --> S√ç
class(soltero)
```


Dado que internamente est√°n guardados como variables binarias, podemos [**realizar operaciones aritm√©ticas**]{.hl-yellow} con ellas

```{r}
2 * TRUE
FALSE - 1
```


Como veremos en breve, las variables l√≥gicas en realidad puede tomar un tercer valor: `NA` o [**dato ausente**]{.hl-yellow}, representando las siglas de *not available*, y ser√° muy habitual encontrarlo dentro de una base de datos.

```{r}
ausente <- NA
ausente + 1
```

::: callout-important
## Importante

Las variables l√≥gicas [**NO son variables de texto**]{.hl-red}: `"TRUE"` es un texto, `TRUE` es un valor l√≥gico.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::


Los valores l√≥gicos suelen ser resultado de [**evaluar condiciones l√≥gicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos [**comprobar**]{.hl-yellow} si una persona se llama Javi.

```{r}
nombre <- "Mar√≠a"
```


Con el [**operador l√≥gico**]{.hl-yellow} `==` preguntamos s√≠ lo que tenemos guardado a la izquierda es [**igual que**]{.hl-purple} lo que tenemos a la derecha: es una [**pregunta**]{.hl-yellow}

```{r}
nombre == "Javi"
```

Con su opuesto `!=` preguntamos [**si es distinto**]{.hl-purple}.

```{r}
nombre != "Javi"
```


::: callout-note
## F√≠jate que...

No es lo mismo `<-` ([**asignaci√≥n**]{.hl-yellow}) que `==` (estamos [**preguntando**]{.hl-yellow}, es una comparaci√≥n l√≥gica).
:::


Adem√°s de las comparaciones ¬´igual a¬ª frente ¬´distinto¬ª, tambi√©n comparaciones de orden como [**menor que**]{.hl-purple} `<`, [**mayor que**]{.hl-purple} `>`,  `<=` o `>=`.

**¬øTiene la persona menos de 32 a√±os?**

```{r}
edad <- 34
edad < 32 # ¬øEs la edad menor de 32 a√±os?
```


**¬øLa edad es mayor o igual que 38 a√±os?**

```{r}
edad >= 38
```

**¬øEl nombre guardado es Javi?**

```{r}
nombre <- "Javi"
nombre == "Javi"
```

#### Variables de fecha

Un tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.

```{r}
fecha_char <- "2021-04-21"
```

Parece una simple cadena de texto pero [**deber√≠a representar un instante en el tiempo**]{.hl-yellow}. ¬øQu√© deber√≠a suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?


```{r}
#| error: true
fecha_char + 1
```


Las fechas [**NO pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha.


&nbsp;

Para trabajar con fechas usaremos el paquete `{lubridate}`, que deberemos instalar antes de poder usarlo.

```{r}
#| eval: false
install.packages("lubridate")
```



Una vez instalado, de todos los paquetes (libros) que tenemos, le indicaremos que nos cargue ese concretamente.

```{r}
library(lubridate) # instala si no lo has hecho

```


Para [**convertir a tipo fecha**]{.hl-yellow} usaremos la funci√≥n `as_date()` del paquete `{lubridate}` (por defecto en formato `yyyy-mm-dd`)

&nbsp;

```{r}
#| error: true
# ¬°no es una fecha, es un texto!
fecha_char + 1
class(fecha_char)
```

```{r}
fecha <- as_date("2023-03-28") # si es una fecha
fecha + 1
class(fecha)
```


En `as_date()` el formato de fecha por defecto es `yyyy-mm-dd` as√≠ que si la cadena de texto no se introduce de manera adecuada...

```{r}
as_date("28-03-2023")
```

... devuelve un ausnete.

Para [**cualquier otro formato debemos especificarlo**]{.hl-yellow} en el argumento opcional `format = ...` tal que `%d` representa d√≠as, `%m` meses, `%Y` en formato de 4 a√±os y `%y` en formato de 2 a√±os.

```{r}
as_date("28-03-2023", format = "%d-%m-%Y")
as_date("28-03-23", format = "%d-%m-%y")
as_date("03-28-2023", format = "%m-%d-%Y")
as_date("28/03/2023", format = "%d/%m/%Y")
```


En dicho paquete tenemos adem√°s funciones muy √∫tiles para [**manejar fechas**]{.hl-yellow}:

-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.

```{r}
today()
```


-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}

```{r}
now()
```

-   Con `year()`, `month()` o `day()` podemos [**extraer el a√±o, mes y d√≠a**]{.hl-purple}

```{r}
fecha <- today()
year(fecha)
month(fecha)
```


![](img/lubridate.png)

::: callout-note
## Amplia contenido

Tienes un resumen en pdf de los paquetes m√°s importantes en la [**carpeta correspondiente en el campus**]{.hl-green}
:::



### Vectores: concatenar

Cuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenaci√≥n**]{.hl-purple} de celdas (valores) del [**mismo tipo**]{.hl-purple} (lo que ser√≠a una columna de una tabla).

La forma m√°s sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus **elementos entre par√©ntesis y separados por comas**

```{r}
edades <- c(32, 27, 60, 61)
edades
```


::: callout-tip
Un n√∫mero individual `x <- 1` (o bien `x <- c(1)`) es en realidad un **vector de longitud uno** --> todo lo que sepamos [**hacer con un n√∫mero podemos hacerlo con un vector de ellos**]{.hl-green}.
:::


![](img/edades_environment.jpg)

Como ves ahora en el `environment` tenemos una **colecci√≥n de elementos** guardada

```{r}
edades
```


De aqu√≠ en adelante calcularemos la [**longitud de un vector**]{.hl-yellow} con la funci√≥n `length()`

```{r}
length(edades)
```

Tambi√©n podemos [**concatenar vectores**]{.hl-yellow} entre s√≠ (los repite uno tras otro)

```{r}
c(edades, edades, 8)
```


#### Secuencias num√©ricas

El vector m√°s famoso ser√° el de tipo num√©rico, y en concreto, las conocidas como [**secuencias num√©ricas**]{.hl-yellow} (por ejemplo, los d√≠as del mes), usadas para, entre otras cosas, indexar bucles.

El comando `seq(inicio, fin)` nos permite crear una [**secuencia num√©rica**]{.hl-yellow} desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.

```{r}
seq(1, 31)
```

F√≠jate que si hacemos eso con [**caracteres no podremos hacerlo**]{.hl-red} ya que no hay un orden a priori entre textos.

```{r}
#| error: true
"a":"z"
```

Un atajo es el comando `1:n`, que nos devuelve lo mismo que `seq(1, n)`

```{r}
1:7
```

Si el elemento inicial es mayor que el final, entender√° que la secuencia es [**en orden decreciente**]{.hl-purple}.

```{r}
7:-3
```


Tambi√©n podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos con el argumento `by = ...`

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```


Otras veces nos interesar√° definir una [**secuencia con una longitud concreta**]{.hl-yellow}

```{r}
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```


Incluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}

```{r}
rep(0, 7) # vector de 7 ceros
```

Dado que internamente son guardados como n√∫meros tambi√©n podremos hacer esto con [**fechas**]{.hl-yellow}.

```{r}
seq(as_date("2023-09-01"), as_date("2023-09-10"), by = 1)
```


#### Vectores de caracteres

Un vector es una **concatenaci√≥n** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente n√∫meros. Vamos a crear una frase de ejemplo.

```{r}
frase <- "Me llamo Javi"
frase
length(frase)
```

En el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas

```{r}
vector <- c("Me", "llamo", "Javi")
vector
length(vector)
```


¬øQu√© suceder√° si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?


```{r}
c(1, 2, "javi", "3", TRUE)
```

F√≠jate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}


```{r}
c(3, 4, TRUE, FALSE)
```

Es importante entender que los valores l√≥gicos en realidad est√°n [**almacenados internamente como 0/1**]{.hl-yellow}


#### Operaciones con vectores

Con los vectores num√©ricos podemos hacer las mismas [**operaciones aritm√©ticas**]{.hl-yellow} que con los n√∫meros ‚Üí un [**n√∫mero es un vector**]{.hl-purple} (de longitud uno)


¬øQu√© suceder√° si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Cuidado

Salvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}
:::

Los vectores tambi√©n pueden interactuar entre ellos, as√≠ que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)

```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```



Dado que la operaci√≥n (por ejemplo, una suma) se realiza elemento a elemento, ¬øqu√© suceder√° si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?



```{r}
z <- c(1, 3, 5, 7)
x + z
```

Lo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que har√° ser√° reciclar del vector con menor longitud.



Una operaci√≥n muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones l√≥gicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...

[**¬øQu√© d√≠as hizo menos de 22 grados?**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```



```{r}
x < 22
```

Nos devolver√° un [**vector l√≥gico**]{.hl-yellow}, en funci√≥n de si **cada elemento** cumple o no la condici√≥n pedida (de **igual longitud** que el vector preguntado)


Si tuvi√©ramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese d√≠a), la condici√≥n evaluada tambi√©n ser√≠a `NA`

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```


Las [**condiciones l√≥gicas pueden ser combinadas**]{.hl-yellow} de dos maneras:

-   [**Intersecci√≥n**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunci√≥n y**]{.hl-purple} con `&`) para devolver un `TRUE`

```{r}
x < 30 & x > 15
```

-   [**Uni√≥n**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunci√≥n o**]{.hl-purple} con `|`)

```{r}
x < 30 | x > 15
```


Adem√°s con `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen

```{r}
any(x < 30)
all(x < 30)
```

##### Acceder a elementos

Otra operaci√≥n muy habitual es la de [**acceder a elementos**]{.hl-yellow}. La forma m√°s sencilla es usar el operador `[i]` (acceder al elemento i-√©simo)

```{r}
edades <- c(20, 30, 33, NA, 61) 
edades[3] # accedemos a la edad de la tercera persona 
```


Dado que un n√∫mero no es m√°s que un vector de longitud uno, esta operaci√≥n tambi√©n la podemos aplicar usando un [**vector de √≠ndices a seleccionar**]{.hl-yellow}

```{r}
y <- c("hola", "qu√©", "tal", "est√°s", "?")
y[c(1:2, 4)] # primer, segundo y cuarto elemento
```


::: callout-tip
Para acceder al √∫ltimo, sin preocuparnos de cu√°l es, podemos pasarle como √≠ndice la propia longitud `x[length(x)]`
:::

Otras veces no querremos seleccionar sino [**eliminar algunos elementos**]{.hl-yellow}. Deberemos repetir la misma operaci√≥n pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-√©simo del vector sino que lo ¬´des-selecciona¬ª

```{r}
y
y[-2]
```


En muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones l√≥gicas**]{.hl-yellow}, en funci√≥n de los valores, as√≠ que pasaremos como √≠ndice la propia condici√≥n (recuerda, `x < 2` nos devuelve un vector l√≥gico)

```{r}
edades <- c(15, 21, 30, 17, 45)
nombres <- c("javi", "mar√≠a", "laura", "carla", "luis")
nombres[edades < 18] # nombres de los menores de edad
```

##### Operaciones estad√≠sticas

Tambi√©n podemos hacer uso de [**operaciones estad√≠sticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**¬øQu√© sucede cuando falta un dato (ausente)?**]{.hl-yellow}


```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

Por defecto, si tenemos un dato ausente, la [**operaci√≥n tambi√©n ser√° ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`

```{r}
sum(x, na.rm = TRUE)
```


Como hemos comentado que los valores l√≥gicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritm√©ticas. Por ejemplo, si queremos [**averiguar el n√∫mero de elementos que cumplen una condici√≥n**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendr√°n asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar dicho vector l√≥gico para obtener el n√∫mero de elementos que cumplen

```{r}
x <- c(2, 4, 6)
sum(x < 3)
```


Otra operaci√≥n habitual que puede sernos √∫til es la [**suma acumulada**]{.hl-yellow} con `cumsum()` que, dado un vector, nos devuelve un vector a su vez con el primero, el primero m√°s el segundo, el primero m√°s el segundo m√°s el tercero...y as√≠ sucesivamente.

```{r}
x <- c(1, 5, 2, -1, 8)
cumsum(x)
```

[**¬øQu√© sucede cuando falta un dato (ausente)?**]{.hl-yellow}


```{r}
x <- c(1, -2, 3, NA, -1)
cumsum(x)
```

En el caso de la suma acumulada lo que sucede es que [**a partir de ese valor, todo lo acumulado posterior ser√° ausente**]{.hl-yellow}.


Otra operaci√≥n habitual que puede sernos √∫til es la [**diferencia (con retardo)**]{.hl-yellow} con `diff()` que, dado un vector, nos devuelve un vector con el segundo menos el primero, el tercero menos el segundo, el cuarto menos el tercero...y as√≠ sucesivamente.


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x)
```



Con el argumento `lag = ` podemos indicar el [**retardo**]{.hl-yellow} de dicha diferencia (por ejemplo, `lag = 3` implica que se resta el cuarto menos el primero, el quinto menos el segundo, etc)


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x, lag = 3)
```

&nbsp;

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La m√°s conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores at√≠picos o outliers (valores muy grandes o muy peque√±os), la media se perturba con mucha facilidad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```


-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```


-   [**Percentiles**]{.hl-yellow}: medidas de posici√≥n (nos dividen en partes iguales los datos).

```{r}
quantile(x) # por defecto percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

##### Ordenar vectores

Por √∫ltimo, una acci√≥n habitual es saber [**ordenar valores**]{.hl-yellow}:

-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(edades)
sort(edades, decreasing = TRUE)
```


-   `order()`: devuelve el [**vector de √≠ndices**]{.hl-yellow} que tendr√≠amos que usar para tener el vector ordenado

```{r}
order(x)
x[order(x)]
```


### üíª Ejercicios

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Define una variable que guarde tu edad (llamada `edad`) y otra con tu nombre (llamada `nombre`)

```{r}
#| code-fold: true
edad <- 33
nombre <- "Javi"
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Comprueba con dicha variable `edad` si NO tiene 60 a√±os o si se llama `"Ornitorrinco"` (debes obtener variables l√≥gicas como resultado)

```{r}
#| code-fold: true
#| eval: false
edad != 60 # distinto de
nombre == "Ornitorrinco" # igual a
```

### [**Ejercicio 3**]{.hl-yellow}

üìù ¬øPor qu√© el c√≥digo inferior da error?

```{r}
#| error: true
edad + nombre
```


### [**Ejercicio 4**]{.hl-yellow}

üìù Define otra variable llamada `hermanos` que responda la pregunta ¬´¬øtienes hermanos?¬ª y otra variable que almacene tu fecha de nacimiento (llamada `fecha_nacimiento`).

```{r}
#| code-fold: true
hermanos <- TRUE

library(lubridate) # sino lo ten√≠as ya cargado
fecha_nacimiento <- as_date("1989-09-10")
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Define otra variable con tus apellidos (llamada `apellidos`) y usa `glue()` para tener, en una sola variable  llamada `nombre_completo`, tu nombre y apellidos separando nombre y apellido por una coma

```{r}
#| code-fold: true
#| eval: false
apellidos <- "√Ålvarez Li√©bana"
glue("{nombre}, {apellidos}")
```

### [**Ejercicio 6**]{.hl-yellow}

üìù De `fecha_nacimiento` extrae el mes.

```{r}
#| code-fold: true
#| eval: false
month(fecha_nacimiento)
```

### [**Ejercicio 7**]{.hl-yellow}

üìù Calcula los d√≠as que han pasado desde la fecha de tu nacimiento hasta hoy (con la fecha de nacimiento definida en el ejercicio 4).

```{r}
#| code-fold: true
#| eval: false
today() - fecha_nacimiento
```

### [**Ejercicio 8**]{.hl-yellow}

üìù Define el vector `x` como la concatenaci√≥n de los 5 primeros n√∫meros impares. Calcula la longitud del vector

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Ejercicio 9**]{.hl-yellow}

üìù Accede al tercer elemento de `x`. Accede al √∫ltimo elemento (sin importar la longitud, un c√≥digo que pueda ejecutarse siempre). Elimina el primer elemento.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Ejercicio 10**]{.hl-yellow}

üìù Obt√©n los elementos de `x` mayores que 4. Calcula el vector `1/x` y gu√°rdalo en una variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Ejercicio 11**]{.hl-yellow}

üìù Crea un vector que represente los nombres de 5 personas, de los cuales uno es desconocido.

```{r}
#| code-fold: true
#| eval: false
nombres <- c("Javi", "Sandra", NA, "Laura", "Carlos")
nombres
```

### [**Ejercicio 12**]{.hl-yellow}

üìù Encuentra del vector `x` de ejercicios anteriores los elementos mayores (estrictos) que 1 Y ADEM√ÅS menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Ejercicio 13**]{.hl-yellow}

üìù Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`,  ¬øpor qu√© su media no devuelve un n√∫mero sino lo que se muestra en el c√≥digo inferior?

```{r}
x <- c(1, -5, 8, NA, 10, -3, 9)
mean(x)
```

### [**Ejercicio 14**]{.hl-yellow}

üìù Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6. 

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
x[-2]
```

### [**Ejercicio 15**]{.hl-yellow}

üìù Dado el vector `x` del ejercicio anterior, ¬øcuales tienen un dato ausente? Pista: las funciones `is.algo()` comprueban si el elemento es tipo `algo` (tabula)

```{r}
#| code-fold: true
#| eval: false
is.na(x)
```


### [**Ejercicio 16**]{.hl-yellow}

üìù Define el vector `x` como la concatenaci√≥n de los 4 primeros n√∫meros pares. Calcula el n√∫mero de elementos de `x` menores estrictamente que 5.

```{r}
#| code-fold: true
#| eval: false
x[x < 5] 
sum(x < 5)
```


### [**Ejercicio 17**]{.hl-yellow}

üìù Calcula el vector `1/x` y obt√©n la versi√≥n ordenada (de menor a mayor) de las dos formas posibles

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Ejercicio 18**]{.hl-yellow}

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Ejercicio 19**]{.hl-yellow}

üìù Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 6. Encuentra una forma de averiguar si todos los elementos son o no negativos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

:::



## Profundizando en textos

Aunque no podamos hacer operaciones aritm√©ticas con ellos si ser√°n importante algunas [**operaciones que podamos realizar con las cadenas de texto**]{.hl-yellow}. Para eso usaremos el paquete `{stringr}` (dentro del mismo ¬´universo de paquetes¬ª de `{lubridate}`)

```{r}
library(stringr)
```

Con dicho paquete vamos a trabajar particularmente con [**cuatro familias de funciones**]{.hl-yellow}

- [**Manipulaci√≥n**]{.hl-purple}

- [**Tratamiento de espacios**]{.hl-purple}

- [**B√∫squeda de patrones**]{.hl-purple}

### Utilidades b√°sicas

#### Longitud

La m√°s obvia es una funci√≥n que, dada una cadena de texto (un string) nos proporcione la [**longitud**]{.hl-yellow}. Para ello podemos usar la funci√≥n `str_length()`

```{r}
str_length("abc")
```

Es importante advertir que cuenta tanto [**n√∫meros como espacios**]{.hl-yellow}, as√≠ como caracteres que **no sean alfanum√©ricos**. 
```{r}
str_length("abc 123 *")
```

Adem√°s si el texto es ausente devuelve ausente (recuerda: `NA` es ausente, `"NA"` es una cadena de texto m√°s) 

```{r}
str_length(NA)
```

&nbsp;

Las [**funciones del paquete est√°n preparadas para ser vectorizadas**]{.hl-yellow} lo que significa que si aplicamos una funci√≥n a un vector de dos cadenas de texto la aplica a ambos de la misma forma.

```{r}
str_length(c("abc", "defghi"))
```

#### Ordenar

Otra muy habitual es [**ordenar cadenas de texto (por orden alfab√©tico)**]{.hl-yellow}. Para ello podemos usar la funci√≥n `str_order()`, distinguiendo `..._sort()` y `..._order()` como con los n√∫meros

```{r}
x <- c("y", "i", "k")
str_order(x)
str_sort(x)
```


### Manipulaci√≥n

#### Extraer subcadenas

* [**Extraer subcadenas**]{.hl-yellow}: dada una cadena de texto, `str_sub(texto, star = ..., end = ...)` nos extrae la subcadena desde la posici√≥n `star` hasta `end` (si es negativo empieza a contar por detr√°s).

```{r}
str_sub("abcd efg", star = 4, end = 6)
str_sub("abcd efg", star = 5)
str_sub("abcd efg", star = 4, end = -2)
```



* [**Extraer subcadenas**]{.hl-yellow}: la funci√≥n `str_sub()` permite aplicarlo a de manera vectorial a m√∫ltiples cadenas de texto, e incluso usarla para asignar valores.

```{r}
x <- c("abcdef", "ghifjk")
str_sub(x, star = 3, end = -2)
str_sub(x, star = -1, end = -1)

# En ambas cadenas, sustituimos por * en la posici√≥n 2
str_sub(x, star = 2, end = 2) <- "*"
```

#### Duplicar cadenas

* [**Duplicar cadenas**]{.hl-yellow}: con `str_dup(..., times = ...)`, dada una cadena de texto (o varias), podemos repetir una cadena `times` veces.

```{r}
str_dup("abc", times = 3)

x <- c("abcdef", "ghifjk")
str_dup(x, times = c(2, 5))
```

#### Concatenar cadenas

* [**Concatenar cadenas**]{.hl-yellow}: con `str_c` podemos concatenar distintas cadenas de texto (con `sep = ...` indicamos el caracter que har√° de separador)

```{r}
str_c("Buenos d√≠as", "Mi nombre es Javier")
str_c("Buenos d√≠as", "Mi nombre es Javier", sep = ". ")
```


#### May√∫sculas y min√∫sculas

* [**May√∫sculas/min√∫sculas**]{.hl-yellow}: con `str_to_...()` podemos convertir textos a may√∫sculas (`..._upper`), a min√∫sculas (`..._lower`) y a t√≠tulo (`..._title`, primera letra de cada palabra en may√∫scula)

```{r}
str_to_upper("me llamo Javi")
str_to_lower("me llamo Javi")
str_to_title("me llamo Javi")
```

#### Reemplazar

* [**Reemplazar**]{.hl-yellow}: `str_replace()` busca un patr√≥n dado en una cadena de texto y, si la encuentra, la sustituye pro otra de reemplazo

```{r}
str_replace(c("javi", "sandra", "carlos"), pattern = "i", replacement = "*")
```

. . .

Con `str_replace_all()` reemplazamos todas las coincidencias (por defecto sino solo se reemplaza la primera)

```{r}
str_replace(c("javi", "sandra", "carlos"), pattern = "a", replacement = "*")
str_replace_all(c("javi", "sandra", "carlos"), pattern = "a", replacement = "*")
```


### Espacios en blanco

#### Rellenar espacios

* [**Rellenar**]{.hl-yellow}: la funci√≥n `str_pad()` rellena una cadena con espacios (al inicio por defecto) para que tenga anchura indicada. Con `side = "both"` como argumento extra nos a√±ade en ambos lados. Con `side = "right"` los a√±ade al final. Con `pad = ...` podemos decidir si queremos rellenar con otro tipo de caracter (espacio por defecto).

```{r}
str_pad("abc", width = 6)
str_pad("abc", 12, side = "both")
str_pad("abc", 6, side = "right", pad = "*")
```

. . .

Si `width` es menor que la longitud de la cadena, no hace nada.

```{r}
str_pad("abc",  width = 2)
```

#### Eliminar espacios

* [**Eliminar espacios**]{.hl-yellow}: con `str_trim()` podemos eliminar espacios en blanco al inicio y al final de la cadena. Si a√±adimos `side = ...` podemos cambiar si queremos que solo los elimine al final o al inicio (por defecto, en ambos). Con `str_squish()` cambiamos cualquier sucesi√≥n de espacios en blanco en medio del texto por uno solo (y elimina al inicio y final)

```{r}
str_trim(" abcde   fghi ")
str_trim(" abcde   ")
str_trim(" abcde   ", side = "left")
str_squish(" abcde   fghi ")
```



### Patrones

#### Detectar. Expresiones regulares.

* [**Detectar**]{.hl-yellow}: con `str_detect()` podemos detectar si una cadena de texto contiene o no una secuencia de caracteres

```{r}
str_detect(c("javi √°lvarez", "javi reyes", "sandra reyes"), pattern = "javi")
str_detect(c("javi √°lvarez", "javi reyes", "sandra reyes"), pattern = "reyes")
str_detect(c("javi √°lvarez", "javi reyes", "sandra reyes"), pattern = "carlos")
```



* [**Expresiones regulares**]{.hl-yellow}: no solo vamos a poder detectar patrones simples sino que podemos hacer uso de las conocidas como **expresiones regulares**, indic√°ndole por ejemplo que queremos localizar todo patr√≥n que sea, al menos una letra

```{r}
str_detect(c("a", "ab", "abc", "abcd"), pattern = "[a-z]")
```

. . .

Si tras los corchetes indicamos `{n}` podemos detectar aquellas cadenas con n letras consecutivas

```{r}
str_detect(c("a", "ab", "abc", "abcd"), pattern = "[a-z]{3}")
```



* [**Expresiones regulares**]{.hl-yellow}: un buen manejo de estas expresiones puede sernos muy √∫til para, por ejemplo, detectar formatos correctos en DNI o n√∫meros de tel√©fono (de Madrid, por ejemplo).

Vamos a considerar que un formato correcto de DNI es aquel seguido por 8 n√∫meros (`[0-9]{8}`) seguido directamente de una letra may√∫scula (`[A-Z]`).

```{r}
str_detect(c("5055A198-W", "50508040W", "5050505W", "50508040-W"),
           pattern = "[0-9]{8}[A-Z]")
```

. . .

Podemos buscar distintos patrones a la vez concaten√°ndolos con una `|`

```{r}
str_detect(c("5055A198-W", "50508040W", "5050505W", "50508040-W"),
           pattern = "[0-9]{8}[A-Z]|[0-9]{8}[-][A-Z]")
```


#### Contar

* [**Contar patrones**]{.hl-yellow}: con `str_count()` podemos contar cuantas veces aparece un mismo patr√≥n

```{r}
str_count(c("abcd defg", "ab defg", "ab cd"), pattern = "[a-z]{4}")
```

#### Localizar posiciones

* [**Localizar posiciones**]{.hl-yellow}: `str_locate()` nos permite localizar la primera posici√≥n en la que se produce un patr√≥n. Con `str_locate_all()` obtenemos todos

```{r}
str_locate(c("abcde abcd", "cba", "*a*"), pattern = "a")
str_locate_all(c("abcde abcd", "cba", "*a*"), pattern = "a")
```


#### Extraer patrones

* [**Extraer patrones**]{.hl-yellow}: con `str_extract()` podemos extraer patrones (con `str_extract_all()` todos ellos) de una cadena de texto.

```{r}
str_extract(c("DNI: 5050W", "DNI: 50558040W, DNI: 50558080-W", "DNI: 50558080-W"),
            pattern = "[0-9]{8}[A-Z]|[0-9]{8}[-][A-Z]")
str_extract_all(c("DNI: 5050W", "DNI: 50558040W, DNI: 50558080-W", "DNI: 50558080-W"),
            pattern = "[0-9]{8}[A-Z]|[0-9]{8}[-][A-Z]")
```

#### Dividir cadenas

* [**Dividir**]{.hl-yellow}: con `str_split()` podemos localizar un patr√≥n y dividir la cadena de texto siempre que aparezca (con `str_split_fixed()` podemos dividir en un n√∫mero concreto de trozos)

```{r}
str_split(c("a-b-c", "ab-c-d-e"), pattern = "-")
str_split_fixed(c("a-b-c", "ab-c-d-e"), pattern = "-", n = 2)
```
. . .

Si usamos `boundary()` como patr√≥n podemos dividir en base a caracteres, frases, palabras, etc.

```{r}
x <- "Esto es una frase. Y esto otra."
str_split(x, boundary("word"))
str_split(x, boundary("sentence"))
```




### üíª Tu turno (textos) 


[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

El dataset ser√° `discursos` (extra√≠do de <https://github.com/lirondos/discursos-de-navidad>) donde est√°n guardados los discursos navidad de los jefes de Estado de Espa√±a desde 1946 hasta 2021 (en dictadura y en democracia).

```{r}
load(file = "./datos/discursos.RData")
```

::: panel-tabset

### [**Ej 1**]{.hl-yellow}

üìù Convierte todos los discurso a min√∫scula.

```{r}
#| code-fold: true
#| eval: false

# Convertimos a min√∫scula
discursos$texto <- str_to_lower(discursos$texto)
```


### [**Ej 2**]{.hl-yellow}

üìù Elimina signos de puntuaci√≥n tales como ":", ",", ".", ";", "¬°", "!", "¬ø" y "?". Tras ello elimina espacios adelante, atr√°s y en medio si existen solo deja uno de ellos.

```{r}
#| code-fold: true
#| eval: false

# Eliminamos los signos de puntuaci√≥n
discursos$texto <-
  str_remove_all(discursos$texto, pattern = "\\:|\\,|\\.|\\;|\\¬°|\\!|\\¬ø|\\?")

# Tras ello eliminamos espacios adelante, atr√°s y en medio solo dejamos uno
discursos$texto <- str_squish(discursos$texto)
```

### [**Ej 3**]{.hl-yellow}

üìù Crea una nueva variable `long` con la longitud de cada discurso

```{r}
#| code-fold: true
#| eval: false

# nueva variable
discursos$long <- str_length(discursos$texto)
```

### [**Ej 4**]{.hl-yellow}

üìù A√±ade una nueva variable `n_words` con el n¬∫ palabras de cada discurso. Pista: si tras dividir cada discurso en palabras usas `length()` te devolver√° seguro 76 ya que lo ha guardado en un tipo de dato llamado lista. Para calcular la longitud de cada uno de los 76 elementos de la lista usaremos `lengths()`

```{r}
#| code-fold: true
#| eval: false
lista <- list("a" = 1:2, "b" = 1:3, "c" = 1:4) # Explicaci√≥n length
length(lista)
lengths(lista)
# Dividimos y aplicamos lengths
discursos$n_words <- lengths(str_split(discursos$texto, boundary("word")))
```

### [**Ej 5**]{.hl-yellow}

üìù Determina los 5 a√±os con mayor longitud, y los 5 a√±os con menor n√∫mero de palabras

```{r}
#| code-fold: true
#| eval: false

# 5 a√±os con mayor longitud (usamos order para obtener √≠ndices)
discursos$year[order(discursos$long, decreasing = TRUE)[1:5]]

# 5 a√±os con menor cantidad de palabras
discursos$year[order(discursos$n_words)[1:5]]
```

### [**Ej 6**]{.hl-yellow}

üìù Incorpora una nueva variable llamada `spain` que calcule el n√∫mero de veces que se dice "espa√±oles", "espa√±olas" o "espa√±a" en el discurso. Determina los 5 a√±os d√≥nde menos se menten dichas palabras

```{r}
#| code-fold: true
#| eval: false

# Contamos
discursos$spain <- str_count(discursos$texto, pattern = "espa√±oles|espa√±olas|espa√±a")

# A√±os con m√°s menciones
discursos$year[order(discursos$spain, decreasing = TRUE)[1:5]]
```

### [**Ej 7**]{.hl-yellow}

üìù De los 76 a√±os calcula el n√∫mero de discursos en los que las palabras "mujer" o "mujeres" se nombren m√°s que las palabras "hombre" u "hombres"

```{r}
#| code-fold: true
#| eval: false

sum(str_count(discursos$texto, pattern = "mujer|mujeres") >
      str_count(discursos$texto, pattern = "hombre|hombres"))
```

### [**Ej 8**]{.hl-yellow}

üìù Detecta los discursos donde aparece "catalu√±a", "catalanes", "catal√°n" o "catalanas" y qu√©date de la base de datos solo con aquellos que lo cumpla

```{r}
#| code-fold: true
#| eval: false

discursos[str_detect(discursos$texto, pattern = "catalu√±a|catalanes|catal√°n|catalanas"), ]
```

:::



## Primeras base de datos

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una ¬´tabla¬ª que las recopile.

### Primer intento: matrices

La opci√≥n m√°s inmediata son las [**matrices**]{.hl-yellow}: concatenaci√≥n de variables del [**mismo tipo e igual longitud**]{.hl-purple}.

Imagina que tenemos estaturas y pesos de 4 personas. ¬øC√≥mo [**crear un dataset con las dos variables**]{.hl-yellow}?

&nbsp;

La opci√≥n m√°s habitual es usando `cbind()`: [**concatenamos (bind) vectores en forma de columnas (c)**]{.hl-yellow}

```{r}
#| code-line-numbers: "3"
estaturas <- c(150, 160, 170, 180)
pesos <- c(63, 70, 85, 95)
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```


Tambi√©n podemos [**construir la matriz por filas**]{.hl-yellow} con la funci√≥n `rbind()` (concatenar - bind - por filas  - rows), aunque lo [**recomendable es tener cada variable en columna**]{.hl-green} e individuo en fila como luego veremos.

```{r}
rbind(estaturas, pesos) # Construimos la matriz por filas
```

- Podemos [**¬´visualizar¬ª la matriz**]{.hl-yellow} con `View(matriz)`.


-   Podemos [**comprobar las dimensiones**]{.hl-yellow} con `dim()`, `nrow()` y `ncol()`: las matrices son un tipo de **datos tabulados** (organizados en filas y columnas)

```{r}
dim(datos_matriz)
nrow(datos_matriz)
ncol(datos_matriz)
```


Tambi√©n podemos [**¬´darle vuelta¬ª (matriz transpuesta)**]{.hl-yellow} con `t()`.

```{r}
t(datos_matriz)
```

Dado que ahora tenemos dos dimensiones en nuestros datos, para [**acceder a elementos con `[]`**]{.hl-yellow} deberemos proporcionar **dos √≠ndices separados por comas**: √≠ndice de la fila y de la columna 

```{r}
datos_matriz[2, 1] # segunda fila, primera columna
datos_matriz[1, 2] # primera fila, segunda columna 
```


En algunas casos querremos obtener los [**datos totales de un individuo**]{.hl-yellow} (una fila concreta pero todas las columnas) o los valores de [**toda una variable**]{.hl-yellow} para todos los individuos (una columna concreta pero todas las filas). Para ello dejaremos [**sin rellenar uno de los √≠ndices**]{.hl-yellow}

```{r}
datos_matriz[2, ] # segundo individuo
datos_matriz[, 1] # primera variable
```


Mucho de lo aprendido con vectores podemos hacerlo con matrices, as√≠ podemos por ejemplo acceder a varias filas y/o columnas haciendo uso de las [**secuencias de enteros 1:n**]{.hl-yellow}

```{r}
datos_matriz[c(1, 3), 1] # primera variable para el primer y tercer individuo
```


Tambi√©n podemos definir una [**matriz a partir de un vector num√©rico**]{.hl-yellow}, reorganizando los valores en forma de matriz (sabiendo que los elementos se van [**colocando por columnas**]{.hl-purple}).

```{r}
z <- matrix(1:9, ncol = 3) 
z
```

Incluso podemos [**definir una matriz de valores constantes**]{.hl-yellow}, por ejemplo de ceros (para luego rellenar)

```{r}
matrix(0, nrow = 2, ncol = 3)
```



#### Operaciones con matrices

Con las matrices sucede como con los vectores: cuando aplicamos una [**operaci√≥n aritm√©tica lo hacemos elemento a elemento**]{.hl-yellow}

```{r}
z/5
```



Para realizar [**operaciones en un sentido matricial**]{.hl-yellow} deberemos a√±adir `%%`, por ejemplo, para multiplicar matrices ser√° `%*%`


```{r}
z * t(z)
z %*% t(z)
```


Tambi√©n podemos [**realizar operaciones por columnas/filas**]{.hl-yellow} sin recurrir a bucles con la funci√≥n `apply()`, y le indicaremos como **argumentos**

-   la matriz
-   el sentido de la operaci√≥n (`MARGIN = 1` por filas, `MARGIN = 2` por columnas)
-   la funci√≥n a aplicar
- argumentos extra que necesite la funci√≥n

Por ejemplo, para aplicar una media a cada variable, ser√° `mean` aplicada con `MARGIN = 2` (misma funci√≥n para cada columna)

```{r}
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")
```


### üíª Tu turno (matrices)

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para definir una matriz `x` de unos, de 3 filas y 7 columnas.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Ejercicio 2**]{.hl-yellow}

üìù A la matriz anterior, suma un 1 a cada n√∫mero de la matriz y divide el resultado entre 5. Tras ello calcula su transpuesta

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù ¬øPor qu√© el c√≥digo inferior nos devuelve dicho mensaje de aviso?

```{r}
#| warning: TRUE
matrix(1:15, nrow = 4)
```



### [**Ejercicio 4**]{.hl-yellow}

üìù Define la matriz `x <- matrix(1:12, nrow = 4)`. Tras ello obt√©n los datos del primer individuo, los datos de la tercera variable, y el elemento `(4, 1)`.

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # primera fila
x[, 3] # tercera columna
x[4, 1] # elemento (4, 1)
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Define una matriz de 2 variables y 3 individuos tal que cada variable capture la estatura y la edad 3 personas, de manera que la edad de la segunda persona sea desconocida (ausente). Tras ello calcula la media de cada variable (¬°nos debe de volver un n√∫mero!)

```{r}
#| code-fold: true
#| eval: false
datos <- cbind("edad" = c(20, NA, 25), "estatura" = c(160, 165, 170))
apply(datos, MARGIN = 2, FUN = "mean", na.rm = TRUE) # media por columnas

```

### [**Ejercicio 6**]{.hl-yellow}

üìù ¬øPor qu√© devuelve error el c√≥digo inferior? ¬øQu√© est√° mal?

```{r}
#| error: true
matriz <- cbind("edad" = c(15, 20, 25), "nombres" = c("javi", "sandra", "carlos"))
matriz
matriz + 1
```

:::

### Segundo intento: data.frame

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte (f√≠jate en el c√≥digo inferior: las edades y los `TRUE/FALSE` los ha convertido a texto)

```{r}
#| code-line-numbers: "4-5"
edades <- c(14, 24, NA)
soltero <- c(TRUE, NA, FALSE)
nombres <- c("javi", "laura", "luc√≠a")
matriz <- cbind(edades, soltero, nombres)
matriz
```

De hecho al no ser n√∫meros ya no podemos realizar operaciones aritm√©ticas

```{r}
#| error: true
matriz + 1
```

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos en `R` lo que se conoce como [**data.frame**]{.hl-yellow}: concatenaci√≥n de variables de igual longitud pero que pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
tabla <- data.frame(edades, soltero, nombres)
class(tabla)
tabla
```

Dado que un `data.frame` es ya un intento de ¬´base de datos¬ª las variables no son meros vectores matem√°ticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple} que describan su significado

```{r}
library(lubridate)
tabla <-
  data.frame("edad" = edades, "estado" = soltero, "nombre" = nombres,
             "f_nacimiento" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
tabla
```


[**¬°TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} (estrictamente no podemos hablar de base de datos pero de momento como lo si fuesen). Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

![](img/view_tabla.jpg)


#### Acceso a variables

Si queremos acceder a sus elementos, al ser de nuevo **datos tabulados**, podemos acceder como en las matrices ([**no recomendable**]{.hl-red}): de nuevo [**tenemos dos √≠ndices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera caracter√≠stica de la segunda persona
```


::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
Pero tambi√©n tiene las ventajas de una [**¬´base¬ª de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} ([**lo recomendable**]{.hl-green} ya que las variables pueden cambiar de posici√≥n y ahora s√≠ tienen un significado), poniendo el nombre de la tabla seguido del s√≠mbolo `$` (con el **tabulador**, nos aparecer√° un men√∫ de columnas a elegir)
:::
:::


#### Funciones de consulta

-   `names()`: nos muestra los nombres de las variables

```{r}
names(tabla)
```


-   `dim()`: nos muestra las dimensiones (tambi√©n `nrow()` y `ncol()`)

```{r}
dim(tabla)
```


-   Podemos acceder a las variables por su nombre

```{r}
tabla[c(1, 3), "nombre"]
tabla$nombre[c(1, 3)]
```



#### A√±adir variable

Si tenemos uno ya creado y queremos [**a√±adir una columna**]{.hl-yellow} es tan simple como usar la funci√≥n `data.frame()` que ya hemos visto para concatenar la columna. Vamos a√±adir por ejemplo una nueva variable, el n√∫mero de hermanos de cada individuo.

```{r}
# A√±adimos una nueva columna con n¬∫ de hermanos/as
hermanos <- c(0, 2, 3)
tabla <- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```



### Intento final: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}. La principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```


En adelante usaremos el formato `tibble` ([**data.frame mejorado**]{.hl-yellow}) del paquete `{tibble}`

```{r}
library(tibble)
datos_tb <- 
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
class(datos_tb)
datos_tb
```


```{r}
datos_tb <-
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
datos_tb
```

Las tablas en formato `tibble` nos permitir√° una [**gesti√≥n m√°s √°gil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

-   [**Metainformaci√≥n**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya autom√°ticamente el n√∫mero de filas y columnas, y el tipo de cada variable


-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)


-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
datos_tb$invent
```

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```



::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de p√°ginas web y documentos sencillos
:::

### üíª Tu turno (tb/df) {#tu-turno-3-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Carga del paquete `{datasets}` el conjunto de datos `airquality` (variables de la calidad del aire de Nueva York desde mayo hasta septiembre de 1973). ¬øEs el conjunto de datos airquality de tipo tibble? En caso negativo, convi√©rtelo a tibble (busca en la documentaci√≥n del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Una vez convertido a `tibble` obt√©n el nombre de las variables y las dimensiones del conjunto de datos. ¬øCu√°ntas variables hay? ¬øCu√°ntos d√≠as se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```


### [**Ejercicio 3**]{.hl-yellow}

üìù Filtra solo los datos de la quinta observaci√≥n

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, ]
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Filtra solo los datos del mes de agosto. ¬øC√≥mo indicarle que queremos solo las filas que cumplan una condici√≥n concreta? (pista: en realidad todo son vectores "formateados")

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, ]
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Selecciona aquellos datos que no sean ni de julio ni de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month != 7 & Month != 8, ]
airquality_tb[!(Month %in% c(7, 8)), ]
```

### [**Ejercicio 6**]{.hl-yellow}

üìù Modifica el siguiente c√≥digo para quedarte solo con las variable de ozono y temperatura (sin importar qu√© posici√≥n ocupen)

```{r}
#| eval: false
airquality_tb[, 3]
```

### [**Ejercicio 7**]{.hl-yellow}

üìù Selecciona los datos de temperatura y viento de agosto. 

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, c("Temp", "Wind")]
```

### [**Ejercicio 8**]{.hl-yellow}

üìù Traduce a castellano el nombre de las variables.


```{r}
#| code-fold: true
#| eval: false
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```

:::




## üê£ Caso pr√°ctico I: airquality (vectores)

En el paquete `{datasets}` (ya instalado por defecto) tenemos diversos conjuntos de datos y uno de ellos es `airquality`. Debajo te he extra√≠do 3 variables de dicho dataset (f√≠jate que se hace con `datos$variable`, ese dolar ser√° importante).

Los datos capturan [**medidas diarias (n = 153 observaciones) de la calidad del aire**]{.hl-yellow} en Nueva York, de mayo a septiembre de 1973. Se midieron **6 variables**: niveles de ozono, radiaci√≥n solar, viento, temperatura, mes y d√≠a.

```{r}
library(datasets)
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

### Pregunta 1

> ¬øC√≥mo averiguar qu√© [**representan los datos**]{.hl-yellow}? Piensa alg√∫n comando que nos d√© informaci√≥n sobre objetos en R, sabiendo que el nombre del dataset es `airquality`

```{r}
#| code-fold: true
#| eval: false
? airquality
```

Haciendo uso de `? ...` podemos consultar en el panel de ayuda lo que significa el objeto.

### Pregunta 2


> Accede solo a los 5 primeros registros de temperaturas. Despu√©s accede al primero, segundo, quinto y d√©cimo

```{r}
#| code-fold: true
#| eval: false

# secuencia de 1 a 5
temperature[1:5] 

# otra forma
temperature[c(1, 2, 3, 4, 5)]

# primero, segundo, quinto y d√©cimo
temperature[c(1, 2, 5, 10)]
```



### Pregunta 3

> Accede solo a los registros de temperaturas de mayo (tienes las temperaturas guardadas, piensa como acceder a ellos pero ahora usando una condici√≥n en lugar de √≠ndices concretos). Despu√©s accede a los elementos de mayo, abril y junio

```{r}
#| code-fold: true
#| eval: false

temperature[month == 5]

# abril, mayo y junio
temperature[month == 4 | month == 5 | month == 6]

# otra forma m√°s legible: %in% nos comprueba si 
# los valores est√°n dentro de una lista permitida
temperature[month %in% c(4, 5, 6)]
```

### Pregunta 4

> ¬øCu√°ntos [**registros tenemos de mayo**]{.hl-yellow}? ¬øY de abril? 

```{r}
#| code-fold: true
#| eval: false

# Una forma para registros de mayo
sum(month == 5)

# Otra forma: la longitud de un vector
length(temperature[month == 5])

# √≠dem en abril
sum(month == 4)
```

### Pregunta 5

> Construye una nueva variable `date` con la fecha de cada registro (combinando a√±o, mes y d√≠a), sabiendo que todos los datos son de 1973. Pista: para construir una fecha antes debes tener un vector de textos (por ejemplo, "1973-01-01")

```{r}
#| code-fold: true
#| eval: false

# variable de tipo date
library(lubridate)
dates <- as_date(glue("{1973}-{month}-{day}"))
```

### Pregunta 6

> Crea una nueva variable `temp_celsius` con la temperatura en ¬∫C (sabiendo que se calcula como $celsius = (fahr - 32) * (5/9)$). Tras ello calcula cu√°ntos d√≠as de junio superaron los 30 grados ¬∫C.

```{r}
#| code-fold: true
#| eval: false

# Temperatura en celsius
temp_celsius <- (temperature - 32) * (5/9)
temp_celsius 

# una forma
sum(temp_celsius[month == 6] > 30)

# otra forma
length(temp_celsius[month == 6 & temp_celsius > 30])
```

### Pregunta 7

> ¬øCu√°l fue la media de temperatura del mes de agosto? 

```{r}
#| code-fold: true
#| eval: false

# media en agosto
mean(temperature[month == 8], na.rm = TRUE)
mean(temp_celsius[month == 8], na.rm = TRUE)
```

### Pregunta 8

>  Dado el vector de temperaturas de agosto, ordena las temperaturas (los m√°s fr√≠os primero, los m√°s c√°lidos despu√©s). Hazlo de las dos maneras aprendidas. Usa despu√©s el paquete `{microbenchmark}` (inst√°lalo, c√°rgalo y busca en la ayuda la funci√≥n `microbenchmark` de dicho paquete) para comparar cu√°l de las dos opciones es m√°s r√°pida.


```{r}
#| code-fold: true
#| eval: false

# con sort
temp_sort <- sort(temp_celsius[month == 8])
temp_sort

# con order
temp_ord <- temp_celsius[month == 8][order(temp_celsius[month == 8])]
temp_ord

# microbenchmark
# install.packages("microbenchmark")
microbenchmark::microbenchmark(sort(temp_celsius[month == 8]),
                               temp_celsius[month == 8][order(temp_celsius[month == 8])],
                               times = 1000)

# ¬°Es m√°s eficiente datos[order(datos)] que sort(datos!
```


## üê£ Caso pr√°ctico II: pinniped dataset

Del paquete `{Biostatistics}` usaremos el conunto de datos `pinniped`, que guarda los datos de peso de cuerpo y cerebro (desagregado por sexo y mono/poligamia) de 33 especies de mam√≠feros marinos.


```{r}
Biostatistics::pinniped
```

### Pregunta 1

> Comprueba si los datos est√°n en formato tibble. En caso negativo convi√©rtelo.

```{r}
#| eval: false
#| code-fold: true

# chequeamos si es tibble
library(tibble)
is_tibble(Biostatistics::pinniped)

# Convertimos a tibble
pinniped_tb <- as_tibble(Biostatistics::pinniped)
```

### Pregunta 2

> ¬øCu√°ntos registros hay? ¬øCu√°ntas variables? ¬øDe qu√© tipo es cada una? ¬øCu√°les son sus nombres?


```{r}
#| code-fold: true
#| eval: false
nrow(pinniped_tb)
ncol(pinniped_tb)
names(pinniped_tb)
```

### Pregunta 3

> Incorpora una variable nueva llamada `phoca` que sea de tipo l√≥gico y que nos diga si una especie es de la categor√≠a `Phoca` o no.

```{r}
#| code-fold: true
#| eval: false
pinniped_tb$phoca <- pinniped_tb$Species == "Phoca"
```

### Pregunta 4

> ¬øA qu√© sexo le pesa m√°s el cerebro: a las hembras o a los machos?

```{r}
#| code-fold: true
#| eval: false

# ¬øa qui√©n le pesa m√°s el cerebro?
mean(pinniped_tb$Male_brain_g, na.rm = TRUE) >
  mean(pinniped_tb$Female_brain_g, na.rm = TRUE)
```

### Pregunta 5

> ¬øA quienes les pesa m√°s el cuerpo a los mon√≥gamos o a los pol√≠gamos? Recuerda que tienes los pesos divididos por sexos en variables distintas que tendr√°s que juntar de alguna forma

```{r}
#| code-fold: true
#| eval: false

# ¬øa qui√©n le pesa m√°s el cerebro?
mean(c(pinniped_tb$Male_mass_Kg[pinniped_tb$Mate_type == "mono"],
       pinniped_tb$Female_mass_Kg[pinniped_tb$Mate_type == "mono"])) >
  mean(c(pinniped_tb$Male_mass_Kg[pinniped_tb$Mate_type == "poly"],
         pinniped_tb$Female_mass_Kg[pinniped_tb$Mate_type == "poly"]))
```


### Pregunta 6

> Incopora una nueva variable llamada `dif_m_f` que represente la diferencia entre el peso del cerebro entre machos y hembras (machos - hembras) para cada especie.

```{r}
#| code-fold: true
#| eval: false
pinniped_tb$dif_m_f <- pinniped_tb$Male_brain_g - pinniped_tb$Female_brain_g
pinniped_tb
```

## üê£ Caso pr√°ctico III: salto de longitud

Para practicar textos y tibbles vamos a usar el dataset `salto_longitud.csv` que tienes guardado en la carpeta de datos, que guarda c√≥mo ha **progresado el r√©cord de salto de longitud masculino**. Dicha tabla ha sido extra√≠da directamente de la wikipedia <https://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression#Low_altitude_record_progression_1965%E2%80%931991>

![](./img/men-long-jump.png)

```{r}
load(file = "./datos/salto_longitud.RData")
```

Aunque m√°s adelante veremos como extraerlo, puedes ver debajo si quieres el c√≥digo que se ha usado para extraer la tabla

```{r}
#| code-fold: true
#| eval: false
library(rvest)
library(tidyverse)
wiki_jump <- 'https://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression'
long_jump <- read_html(wiki_jump)
salto_longitud <- html_table(html_node(long_jump, 'table'))
```



### Pregunta 1

> ¬øCu√°ntos registros hay? ¬øCu√°ntas variables? ¬øDe qu√© tipo es cada una? ¬øCu√°les son sus nombres? ¬øQu√© crees que significan?


```{r}
#| code-fold: true
#| eval: false
nrow(salto_longitud)
ncol(salto_longitud)
names(salto_longitud)

# tenemos 19 r√©cords y 5 variables: la marca (en metros, pies y pulgadas), el viento que hac√≠a, la persona que bati√≥ el record, el lugar y la fecha.
```



### Pregunta 2

> Crea una nueva variable llamada `Mark` (sustituye a la anterior) en la que hayas extra√≠do la marca en metros (y convertida a n√∫mero). Pr√°ctica antes con un valor de juguete, por ejemplo, si tuvi√©semos `x <- "7.61 m (24 ft 11+1/2 in)", ¬øc√≥mo podr√≠amos quedarnos solo con la marca en metros?


```{r}
#| code-fold: true
#| eval: false

# Sabemos que el patr√≥n es 1 n√∫mero, un ., y dos decimales, as√≠ que
# usamos str_extract para extraer ese patr√≥n que le indicamos
# con una expresi√≥n regular.
salto_longitud$Mark <-
  str_extract(salto_longitud$Mark, pattern = "[0-9][.][0-9]{2}")

# Tras ello convertimos a n√∫mero
salto_longitud$Mark <- as.numeric(salto_longitud$Mark)

# importante: ahora en la cabecera debajo de mark pone <dbl>, es un n√∫mero
salto_longitud 
```

### Pregunta 3

> Crea una nueva variable llamada `Wind` (sustituye la original) en la que tengas el viento convertido a n√∫mero. 


```{r}
#| code-fold: true
#| eval: false
salto_longitud$Wind <- as.numeric(salto_longitud$Wind)
salto_longitud
```

> ¬øEn cu√°ntos r√©cords no hab√≠a viento? ¬øEn cu√°ntos no tenemos registros de dicha medida?

```{r}
#| code-fold: true
#| eval: false

# Con viento 0
sum(salto_longitud$Wind == 0, na.rm = TRUE)

# Sin registros
sum(is.na(salto_longitud$Wind))

# importante: ausente y 0 no es lo mismo
```

### Pregunta 4

> Crea una nueva variable llamada `country` que extraiga las siglas de los pa√≠ses de la variable `Athlete`

```{r}
#| code-fold: true
#| eval: false
# Primero extraemos con los par√©ntesis (es m√°s f√°cil detectarlo)
salto_longitud$country <-
  str_extract(salto_longitud$Athlete, pattern = "[(][A-Z]{3}[)]")

# Luego los eliminamos los ( y los ) (de ah√≠ la barra vertical en medio)
# F√≠jate que para que entienda que es un caracter especial (par√©ntesis)
# se lo pasamos como \\( y como \\). Ppasar√≠a lo mismo si queremos detectar,
# por ejemplo, un punto, con \\.
salto_longitud$country <- str_remove_all(salto_longitud$country, "\\(|\\)")
```



### Pregunta 5

> Ordena la tabla por orden alfab√©tico de las siglas

```{r}
#| code-fold: true
#| eval: false
salto_longitud <- salto_longitud[order(salto_longitud$country), ]
```

### Pregunta 6

> Reemplaza la variable `Date` por la fecha correcta en formato fecha


```{r}
#| code-fold: true
#| eval: false

# primero eliminamos todos los [?]
salto_longitud$Date <-
  str_remove_all(salto_longitud$Date, pattern = "\\[[0-9]{1}\\]")

# luego atendemos el caso particualr de [note 1]
salto_longitud$Date <-
  str_remove_all(salto_longitud$Date, pattern = "\\[note 1\\]")

# tras depurar convertimos a fecha
salto_longitud$Date <- dmy(salto_longitud$Date)
salto_longitud
```

### Pregunta 7

> ¬øCu√°ntos r√©cords no son de Estados Unidos? ¬øQu√© porcentaje representa respecto al total?

```{r}
#| code-fold: true
#| eval: false

# total absoluto
sum(salto_longitud$country == "USA")

# porcentaje relativo
100*sum(salto_longitud$country == "USA") / length(salto_longitud$country)
```


### Pregunta 8

> Para cada r√©cord, calcula los metros de mejora respecto al anterior, y gu√°rdalo en la base de datos. Pista: prueba bien la funci√≥n `diff()` y chequea la longitud de lo que te devuelve.

```{r}
#| code-fold: true
#| eval: false

# Usamos la funci√≥n diff que, dado un vector, calcula las diferencias
# f√≠jate que el primero no conocemos la mejora (ya que no hay registro previo)
salto_longitud$mejora <- c(NA, diff(salto_longitud$Mark))
```

