---
title: "Data programming and intro to R"
subtitle: "Prepare, clean, transform and enrich data in R"
title-slide-attributes:
  data-background-image: img/background-mucss.webp
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Master in Computational Social Sciences ‚Ä¢ Javier √Ålvarez Li√©bana"
affiliation: Facultad de Estudios Estad√≠sticos (UCM)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier √Ålvarez Li√©bana</strong>](...) ‚Ä¢ Master in Computational Social Sciences (UC3M)"
    slide-number: c/t
execute:
  echo: true
---

::: r-fit-text
[Welcome to R!]{.flow}
:::

[**Put your spreadsheets, SAS and SPSS aside**]{style="color:#444442;"}

---

## Hi!

[**Mail**]{.hl-green}: **<javalv09@ucm.es>**.

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
-   [**Javier √Ålvarez Li√©bana**]{.hl-yellow} from Carabanchel (Madrid).

-   Degree in Mathematics (UCM). [**PhD in Statistics**]{.hl-yellow} (UGR).

-   In charge of  [**data visualization and analysis**]{.hl-yellow} for the Principality of Asturias (2021-2022) during the COVID pandemic

-   Member of the [**Spanish Society of Statistics and OR**]{.hl-yellow} and the [**Spanish Royal Mathematical Society**]{.hl-yellow}.


:::
:::
:::


Currently, [**Assistant Professor at the Faculty of Statistics of the UCM**]{.hl-yellow}. Disseminating via [**Twitter**](https://twitter.com/dadosdelaplace) e [**Instagram**](https://instagram.com/javieralvarezliebana)


---

## Goals

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
- Take away the [**fear of programming**]{.hl-yellow} ‚Üí learn to program by programming

- Understanding [**basic R concepts**]{.hl-yellow} from scratch ‚Üí learning to **abstract** ideas and algorithms

- Utility of programming ‚Üí [**reproducible, transparent and maintainable workflows**]{.hl-yellow}.

- Introduction to [**analysis and preprocessing of data**]{.hl-yellow} ‚Üí `{tidyverse}`.

- Handling [**advanced data types**]{.hl-yellow} ‚Üí `{forcats}`, `{lubridate}` and `{purrr}` packages

:::
:::
:::


---

## Evaluation: intro to R

-  [**Attendance and individual participation**]{.hl-yellow} (30%)

. . .

- [**Final exam**]{.hl-yellow} on 10/09/2024, 15:00-16:10 (70%). 

. . .

* [**Max grade**]{.hl-yellow}: to get a grade greater than 9/10 you should get at least 9/10 in the final exam.

---

## Evaluation: data programming

-  [**Attendance and individual participation**]{.hl-yellow} (10%)

. . .

- [**2 individual tasks**]{.hl-yellow} done during the course (15%-25%). 

. . .

- [**1 group task**]{.hl-yellow} between 4 and 6 people (20%). **Deadline**: 23/12/2024.

. . .

- [**Final exam**]{.hl-yellow} with all materials and internet (30%). [**You are exempt if you get more than 7.5/10**]{.hl-purple} in the previous tasks.

. . .

* [**Max grade**]{.hl-yellow}: to get a grade greater than 9/10 you should get at least 9/10 in the individual tasks.


---

## Planning

* [**Final exam (intro R 70%)**]{.hl-yellow}: 10/09/2024 (15:00 - 16:10).

&nbsp;

* [**Individual task I (15%)**]{.hl-yellow}: deadline 03/11/2024

* [**Individual task II (25%)**]{.hl-yellow}: deadline 30/11/2024

* [**Group task (20%)**]{.hl-yellow}: deadline 23/12/2024.

&nbsp;

* [**Final examen (30% if required)**]{.hl-yellow}: TBA


---

## Planning: intro R {#planificacion}

::: column-screen-inset-right
::: {style="font-size:20px"}
|  LESSON | WEEK | DATES | TOPIC | EX. | WORKBOOK | TASK | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
| [0-1](#clase-0-1) | S1 | 2 sep | First steps: R base programming | [üíª](#tu-turno-0-1-1) [üíª](#tu-turno-0-1-2)  |  |  | 
| [0-2](#clase-0-2) | S1 | 4 sep | First data: concatenate values and databases | [üíª](#tu-turno-0-2-1) [üíª](#tu-turno-0-2-2) [üíª](#tu-turno-0-2-3) |  [üê£](#caso-practico-0-2-1) [üê£](#caso-practico-0-2-2) |  |
| [0-3](#clase-0-3) | S1 | 6 sep | Quarto and flow structures | [üíª](#tu-turno-0-3-1) [üíª](#tu-turno-0-3-2) [üíª](#tu-turno-0-3-3) |  [üê£](#caso-practico-0-3-1) [üê£](#caso-practico-0-3-2) [üê£](#caso-practico-0-3-3) |  |
| [0-4](#clase-0-4) | S2 | 10 sep | Final task (70%) | | | [üéØ](#clase-0-4) |
:::
:::

---

## Planning: data programming {#planificacion-curso}

::: column-screen-inset-right
::: {style="font-size:20px"}
|  LESSON | WEEK | DATES | TOPIC | EX. | WORKBOOK | TASK | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
| [1](#clase-1) | S2 | 12 sep | First steps: R base programming | [üíª](#tu-turno-0-1-1) [üíª](#tu-turno-0-1-2)  |  |  | 
| [2](#clase-2) | S3 | 19 sep | First data: concatenate values and databases | [üíª](#tu-turno-0-2-1) [üíª](#tu-turno-0-2-2) [üíª](#tu-turno-0-2-3) |  [üê£](#caso-practico-0-2-1) [üê£](#caso-practico-0-2-2) |  |
| [3](#clase-3) | S4 | 26 sep | Quarto and flow structures | [üíª](#tu-turno-0-3-1) [üíª](#tu-turno-0-3-2) [üíª](#tu-turno-0-3-3) |  [üê£](#caso-practico-0-3-1) [üê£](#caso-practico-0-3-2) [üê£](#caso-practico-0-3-3) |  |
:::
:::


  
---

## Materials

* [**Slides**]{.hl-yellow}: slides made with `Quarto` available and updated on **<https://javieralvarezliebana.es/docencia/mucss-data-programming>**. In the slide menu (bottom left) you have an option to  [**download them in pdf**]{.hl-yellow} in `Tools`

&nbsp;

* [**Material**]{.hl-yellow}: [**workbooks**](https://javieralvarezliebana.es/docencia/mucss-data-programming/material/) and extra materials.

* [üóÉ **Data**]{.hl-yellow}: datasets that will be used, available on **<https://javieralvarezliebana.es/docencia/mucss-data-programming/material>**

* [üìö **Extra resources**]{.hl-yellow}:  <https://r4ds.had.co.nz/>, <https://cdr-book.github.io/> and <https://ivelasq.quarto.pub/intro-to-quarto/>.

---

## Datasets

* [üóÉ **Data**]{.hl-yellow}: datasets that will be used, available on **<https://javieralvarezliebana.es/docencia/mucss-data-programming/material>**

&nbsp;

* `airquality` from the `{datasets}` package (already installed by default): daily measurements (153 observations) of air quality in New York, from May to September 1973. Measured **6 variables**: ozone, solar radiation, wind, temperature, month and day.

* `salto_longitud`: guarda c√≥mo ha **progresado el r√©cord de salto de longitud masculino**. Tabla extra√≠da de la wikipedia <https://shorturl.at/Wqif1>

* `pinniped` del paquete `{Biostatistics}`: **peso corporal y cerebral** de 33 especies de pinn√≠pedos (morsas, leones marinos y elefantes marinos) desagregado por sexos y mono/poligamia.

---

## Datasets

* [üóÉ **Data**]{.hl-yellow}: datasets that will be used, available on **<https://javieralvarezliebana.es/docencia/mucss-data-programming/material>**

&nbsp;

* `discursos`: recopila los discursos de navidad de los jefes de Estado en Espa√±a (en dictadura y en democracia) desde 1946 hasta 2021

* `relig_income` del paquete `{tidyr}`: recopila los datos de ingresos anuales en funci√≥n de la religi√≥n (fuente original <https://www.pewresearch.org/religion/religious-landscape-study/>)

* `who` del paquete `{tidyr}`: datos de la OMS respecto infecciones por tuberculosis, desagregados por tipo de enfermedad, sexo y edad.

* `billboard` del paquete `{tidyr}`: ranking top 100 de canciones seg√∫n Billboard (algo parecido a Los 40) para el a√±o 2000.

# L1: [first steps]{.flow} {#clase-0-1}



[**Introduction to R and RStudio. Working with projects. First uses of functions and packages. Basic data types**]{style="color:#444442;"}

* [üíª Solved exercises: first steps](#tu-turno-0-1-1)
* [üíª Solved exercises: first variables](#tu-turno-0-1-2)
* [üìÜ Planning](#planificacion)

---

## Requirements

For the course, the only requirements will be:

1. [**Internet connection**]{.hl-yellow} (to download some data and packages).

. . .

2. [**Install R**]{.hl-yellow}: it will be our language. We will download it (for free) from <https://cran.r-project.org/>

. . .

3. [**Install RStudio**]{.hl-yellow} from <https://posit.co/download/rstudio-desktop/>

::: columns
::: {.column width="50%"}

![](img/cranR.jpg){width="420"}

:::


::: {.column width="50%"}

![](img/rstudio.jpg){width="420"}

:::
:::

---

## R vs RStudio

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="360"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="430"}
:::
:::


::: {.fragment .fade-in-then-out}

We will program as we write 

:::

::: {.fragment .fade-up}

-   We will need a [**grammar, a language**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}

-   And an environment, such as [**Word**]{.hl-yellow} (`RStudio`) to write it

:::
:::

---

## Installing R

The `R` language will be our [**grammar and spelling**]{.hl-yellow} (our rules of the game)


::: incremental
-   [**Step 1**]{.hl-yellow}: go to <https://cran.r-project.org/> and select your operating system.

-   [**Step 2**]{.hl-yellow}: for Mac, simply click on the **.pkg file**, and open it once downloaded. For Windows systems, we need to click on **install R for the first time** and then on **Download R for Windows**. Once downloaded, open it like any installation file.

-   [**Step 3**]{.hl-yellow}: open the installation executable.

:::

. . .

::: callout-warning

Whenever you need to download something from CRAN (either `R` itself or a package), [**make sure you have an internet connection**]{.hl-orange}.

:::

---

## First operation {auto-animate="true"}

::: columns
::: {.column width="60%"}

To check the installation, after opening `R`, you should see the `R GUI` (Graphical User Interface) with a **white screen** similar to this ([**console**]{.hl-yellow}).

:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**First code**]{.hl-yellow}: we will **assign** the value `1` to a variable called `a` (we will write the code in the console and press "enter"). Then we will do the sum `a + b`.

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## First operation {auto-animate="true"}

::: columns
::: {.column width="60%"}

To check the installation, after opening `R`, you should see the `R GUI` (Graphical User Interface) with a **white screen** similar to this ([**console**]{.hl-yellow}).

:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**First code**]{.hl-yellow}: we will **assign** the value `1` to a variable called `a` (we will write the code in the console and press "enter"). Then we will do the sum `a + b`.

```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

---

## First operation {auto-animate="true"}

::: columns
::: {.column width="60%"}

To check the installation, after opening `R`, you should see the `R GUI` (Graphical User Interface) with a **white screen** similar to this ([**console**]{.hl-yellow}).

:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**First code**]{.hl-yellow}: we will **assign** the value `1` to a variable called `a` (we will write the code in the console and press "enter"). Then we will do the sum `a + b`.

```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

. . .

::: callout-note
## Note that...

In the console, a number `[1]` appears: it's simply an element counter (like counting rows in Word)

:::

---

## Installing R Studio

`RStudio` will be the [**Word**]{.hl-yellow} we will use to write (what is known as an [**IDE: Integrated Development Environment**]{.hl-yellow}).

::: incremental
-   [**Step 1**]{.hl-yellow}: go to the [official RStudio website](https://posit.co/download/rstudio-desktop/) (now called Posit) and select the free download.

-   [**Step 2**]{.hl-yellow}: select the executable that appears according to your operating system.

-   [**Step 3**]{.hl-yellow}: after downloading the executable, open it like any other and let the installation finish.

:::

---

## RStudio Organization

When you open `RStudio` you will likely have three windows:


-   [**Console**]{.hl-yellow}: is the name for the large window that takes up most of your screen. Try writing the same code as before (the sum of the variables) in it. The console is where **we will execute commands and display results**.

![](img/consola_rstudio.jpg){width="420"}

---

## RStudio Organization

When you open `RStudio` you will likely have three windows:

-   [**Environment**]{.hl-yellow}: the small screen (you can adjust the margins with the mouse to your liking) that we have in the top right corner. It will show us the **variables we have defined**.


![](img/environment.jpg){width="420"}

---

## RStudio Organization

When you open `RStudio` you will likely have three windows:

-   [**Multi-purpose panel**]{.hl-yellow}: the window at the bottom right will be used to **look for function help**, as well as to **visualize plots**.

![](img/multiusos.jpg){width="420"}

---

## What is R? Why R?

![](img/meme_barco.jpg)

---


## What is R? Why R?

![](img/incel_excel.png)

`R` is the evolution of the work of Bell Laboratories with the `S` language, which was brought into the open-source world by Ross Ihaka and Robert Gentleman in the 1990s. The version `R 1.0.0` was released on February 29, 2000.


---

## What is R? Why R?

`R` is the [**statistical language par excellence**]{.hl-yellow}, created by and for statisticians, with 6 fundamental advantages [**over Excel, SAS, Stata, or SPSS**]{.hl-red}:

. . .

-   [**Programming language**]{.hl-yellow}: the obvious ‚Üí [**replicable**]{.hl-purple} analysis

. . .

-   [**Free**]{.hl-yellow}: the philosophy of the `R` community is to share code under **copyleft** ‚Üí **ethical use of spending and algorithms**

. . .

-   [**Open-source software**]{.hl-yellow}: not only is it free, but it also allows free access to others' code, even to the **source code itself** ‚Üí [**flexibility and transparency**]{.hl-purple} (Free and Open Source Software FOSS)

---

## What is R? Why R?

`R` is the [**statistical language par excellence**]{.hl-yellow}, created by and for statisticians, with 6 fundamental advantages [**over Excel, SAS, Stata, or SPSS**]{.hl-red}:


-   [**Modular language**]{.hl-yellow}: we have installed the minimum, but there are codes from other people that we can reuse (almost 20,000 [**packages**]{.hl-yellow}) ‚Üí [**time saving**]{.hl-purple} and [**immediate innovation**]{.hl-purple}

. . .

-   [**High-level language**]{.hl-yellow}: facilitates programming (like Python) ‚Üí [**lower learning curve**]{.hl-purple}

. . .

- [**Community and employability**]{.hl-yellow}: along with Python, it is the most used language in the field of statistics and data science in research, teaching, companies (L√≠nea Directa, Mapfre, Telef√≥nica, Orange, Apple, Spotify, Netflix, El Pa√≠s, Civio, HP, etc.) and public organizations (ISCIII, CNIC, CNIO, INE, IGN, CIS, CEO, DGT, AEMET, RTVE, etc.)

---

## Why programming?

-   [**Automate**]{.hl-yellow} ‚Üí it will allow you to automate recurring tasks.

-   [**Replicability**]{.hl-yellow} ‚Üí you will be able to replicate your analysis in the same way every time.

-   [**Flexibility**]{.hl-yellow} ‚Üí you will be able to adapt the software to your needs.

-   [**Transparency**]{.hl-yellow} ‚Üí to be audited by the community.

![](img/the_general_problem.png)

---

## Fundamental Idea: Packages

One of the key ideas of `R` is the [**use of packages**]{.hl-yellow}: codes that other people have implemented to **solve a problem**


::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}

-   [**Installation**]{.hl-yellow}: we download the codes from the web (we need internet) ‚Üí [**buy a book**]{.hl-purple}, only once (per computer)


```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}

-   [**Loading**]{.hl-yellow}: with the package downloaded, we indicate which packages we want to use each time we open `RStudio` ‚Üí [**take the book off the shelf**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```

:::
:::
:::

---

## Fundamental Idea: Packages

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}

Once installed, there are **two ways to use a package** (take it off the shelf)

::: {.fragment fragment-index="1"}

-   [**Whole package**]{.hl-yellow}: with `library()`, using the package name without quotes, we load [**the whole book**]{.hl-purple} into the session


```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}

-   [**Specific functions**]{.hl-yellow} using `package::function+  we indicate that we only want [**a specific page of that book**]{.hl-purple}


```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## You will be wrong

During your learning, it will be very common for things not to work out on the first try ‚Üí [**you will be wrong**]{.hl-yellow}. It will not only be important to accept it but also [**to read the error messages**]{.hl-yellow} to learn from them.


. . .

-   [**Error messages**]{.hl-red}: preceded by **"Error in..."** and will be those failures that [**prevent execution**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Warning messages**]{.hl-orange}: preceded by **¬´Warning in...¬ª** they are the (possible) more delicate errors as they are inconsistencies that [**do not prevent execution**]{.hl-orange}


```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```

---

## Scripts (.R files)


::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}

A [**script**]{.hl-yellow} will be the document in which we program, our `.doc` file (here with a `.R` extension) where we will write the commands. To **open our first script**, click on the menu in `File < New File < R Script`.


::: callout-warning
## Be careful

It's important **not to overuse the console**: everything you don't write in a script, when you close, [**will be lost**]{.hl-orange}.

:::

:::
:::



::: callout-warning
## Be careful

`R` is [**case-sensitive**]{.hl-orange}: it is sensitive to uppercase and lowercase, so `x` and `X` represent different variables.

:::


---

## Running the first script

Now we have a **fourth window**: the window where we will [**write our codes**]{.hl-yellow}. How do we run it?

. . .

1. **Write the code** to be executed.
. . .

2. **Save the .R file** by clicking on `Save current document`.
. . .

3. The code does not execute unless we indicate it. We have **three options to run a script**:

- [**Copy and paste**]{.hl-yellow} into the console.
- [**Select lines**]{.hl-yellow} and press `Ctrl+Enter`
- [**Enable Source on Save**]{.hl-yellow} next to save: not only saves but also executes the **entire code**.

---


## Organizing: projects

Just as we usually work [**organized by folders**]{.hl-yellow} on the computer, in `RStudio` we can do the same to work [**efficiently by creating projects**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}

A [**project will be a "folder"**]{.hl-yellow} within `RStudio`, so our root directory will automatically be the project folder itself (allowing us to switch from one project to another using the top right menu).

We can create one in a new folder or in an existing folder."

:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::


---

## üíª It's your turn {#tu-turno-0-1-1}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

üìù Create in your computer a folder of the subject and create inside it the `RStudio` project: it is there where you are going to save everything that we will do along this course, after creating the project you will have an `R Project` file. Then create in this folder two subfolders: `data` (this is where you will save the different datasets that we will use) and `scripts` (this is where you will save the `.R` files of each class).

### [**Exercise 2**]{.hl-yellow}

üìù Inside the project create a script `Exercises-class1.R` (inside the `scripts` folder). Once created, define in it a variable named `a` and whose value is -1. Execute the code in the (three) ways explained before.

```{r}
#| code-fold: true
a <- -1
```

### [**Exercise 3**]{.hl-yellow}

üìù Add below another line to define a variable `b` with the value 5. Then save the multiplication of both variables. Execute the code as you want.

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # without saving it
mult <- a * b # save it
```

### [**Exercise 4**]{.hl-yellow}

üìù Modify the code below to define two variables c and d, with values 3 and -1. Then divide the variables and save the result.

```{r}
#| eval: false
c <- # you should assign 3
d <- # you should assign -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d
div <- c / d
```

### [**Exercise 5**]{.hl-yellow}

üìù Assign to `x` a positive value and then compute its square root; assign to `y` a negative number and compute its absolute value using `abs()`.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

::: callout-note
## Note that...

Commands like `sqrt()`, `abs()` or `max()` are what we call [**functions**]{.hl-purple}: lines of code that we have "encapsulated" under a name, and given some input arguments, execute the commands (a sort of shortcut). In the functions the [**arguments will ALWAYS be enclosed in parentheses**]{.hl-yellow}

:::


### [**Exercise 6**]{.hl-yellow}

üìù Using the variable `x` already defined, complete/modify the code below to store in a new variable `z` the result stored in `x` minus 5.

```{r}
#| eval: false
z <- ? - ? # complete the code
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```

### [**Exercise 7**]{.hl-yellow}

üìù Define an `x` variable and assign it the value `-1`. Define another `y` and assign it the value `0`. Then perform the operations a) `x` by `y`; b) square root of `x`. What do you get?


```{r}
#| code-fold: true
#| eval: false
x <- -1
y <- 0

x / y
sqrt(x)
```

### [**Exercise 8**]{.hl-yellow}

üìù Write the code below in your script. Why do you think it doesn't work?

```{r}
#| error: true
x <- -1
y <- 0

X + y
```

:::



---

## From CELL to TABLE

What [**data type**]{.hl-yellow} can we have in each **cell of a table**?



![](img/celdas.jpg)

::: incremental

- [**Cell**]{.hl-yellow}: an individual piece of data of a specific type.
- [**Variable**]{.hl-yellow}: **concatenation** of values of the same type ([**vectors in R**]{.hl-purple}).
- [**Matrix**]{.hl-yellow}: concatenation of variables of the **same type and length**.
- [**Table**]{.hl-yellow}: concatenation of variables of [**different types but the same length**]{.hl-purple}
- [**List**]{.hl-yellow}: concatenation of variables of [**different types and different lengths**]{.hl-purple}
:::

---

## But first...best practices

Before we continue, it‚Äôs important to know something as soon as possible: [**starting with programming can be frustrating**]{.hl-yellow}

. . .

Just like when learning a new language, the first obstacle is not so much what to say but how to say it correctly. The same goes for `R`, so let‚Äôs [**standardize our programming style**]{.hl-yellow} as much as possible to avoid future errors.

. . .

* [**Tip 1**]{.hl-green}: [**assignment, evaluation, and comparison are not the same**]{.hl-yellow}. If you‚Äôve noticed in `R`, we use `<-` to assign values to variables. We use `=` to evaluate function arguments and `==` to check if two elements are equal.

```{r}
#| eval: false
x <- 1 # asign
x = 1 # evaluation
x == 1 # comparison
```



---

## But first...best practices

* [**Tip 2**]{.hl-green}: program like you write. Just like when writing in Spanish, get used to incorporating [**spaces and line breaks**]{.hl-yellow} to avoid making your code hard to read (it's a good practice, not a requirement, because `R` does not process spaces).


```{r}
#| eval: false
x <- 1 # optimal
x<-1 # meh
x<- 1 # worst (make up your mind)
```

. . .

* [**Tip 3**]{.hl-green}: don‚Äôt be chaotic, [**standardize names**]{.hl-yellow}. Always get used to naming variables consistently. The only requirement is that **they must always start with a letter** (and without accents). The most recommended form is `snake_case`.



```{r}
#| eval: false
variable_in_snake_case
anotherHarderToReadFormat
there.are.people.who.use.this
Even_People_Here.Confusing_That_Do_Not_Deserve_Our_ATTENTION
```

---

## But first...best practices

* [**Tip 4**]{.hl-green}: make reading and writing easier, [**set limits**]{.hl-yellow}. In `Tools < Global Options`, you can customize some options in `RStudio`. In `Code < Display`, you can set `Show margin` to display an "imaginary" margin (not interacting with the code) to "force" you to make line breaks.

![](img/show_margin.jpg)


---

## But first...best practices

* [**Tip 5**]{.hl-green}: the [**tab key is your best friend**]{.hl-yellow}. In `RStudio`, there‚Äôs a wonderful tool: if you type part of a variable or function name and press tab, `RStudio` will autocomplete it for you.


![](img/tab-autocompletar.png)  


---

## But first...best practices

* [**Tip 6**]{.hl-green}: no single parentheses. Whenever you open a parenthesis, you must close it. To make this task easier, go to `Tools < Global Options < Code < Display` and enable the `Rainbow parentheses option`.

![](img/rainbow-parentheses.jpg)



---

## But first...best practices

* [**Tip 7**]{.hl-green}: pay attention to the left side. You will not only see the line of code you are on but also, in case of a [**syntax error**]{.hl-red}, `RStudio` will notify you.

![](img/rstudio-error-sintaxis.png)

* [**Tip 8**]{.hl-green}: try to [**always work by projects**]{.hl-yellow} (for this class, create a script `class1.R` in the project we created before)


&nbsp;

See more tips at <https://r4ds.had.co.nz/workflow-basics.html#whats-in-a-name>

---

## Cells: data types

Are there [**variables beyond numbers in data science**]{.hl-yellow}? For example, think about the data you might store about a person:


::: {.fragment .fade-up}
-  Age or weight will be a [**number**]{.hl-yellow}.

```{r}
age <- 33
```
:::

::: {.fragment .fade-up}
- Their name will be a string of [**text (known as string or char)**]{.hl-yellow}.

```{r}
name <- "javi"
```

:::

::: {.fragment .fade-up}
-   The answer to the question "Are you enrolled in the Faculty?" will be what we call a [**logical variable**]{.hl-yellow} (`TRUE` if enrolled or `FALSE` otherwise).


```{r}
enrolled <- TRUE
```
:::

::: {.fragment .fade-up}
-   Their date of birth will be precisely that, a [**date**]{.hl-yellow}.
:::

---

## Numerical variables {auto-animate="true"}

The simplest data (which we‚Äôve already used) will be [**numeric variables**]{.hl-yellow}. To find out the [**data class in R**]{.hl-yellow} of a variable, we use the `class()` function.


```{r}
#| eval: false
#| code-line-numbers: "1"
a <- 5
```

---

## Numerical variables {auto-animate="true"}

The simplest data type (we have already used it) will be the [**numeric variables**]{.hl-yellow}. To know the [**data class in R**]{.hl-yellow} of a variable we have the function `class()`.


```{r}
#| eval: false
#| code-line-numbers: "2"
a <- 5
class(a)
```

. . .

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

To know its [**typology (format)**]{.hl-yellow} variable we have `typeof()`.

```{r}
typeof(1) # 1 value but stored as a real number (double precision)
typeof(as.integer(1)) # 1 value but stored as a floor number
```

::: callout-note
## Note that...

In `R` we have a collection of functions starting with `as.x()` that serve as [**conversion functions**]{.hl-yellow}: a data that was of one type, we convert it to type `x`.
:::

---


## Numerical variables

In addition to the "common" numbers we will have the [**plus/minus infinity**]{.hl-yellow} coded as `Inf` or `-Inf`.

```{r}
1/0
```

```{r}
-1/0
```

. . .

And values that [**are not real numbers**]{.hl-yellow} _not a number_ (indeterminacies, complexes numbers, etc) encoded as `NaN`.

```{r}
0/0
```

```{r}
sqrt(-2)
```



---

## Numerical variables

With numeric variables we can perform the [**arithmetic operations**]{.hl-yellow} of a calculator: adding (`+`)...

```{r}
a + b
```

. . .

...square root (`sqrt()`)...

```{r}
sqrt(a)
```

. . .

... power (`^2`, `^3`)...

```{r}
a^2
```

. . .

...absolute value (`abs()`), etc.

```{r}
abs(a)
```


---

## String variables

Let us imagine that, in addition to the age of a person we want to store his/her name: now the variable will be of type `character`.

```{r}
name <- "Javi"
class(name)
```

. . .

The [**text strings**]{.hl-yellow} are a type with which we obviously [**cannot perform arithmetic operations**]{.hl-red} (other operations such as pasting or locating patterns can be performed).

```{r}
#| error: true
name + 1 # error when we try to sum 1 to a text
```

. . .

::: callout-warning
## Reminder

Text variables (character or string) are [** ALWAYS in quotes**]{.hl-orange}: `TRUE` (logical, binary value) is not the same as `"TRUE"` (text).

:::

---

## First function: paste

Como hemos comentado `R` llamaremos [**funci√≥n**]{.hl-yellow} a un trozo de [**c√≥digo encapsulado**]{.hl-yellow} bajo un nombre, y que depende de unos [**argumentos**]{.hl-yellow} de entrada. Nuestra primera funci√≥n ser√° `paste()`: dadas dos cadenas de texto nos permite pegarlas.

```{r}
paste("Javi", "√Ålvarez")
```

. . .

F√≠jate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos a√±adir un [**argumento opcional**]{.hl-yellow} para indicarle el separador (en `sep = ...`). 

```{r}
paste("Javi", "√Ålvarez", sep = "*")
```

---

## First function: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}
¬øC√≥mo saber [**qu√© argumentos necesita una funci√≥n**]{.hl-yellow}? Escribiendo en consola `? paste` te aparecer√° una [**ayuda**]{.hl-yellow} en el panel multiusos.

En dicha ayuda podr√°s ver en su cabecera que argumentos ya tiene [**asignados por defecto**]{.hl-yellow} la funci√≥n
:::
:::

. . .

Existe una funci√≥n similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).

```{r}
paste0("Javi", "√Ålvarez")
```

---

## First function: paste

Los argumentos (y su detalle) tambi√©n pueden ser consultado **tabulando (detras una coma)**.

![](img/tab-functions.png)

--- 

## Functions: default arguments

Es muy importante entender el concepto de [**argumento por defecto de una funci√≥n**]{.hl-yellow} en `R`: es un valor que la funci√≥n usa pero a veces podemos no ver porque [**ya tiene un valor asignado**]{.hl-yellow}. 

```{r}
# Same
paste("Javi", "√Ålvarez")
paste("Javi", "√Ålvarez", sep = " ")
```

. . .

::: callout-note

The `=` operator is [**reserved for assigning arguments**]{.hl-yellow} within functions. For all other assignments, we will use `<-`.

:::

---

## First package: glue

A more intuitive way to work with text is to use the `{glue}` package: the first thing to do is to "buy the book" (if we have never done it before). After that [**load the package**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue") # just the first time
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

With the `glue()` function of that package we can use [**variables inside strings**]{.hl-yellow}. For example, "age is ... years old", where the age is stored in a variable.

```{r}
age <- 34
glue("I am {age} old")
```

. . .

Within the keys we can also [**execute operations**]{.hl-yellow}

```{r}
units <- "days"
glue("I am {age * 365} {units} old")
```

---

## Logical variables

Another fundamental type will be the [**logical or binary variables**]{.hl-yellow} (**two values**):

- `TRUE`: [**true**]{.hl-yellow} stored internally as a 1.

- `FALSE`: [**false**]{.hl-yellow} stored internally as a 0.

```{r}
single <- FALSE # Single? --> NO
class(single)
```

. . .

Since they are stored internally as binary variables, we can [**perform arithmetic operations**]{.hl-yellow} on them


```{r}
2 * TRUE
FALSE - 1
```

---

## Logical variables

As we will see shortly, logical variables can actually take a third value: `NA` or [**missing data**]{.hl-yellow}, representing *not available*, and it will be very common to find it within a database.

```{r}
missing <- NA
missing + 1
```


. . .

::: callout-important
## Important

Logical variables [**NOT text variables**]{.hl-red}: `"TRUE"` is a text, `TRUE` is a logical value.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Logical conditions

Logical values are usually the result of [**evaluate logical conditions**]{.hl-yellow}. For example, imagine that we want to [**check**]{.hl-yellow} whether a person is named Javi.


```{r}
name <- "Mar√≠a"
```


. . .

With the [**logical operator**]{.hl-yellow} `==` we ask if what we have stored on the left is [**same as**]{.hl-purple} what we have on the right: [**we ASK**]{.hl-yellow}

```{r}
name == "Javi"
```

. . .

With its opposite `!=` we ask [**if different**]{.hl-purple}.

```{r}
name != "Javi"
```

. . .

::: callout-note
## Note that...

It is not the same `<-` ([**assignment**]{.hl-yellow}) as `==` (we are [**asking**]{.hl-yellow}, it is a logical comparison).

:::

---

## Logical conditions

In addition to "equal to" versus "different" comparisons, also order comparisons such as [**less than**]{.hl-purple} `<`, [**greater than**]{.hl-purple} `>`, `<=` or `>=`.
**Is the person less than 32 years old?**

```{r}
age <- 34
age < 32 # less than 32 years old?
```

. . .

**Age is greater than or equal to 38 years?**

```{r}
age >= 38
```

. . .

**Is the saved name equal to Javi?**

```{r}
name <- "Javi"
name == "Javi"
```

---

## Date variables

A very special data type: the [**date type data**]{.hl-yellow}.

```{r}
date_char <- "2021-04-21"
```

It looks like a simple text string but [**should represent an instant in time**]{.hl-yellow}. What should happen if [**we add a 1 to a date**]{.hl-purple}?
. . .

```{r}
#| error: true
date_char + 1
```


Dates [**cannot be string/text**]{.hl-red}: we must convert the text string to date.

. . .

&nbsp;

To work with dates we will use the `{lubridate}` package, which we must install before we can use it.

```{r}
#| eval: false
install.packages("lubridate")
```

---

## Date variables

Once installed, of all the packages (books) that we have, we will indicate it to load this one concretely.

```{r}
library(lubridate) 
```

. . .

To [**convert to date type**]{.hl-yellow} we will use the `as_date()` function of the `{lubridate}` package (default in `yyyy-mm-dd` format).


&nbsp;

:::: columns
::: {.column width="50%"}

```{r}
#| error: true

# it's not a date, it's a text!
date_char + 1
class(date_char)
```

:::

::: {.column width="50%"}

```{r}
date <- as_date("2023-03-28")
date + 1
class(date)
```

:::

::::

---

## Date variables

In `as_date()` the default date format is `yyyy-mm-dd` so if the string is not entered correctly...

```{r}
as_date("28-08-2024")
```

. . .

For [**any other format we must specify it**]{.hl-yellow} in the optional argument `format = ...` such that `%d` represents days, `%m` months, `%Y` in 4-year format and `%y` in 2-year format.


```{r}
as_date("28-03-2023", format = "%d-%m-%Y")
as_date("28-03-23", format = "%d-%m-%y")
as_date("03-28-2023", format = "%m-%d-%Y")
as_date("28/03/2023", format = "%d/%m/%Y")
```


---

## Date variables

In this package we have very useful functions for [**date management**]{.hl-yellow}:

- With `today()` we can directly obtain the [**current date**]{.hl-purple}.

```{r}
today()
```

. . .

-  With `now()` we can obtain [**current date and time**]{.hl-purple}

```{r}
now()
```

. . .

- With `year()`, `month()` or `day()` we can [**extract year, month and day**]{.hl-purple}

```{r}
date_today <- today()
year(date_today)
month(date_today)
```

---

## Cheatsheets

![](img/lubridate.png)

::: callout-note
## More information

You have a pdf summary of the most important packages in the [**corresponding folder on campus**]{.hl-green}

:::

---

## üíª It's your turn {#tu-turno-0-1-2}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

üìù Define a variable that stores your age (called `age`) and another with your name (called `name`).

```{r}
#| code-fold: true
age <- 34
name <- "Javi"
```

### [**Exercise 2**]{.hl-yellow}

üìù Check with this variable `age` if it is NOT 60 years old or if it is called `"Ornitorrinco"` (you must obtain logical variables as a result).

```{r}
#| code-fold: true
#| eval: false
age != 60 # different to
name == "Ornitorrinco" # equal to
```

### [**Exercise 3**]{.hl-yellow}

üìù Why does the lower code give an error?

```{r}
#| error: true
age + name
```


### [**Exercise 4**]{.hl-yellow}

üìù Define another variable called `siblings` that answers the question "do you have siblings?" and another variable that stores your date of birth (called `birth_date`).

```{r}
#| code-fold: true
siblings <- TRUE

library(lubridate) # if not before
birth_date <- as_date("1989-09-10")
```

### [**Exercise 5**]{.hl-yellow}

üìù Define another variable with your last name (called `surname`) and use `glue()` to have, in a single variable called `full_name`, your first and last name separated by a comma.

```{r}
#| code-fold: true
#| eval: false
surname <- "√Ålvarez Li√©bana"
full_name <- glue("{name}, {surname}")
full_name
```

### [**Exercise 6**]{.hl-yellow}

üìù From `birth_date` extract the month.

```{r}
#| code-fold: true
#| eval: false
month(birth_date)
```

### [**Exercise 7**]{.hl-yellow}

üìù Calculate the days that have passed since your birth date until today (with the birth date defined in Exercise 4).

```{r}
#| code-fold: true
#| eval: false
today() - birth_date
```
:::

# L2 : [databases]{.flow} {#clase-0-2}

[**Concatenating cells: vectors. First databases**]{style="color:#444442;"}

* [üíª Solved exercises: vectors](#tu-turno-0-2-1) 

* [üíª Solved exercises: matrix](#tu-turno-0-2-2) 

* [üíª Solved exercises: data.frame and tibble](#tu-turno-0-2-3) 

* [üê£ Workbook/case study I-II](#caso-practico-0-2-1)

* [üìÜ Planning](#planificacion)

---

## Vectors: concatenation

When working with data, we often have [**columns that represent variables**]{.hl-yellow}: we will refer to these as [**vectors**]{.hl-yellow}, which are a [**concatenation**]{.hl-purple} of cells (values) of the [**same type**]{.hl-purple} (similar to a column in a table).

. . .

The simplest way to create a vector is with the `c()` function (c stands for **concatenate**), and you just need to input the **elements within parentheses, separated by commas**.

```{r}
ages <- c(32, 27, 60, 61)
ages
```

. . .

::: callout-tip

An individual number `x <- 1` (or `x <- c(1)`) is actually a **vector of length one** --> everything we know how to [**do with a number, we can do with a vector of numbers**]{.hl-green}.

:::

---

## Vectors: concatenation

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}

As you can see now in the `environment`, we have a **collection of elements** stored.


```{r}
ages # ages = edades in spanish
```
:::
:::

. . .


The [**length of a vector**]{.hl-yellow} can be calculated with `length()`.


```{r}
length(ages)
```

. . .

We can also [**concatenate vectors**]{.hl-yellow} together (it repeats them one after another).

```{r}
c(ages, ages, 8)
```

---

## Numeric sequences

The most common type of vector is numeric, specifically, the well-known [**numeric sequences**]{.hl-yellow} (e.g., the days of the month), used among other things, to index loops.

. . .

The `seq(start, end)` function allows us to create a [**numeric sequence]**{.hl-yellow} from a starting element to an ending one, [**advancing one by one**]{.hl-purple}.


```{r}
seq(1, 31)
```

. . .

Note that if we try this with [**characters, it won't work**]{.hl-red} since there is no predefined order among text strings.

```{r}
#| error: true
"a":"z"
```

---

## Numeric sequences

A shortcut is the `1:n` command, which returns the same as `seq(1, n)`.


```{r}
1:7
```

If the starting element is greater than the ending one, it understands that the sequence is in [**descending order**]{.hl-purple}.

```{r}
7:-3
```

. . .

We can also define [**a different step**]{.hl-yellow} between consecutive elements with the `by = ...` argument.


```{r}
seq(1, 7, by = 0.5) # seq from 1 to 7, with a step of 0.5
```

---

## Numeric sequences

Sometimes we may want to define a [**sequence with a specific length**]{.hl-yellow}.


```{r}
seq(1, 50, l = 7) # seq from 1 to 50 with length equal to 7
```

. . .

We might also want to generate a vector of [**n repeated elements**]{.hl-yellow}.

```{r}
rep(0, 7) # vector of 7 0's
```

. . .

Since they are internally stored as numbers, we can also do this with [**dates**]{.hl-yellow}.


```{r}
seq(as_date("2023-09-01"), as_date("2023-09-10"), by = 1)
```


---

## String vectors

A vector is a **concatenation** of elements of the [**same type**]{.hl-yellow}, but they don't necessarily have to be numbers. Let's create a sample sentence.

```{r}
sentence <- "My name is Javi"
sentence
length(sentence)
```

. . .

In the previous case, it wasn't a vector, it was a single text element. To create a vector, we need to use `c()` again and separate elements with commas.


```{r}
sentence <- c("My", "name", "is", "Javi")
sentence
length(sentence)
```

---

## String vectors

What will happen if we [**concatenate elements of different types**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

Note that since all elements must be of the same type, what `R` does is [**convert**]{.hl-yellow} everything to text, violating the [**data integrity**]{.hl-red}.


. . .

```{r}
c(3, 4, TRUE, FALSE)
```

It's important to understand that logical values are actually [**internally stored as 0/1**]{.hl-yellow}.


---

## Operations with vectors

With numeric vectors, we can perform the same [**arithmetic operations**]{.hl-yellow} as with numbers ‚Üí a [**number is a vector**]{.hl-purple} (of length one).

. . .

What will happen if we [**add or subtract a value**]{.hl-yellow} to a vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Warning

Unless otherwise specified, in `R`,  vector operations are always [**element by element**]{.hl-orange}.

:::

---

## Adding vectors

Vectors can also interact with each other, so we can define, for example, [**vector sums**]{.hl-yellow} (element by element).


```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Since the operation (e.g., a sum) is performed element by element, what will happen if we [**add two vectors of different lengths**]{.hl-yellow}?

. . .


```{r}
z <- c(1, 3, 5, 7)
x + z
```

What it does is [**recycle elements**]{.hl-yellow}: if we have a vector of 4 elements and we add another with 3 elements, it will recycle the elements from the shorter vector.

---

## Comparing vectors

A very common operation is to [**ask questions of the data**]{.hl-yellow} using [**logical conditions**]{.hl-purple}. For example, if we define a vector of temperatures...

[**Which days were below 22 degrees?**]{.hl-yellow}


```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

This will return a [**logical vector**]{.hl-yellow}, depending on whether **each element** meets the given condition (of the **same length** as the vector being queried).

. . .

If we had a [**missing value**]{.hl-yellow} (due to a sensor error that day), the evaluated condition would also be `NA`.


```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Comparing vectors

[**Logical conditions can be combined**]{.hl-yellow} in two ways:

- [**Intersection**]{.hl-yellow}: [**all**]{.hl-purple} concatenated conditions must be met ([**AND conjunction**]{.hl-purple} with `&`) to return `TRUE`.


```{r}
x < 30 & x > 15
```

- [**Union**]{.hl-yellow}: it is enough for [**at least one**]{.hl-purple} condition to be met ([**OR conjunction**]{.hl-purple} with `|`).


```{r}
x < 30 | x > 15
```

. . .

With `any()` and `all()`, we can check if [**all elements**]{.hl-yellow} satisfy the condition.

```{r}
any(x < 30)
all(x < 30)
```

---

## Getting elements

Another common operation is [**accessing or getting elements**]{.hl-yellow}. The simplest way is to use the `[i]`  operator (access the i-th element).

```{r}
ages <- c(20, 30, 33, NA, 61) 
ages[3] # get the age's third person
```

. . .

Since a number is just a vector of length one, this operation can also be applied using a [**vector of indices to select**]{.hl-yellow}.

```{r}
y <- c("hi", "how", "are", "you", "?")
y[c(1:2, 4)] # first, second and fourth element
```

. . .

::: callout-tip

To access the last element without worrying about its position, you can pass the vector's length as the index `x[length(x)]`.

:::

---

## Removing elements

Sometimes, instead of selecting, we may want to [**remove elements**]{.hl-yellow}. This is done with the same operation but using [**negative indexing**]{.hl-purple}: the opetator `[-i]` ¬´un-select¬ª the i-th element 

```{r}
y
y[-2] # everything except the second element
```


. . .

In many cases, we want to [**select or remove elements based on logical conditions**]{.hl-yellow}, depending on the values, so we will pass the condition itself as the index (remember, `x < 2` returns a logical vector).


```{r}
ages <- c(15, 21, 30, 17, 45)
names <- c("javi", "mar√≠a", "sandra", "carla", "luis")
names[ages < 18] # names of people under 18
```

---


## Stats operations

We can also make use of [**statistical operations**]{.hl-yellow}, such as `sum()`, which, given a vector, returns the sum of all its elements.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**What happens when a data point is missing?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

By default, if we have a missing data point, the [**operation will also result in a missing value**]{.hl-yellow}. To [**ignore that missing data**]{.hl-purple}, we use the optional argument `na.rm = TRUE`.


```{r}
sum(x, na.rm = TRUE)
```

---

## Stats operations

As we've mentioned, logical values are internally stored as 0 and 1, so we can use them in arithmetic operations.

For example, if we want to [**find out the number of elements that meet a condition**]{.hl-yellow} (e.g., less than 3), those that do will be assigned a 1 (`TRUE`), and those that don't will get a 0 (`FALSE`). Therefore, summing the logical vector will give us the number of elements that meet the condition.


```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Stats operations

Another common operation that can be useful is the [**cumulative sum**]{.hl-yellow} with `cumsum()`, which, given a vector, returns a vector where each element is the sum of the first, the first plus the second, the first plus the second plus the third, and so on.

```{r}
x <- c(1, 5, 2, -1, 8)
cumsum(x)
```

[**What happens when a data point is missing?**]{.hl-yellow}


```{r}
x <- c(1, -2, 3, NA, -1)
cumsum(x)
```

In the case of the cumulative sum, what happens is that [**from that point onward, all subsequent accumulated values will be missing**]{.hl-yellow}.

---

## Stats operations

Another common operation that can be useful is the [**difference (with delay)**]{.hl-yellow} with `diff()` which, given a vector, returns a vector with the second minus the first, the third minus the second, the fourth minus the third...and so on.


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x)
```

. . .

Using the argument `lag = ` we can indicate the [**delay**]{.hl-yellow} of this difference (e.g. `lag = 3` implies that the fourth minus the first, the fifth minus the second, etc.).


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x, lag = 3)
```

---

## Stats operations

Other common operations are [**mean**]{.hl-yellow}, [**median**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

- [**mean**]{.hl-yellow}: centrality measure that consists of adding all the elements and dividing by the number of elements added. The best known but the [**least robust**]{.hl-red}: given a set, if outliers (very large or very small values) are introduced, the mean is very easily perturbed.


```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Stats operations

Other common operations are [**mean**]{.hl-yellow}, [**median**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.


-   [**Median**]{.hl-yellow}: measure of centrality that consists of ordering the elements and keeping the one that occupies the middle.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Quantiles**]{.hl-yellow}: position measurements (they divide the data into equal parts).

```{r}
quantile(x) # by default quantiles/percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

---


## Sorting vectors

Finally, a common action is to know [**sort values**]{.hl-yellow}:

- `sort()`: returns the [**sorted vector**]{.hl-yellow}. By default from smallest to largest but with `decreasing = TRUE` we can change it.


```{r}
ages <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(ages)
sort(ages, decreasing = TRUE)
```

. . .

-   `order()`: returns the [**index vector**]{.hl-yellow} that we would have to use to have the vector ordered

```{r}
order(ages)
ages[order(ages)]
```

---

## üíª It's your turn {#tu-turno-0-2-1}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

üìù Define the vector `x` as the concatenation of the first 5 odd numbers. Calculate the length of the vector

```{r}
#| code-fold: true
#| eval: false
# Two ways
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Exercise 2**]{.hl-yellow}

üìù Access the third element of `x`. Access the last element (regardless of length, a code that can always be executed). Delete the first element.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Exercise 3**]{.hl-yellow}

üìù Get the elements of `x` greater than 4. Calculate the vector `1/x` and store it in a variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Exercise 4**]{.hl-yellow}

üìù Create a vector representing the names of 5 people, one of whom is unknown.

```{r}
#| code-fold: true
#| eval: false
names <- c("Javi", "Sandra", NA, "Laura", "Carlos")
names
```

### [**Exercise 5**]{.hl-yellow}

üìù Find from the vector `x` of exercises above the elements greater (strictly) than 1 and less (strictly) than 7. Find a way to find out if all the elements are positive or not.


```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Exercise 6**]{.hl-yellow}

üìù Given the vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, why does its mean return not a number but what is shown in the code below?

```{r}
x <- c(1, -5, 8, NA, 10, -3, 9)
mean(x)
```

### [**Exercise 7**]{.hl-yellow}

üìù Given the vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extract the elements occupying the locations 1, 2, 5, 6. 

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
x[-2]
```

### [**Exercise 8**]{.hl-yellow}

üìù Given the `x` vector of the previous exercise, which ones have a missing data? Hint: the `is.something()` functions check if the element is of type `something` (press tab).


```{r}
#| code-fold: true
#| eval: false
is.na(x)
```


### [**Exercise 9**]{.hl-yellow}

üìù Define the vector `x` as the concatenation of the first 4 even numbers. Calculate the number of elements of `x` strictly less than 5.

```{r}
#| code-fold: true
#| eval: false
x[x < 5] 
sum(x < 5)
```


### [**Exercise 10**]{.hl-yellow}

üìù Calculate the vector `1/x` and obtain the ordered version (from smallest to largest) in the two possible ways

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Exercise 11**]{.hl-yellow}

üìù Calculate min and max of previous `x` vector

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Exercise 12**]{.hl-yellow}

üìù Find of the vector `x` the elements greater (strictly) than 1 and less (strictly) than 6. Find a way to find out if all the elements are negative or not.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

:::


---

## More with string variables

Although we cannot do arithmetic operations with them, some [**operations we can do with the text strings**]{.hl-yellow} will be important.

For that we will use in the future the `{stringr}` package (within the same `{lubridate}` "universe of packages", which we will talk about later).

```{r}
library(stringr)

# Find a correct phone format
phone_number <- c("611093", "292039", "628810585", "600917043")
str_detect(phone_number, pattern = "[6]{1}[0-9]{8}")
```

---

## First databases

When analyzing data we usually have [**several variables**]{.hl-yellow} for each individual: we need a "table" to collect them. The most immediate option is [**matrices**]{.hl-yellow}: concatenation of variables of [**same type and equal length**]{.hl-purple}.

Imagine we have heights and weights of 4 people. How to [**create a dataset with the two variables**]{.hl-yellow}?

. . .

The most common option is to use `cbind()`: [**concatenate (bind) vectors in the form of columns (c)**]{.hl-yellow}

```{r}
#| code-line-numbers: "3"
h <- c(150, 160, 170, 180)
w <- c(63, 70, 85, 95)
data_mat <- cbind(h, w)
data_mat 
```

---

## First databases

We can also [**build the matrix by rows**]{.hl-yellow} with the `rbind()` function (concatenate - bind - by rows - r), although it is [**recommended to have each variable in column**]{.hl-green} and individual in row as we will see later.

```{r}
rbind(h, w) # Matrix by rows
```

. . .

- We can [**"view" the matrix**]{.hl-yellow} with `View(matrix)`.

. . .

-   We can [**check dimensions**]{.hl-yellow} with `dim()`, `nrow()` and `ncol()`: matrices are a type of **tabular data** (organized in rows and columns).

```{r}
dim(data_mat)
nrow(data_mat)
ncol(data_mat)
```

---

## First databases

We can also [**"flip" (transposed matrix)**]{.hl-yellow} with `t()`.

```{r}
t(data_mat)
```

. . .
Since we now have two dimensions in our data, to [**access elements with `[]`**]{.hl-yellow} we must provide **two comma-separated indexes**: row and column indexes 

```{r}
data_mat[2, 1] # second row, first column
data_mat[1, 2] # first fila, second column
```

---

## First databases

In some cases we will want to get the [**total data for an individual**]{.hl-yellow} (a particular row but all columns) or the values of [**a whole variable**]{.hl-yellow} for all individuals (a particular column but all rows). To do so, we leave [**one of the indexes**]{.hl-yellow} unfilled.

```{r}
data_mat[2, ] # second individual
data_mat[, 1] # first variable
```

. . .

Much of what we have learned with vectors we can do with matrices, so we can for example access multiple rows and/or columns using the [**sequences of integers 1:n**]{.hl-yellow}


```{r}
data_mat[c(1, 3), 1] # first variable for first and third individual
```


---

## First databases

We can also define a [**matrix from a numeric vector**]{.hl-yellow}, rearranging the values in the form of a matrix (knowing that the elements are [**placed by columns**]{.hl-purple}).

```{r}
z <- matrix(1:9, ncol = 3) 
z
```

. . .

We can even [**define an array of constant values**]{.hl-yellow}, e.g. of zeros (to be filled later)


```{r}
matrix(0, nrow = 2, ncol = 3)
```


---

## Matrix operations

With matrices it is the same as with vectors: when we apply an [**arithmetic operation we do it element by element**]{.hl-yellow}

```{r}
z/5
```

. . .

To perform [**operations in a matrix sense**]{.hl-yellow} we must add `%%%`, for example, to multiply matrices it will be `%*%`.

```{r}
z * t(z)
z %*% t(z)
```


---

## Matrix operations

We can also [**perform operations by columns/rows**]{.hl-yellow} without loops with the `apply()` function, and we will indicate as **arguments**

- the matrix
- the sense of the operation (`MARGIN = 1` for rows, `MARGIN = 2` for columns)
- the function to apply
- extra arguments needed by the function

. . .

For example, to apply an average to each variable, it will be `mean` applied with `MARGIN = 2` (same function for each column).

```{r}
# Mean for each column (MARGIN = 2)
apply(data_mat, MARGIN = 2, FUN = "mean")
```



---

## üíª It's your turn {#tu-turno-0-2-2}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset

### [**Exercise 1**]{.hl-yellow}

üìù Modify the code below to define an `x` matrix of ones, with 3 rows and 7 columns.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Exercise 2**]{.hl-yellow}

üìù To the above matrix, add 1 to each number in the matrix and divide the result by 5. Then calculate its transpose

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
```

### [**Exercise 3**]{.hl-yellow}

üìù Why does the code below return such a warning message?

```{r}
#| warning: TRUE
matrix(1:15, nrow = 4)
```



### [**Exercise 4**]{.hl-yellow}

üìù Define the matrix `x <- matrix(1:12, nrow = 4)`. Then get the data of the first individual, the data of the third variable, and the element `(4, 1)`.

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # first row
x[, 3] # third column
x[4, 1] # (4, 1) element
```

### [**Exercise 5**]{.hl-yellow}

üìù Define a matrix of 2 variables and 3 individuals such that each variable captures the height and age of 3 persons, so that the age of the second person is unknown (absent). Then calculate the mean of each variable (we should get a number!).

```{r}
#| code-fold: true
#| eval: false
data <- cbind("age" = c(20, NA, 25), "h" = c(160, 165, 170))
apply(data, MARGIN = 2, FUN = "mean", na.rm = TRUE) # mean by columns

```

### [**Exercise 6**]{.hl-yellow}

üìù Why does the lower code return an error? What is wrong?

```{r}
#| error: true
mat <- cbind("age" = c(15, 20, 25), "names" = c("javi", "sandra", "carlos"))
mat
mat + 1
```

:::

---

## Second attempt: data.frame

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte (f√≠jate en el c√≥digo inferior: las edades y los `TRUE/FALSE` los ha convertido a texto)

```{r}
#| code-line-numbers: "4-5"
edades <- c(14, 24, NA)
soltero <- c(TRUE, NA, FALSE)
nombres <- c("javi", "laura", "luc√≠a")
matriz <- cbind(edades, soltero, nombres)
matriz
```

. . .

De hecho al no ser n√∫meros ya no podemos realizar operaciones aritm√©ticas

```{r}
#| error: true
matriz + 1
```

---

## Second attempt: data.frame

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos en `R` lo que se conoce como [**data.frame**]{.hl-yellow}: concatenaci√≥n de variables de igual longitud pero que pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
tabla <- data.frame(edades, soltero, nombres)
class(tabla)
tabla
```

---

## Second attempt: data.frame

Dado que un `data.frame` es ya un intento de ¬´base de datos¬ª las variables no son meros vectores matem√°ticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple} que describan su significado

```{r}
library(lubridate)
tabla <-
  data.frame("edad" = edades, "estado" = soltero, "nombre" = nombres,
             "f_nacimiento" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
tabla
```

---

## Second attempt: data.frame

[**¬°TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} (estrictamente no podemos hablar de base de datos pero de momento como lo si fuesen). Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

![](img/view_tabla.jpg)

---

## Get variables

Si queremos acceder a sus elementos, al ser de nuevo **datos tabulados**, podemos acceder como en las matrices ([**no recomendable**]{.hl-red}): de nuevo [**tenemos dos √≠ndices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera caracter√≠stica de la segunda persona
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
Pero tambi√©n tiene las ventajas de una [**¬´base¬ª de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} ([**lo recomendable**]{.hl-green} ya que las variables pueden cambiar de posici√≥n y ahora s√≠ tienen un significado), poniendo el nombre de la tabla seguido del s√≠mbolo `$` (con el **tabulador**, nos aparecer√° un men√∫ de columnas a elegir)
:::
:::

---

## Ask functions

-   `names()`: nos muestra los nombres de las variables

```{r}
names(tabla)
```

. . .

-   `dim()`: nos muestra las dimensiones (tambi√©n `nrow()` y `ncol()`)

```{r}
dim(tabla)
```

. . .

-   Podemos acceder a las variables por su nombre

```{r}
tabla[c(1, 3), "nombre"]
tabla$nombre[c(1, 3)]
```

---

## Add a variable

Si tenemos uno ya creado y queremos [**a√±adir una columna**]{.hl-yellow} es tan simple como usar la funci√≥n `data.frame()` que ya hemos visto para concatenar la columna. Vamos a√±adir por ejemplo una nueva variable, el n√∫mero de hermanos de cada individuo.

```{r}
# A√±adimos una nueva columna con n¬∫ de hermanos/as
hermanos <- c(0, 2, 3)
tabla <- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

---

## Last attempt: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}. La principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```

. . .


En adelante usaremos el formato `tibble` ([**data.frame mejorado**]{.hl-yellow}) del paquete `{tibble}`

```{r}
library(tibble)
datos_tb <- 
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
class(datos_tb)
datos_tb
```

---

## Last attempt: tibble

```{r}
datos_tb <-
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
datos_tb
```

Las tablas en formato `tibble` nos permitir√° una [**gesti√≥n m√°s √°gil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

-   [**Metainformaci√≥n**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya autom√°ticamente el n√∫mero de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

---

## Last attempt: tibble

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
datos_tb$invent
```

. . .

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de p√°ginas web y documentos sencillos
:::


---


## In summary...

-   Cada [**celda puede ser de un tipo diverso**]{.hl-yellow}: n√∫meros, texto, fechas, valores l√≥gicos, etc

. . .

-   Un [**vector es una concatenaci√≥n de celdas**]{.hl-yellow} (las futuras columnas de nuestras tablas) --> En `R` por defecto las operaciones se hacen [**elemento a elemento**]{.hl-yellow}

. . .

-   Una [**matriz**]{.hl-yellow} nos permite concatenar [**variables del MISMO tipo y MISMA longitud**]{.hl-yellow} --> datos tabulados

. . .

-   Un [**data.frame**]{.hl-yellow} nos permite concatenar [**variables de DISTINTO tipo y MISMA longitud**]{.hl-yellow} --> usaremos [**tibble**]{.hl-yellow} como una opci√≥n mejorada de base de datos

---

## üíª It's your turn {#tu-turno-0-2-3}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset

### [**Exercise 1**]{.hl-yellow}

üìù Load from the `{datasets}` package the `airquality` dataset (New York air quality variables from May through September 1973). Is the airquality dataset of type tibble? If not, convert it to tibble (look in the package documentation at <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Exercise 2**]{.hl-yellow}

üìù Once converted to `tibble` get the name of the variables and the dimensions of the data set. How many variables are there? How many days have been measured?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```


### [**Exercise 3**]{.hl-yellow}

üìù Filters only the data of the fifth observation

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, ]
```

### [**Exercise 4**]{.hl-yellow}

üìù Filter only the data for the month of August. How to tell it that we want only the rows that meet a specific condition?

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, ]
```

### [**Exercise 5**]{.hl-yellow}

üìù Select those data that are not from July or August.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month != 7 & Month != 8, ]
airquality_tb[!(Month %in% c(7, 8)), ]
```

### [**Exercise 6**]{.hl-yellow}

üìù Modify the following code to keep only the ozone and temperature variables (no matter what position they are).

```{r}
#| eval: false
airquality_tb[, 3]
```

### [**Exercise 7**]{.hl-yellow}

üìù Select the temperature and wind data for August. 

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, c("Temp", "Wind")]
```

### [**Exercise 8**]{.hl-yellow}

üìù Translate the name of the variables into your native language.


```{r}
#| code-fold: true
#| eval: false
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```

:::


---

## üê£ Case study I {#caso-practico-0-2-1}

En el paquete `{datasets}` (ya instalado por defecto) tenemos diversos conjuntos de datos y uno de ellos es `airquality`. Debajo te he extra√≠do 3 variables de dicho dataset (f√≠jate que se hace con `datos$variable`, ese dolar ser√° importante en el futuro).

Los datos capturan [**medidas diarias (n = 153 observaciones) de la calidad del aire**]{.hl-yellow} en Nueva York, de mayo a septiembre de 1973. Se midieron **6 variables**: niveles de ozono, radiaci√≥n solar, viento, temperatura, mes y d√≠a.

```{r}
library(datasets)
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/intro-r-base/)



---

## üê£ Case study II {#caso-practico-0-2-2}

Del paquete `{Biostatistics}` usaremos el conunto de datos `pinniped`, que guarda los **datos de peso de cuerpo y cerebro** (desagregado por sexo y mono/poligamia) de 33 especies de mam√≠feros marinos.


```{r}
Biostatistics::pinniped
```


Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/textos-primeras-bbdd/)



# L3: [functions, flow and Quarto]{.flow} {#clase-0-3}

[**Flow structures: if-else and loops. Functions in R. Quarto**]{style="color:#444442;"}

* [üíª Solved exercises: if-else](#tu-turno-0-3-1) 

* [üíª Solved exercises: loops](#tu-turno-0-3-2)

* [üíª Solved exercises: functions](#tu-turno-0-3-3)

* [üê£ Workbook/case study I-II-III](#caso-practico-0-3-1)

* [üìÜ Planning](#planificacion)

---

## Flow structures

A [**flow or control structure**]{.hl-yellow} consists of a series of commands oriented to [**decide the path**]{.hl-yellow} that your code must follow

* If condition A is met, what happens?

* What if B happens?

* How can I repeat the same expression (depending on a variable)?

. . .

If you have programmed before, you may be familiar with what are known as [**conditional structures**]{.hl-yellow} such as `if (bla bla) {...} else {...}` or [**loops**]{.hl-yellow} `for/while` (to be avoided whenever possible).

---

## If

One of the most famous control structures are those known as [**conditional structures**]{.hl-yellow} `if`.

> IF a set of conditions is met (TRUE), then execute whatever is inside the curly brackets.


For example, the structure `if (x == 1) { code A }` what it will do is [**execute code A in braces**]{.hl-yellow} but [**ONLY IF**]{.hl-purple} the [**condition in brackets is true**]{.hl-purple} (only if `x` is 1). In any other case, it will do nothing

. . .

For example, let's define a vector of ages of 8 people


```{r}
ages <- c(14, 17, 24, 56, 31, 20, 87, 73)
ages < 18
```

---

## If


Our conditional structure will do the following: [**if there is a minor, it will print**]{.hl-yellow} a message.

```{r}
if (any(ages < 18)) { 
  
  print("There is a minor")
  
}
```

---

## If

```{r}
#| eval: false
if (any(ages < 18)) { 
  
  print("There is a minor")
  
}
```


In case the [**conditions are not true**]{.hl-yellow} inside `if()` (`FALSE`), nothing happens.


```{r}
if (all(ages >= 18)) { 
  
  print("All of them are of legal age")
  
}
```

**We get no message** because the condition `all(ages >= 18)` is not `TRUE`, so it does not execute anything.

---

## If-else

The structure `if (condition) { code A }` can be combined with an `else { code B }`: when the [**condition is not checked**]{.hl-yellow}, it will [**execute the alternative code B**]{. hl-yellow} inside `else { }`, allowing us to decide what happens when it is satisfied and when it is not

. . .

For example, `if (x == 1) { code A } else { code B }` will execute A if `x` is equal to 1 and B in any other case.

```{r}
if (all(ages >= 18)) { 
  
  print("All of them are of legal age")
  
} else {
  
  print("There is a minor")
}
```

---

## If-else

Esta estructura `if - else` puede ser [**anidada**]{.hl-yellow}: imagina que queremos ejecutar un c√≥digo si todos son menores; si no sucede, pero todos son mayores de 16, hacer otra cosa; en cualquier otra cosa, otra acci√≥n.

```{r}
if (all(ages >= 18)) { 
  
  print("All of them are of legal age")
  
} else if (all(ages >= 16)) {
  
  print("There is a minor but all of them are greater or equal to 16 years old")
  
} else { print("There are any persons under 16 years of age") }
```

::: callout-note
## Tip

You can **collapse the structures** by clicking on the left arrow in your script.

:::


---

## If-else vectorized


This conditional structure can be [**vectorized**]{.hl-yellow} (in a single line) with `if_else()` (from the `{dplyr}` package), whose arguments are

* the condition to evaluate

* what happens when it is met and when not

* an optional argument for when the condition to evaluate is `NA`

We will label without are greater/lesser and an `unknown` when we don't know.

```{r}
library(dplyr)
ages <- c(NA, ages)
if_else(ages >= 18, "legal age", "minor", missing = "unknown")
```

In `R` base there is `ifelse()`: it does not let you specify what to do with the absent ones but allows you to specify different types of data in `TRUE` and `FALSE`.

---

## üíª It's your turn {#tu-turno-0-3-1}


[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset

### [**Exercise 1**]{.hl-yellow}

üìù What will be the output of the following code?

```{r}
#| eval: false
if_else(sqrt(9) < 2, sqrt(9), 0)
```

```{r}
#| eval: false
#| code-fold: true

The output is 0 since sqrt(9) equals 3, and since it is not less than 2, it returns the second argument which is 0.
```

### [**Exercise 2**]{.hl-yellow}

üìù What will be the output of the following code?

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true

The output is the vector c(0, NA, NA, 1) since sqrt(1) is less than 2, sqrt(9) is not, and in the case of both sqrt(NA) (root of absent) and sqrt(-1) (returns NaN, not a number), its square root cannot be checked whether it is less than 2 or not, so the output is NA.
```


### [**Exercise 3**]{.hl-yellow}

üìù Modify the code below so that, when the square root of a number cannot be verified to be less than 2, it returns -1.

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1, missing = -1)
```


### [**Exercise 4**]{.hl-yellow}

üìù What are the values of `x` and `y` of the lower code for `z <- 1`, `z <- -1` and `z <- -5`?

```{r}
#| eval: false
z <- -1
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
In the first case x = 1 and y = -1. In the second case x = 1 and y = 1. In the third case -1 and 2.
```


### [**Exercise 5**]{.hl-yellow}

üìù What will happen if we execute the code below?

```{r}
#| eval: false
z <- "a"
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| code-fold: true
#| eval: false

# will give error since it is not a numeric argument
Error in z^3 : non-numeric argument to binary operator
```


### [**Exercise 6**]{.hl-yellow}

üìù From the `{lubridate}` package, the `hour()` function returns the time of a given date, and the `now()` function returns the date and time of the current time. With both functions, have `cat()` (`cat()`) print ‚Äúgood night‚Äù only after 21:00.

```{r}
#| code-fold: true
#| eval: false

# loading library
library(lubridate)

# Current date-time
current_dt <- now()

# If structure
if (hour(current_dt) > 21) {
  
  cat("Good night") # print or cat (two ways of printing)
}
```


:::

---

## Loops

Aunque en la mayor√≠a de ocasiones se pueden reemplazar por otras estructuras m√°s eficientes y legibles, es importante conocer una de las expresiones de control m√°s famosas: los [**bucles**]{.hl-yellow}.

* `for { }`: permite [**repetir el mismo c√≥digo**]{.hl-yellow} en un [**n√∫mero prefijado y conocido**]{.hl-purple} de veces.

* `while { }`: permite [**repetir el mismo c√≥digo**]{.hl-yellow} pero en un [**n√∫mero indeterminado de veces**]{.hl-purple} (hasta que una **condici√≥n** deje de cumplirse).

---

## For loop {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de √≥rdenes un n√∫mero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de √≠ndices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vac√≠a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los par√©ntesis indicaremos un √≠ndice y unos valores a recorrer, dentro de las llaves el c√≥digo a ejecutar en cada iteraci√≥n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()
```

---

## For loop {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de √≥rdenes un n√∫mero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de √≠ndices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vac√≠a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los par√©ntesis indicaremos un √≠ndice y unos valores a recorrer, dentro de las llaves el c√≥digo a ejecutar en cada iteraci√≥n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  
}
```

---

## For loop {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de √≥rdenes un n√∫mero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de √≠ndices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vac√≠a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los par√©ntesis indicaremos un √≠ndice y unos valores a recorrer, dentro de las llaves el c√≥digo a ejecutar en cada iteraci√≥n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
```

---

## For loop

F√≠jate que debido a que `R` funciona de manera [**vectorial por defecto**]{.hl-yellow}, el bucle es lo mismo que hacer `x + 1` directamente.

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
y

y2 <- x + 1
y2
```

---

## For loop

Otra opci√≥n habitual es indicar los √≠ndices de manera ¬´autom√°tica¬ª: desde el primero `1` hasta el √∫ltimo (que corresponde con la longitud de x `length(x)`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:length(x)) {
  y[i] <- x[i] + 1
}
y

```


---

## For loop

As√≠ la [**estructura general de un bucle for**]{.hl-yellow} ser√° siempre la siguiente

```{r}
#| eval: false
for (√≠ndice in conjunto) { 
  c√≥digo (dependiente de i)
}
```

[**SIEMPRE**]{.hl-green} sabemos cu√°ntas iteraciones tenemos (tantas como elementos haya en el conjunto a indexar)

---

## Avoiding loop


Como ya hemos aprendido con el paquete`{microbenchmark}` podemos chequear como [**los bucles suelen ser muy ineficientes**]{.hl-yellow} (de ah√≠ que debamos evitarlos en la mayor√≠a de ocasiones

```{r}
library(microbenchmark)
x <- 1:1000
microbenchmark(y <- x^2, 
               for (i in 1:100) { y[i] <- x[i]^2 },
               times = 500)
```

---
 
## For loop


Podemos ver otro ejemplo de bucle  [**combinando n√∫meros y textos**]{.hl-yellow}: definimos un vector de edades y de nombres, e imprimimos el nombre y edad i-√©sima.

```{r}
nombres <- c("Javi", "Sandra", "Carlos", "Marcos", "Marta")
edades <- c(33, 27, 18, 43, 29)

for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} a√±os")) 
  
}
```


---

## For loop

Aunque normalmente se suelen indexar con vectors num√©ricos, los bucles pueden ser [**indexados sobre cualquier estructura vectorial**]{.hl-yellow}, da igual de que tipo sea el conjunto

```{r}
library(stringr)
week_days <- c("monday", "tuesday", "wednesday", "thursday",
               "friday", "saturday", "sunday")

for (days in week_days) {
  
  print(str_to_upper(days))
}
```

---

## Bucles y condicionales

Vamos a **combinar las estructuras condicionales y los bucles**: usando el conjunto `swiss` del paquete `{datasets}`, vamos a asignar `NA`  si los valores de fertilidad son mayores de 80.

```{r}
for (i in 1:nrow(swiss)) {
  
  if (swiss$Fertility[i] > 80) { 
    
    swiss$Fertility[i] <- NA
    
  }
}
```

. . .

Esto es exactamente igual a un `if_else()` vectorizado

```{r}
data("swiss")
swiss$Fertility <- if_else(swiss$Fertility > 80, NA, swiss$Fertility)
```


---

## Bucles while

Otra forma de crear un bucle es con la estructura `while { }`, que nos ejecutar√° un bucle [**un n√∫mero desconocido de veces**]{.hl-yellow}, hasta que una condici√≥n [**deje de cumplirse**]{.hl-yellow} (de hecho puede que nunca termine). Por ejemplo, vamos a inializar una variable `ciclos <- 1`, que incrementaremos en cada paso, y no saldremos del bucle hasta que `ciclos > 4`.

```{r}
ciclos <- 1
while(ciclos <= 4) {
  
  print(glue("No todav√≠a, vamos por el ciclo {ciclos}")) 
  ciclos <- ciclos + 1
  
}
```

---

## Bucles while

Un bucle `while` ser√° siempre como sigue

```{r}
#| eval: false
while(condici√≥n) {
  
  c√≥digo a hacer mientras la condici√≥n sea TRUE
  # normalmente aqu√≠ se actualiza alguna variable
  
}
```

---
  
## Bucles while

¬øQu√© sucede cuando la [**condici√≥n nunca es FALSE**]{.hl-yellow}? Pru√©balo tu mismo

```{r}
#| eval: false
while (1 > 0) {
  
  print("Presiona ESC para salir del bucle")
  
}
```

&nbsp;

::: callout-warning
## Cuidado

Un bucle `while { }` puede ser bastante ¬´peligroso¬ª sino controlamos bien c√≥mo pararlo.

:::

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `break`: permite [**abortar un bucle**]{.hl-yellow} incluso si no se ha llegado a su final

```{r}
for(i in 1:10) {
  if (i == 3) {
    
    break # si i = 3, abortamos bucle
    
  }
  print(i)
}
```

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `next`: [**fuerza un bucle a avanzar a la siguiente iteraci√≥n**]{.hl-yellow} 

```{r}
for(i in 1:5) {
  if (i == 3) {
    
    next # si i = 3, la obvia y continua al siguiente
    
  }
  print(i)
}
```


---


## üíª It's your turn {#tu-turno-0-3-2}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}


::: panel-tabset

### [**Exercise 1**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para que se imprima un mensaje por pantalla si y solo si todos los datos de `airquality` son con mes distinto a enero

```{r}
#| eval: false
library(datasets)
months <- airquality$Month

if (months == 2) {
  print("No hay datos de enero")
}
```

```{r}
#| code-fold: true
#| eval: false
library(datasets)
months <- airquality$Month

if (all(months != 1)) {
  print("No hay datos de enero")
}
```


### [**Exercise 2**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para guardar en una variable llamada `temp_alta` un `TRUE` si alguno de los registros tiene una temperatura superior a 90 grados Farenheit y `FALSE` en cualquier otro caso
 
```{r}
#| eval: false
temp <- airquality$Temp

if (temp == 100) {
  print("Algunos de los registros tienen temperaturas superiores a 90 grados Farenheit")
}
```

 
```{r}
#| eval: false
#| code-fold: true
# Option 1
temp <- airquality$Temp
temp_alta <- FALSE
if (any(temp > 90)) {
   temp_alta <- TRUE
}

# Option 2
temp_alta <- any(airquality$Temp > 90)
```

### [**Exercise 3**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para dise√±ar un bucle `for` de 5 iteraciones que solo recorra los primeros 5 impares (y en cada paso del bucle los imprima)

```{r}
#| eval: false
for (i in 1:5) {
  
  print(i)
}
```

```{r}
#| eval: false
#| code-fold: true
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i)
}
```

### [**Exercise 4**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para dise√±ar un bucle `while` que empiece con un contador `count <- 1` y pare cuando llegue a 6

```{r}
#| eval: false
count <- 1
while (count == 2) {
  
  print(count)
}
```

```{r}
#| eval: false
#| code-fold: true
count <- 1
while (count < 6) {
  
  print(count)
  count <- count + 1
  
}
```


:::


---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, adem√°s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¬øC√≥mo [**crear nuestra propia funci√≥n**]{.hl-purple}? Veamos su **esquema b√°sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extra√±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funci√≥n dentro de `{ }`.

* Finalizamos la funci√≥n con los [**argumentos de salida**]{.hl-yellow} con `return()`.



```{r}
#| eval: false
name_fun <- function() {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, adem√°s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¬øC√≥mo [**crear nuestra propia funci√≥n**]{.hl-purple}? Veamos su **esquema b√°sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extra√±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funci√≥n dentro de `{ }`.

* Finalizamos la funci√≥n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, adem√°s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¬øC√≥mo [**crear nuestra propia funci√≥n**]{.hl-purple}? Veamos su **esquema b√°sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extra√±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funci√≥n dentro de `{ }`.

* Finalizamos la funci√≥n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  c√≥digo a ejecutar
  
}
```

---


## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, adem√°s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¬øC√≥mo [**crear nuestra propia funci√≥n**]{.hl-purple}? Veamos su **esquema b√°sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extra√±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funci√≥n dentro de `{ }`.

* Finalizamos la funci√≥n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  c√≥digo a ejecutar
  
  return(var_salida)
  
}
```


---

## Creando funciones

* `arg1, arg2, ...`: ser√°n los [**argumentos de entrada**]{.hl-yellow}, los argumentos que toma la funci√≥n para ejecutar el c√≥digo que tiene dentro

* `c√≥digo`: l√≠neas de c√≥digo que queramos que [**ejecute la funci√≥n**]{.hl-yellow}. 

* `return(var_salida)`: se introducir√°n los [**argumentos de salida**]{.hl-yellow}.


```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # C√≥digo que queramos ejecutar
  c√≥digo
  
  # Salida
  return(var_salida)
  
}
```

::: callout-important
## Importante

Todas las variables que definamos dentro de la funci√≥n son [**variables LOCALES: solo existir√°n dentro de la funci√≥n**]{.hl-yellow} salvo que especifiquemos lo contrario.

:::

---

## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funci√≥n para [**calcular el √°rea de un rect√°ngulo**]{.hl-yellow}.

Dado que el √°rea de un rect√°ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos ser√°n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} ser√° justo su **√°rea** ($lado_1 * lado_2$).

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
}
```

---


## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funci√≥n para [**calcular el √°rea de un rect√°ngulo**]{.hl-yellow}.

Dado que el √°rea de un rect√°ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos ser√°n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} ser√° justo su **√°rea** ($lado_1 * lado_2$).

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  
}
```

---


## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funci√≥n para [**calcular el √°rea de un rect√°ngulo**]{.hl-yellow}.

Dado que el √°rea de un rect√°ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos ser√°n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} ser√° justo su **√°rea** ($lado_1 * lado_2$).

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  return(area)
  
}
```

---

## Uso de funciones

Tambi√©n podemos hacer una definici√≥n directa de las variables **sin almacenar por el camino**.

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  return(lado_1 * lado_2)
  
}
```

. . .

[**¬øC√≥mo aplicar la funci√≥n?**]{.hl-yellow}

```{r}
calcular_area(5, 3) # √°rea de un rect√°ngulo 5 x 3 
calcular_area(1, 5) # √°rea de un rect√°ngulo 1 x 5
```

---

## Uso de funciones

::: callout-tip

Aunque no sea necesario, es [**recomendable hacer expl√≠cita la llamada de los argumentos**]{.hl-green}, especificando en el c√≥digo qu√© valor es para cada argumento para que no dependa de su orden, haciendo el c√≥digo m√°s legible
:::


```{r}
calcular_area(lado_1 = 5, lado_2 = 3) # √°rea de un rect√°ngulo 5 x 3 
calcular_area(lado_2 = 3, lado_1 = 5) # √°rea de un rect√°ngulo 5 x 3 
```

---

## Argumentos por defecto

Imagina ahora que nos damos cuenta que el 90% de las veces usamos dicha funci√≥n para [**calcular por defecto el √°rea de un cuadrado**]{.hl-yellow} (es decir, solo necesitamos un lado). Para ello, podemos definir [**argumentos por defecto**]{.hl-yellow} en la funci√≥n: tomar√°n dicho valor salvo que le asignemos otro.

¬øPor qu√© no asignar `lado_2 = lado_1` **por defecto**, para ahorrar l√≠neas de c√≥digo y tiempo?

. . .

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

---

## Argumentos por defecto


```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```


Ahora [**por defecto**]{.hl-yellow} el segundo lado ser√° igual al primero (si se lo a√±adimos usar√° ambos).


```{r}
calcular_area(lado_1 = 5) # cuadrado
calcular_area(lado_1 = 5, lado_2 = 7) # rect√°ngulo
```

---
 

## Salida m√∫ltiple

Compliquemos un poco la funci√≥n y a√±adamos en la salida los valores de cada lado, etiquetados como `lado_1` y `lado_2`, [**empaquetando la salida en una vector**]{.hl-yellow}.

```{r}
#| code-line-numbers: "7-8"
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

---

## Salida m√∫ltiple

Podemos complicar un poco m√°s la salida a√±adiendo una cuarta variable que nos diga, en funci√≥n de los argumentos, [**si rect√°ngulo o cuadrado**]{.hl-yellow}, teniendo que a√±adir en la salida una variable que de tipo caracter (o l√≥gica).

```{r}
#| code-line-numbers: "7-9"
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rect√°ngulo")))
  
}
calcular_area(5, 3)
```

. . .

[**Problema**]{.hl-red}: al intentar juntar n√∫meros y texto, lo convierte todo a n√∫meros. Podr√≠amos guardarlo todo en un `tibble()` como hemos aprendido o en un objeto conocido en `R` como [**listas**]{.hl-yellow} (lo veremos m√°s adelante)


---

## Orden de los argumentos

Antes nos daba igual el orden de los argumentos pero ahora el [**orden de los argumentos de entrada importa**]{.hl-yellow}, ya que en la salida incluimos `lado_1` y `lado_2`. 

. . .

::: callout-note
## Recomendaci√≥n

Como se comentaba, altamente recomendable hacer la llamada a la funci√≥n [**indicando expl√≠citamente los argumentos**]{.hl-yellow} para mejorar **legibilidad e interpretabilidad**.

```{r}
# Equivalente a calcular_area(5, 3)
calcular_area(lado_1 = 5, lado_2 = 3)
```

:::

---

## Funciones: generando conocimiento

Parece una tonter√≠a lo que hemos hecho pero hemos cruzado una frontera importante: hemos pasado de [**consumir conocimiento**]{.hl-yellow} (c√≥digo de otros paquetes, elaborado por otros/as), a [**generar conocimiento**]{.hl-purple}, creando nuestras propias funciones.

. . .

Las funciones van a ser claves en tu d√≠a a d√≠a ya que te permitir√° automatizar c√≥digo que vas a repetir una y otra vez: empaquetando ese c√≥digo bajo un alias (nombre de la funci√≥n) vas a [**poder usarlo una y otra vez sin necesidad de programarlo (por lo que hacer el doble de trabajo no implicar√° trabajar el doble)**]{.hl-yellow}

---

## Variables locales vs globales

Un aspecto importante sobre el que reflexionar con las funciones: ¬øqu√© sucede si [**nombramos a una variable dentro**]{.hl-yellow} de una funci√≥n a la que se nos ha **olvidado asignar** un valor dentro de la misma?

. . .

Debemos ser cautos al usar funciones en `R`, ya que debido a la [**¬´regla lexicogr√°fica¬ª**]{.hl-yellow}, si una variable no se define dentro de la funci√≥n, `R` [**buscar√° dicha variable en el entorno**]{.hl-purple} de variables.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  print(x) # No devuelve nada, solo realiza la acci√≥n 
}
funcion_ejemplo()
```

---

## Variables locales vs globales

Si una variable  [**ya est√° definida fuera de la funci√≥n (entorno global)**]{.hl-yellow}, y adem√°s es usada dentro de cambiando su valor, el valor [**solo cambia dentro**]{.hl-yellow} pero [**no en el entorno global**]{.hl-red}.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  x <- 2
  print(x) # lo que vale dentro
}
```

```{r}
# lo que vale dentro
funcion_ejemplo() #<<
# lo que vale fuera
print(x) #<<
```

---

## Variables locales vs globales


Si queremos que adem√°s de cambiar localmente lo haga [**globalmente**]{.hl-yellow} deberemos usar la [**doble asignaci√≥n**]{.hl-yellow} (`<<-`).

```{r}
x <- 1
y <- 2
funcion_ejemplo <- function() {
  
  # no cambia globalmente, solo localmente
  x <- 3 
  # cambia globalmente
  y <<- 0 #<<
  
  print(x)
  print(y)
}

funcion_ejemplo() # lo que vale dentro
x # lo que vale fuera
y # lo que vale fuera
```

---


## üíª It's your turn {#tu-turno-0-3-3}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset

### [**Ej 1**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para definir una funci√≥n llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.

```{r}
#| eval: false
nombre <- function(x, y) {
  suma <- # c√≥digo a ejecutar
  return()
}
# Aplicamos la funci√≥n
suma(3, 7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_suma <- function(x, y) {
  suma <- x + y
  return(suma)
}
funcion_suma(3, 7)
```

### [**Ej 2**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para definir una funci√≥n llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado

```{r}
#| eval: false
nombre <- function(x, y) {
  producto <- # c√≥digo de la multiplicaci√≥n
  return()
}
producto(3)
producto(3, -7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_producto <- function(x, y = x) {
  producto <- x * y
  return(producto)
}
funcion_producto(3)
funcion_producto(3, -7)
```

### [**Ej 3**]{.hl-yellow}

üìù Define una funci√≥n llamada `igualdad_nombres` que, dados dos nombres, nos diga si son iguales o no. Hazlo considerando importantes las may√∫sculas, y sin que importen las may√∫sculas. Usa el paquete `{stringr}`.

```{r}
#| code-fold: true
#| eval: false
# Distinguiendo may√∫sculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Luc√≠a")

# Sin importar may√∫sculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(toupper(persona_1) == toupper(persona_2))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Luc√≠a")
```

### [**Ej 4**]{.hl-yellow}

üìù Crea una funci√≥n llamada `calculo_IMC` que, dados dos argumentos (peso y estatura en metros) y un nombre, devuelva una lista con el IMC ($peso/(estatura_m^2)$) y el nombre.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura) {
  
  return(list("nombre" = nombre, "IMC" = peso/(estatura^2)))
}
```

### [**Ej 5**]{.hl-yellow}

üìù Repite el Exercise anterior pero con otro argumento opcional que se llame unidades (por defecto, `unidades = "metros"`). Desarrolla la funci√≥n de forma que haga lo correcto si `unidades = "metros"` y si `unidades = "cent√≠metros"`.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  
  return(list("nombre" = nombre,
              "IMC" = peso/(if_else(unidades == "metros", estatura, estatura/100)^2)))
}
```

 
### [**Ej 6**]{.hl-yellow}

üìù Crea un tibble ficticio de 7 personas, con tres variables (inventa nombre, y simula peso, estatura en cent√≠metros), y aplica la funci√≥n definida de forma que obtengamos una cuarta columna con su IMC.

```{r}
#| code-fold: true
#| eval: false
datos <-
  tibble("nombres" = c("javi", "sandra", "laura",
                       "ana", "carlos", "leo", NA),
         "peso" = rnorm(n = 7, mean = 70, sd = 1),
         "estatura" = rnorm(n = 7, mean = 168, sd = 5))

datos |> 
  mutate(IMC = calculo_IMC(nombres, peso, estatura, unidades = "cent√≠metros")$IMC)
```


### [**Ej 7**]{.hl-yellow}

üìù Crea una funci√≥n llamada `atajo` que tenga dos argumentos num√©ricos `x` e `y`. Si ambos son iguales, debes devolver `"iguales"` y hacer que la funci√≥n acaba autom√°ticamente (piensa cu√°ndo una funci√≥n sale). OJO: `x` e `y` podr√≠an ser vectores. Si son distintos (de igual de longitud) calcula la proporci√≥n de elementos  diferentes. Si son distintos (por ser distinta longitud), devuelve los elementos que no sean comunes.

```{r}
#| code-fold: true
#| eval: false
atajo <- function(x, y) {
  
  if (all(x == y) & length(x) == length(y)) { return("iguales") }
  else {
   
    if (length(x) == length(y)) {
      
      n_diff <- sum(x != y) / length(x)
      return(n_diff)
      
    } else {
      
      diff_elem <- unique(c(setdiff(x, y), setdiff(y, x)))
      return(diff_elem)
    }
    
  }
}
```


:::


---

## Comunicar: rmd y Quarto

Una de las [**principales fortalezas**]{.hl-yellow} de `R` es la [**facilidad para generar informes, libros, webs, apuntes y hasta diapositivas**]{.hl-yellow} (este mismo material por ejemplo). Para ello [**instalaremos**]{.hl-purple} antes

::: columns
::: {.column width="40%"}
-   el paquete `{rmarkdown}` (para generar archivos `.rmd`)

```{r}
#| eval: false
install.packages("rmarkdown")
```

- instalar [**Quarto**](https://quarto.org/docs/get-started/) (si ya conoc√≠as `R`, el ¬´nuevo¬ª `.rmd` ahora como `.qmd`)
:::

::: {.column width="60%"}
![](img/quarto.png)
:::
:::

---

## Comunicar: rmd y Quarto

Hasta ahora solo hemos programado en scripts (archivos `.R`) dentro de proyectos, pero en muchas ocasiones [**no trabajaremos solos**]{.hl-yellow} y necesitaremos [**comunicar los resultados**]{.hl-yellow} en diferentes formatos:

- apuntes (para nosotros mismos)
- diapositivas
- web
- informes


Para todo ello usaremos [**Quarto**]{.hl-yellow} (ver m√°s en <https://ivelasq.quarto.pub/intro-to-quarto/>)


---

## Comunicar: rmd y Quarto

Los archivos de extensi√≥n `.qmd` (o `.rmd` antes) nos permitir√°n f√°cilmente combinar:

-   [**Markdown**]{.hl-yellow}: [**lenguaje tipado**]{.hl-purple} que nos permite crear contenido simple (tipo wordpress, con texto, **negritas**, _cursivas_, etc) con un dise√±o legible.

. . .

-   [**Matem√°ticas (latex)**]{.hl-yellow}: lenguaje para escribir notaci√≥n matem√°tica como $x^2$ o $\sqrt{y}$ o $\int_{a}^{b} f(x) dx$

. . .

-   [**C√≥digo y salidas**]{.hl-yellow}: podremos no solo mostrar el paso final sino el c√≥digo que has ido realizando (en `R`, `Python`, `C++`, `Julia`, ...), con [**cajitas de c√≥digo llamadas CHUNKS**]{.hl-purple}.

. . .

-   Im√°genes, [**gr√°ficas**]{.hl-yellow}, tablas, estilos (css, js), etc.

---

## Comunicar: rmd y Quarto

La principal ventaja de realizar este tipo de material en Quarto/Rmarkdown es que, al hacerlo desde `RStudio`, puedes generar un [**informe o una presentaci√≥n sin salirte del entorno de programaci√≥n**]{.hl-yellow} en el que est√°s trabajando

De esta forma podr√°s analizar los datos, resumirlos y a la vez comunicarlos con la misma herramienta.

. . .

Recientemente el equipo de `RStudio` desarroll√≥ [**Quarto**]{.hl-yellow}, una versi√≥n mejorada de Rmarkdown (archivos `.qmd`), con un formato un poco m√°s est√©tico y simple. Tienes toda la documentaci√≥n y ejemplos en [**https://quarto.org/**](https://quarto.org/)

---

## Usos de Quarto

::: panel-tabset
### Webs

![](./img/website.png){height="350"}

### Libros

![](./img/book.png){height="350"}

### Blogs

![](./img/blog.png){height="350"}

### Presentaciones

![](./img/presentation.png){height="350"}

### Revistas

![](https://user-images.githubusercontent.com/163582/42351114-e5deaa1c-8078-11e8-90de-2aff57bba255.png){height="350"}
:::

Im√°genes obtenidas de <https://ivelasq.quarto.pub/intro-to-quarto/#/working-with-the-rstudio-visual-editor>

---

## Nuestro primer informe

::: columns
::: {.column width="55%"}
![](img/quarto-create.png)
:::

::: {.column width="45%"}
Vamos a crear el [**primer fichero rmarkdown con Quarto**]{.hl-yellow} con extensi√≥n `.qmd`. Para ello solo necesitaremos hacer click en

`File << New File << Quarto Document`
:::
:::

---

## Nuestro primer informe

:::: columns
::: {.column width="45%"}
![](img/quarto-format.png)
:::

::: {.column width="55%"}
Tras hacerlo nos aparecer√°n varias [**opciones de formatos de salida**]{.hl-yellow}:

-   archivo `.pdf`
-   archivo `.html` ([**recomendable**]{.hl-yellow}): documento din√°mico, permite la interacci√≥n con el usuario, como una ¬´p√°gina web¬ª.
-   archivo `.doc` (nada recomendable)
:::
::::

. . .

De momento dejaremos marcado el [**formato HTML que viene por defecto**]{.hl-yellow}, y escribiremos el [**t√≠tulo**]{.hl-yellow} de nuestro documento. Tras ello tendremos nuestro [**archivo .qmd**]{.hl-yellow} (ya no es un script .R como los que hemos abierto hasta ahora).

---

## Nuestro primer informe

:::: columns
::: {.column width="60%"}
![](img/quarto-example.png)
:::

::: {.column width="40%"}

Deber√≠as tener algo similar a la captura de la imagen con [**dos modos de edici√≥n**]{.hl-yellow}: `Source` (con c√≥digo, la opci√≥n recomendada hasta que lo domines) y `Visual` (m√°s parecido a un blog)

:::
::::

Para [**ejecutar TODO el documento**]{.hl-yellow} debes clickar `Render on Save` y darle a guardar.

---

## Salida de Quarto

![](img/quarto-prueba-html.png)

Deber√≠as haber obtenido una [**salida en html similar a esta**]{.hl-yellow} (y se te ha generado en tu ordenador un [**archivo html**]{.hl-yellow})

---

## Editor: source vs visual

Como se indicaba, tienes dos formas de trabajar: con c√≥digo puro y algo parecido a un Notion (blog)

![](./img/rstudio-source-visual.png)

Imagen obtenida de <https://ivelasq.quarto.pub/intro-to-quarto/#/working-with-the-rstudio-visual-editor>

---

## Nuestro primer informe

:::: columns
::: {.column width="50%"}
![](img/quarto-example.png)

:::

::: {.column width="50%"}

Un fichero `.qmd` se [**divide b√°sicamente en tres partes**]{.hl-yellow}:

* [**Cabecera**]{.hl-yellow}: la parte que tienes al inicio entre `---`.

* [**Texto**]{.hl-yellow}: que podremos formatear y mejorar con negritas (escrito como **negritas**, con doble ast√©risco al inicio y final), cursivas (_cursivas_, con barra baja al inicio y final) o destacar nombres de funciones o variables de R. Puedes a√±adir ecuaciones como $x^2$ (he escrito `$x^2$`, entre d√≥lares).

* [**C√≥digo R**]{.hl-yellow}

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera est√°n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el t√≠tulo/subt√≠tulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes alg√∫n archivo de estilos
  * `toc`: si quieres √≠ndice o no
  * `toc-location`: posici√≥n del √≠ndice
  * `toc-title`: t√≠tulo del √≠ndice
* `editor`: si est√°s en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
format:
  html:
editor: visual
---
```

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera est√°n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el t√≠tulo/subt√≠tulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes alg√∫n archivo de estilos
  * `toc`: si quieres √≠ndice o no
  * `toc-location`: posici√≥n del √≠ndice
  * `toc-title`: t√≠tulo del √≠ndice
* `editor`: si est√°s en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier √°lvarez li√©bana"
format:
  html:
editor: visual
---
```

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera est√°n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el t√≠tulo/subt√≠tulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes alg√∫n archivo de estilos
  * `toc`: si quieres √≠ndice o no
  * `toc-location`: posici√≥n del √≠ndice
  * `toc-title`: t√≠tulo del √≠ndice
* `editor`: si est√°s en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier √°lvarez li√©bana"
format:
  html:
    style: style.css
    toc: true
editor: visual
---
```

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera est√°n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el t√≠tulo/subt√≠tulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes alg√∫n archivo de estilos
  * `toc`: si quieres √≠ndice o no
  * `toc-location`: posici√≥n del √≠ndice
  * `toc-title`: t√≠tulo del √≠ndice
* `editor`: si est√°s en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier √°lvarez li√©bana"
format:
  html:
    style: style.css
    toc: true
    toc-location: left
editor: visual
---
```

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera est√°n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el t√≠tulo/subt√≠tulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes alg√∫n archivo de estilos
  * `toc`: si quieres √≠ndice o no
  * `toc-location`: posici√≥n del √≠ndice
  * `toc-title`: t√≠tulo del √≠ndice
* `editor`: si est√°s en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier √°lvarez li√©bana"
format:
  html:
    style: style.css
    toc: true
    toc-location: left
    toc-title: √çndice
editor: visual
---
```

:::
::::


---

## Texto de un qmd

Respecto a la escritura solo hay una [**cosa importante**]{.hl-yellow}: salvo que indiquemos lo contrario, [**TODO lo que vamos a escribir es texto (normal)**]{.hl-yellow}. No c√≥digo R.

:::: columns
::: {.column width="35%"}
![](img/quarto-prueba-qmd2.png){width=350}
![](img/quarto-prueba-html2.png){width=320}
:::

::: {.column width="65%"}
Vamos a empezar escribiendo una secci√≥n al inicio (`# Intro` y detr√°s por ej. la frase

> Este material ha sido dise√±ado por el profesor Javier √Ålvarez Li√©bana, docente en la Universidad Complutense de Madrid

Adem√°s al `Running Code` le a√±adiremos una almohadilla `#`: las [**almohadillas FUERA DE CHUNKS**]{.hl-yellow} nos servir√°n para crear [**ep√≠grafes (secciones)**]{.hl-yellow} en el documento


:::
::::


---

## √çndice de un qmd

:::: columns
::: {.column width="40%"}
![](img/quarto-indice-qmd-2.png){width=370}
![](img/quarto-indice-html2.png){width=370}
:::

::: {.column width="60%"}
Para que el [**√≠ndice capture dichas secciones**]{.hl-yellow} modificaremos la cabecera del archivo como se observa en la imagen (puedes cambiar la localizaci√≥n del √≠ndice y el t√≠tulo si quieres para probar).

:::
::::

---

## Texto en un qmd

Vamos a [**personalizar un poco el texto**]{.hl-yellow} haciendo lo siguiente:


:::: columns
::: {.column width="50%"}
![](img/quarto-texto-mejorado-qmd.png){width=370}
![](img/quarto-texto-mejorado-html.png){width=370}
:::

::: {.column width="50%"}
* Vamos a a√±adir [**negrita al nombre**]{.hl-yellow} (poniendo ** al inicio y al final).

* Vamos a√±adir [**cursiva**]{.hl-yellow} a la palabra material (poniendo _ al inicio y al final).

* Vamos a√±adir un [**enlace**]{.hl-yellow} <https://www.ucm.es>, asoci√°ndolo al nombre de la Universidad. Para ello el t√≠tulo lo ponemos entre corchetes y justo detr√°s el enlace entre par√©ntesis `[¬´Universidad Complutense de Madrid¬ª](https://www.ucm.es)`

:::
::::

---

## C√≥digo en un qmd

Para [**a√±adir c√≥digo R**]{.hl-yellow} debemos crear nuestras [**cajas de c√≥digo llamadas chunks**]{.hl-yellow}: altos en el camino en nuestro texto markdown donde podremos incluir c√≥digo de casi cualquier lenguaje (y sus salidas).

&nbsp;

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-qmd.png){width=470}
:::

::: {.column width="50%"}

Para incluir uno deber√° de ir [**encabezado**]{.hl-yellow} de la siguiente forma tienes un atajo `Command + Option + I` (Mac) o `Ctrl + Shift + I` (Windows)
:::

::::

---

## C√≥digo en un qmd

Dentro de dicha cajita (que tiene ahora otro color en el documento) [**escribiremos c√≥digo R**]{.hl-yellow} como lo ven√≠amos haciendo hasta ahora en los scripts.

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-1-qmd.png){width=410}
![](img/quarto-chunk-1-html.png){width=410}
:::

::: {.column width="50%"}

 Vamos por ejemplo a definir dos variables y su suma de la siguiente manera, escribiendo dicho c√≥digo en nuestro `.qmd` (dentro de ese chunk)

```{r}
# C√≥digo R
x <- 1
y <- 2
x + y
```

:::

::::


---

## Etiquetando chunks


:::: columns
::: {.column width="50%"}
![](img/quarto-tag-chunks-qmd.png){width=400}
![](img/quarto-tag-chunks-html.png){width=400}
:::

::: {.column width="50%"}
Los chunks pueden tener un [**nombre o etiqueta**]{.hl-yellow}, de forma que podamos referenciarlos de nuevo para no repetir c√≥digo.
:::
::::


---

## Ejecutando chunks

:::: columns
::: {.column width="40%"}
![](img/quarto-inline-qmd.png){width=400}
![](img/quarto-inline-html.png){width=380}
:::

::: {.column width="60%"}
En cada chunk aparecen [**dos botones**]{.hl-yellow}:

* bot√≥n de [**play**]{.hl-yellow}: activa la [**ejecuci√≥n y salida de ese chunk particular**]{.hl-yellow} (lo puedes visualizar dentro de tu propio `RStudio`)

* bot√≥n de [**rebobinar**]{.hl-yellow}: activa la [**ejecuci√≥n y salida de todos los chunk hasta ese**]{.hl-yellow} (sin llegar a √©l)

&nbsp;

Adem√°s podemos [**incluir c√≥digo R dentro de la l√≠nea de texto**]{.hl-yellow} (en lugar de mostrar el texto x ejecuta el c√≥digo R mostrando la variable).
:::
::::



---

## Personalizaci√≥n de chunks

Los [**chunks podemos personalizarlos**]{.hl-yellow} con opciones al inicio del chunk precedido de `#|`:

* `#| echo: false`: [**ejecuta c√≥digo**]{.hl-green} y se [**muestra resultado**]{.hl-green} pero [**no visualiza c√≥digo**]{.hl-red} en la salida.

* `#| include: false`: [**ejecuta c√≥digo**]{.hl-green} pero [**no muestra resultado**]{.hl-red} y [**no visualiza c√≥digo**]{.hl-red} en la salida.

* `#| eval: false`: [**no ejecuta c√≥digo**]{.hl-red}, [**no muestra resultado**]{.hl-red} pero [**s√≠ visualiza c√≥digo**]{.hl-green} en la salida.

* `#| message: false`: [**ejecuta c√≥digo**]{.hl-green} pero [**no muestra mensajes de salida**]{.hl-red}.

* `#| warning: false`: [**ejecuta c√≥digo**]{.hl-green} pero [**no muestra mensajes de warning**]{.hl-red}.

* `#| error: true`: [**ejecuta c√≥digo**]{.hl-green} y [**permite que haya errores**]{.hl-green} mostrando el mensaje de error en la salida.


![](img/quarto-options-chunk.png){width=380}

Estas opciones podemos aplicarlas chunk a chunk o fijar los par√°metros de forma global con `knitr::opts_chunk$set()` al inicio del documento (dentro de un chunk).

---

## Personalizando chunks

Si queremos que aplique la **opci√≥n a todos los chunks por defecto** debemos incluirlo al final de la cabecera, como [**opciones de ejecuci√≥n**]{.hl-yellow}

``` yaml
---
title: "¬°Hola!"
format: html
editor: visual
execute:
  echo: false
---
```

---

## Organizando qmd

Adem√°s de texto y c√≥digo podemos introducir lo siguiente:

* [**Ecuaciones**]{.hl-yellow}: puedes a√±adir adem√°s ecuaciones como $x^2$ (he escrito `$x^2$`, la ecuaci√≥n entre d√≥lares).

* [**Listas**]{.hl-yellow}: puedes itemizar elementos poniendo `*`

`* Paso 1: ...`

`* Paso 2: ...`

* [**Cross-references**]{.hl-yellow}: puedes etiquetar partes del documento (la etiqueta se construye con `{#nombre-seccion}`) y llamarlas luego con `[Secci√≥n](@nombre-seccion)`

---

## Gr√°ficas/im√°genes en qmd

:::: columns
::: {.column width="50%"}
![](img/quarto-fig-qmd.png){width=340}
![](img/quarto-fig-html.png){width=390}
:::

::: {.column width="50%"}
Por √∫ltimo, tambi√©n podemos [**a√±adir pies de gr√°ficas o im√°genes**]{.hl-yellow} a√±adiendo `#| fig-cap: "..."`
:::
::::

. . .

:::: columns
::: {.column width="65%"}
F√≠jate que el [**caption est√° en el margen**]{.hl-yellow} (por ejemplo). Puedes cambiarlo introduciendo [**ajustes en la cabecera**]{.hl-yellow} (todo lo relativo a figuras empieza por `fig-`, y puedes ver las opciones tabulando). Tienes m√°s informaci√≥n en **<https://quarto.org/>**
:::

::: {.column width="35%"}
![](img/quarto-cabecera-desplegable.png){width=400}
:::
::::

---

## A√±adir estilos

:::: columns
::: {.column width="50%"}
![](img/quarto-estilos-qmd.png){width=400}
![](img/quarto-estilos-html.png){width=400}
:::

::: {.column width="50%"}
Por √∫ltimo puedes a√±adir un [**tema personalizado**]{.hl-yellow} incluyendo un [**archivo de estilos**]{.hl-yellow} (archivo en formato `.scss` o `.css`). Te he dejado uno en <https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material>.

::: callout-important
## Importante

El archivo de estilos debe estar en la misma carpeta que el archivo `.qmd`
:::
:::
::::

---

## A√±adir estilos

Tambi√©n puedes hacerlo de manera sencilla [**a√±adiendo a los textos un poco de HTML**]{.hl-yellow}. Por ejemplo, para personalizar el color de un texto va entre corchetes y justo tras el texto, entre llaves, las opciones de estilo

``` html
Esta palabra es [roja]{style="color:red;"} ...
```

``` html
... y esta [verde y en negrita]{style="color:green; font-weight: bold;"}
```

. . .

Esta palabra es [roja]{style="color:red;"} ...

... y esta [verde y en negrita]{style="color:green; font-weight: bold;"}

---

## Revealjs

Puedes a√±adir algunas ¬´animaciones¬ª usando lo que se conoce como Revealjs (javascript), especifc√°ndolo en la cabecera y usando [**bloques**]{.hl-yellow} de dicho lenguaje delimitados por `:::` al inicio y final, y la palabra de la ¬´herramienta¬ª a usar. Por ejemplo `{.incremental}` hace una transici√≥n de los elementos.

``` yaml
format:
  revealjs
```
&nbsp;

``` revealjs
::: {.incremental}
- Me
- llamo
- Javi
:::
```


::: {.incremental}
- Me
- llamo
- Javi
:::

---

## Bloques de llamada

Tambi√©n puedes usar los [**bloques de llamada**]{.hl-yellow} que por defecto son `note`, `tip`, `warning`, `caution` e `important` (aunque los puedes crear y personalizar). Para ello basta con usar `:::{.callout-tipo}` y el tipo que quieras

``` html
:::{.callout-tip}

Note that there are five types of callouts, including: 
`note`, `tip`, `warning`, `caution`, and `important`.

:::
```

. . .

:::{.callout-tip}

Recuerda que los 5 tipos son `note`, `tip`, `warning`, `caution` e `important`.

:::

. . .

:::{.callout-caution}

√ösalos con cabeza, a veces mucho recursos est√©tico puede marear.

:::

---

## M√∫ltiples columnas

Con `:::: columns` podemos definir una disposici√≥n de [**m√∫ltiples columnas**]{.hl-yellow} donde cada una viene definida por `::: {.column width="65%"} cosa :::`, indicando al lado del porcentaje cuanto quieres que ocupe cada columna (¬°cuidado, no dejar espacios!)

``` html
:::: columns
::: {.column width="65%"}
As√≠ se define un vector
:::
::: {.column width="35%"}
x <- c(1, 2, 3)
x
:::
::::
```
&nbsp;

. . .

:::: columns
::: {.column width="65%"}
As√≠ se define un vector
:::

::: {.column width="35%"}
```{r}
x <- c(1, 2, 3)
x
```
:::
::::


---

## C√≥digo ajeno a R

Adem√°s `{reticulate}` nos permite crear chunks de `python` dentro de un Quarto en `R` (ver <https://quarto.org/docs/computations/python.html> para crear jupyter notebooks directamente desde Quarto)

```{r}
#| echo: false
library(reticulate)
```

```{r}
#| eval: false
# install.packages("reticulate")
library(reticulate)

install_python("3.9.12") # Instalar python en PC sino lo tienes

# Instalar paquetes de Python
reticulate::py_install("numpy")
reticulate::py_install("matplotlib")
```

:::: columns
::: {.column width="60%"}

```{python}
#| eval: false
import numpy as np
import matplotlib.pyplot as plt
r = np.arange(0, 2, 0.05)
theta = 2 * np.pi * r
fig, ax = plt.subplots(
  subplot_kw = {'projection': 'polar'} 
)
ax.plot(theta, r)
plt.show()
```

:::

::: {.column width="40%"}

```{python}
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
r = np.arange(0, 2, 0.05)
theta = 2 * np.pi * r
fig, ax = plt.subplots(
  subplot_kw = {'projection': 'polar'} 
)
ax.plot(theta, r)
plt.show()
```

:::
::::

---


## üê£ Case study I: flow structures {#caso-practico-0-3-1}

Dise√±a un bucle for de 200 iteraciones que, empezando en un valor inicial de 100 (euros), te sume 3‚Ç¨ si el n√∫mero actual es par y te reste 5‚Ç¨ si es impar. Un n√∫mero par o impar: un n√∫mero par ser√° todo aquel n√∫mero que al dividir entre 2, la divisi√≥n es exacta, es decir, que su resto es nulo. Por ejemplo, al dividir 5 entre 2, el resto es 1, pero al dividir 12 entre 2 el resto es 0. Para calcula ese resto usaremos la funci√≥n %%.

+ cosas de if-elses

---

## üê£ Case study II: functions {#caso-practico-0-3-2}

Define una funci√≥n llamada `conversor_temperatura` que, dada una temperatura en Fahrenheit, Celsius o Kelvin, la convierta a cualquiera de las otras

* Piensa qu√© argumentos necesita el usuario.

* Piensa todas las combinaciones posibles e intenta conceptuar la idea antes en un papel.

* Haz el c√≥digo m√°s simple y legible posible.

* Aplica la funci√≥n a la columna `Temp` del conjunto `airquality`, e incorp√≥rala al fichero en una nueva columna `Temp_Celsius`.



---

## üê£ Case study III: mock task {#caso-practico-0-3-3}

1. Crea un documento `.qmd` en el que al menos la cabecera contenga
  - T√≠tulo, autor y formato (html)
  - √çndice con t√≠tulo y situado a la derecha
  
2. Tras ello vuelve a [Exercises del tema 3](#tu-turno-3-3) y estructura un documento donde cada Exercise sea una subsecci√≥n. En cada subsecci√≥n pon el enunciado.

4. Debajo de cada enunciado pon el chunk con el c√≥digo correspondiente, as√≠ como comentarios de texto de la salida (con negritas y cursivas)

5. A√±ade un √∫ltimo chunk en el que, dado un vector `x <- 1:5`, calcules su media, e incluye con `$ $` la f√≥rmula de la media aritm√©tica e incrusta adem√°s una foto de la f√≥rmula que encuentres por google.

6. Renderiza el documento para obtener el html


---

## Ejemplo de entrega

Vamos a realizar un peque√±o simulacro antes de la entrega usando el dataset `starwars` del paquete `{dplyr}`

![](https://sm.ign.com/t/ign_latam/screenshot/default/baby-yoda-nombre_3x56.1280.jpg)

---

## Ejemplo de entrega

```{r}
library(dplyr)
starwars
```

En √©l tenemos **diferentes variables de los personajes de Star Wars**, con caracter√≠sticas de su pelo, piel, altura, nombre, etc.


---

## Ejemplo de entrega

> Crea un documento `.qmd` con nombre, t√≠tulo, formato e √≠ndice. Cada Exercise posterior ser√° una subsecci√≥n del documento. Ejecuta los chunks que consideres y comenta las salidas para responder a cada pregunta

. . .

> Exercise 1. ¬øCu√°ntos personajes hay guardados en la base de datos? ¬øCu√°ntas caracter√≠sticas se han medido de cada uno?

. . .

> Exercise 2. Extrae en dos variables distintas `nombres` y `edades` las variables correspondientes de la tabla. ¬øDe qu√© tipo es la variable nombre? ¬øY la variable birth_year?

. . .

> Exercise 3. Obt√©n el vector de nombres de los personajes ordenados de mayores a j√≥venes.


---

## Ejemplo de entrega

> Exercise 4. Busca ayuda de la funci√≥n unique(). √ösala para saber que modalidades tiene la variable cualitativa correspondiente al color de ojos. ¬øCu√°ntos distintos hay?

. . .

> Exercise 5. ¬øExiste ALG√öN valor ausente en la variable de color ojos? 

. . .

> Exercise 6.  Calcula la media y desviaci√≥n t√≠pica de las variables de estatura y peso (cuidado con los ausentes). Define un nuevo tibble con esas dos variables e incorpora una tercera variable que se llame ‚ÄúIMC‚Äù que calcule el √≠ndice de masa corporal. Incorpora con `$ $` la f√≥rmula usada para el IMC.


# Final task: [foundations of R base]{.flow} {#clase-0-4}

[**Final task (70%)**: 10/09/2024 from 15:00 to 16:10]{style="color:#444442;"}

---

## Final task (intro R)

The day of the submission you will have uploaded a [**submission template**]{.hl-yellow} in `.qmd` format on campus.

1. **Unzip the folder** (important! if you don't unzip, even if you can edit the `.qmd`, you won't be able to generate the `. html`)

2. **Edit the header** with your name and ID

3. You must **fill in each chunk** with the code you consider (in some I have left hints) and **change** from `#| eval: false` to `#| eval: true` (if you remove them directly, by default it is already true)

4. You must **comment** with normal text what you consider to answer the questions.

5. It will be [**MANDATORY**]{.hl-yellow} to upload the generated `.html` file (only that file will be corrected) so render as you fill in the document, don't leave it to the end.




