---
title: "Data programming and intro to R"
subtitle: "Prepare, clean, transform and enrich data in R"
title-slide-attributes:
  data-background-image: img/background-mucss.webp
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Master in Computational Social Sciences • Javier Álvarez Liébana"
affiliation: Facultad de Estudios Estadísticos (UCM)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier Álvarez Liébana</strong>](...) • Master in Computational Social Sciences (UC3M)"
    slide-number: c/t
execute:
  echo: true
---

::: r-fit-text
[Welcome to R!]{.flow}
:::

[**Put your spreadsheets, SAS and SPSS aside**]{style="color:#444442;"}

---

## Hi!

[**Mail**]{.hl-green}: **<javalv09@ucm.es>**.

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
-   [**Javier Álvarez Liébana**]{.hl-yellow} from Carabanchel (Madrid).

-   Degree in Mathematics (UCM). [**PhD in Statistics**]{.hl-yellow} (UGR).

-   In charge of  [**data visualization and analysis**]{.hl-yellow} for the Principality of Asturias (2021-2022) during the COVID pandemic

-   Member of the [**Spanish Society of Statistics and OR**]{.hl-yellow} and the [**Spanish Royal Mathematical Society**]{.hl-yellow}.


:::
:::
:::


Currently, [**Assistant Professor at the Faculty of Statistics of the UCM**]{.hl-yellow}. Disseminating via [**Twitter**](https://twitter.com/dadosdelaplace) e [**Instagram**](https://instagram.com/javieralvarezliebana)


---

## Goals

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
- Take away the [**fear of programming**]{.hl-yellow} → learn to program by programming

- Understanding [**basic R concepts**]{.hl-yellow} from scratch → learning to **abstract** ideas and algorithms

- Utility of programming → [**reproducible, transparent and maintainable workflows**]{.hl-yellow}.

- Introduction to [**analysis and preprocessing of data**]{.hl-yellow} → `{tidyverse}`.

- Handling [**advanced data types**]{.hl-yellow} → `{forcats}`, `{lubridate}` and `{purrr}` packages

:::
:::
:::


---

## Evaluation: intro to R

-  [**Attendance and individual participation**]{.hl-yellow} (30%)

. . .

- [**Final exam**]{.hl-yellow} on 10/09/2024, 15:00-16:10 (70%). 

. . .

* [**Max grade**]{.hl-yellow}: to get a grade greater than 9/10 you should get at least 9/10 in the final exam.

---

## Evaluation: data programming

-  [**Attendance and individual participation**]{.hl-yellow} (10%)

. . .

- [**2 individual tasks**]{.hl-yellow} done during the course (15%-25%). 

. . .

- [**1 group task**]{.hl-yellow} between 4 and 6 people (20%). **Deadline**: 23/12/2024.

. . .

- [**Final exam**]{.hl-yellow} with all materials and internet (30%). [**You are exempt if you get more than 7.5/10**]{.hl-purple} in the previous tasks.

. . .

* [**Max grade**]{.hl-yellow}: to get a grade greater than 9/10 you should get at least 9/10 in the individual tasks.


---

## Planning

* [**Final exam (intro R 70%)**]{.hl-yellow}: 10/09/2024 (15:00 - 16:10).

&nbsp;

* [**Individual task I (15%)**]{.hl-yellow}: deadline 03/11/2024

* [**Individual task II (25%)**]{.hl-yellow}: deadline 30/11/2024

* [**Group task (20%)**]{.hl-yellow}: deadline 23/12/2024.

&nbsp;

* [**Final examen (30% if required)**]{.hl-yellow}: TBA


---

## Planning: intro R {#planificacion}

::: column-screen-inset-right
::: {style="font-size:20px"}
|  LESSON | WEEK | DATES | TOPIC | EX. | WORKBOOK | TASK | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
| [0-1](#clase-0-1) | S1 | 2 sep | First steps: R base programming | [💻](#tu-turno-0-1-1) [💻](#tu-turno-0-1-2)  |  |  | 
| [0-2](#clase-0-2) | S1 | 4 sep | First data: concatenate values and databases | [💻](#tu-turno-0-2-1) [💻](#tu-turno-0-2-2) [💻](#tu-turno-0-2-3) |  [🐣](#caso-practico-0-2-1) [🐣](#caso-practico-0-2-2) |  |
| [0-3](#clase-0-3) | S1 | 6 sep | Quarto and flow structures | [💻](#tu-turno-0-3-1) [💻](#tu-turno-0-3-2) [💻](#tu-turno-0-3-3) |  [🐣](#caso-practico-0-3-1) [🐣](#caso-practico-0-3-2) [🐣](#caso-practico-0-3-3) |  |
| [0-4](#clase-0-4) | S2 | 10 sep | Final task| | | [🎯 (70%)](#clase-0-4) |
:::
:::

---

## Planning: data programming {#planificacion-curso}

::: column-screen-inset-right
::: {style="font-size:20px"}
|  LESSON | WEEK | DATES | TOPIC | EX. | WORKBOOK | TASK | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
| [1](#clase-1) | S2 | 12 sep | First steps: R base programming | [💻](#tu-turno-0-1-1) [💻](#tu-turno-0-1-2)  |  |  | 
| [2](#clase-2) | S3 | 19 sep | First data: concatenate values and databases | [💻](#tu-turno-0-2-1) [💻](#tu-turno-0-2-2) [💻](#tu-turno-0-2-3) |  [🐣](#caso-practico-0-2-1) [🐣](#caso-practico-0-2-2) |  |
| [3](#clase-3) | S4 | 26 sep | Quarto and flow structures | [💻](#tu-turno-0-3-1) [💻](#tu-turno-0-3-2) [💻](#tu-turno-0-3-3) |  [🐣](#caso-practico-0-3-1) [🐣](#caso-practico-0-3-2) [🐣](#caso-practico-0-3-3) |  |
:::
:::


  
---

## Materials

* [**Slides**]{.hl-yellow}: slides made with `Quarto` available and updated on **<https://javieralvarezliebana.es/docencia/mucss-data-programming>**. In the slide menu (bottom left) you have an option to  [**download them in pdf**]{.hl-yellow} in `Tools`

&nbsp;

* [**Material**]{.hl-yellow}: [**workbooks**](https://javieralvarezliebana.es/docencia/mucss-data-programming/material/) and extra materials.

* [🗃 **Data**]{.hl-yellow}: datasets that will be used, available on **<https://javieralvarezliebana.es/docencia/mucss-data-programming/material>**

* [📚 **Extra resources**]{.hl-yellow}:  <https://r4ds.had.co.nz/>, <https://cdr-book.github.io/> and <https://ivelasq.quarto.pub/intro-to-quarto/>.

---

## Datasets

* [🗃 **Data**]{.hl-yellow}: datasets that will be used, available on **<https://javieralvarezliebana.es/docencia/mucss-data-programming/material>**

&nbsp;

* `airquality` from the `{datasets}` package (already installed by default): daily measurements (153 observations) of air quality in New York, from May to September 1973. Measured **6 variables**: ozone, solar radiation, wind, temperature, month and day.

* `surveys`: we have all **poll surveys for Spain from 1982 to 2019** collected from Wikipedia.

* `discursos`: compiles the Christmas speeches of the heads of state in Spain (under dictatorship and democracy) from 1946 to 2021.


---

## Datasets

* [🗃 **Data**]{.hl-yellow}: datasets that will be used, available on **<https://javieralvarezliebana.es/docencia/mucss-data-programming/material>**

&nbsp;

* `relig_income` del paquete `{tidyr}`: recopila los datos de ingresos anuales en función de la religión (fuente original <https://www.pewresearch.org/religion/religious-landscape-study/>)

* `who` del paquete `{tidyr}`: datos de la OMS respecto infecciones por tuberculosis, desagregados por tipo de enfermedad, sexo y edad.

* `billboard` del paquete `{tidyr}`: ranking top 100 de canciones según Billboard (algo parecido a Los 40) para el año 2000.

# L1: [first steps]{.flow} {#clase-0-1}



[**Introduction to R and RStudio. Working with projects. First uses of functions and packages. Basic data types**]{style="color:#444442;"}

* [💻 Solved exercises: first steps](#tu-turno-0-1-1)
* [💻 Solved exercises: first variables](#tu-turno-0-1-2)
* [📆 Planning](#planificacion)

---

## Requirements

For the course, the only requirements will be:

1. [**Internet connection**]{.hl-yellow} (to download some data and packages).

. . .

2. [**Install R**]{.hl-yellow}: it will be our language. We will download it (for free) from <https://cran.r-project.org/>

. . .

3. [**Install RStudio**]{.hl-yellow} from <https://posit.co/download/rstudio-desktop/>

::: columns
::: {.column width="50%"}

![](img/cranR.jpg){width="420"}

:::


::: {.column width="50%"}

![](img/rstudio.jpg){width="420"}

:::
:::

---

## R vs RStudio

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="360"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="430"}
:::
:::


::: {.fragment .fade-in-then-out}

We will program as we write 

:::

::: {.fragment .fade-up}

-   We will need a [**grammar, a language**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}

-   And an environment, such as [**Word**]{.hl-yellow} (`RStudio`) to write it

:::
:::

---

## Installing R

The `R` language will be our [**grammar and spelling**]{.hl-yellow} (our rules of the game)


::: incremental
-   [**Step 1**]{.hl-yellow}: go to <https://cran.r-project.org/> and select your operating system.

-   [**Step 2**]{.hl-yellow}: for Mac, simply click on the **.pkg file**, and open it once downloaded. For Windows systems, we need to click on **install R for the first time** and then on **Download R for Windows**. Once downloaded, open it like any installation file.

-   [**Step 3**]{.hl-yellow}: open the installation executable.

:::

. . .

::: callout-warning

Whenever you need to download something from CRAN (either `R` itself or a package), [**make sure you have an internet connection**]{.hl-orange}.

:::

---

## First operation {auto-animate="true"}

::: columns
::: {.column width="60%"}

To check the installation, after opening `R`, you should see the `R GUI` (Graphical User Interface) with a **white screen** similar to this ([**console**]{.hl-yellow}).

:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**First code**]{.hl-yellow}: we will **assign** the value `1` to a variable called `a` (we will write the code in the console and press "enter"). Then we will do the sum `a + b`.

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## First operation {auto-animate="true"}

::: columns
::: {.column width="60%"}

To check the installation, after opening `R`, you should see the `R GUI` (Graphical User Interface) with a **white screen** similar to this ([**console**]{.hl-yellow}).

:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**First code**]{.hl-yellow}: we will **assign** the value `1` to a variable called `a` (we will write the code in the console and press "enter"). Then we will do the sum `a + b`.

```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

---

## First operation {auto-animate="true"}

::: columns
::: {.column width="60%"}

To check the installation, after opening `R`, you should see the `R GUI` (Graphical User Interface) with a **white screen** similar to this ([**console**]{.hl-yellow}).

:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**First code**]{.hl-yellow}: we will **assign** the value `1` to a variable called `a` (we will write the code in the console and press "enter"). Then we will do the sum `a + b`.

```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

. . .

::: callout-note
## Note that...

In the console, a number `[1]` appears: it's simply an element counter (like counting rows in Word)

:::

---

## Installing R Studio

`RStudio` will be the [**Word**]{.hl-yellow} we will use to write (what is known as an [**IDE: Integrated Development Environment**]{.hl-yellow}).

::: incremental
-   [**Step 1**]{.hl-yellow}: go to the [official RStudio website](https://posit.co/download/rstudio-desktop/) (now called Posit) and select the free download.

-   [**Step 2**]{.hl-yellow}: select the executable that appears according to your operating system.

-   [**Step 3**]{.hl-yellow}: after downloading the executable, open it like any other and let the installation finish.

:::

---

## RStudio Organization

When you open `RStudio` you will likely have three windows:


-   [**Console**]{.hl-yellow}: is the name for the large window that takes up most of your screen. Try writing the same code as before (the sum of the variables) in it. The console is where **we will execute commands and display results**.

![](img/consola_rstudio.jpg){width="420"}

---

## RStudio Organization

When you open `RStudio` you will likely have three windows:

-   [**Environment**]{.hl-yellow}: the small screen (you can adjust the margins with the mouse to your liking) that we have in the top right corner. It will show us the **variables we have defined**.


![](img/environment.jpg){width="420"}

---

## RStudio Organization

When you open `RStudio` you will likely have three windows:

-   [**Multi-purpose panel**]{.hl-yellow}: the window at the bottom right will be used to **look for function help**, as well as to **visualize plots**.

![](img/multiusos.jpg){width="420"}

---

## What is R? Why R?

![](img/meme_barco.jpg)

---


## What is R? Why R?

![](img/incel_excel.png)

`R` is the evolution of the work of Bell Laboratories with the `S` language, which was brought into the open-source world by Ross Ihaka and Robert Gentleman in the 1990s. The version `R 1.0.0` was released on February 29, 2000.


---

## What is R? Why R?

`R` is the [**statistical language par excellence**]{.hl-yellow}, created by and for statisticians, with 6 fundamental advantages [**over Excel, SAS, Stata, or SPSS**]{.hl-red}:

. . .

-   [**Programming language**]{.hl-yellow}: the obvious → [**replicable**]{.hl-purple} analysis

. . .

-   [**Free**]{.hl-yellow}: the philosophy of the `R` community is to share code under **copyleft** → **ethical use of spending and algorithms**

. . .

-   [**Open-source software**]{.hl-yellow}: not only is it free, but it also allows free access to others' code, even to the **source code itself** → [**flexibility and transparency**]{.hl-purple} (Free and Open Source Software FOSS)

---

## What is R? Why R?

`R` is the [**statistical language par excellence**]{.hl-yellow}, created by and for statisticians, with 6 fundamental advantages [**over Excel, SAS, Stata, or SPSS**]{.hl-red}:


-   [**Modular language**]{.hl-yellow}: we have installed the minimum, but there are codes from other people that we can reuse (almost 20,000 [**packages**]{.hl-yellow}) → [**time saving**]{.hl-purple} and [**immediate innovation**]{.hl-purple}

. . .

-   [**High-level language**]{.hl-yellow}: facilitates programming (like Python) → [**lower learning curve**]{.hl-purple}

. . .

- [**Community and employability**]{.hl-yellow}: along with Python, it is the most used language in the field of statistics and data science in research, teaching, companies (Línea Directa, Mapfre, Telefónica, Orange, Apple, Spotify, Netflix, El País, Civio, HP, etc.) and public organizations (ISCIII, CNIC, CNIO, INE, IGN, CIS, CEO, DGT, AEMET, RTVE, etc.)

---

## Why programming?

-   [**Automate**]{.hl-yellow} → it will allow you to automate recurring tasks.

-   [**Replicability**]{.hl-yellow} → you will be able to replicate your analysis in the same way every time.

-   [**Flexibility**]{.hl-yellow} → you will be able to adapt the software to your needs.

-   [**Transparency**]{.hl-yellow} → to be audited by the community.

![](img/the_general_problem.png)

---

## Fundamental Idea: Packages

One of the key ideas of `R` is the [**use of packages**]{.hl-yellow}: codes that other people have implemented to **solve a problem**


::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}

-   [**Installation**]{.hl-yellow}: we download the codes from the web (we need internet) → [**buy a book**]{.hl-purple}, only once (per computer)


```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}

-   [**Loading**]{.hl-yellow}: with the package downloaded, we indicate which packages we want to use each time we open `RStudio` → [**take the book off the shelf**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```

:::
:::
:::

---

## Fundamental Idea: Packages

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}

Once installed, there are **two ways to use a package** (take it off the shelf)

::: {.fragment fragment-index="1"}

-   [**Whole package**]{.hl-yellow}: with `library()`, using the package name without quotes, we load [**the whole book**]{.hl-purple} into the session


```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}

-   [**Specific functions**]{.hl-yellow} using `package::function+  we indicate that we only want [**a specific page of that book**]{.hl-purple}


```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## You will be wrong

During your learning, it will be very common for things not to work out on the first try → [**you will be wrong**]{.hl-yellow}. It will not only be important to accept it but also [**to read the error messages**]{.hl-yellow} to learn from them.


. . .

-   [**Error messages**]{.hl-red}: preceded by **"Error in..."** and will be those failures that [**prevent execution**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Warning messages**]{.hl-orange}: preceded by **«Warning in...»** they are the (possible) more delicate errors as they are inconsistencies that [**do not prevent execution**]{.hl-orange}


```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```

---

## Scripts (.R files)


::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}

A [**script**]{.hl-yellow} will be the document in which we program, our `.doc` file (here with a `.R` extension) where we will write the commands. To **open our first script**, click on the menu in `File < New File < R Script`.


::: callout-warning
## Be careful

It's important **not to overuse the console**: everything you don't write in a script, when you close, [**will be lost**]{.hl-orange}.

:::

:::
:::



::: callout-warning
## Be careful

`R` is [**case-sensitive**]{.hl-orange}: it is sensitive to uppercase and lowercase, so `x` and `X` represent different variables.

:::


---

## Running the first script

Now we have a **fourth window**: the window where we will [**write our codes**]{.hl-yellow}. How do we run it?

. . .

1. **Write the code** to be executed.

. . .

2. **Save the .R file** by clicking on `Save current document`.

. . .

3. The code does not execute unless we indicate it. We have **three options to run a script**:

- [**Copy and paste**]{.hl-yellow} into the console.
- [**Select lines**]{.hl-yellow} and press `Ctrl+Enter`
- [**Enable Source on Save**]{.hl-yellow} next to save: not only saves but also executes the **entire code**.

---


## Organizing: projects

Just as we usually work [**organized by folders**]{.hl-yellow} on the computer, in `RStudio` we can do the same to work [**efficiently by creating projects**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}

A [**project will be a "folder"**]{.hl-yellow} within `RStudio`, so our root directory will automatically be the project folder itself (allowing us to switch from one project to another using the top right menu).

We can create one in a new folder or in an existing folder."

:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::


---

## 💻 It's your turn {#tu-turno-0-1-1}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

📝 Create in your computer a folder of the subject and create inside it the `RStudio` project: it is there where you are going to save everything that we will do along this course, after creating the project you will have an `R Project` file. Then create in this folder two subfolders: `data` (this is where you will save the different datasets that we will use) and `scripts` (this is where you will save the `.R` files of each class).

### [**Exercise 2**]{.hl-yellow}

📝 Inside the project create a script `Exercises-class1.R` (inside the `scripts` folder). Once created, define in it a variable named `a` and whose value is -1. Execute the code in the (three) ways explained before.

```{r}
#| code-fold: true
a <- -1
```

### [**Exercise 3**]{.hl-yellow}

📝 Add below another line to define a variable `b` with the value 5. Then save the multiplication of both variables. Execute the code as you want.

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # without saving it
mult <- a * b # save it
```

### [**Exercise 4**]{.hl-yellow}

📝 Modify the code below to define two variables c and d, with values 3 and -1. Then divide the variables and save the result.

```{r}
#| eval: false
c <- # you should assign 3
d <- # you should assign -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d
div <- c / d
```

### [**Exercise 5**]{.hl-yellow}

📝 Assign to `x` a positive value and then compute its square root; assign to `y` a negative number and compute its absolute value using `abs()`.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

::: callout-note
## Note that...

Commands like `sqrt()`, `abs()` or `max()` are what we call [**functions**]{.hl-purple}: lines of code that we have "encapsulated" under a name, and given some input arguments, execute the commands (a sort of shortcut). In the functions the [**arguments will ALWAYS be enclosed in parentheses**]{.hl-yellow}

:::


### [**Exercise 6**]{.hl-yellow}

📝 Using the variable `x` already defined, complete/modify the code below to store in a new variable `z` the result stored in `x` minus 5.

```{r}
#| eval: false
z <- ? - ? # complete the code
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```

### [**Exercise 7**]{.hl-yellow}

📝 Define an `x` variable and assign it the value `-1`. Define another `y` and assign it the value `0`. Then perform the operations a) `x` by `y`; b) square root of `x`. What do you get?


```{r}
#| code-fold: true
#| eval: false
x <- -1
y <- 0

x / y
sqrt(x)
```

### [**Exercise 8**]{.hl-yellow}

📝 Write the code below in your script. Why do you think it doesn't work?

```{r}
#| error: true
x <- -1
y <- 0

X + y
```

:::



---

## From CELL to TABLE

What [**data type**]{.hl-yellow} can we have in each **cell of a table**?



![](img/celdas.jpg)

::: incremental

- [**Cell**]{.hl-yellow}: an individual piece of data of a specific type.
- [**Variable**]{.hl-yellow}: **concatenation** of values of the same type ([**vectors in R**]{.hl-purple}).
- [**Matrix**]{.hl-yellow}: concatenation of variables of the **same type and length**.
- [**Table**]{.hl-yellow}: concatenation of variables of [**different types but the same length**]{.hl-purple}
- [**List**]{.hl-yellow}: concatenation of variables of [**different types and different lengths**]{.hl-purple}
:::

---

## But first...best practices

Before we continue, it’s important to know something as soon as possible: [**starting with programming can be frustrating**]{.hl-yellow}

. . .

Just like when learning a new language, the first obstacle is not so much what to say but how to say it correctly. The same goes for `R`, so let’s [**standardize our programming style**]{.hl-yellow} as much as possible to avoid future errors.

. . .

* [**Tip 1**]{.hl-green}: [**assignment, evaluation, and comparison are not the same**]{.hl-yellow}. If you’ve noticed in `R`, we use `<-` to assign values to variables. We use `=` to evaluate function arguments and `==` to check if two elements are equal.

```{r}
#| eval: false
x <- 1 # asign
x = 1 # evaluation
x == 1 # comparison
```



---

## But first...best practices

* [**Tip 2**]{.hl-green}: program like you write. Just like when writing in Spanish, get used to incorporating [**spaces and line breaks**]{.hl-yellow} to avoid making your code hard to read (it's a good practice, not a requirement, because `R` does not process spaces).


```{r}
#| eval: false
x <- 1 # optimal
x<-1 # meh
x<- 1 # worst (make up your mind)
```

. . .

* [**Tip 3**]{.hl-green}: don’t be chaotic, [**standardize names**]{.hl-yellow}. Always get used to naming variables consistently. The only requirement is that **they must always start with a letter** (and without accents). The most recommended form is `snake_case`.



```{r}
#| eval: false
variable_in_snake_case
anotherHarderToReadFormat
there.are.people.who.use.this
Even_People_Here.Confusing_That_Do_Not_Deserve_Our_ATTENTION
```

---

## But first...best practices

* [**Tip 4**]{.hl-green}: make reading and writing easier, [**set limits**]{.hl-yellow}. In `Tools < Global Options`, you can customize some options in `RStudio`. In `Code < Display`, you can set `Show margin` to display an "imaginary" margin (not interacting with the code) to "force" you to make line breaks.

![](img/show_margin.jpg)


---

## But first...best practices

* [**Tip 5**]{.hl-green}: the [**tab key is your best friend**]{.hl-yellow}. In `RStudio`, there’s a wonderful tool: if you type part of a variable or function name and press tab, `RStudio` will autocomplete it for you.


![](img/tab-autocompletar.png)  


---

## But first...best practices

* [**Tip 6**]{.hl-green}: no single parentheses. Whenever you open a parenthesis, you must close it. To make this task easier, go to `Tools < Global Options < Code < Display` and enable the `Rainbow parentheses option`.

![](img/rainbow-parentheses.jpg)



---

## But first...best practices

* [**Tip 7**]{.hl-green}: pay attention to the left side. You will not only see the line of code you are on but also, in case of a [**syntax error**]{.hl-red}, `RStudio` will notify you.

![](img/rstudio-error-sintaxis.png)

* [**Tip 8**]{.hl-green}: try to [**always work by projects**]{.hl-yellow} (for this class, create a script `class1.R` in the project we created before)


&nbsp;

See more tips at <https://r4ds.had.co.nz/workflow-basics.html#whats-in-a-name>

---

## Cells: data types

Are there [**variables beyond numbers in data science**]{.hl-yellow}? For example, think about the data you might store about a person:


::: {.fragment .fade-up}
-  Age or weight will be a [**number**]{.hl-yellow}.

```{r}
age <- 33
```
:::

::: {.fragment .fade-up}
- Their name will be a string of [**text (known as string or char)**]{.hl-yellow}.

```{r}
name <- "javi"
```

:::

::: {.fragment .fade-up}
-   The answer to the question "Are you enrolled in the Faculty?" will be what we call a [**logical variable**]{.hl-yellow} (`TRUE` if enrolled or `FALSE` otherwise).


```{r}
enrolled <- TRUE
```
:::

::: {.fragment .fade-up}
-   Their date of birth will be precisely that, a [**date**]{.hl-yellow}.
:::

---

## Numerical variables {auto-animate="true"}

The simplest data (which we’ve already used) will be [**numeric variables**]{.hl-yellow}. To find out the [**data class in R**]{.hl-yellow} of a variable, we use the `class()` function.


```{r}
#| eval: false
#| code-line-numbers: "1"
a <- 5
```

---

## Numerical variables {auto-animate="true"}

The simplest data type (we have already used it) will be the [**numeric variables**]{.hl-yellow}. To know the [**data class in R**]{.hl-yellow} of a variable we have the function `class()`.


```{r}
#| eval: false
#| code-line-numbers: "2"
a <- 5
class(a)
```

. . .

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

To know its [**typology (format)**]{.hl-yellow} variable we have `typeof()`.

```{r}
typeof(1) # 1 value but stored as a real number (double precision)
typeof(as.integer(1)) # 1 value but stored as a floor number
```

::: callout-note
## Note that...

In `R` we have a collection of functions starting with `as.x()` that serve as [**conversion functions**]{.hl-yellow}: a data that was of one type, we convert it to type `x`.
:::

---


## Numerical variables

In addition to the "common" numbers we will have the [**plus/minus infinity**]{.hl-yellow} coded as `Inf` or `-Inf`.

```{r}
1/0
```

```{r}
-1/0
```

. . .

And values that [**are not real numbers**]{.hl-yellow} _not a number_ (indeterminacies, complexes numbers, etc) encoded as `NaN`.

```{r}
0/0
```

```{r}
sqrt(-2)
```



---

## Numerical variables

With numeric variables we can perform the [**arithmetic operations**]{.hl-yellow} of a calculator: adding (`+`)...

```{r}
a + b
```

. . .

...square root (`sqrt()`)...

```{r}
sqrt(a)
```

. . .

... power (`^2`, `^3`)...

```{r}
a^2
```

. . .

...absolute value (`abs()`), etc.

```{r}
abs(a)
```


---

## String variables

Let us imagine that, in addition to the age of a person we want to store his/her name: now the variable will be of type `character`.

```{r}
name <- "Javi"
class(name)
```

. . .

The [**text strings**]{.hl-yellow} are a type with which we obviously [**cannot perform arithmetic operations**]{.hl-red} (other operations such as pasting or locating patterns can be performed).

```{r}
#| error: true
name + 1 # error when we try to sum 1 to a text
```

. . .

::: callout-warning
## Reminder

Text variables (character or string) are [** ALWAYS in quotes**]{.hl-orange}: `TRUE` (logical, binary value) is not the same as `"TRUE"` (text).

:::

---

## First function: paste

As we have commented `R` we will call [**function**]{.hl-yellow} a piece of [**encapsulated code**]{.hl-yellow} under a name, and which depends on some input [**arguments**]{.hl-yellow}. Our first function will be `paste()`: given two strings, it allows us to paste them together.

```{r}
paste("Javi", "Álvarez")
```

. . .

Note that [**default**]{.hl-yellow} pastes strings with a space, but we can add an [**optional argument**]{.hl-yellow} to tell it the separator (in `sep = ...`). 

```{r}
paste("Javi", "Álvarez", sep = "*")
```

---

## First function: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}

How do I know [**what arguments does a function need**]{.hl-yellow}?

By typing `? paste` in the console, you will get a [**help**]{.hl-yellow} in the multipurpose panel, where you can see in its header what arguments the function already has [**default arguments**]{.hl-yellow} assigned to it.

:::
:::

. . .

There is a similar function called `paste0()` that pastes by default with `sep = “”` (without anything).

```{r}
paste0("Javi", "Álvarez")
```

---

## First function: paste

The arguments (and their detail) can also be consulted by **tabulating (after a comma)**.

![](img/tab-functions.png)

--- 

## Functions: default arguments

It is very important to understand the concept of [**default argument of a function**]{.hl-yellow} in `R`: it is a value that the function uses but sometimes we may not see because [**already has a value assigned**]{.hl-yellow}. 
```{r}
# Same
paste("Javi", "Álvarez")
paste("Javi", "Álvarez", sep = " ")
```

. . .

::: callout-note

The `=` operator is [**reserved for assigning arguments**]{.hl-yellow} within functions. For all other assignments, we will use `<-`.

:::

---

## First package: glue

A more intuitive way to work with text is to use the `{glue}` package: the first thing to do is to "buy the book" (if we have never done it before). After that [**load the package**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue") # just the first time
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

With the `glue()` function of that package we can use [**variables inside strings**]{.hl-yellow}. For example, "age is ... years old", where the age is stored in a variable.

```{r}
age <- 34
glue("I am {age} old")
```

. . .

Within the keys we can also [**execute operations**]{.hl-yellow}

```{r}
units <- "days"
glue("I am {age * 365} {units} old")
```

---

## Logical variables

Another fundamental type will be the [**logical or binary variables**]{.hl-yellow} (**two values**):

- `TRUE`: [**true**]{.hl-yellow} stored internally as a 1.

- `FALSE`: [**false**]{.hl-yellow} stored internally as a 0.

```{r}
single <- FALSE # Single? --> NO
class(single)
```

. . .

Since they are stored internally as binary variables, we can [**perform arithmetic operations**]{.hl-yellow} on them


```{r}
2 * TRUE
FALSE - 1
```

---

## Logical variables

As we will see shortly, logical variables can actually take a third value: `NA` or [**missing data**]{.hl-yellow}, representing *not available*, and it will be very common to find it within a database.

```{r}
missing <- NA
missing + 1
```


. . .

::: callout-important
## Important

Logical variables [**NOT text variables**]{.hl-red}: `"TRUE"` is a text, `TRUE` is a logical value.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Logical conditions

Logical values are usually the result of [**evaluate logical conditions**]{.hl-yellow}. For example, imagine that we want to [**check**]{.hl-yellow} whether a person is named Javi.


```{r}
name <- "María"
```


. . .

With the [**logical operator**]{.hl-yellow} `==` we ask if what we have stored on the left is [**same as**]{.hl-purple} what we have on the right: [**we ASK**]{.hl-yellow}

```{r}
name == "Javi"
```

. . .

With its opposite `!=` we ask [**if different**]{.hl-purple}.

```{r}
name != "Javi"
```

. . .

::: callout-note
## Note that...

It is not the same `<-` ([**assignment**]{.hl-yellow}) as `==` (we are [**asking**]{.hl-yellow}, it is a logical comparison).

:::

---

## Logical conditions

In addition to "equal to" versus "different" comparisons, also order comparisons such as [**less than**]{.hl-purple} `<`, [**greater than**]{.hl-purple} `>`, `<=` or `>=`.
**Is the person less than 32 years old?**

```{r}
age <- 34
age < 32 # less than 32 years old?
```

. . .

**Age is greater than or equal to 38 years?**

```{r}
age >= 38
```

. . .

**Is the saved name equal to Javi?**

```{r}
name <- "Javi"
name == "Javi"
```

---

## Date variables

A very special data type: the [**date type data**]{.hl-yellow}.

```{r}
date_char <- "2021-04-21"
```

It looks like a simple text string but [**should represent an instant in time**]{.hl-yellow}. What should happen if [**we add a 1 to a date**]{.hl-purple}?

. . .

```{r}
#| error: true
date_char + 1
```


Dates [**cannot be string/text**]{.hl-red}: we must convert the text string to date.

. . .

&nbsp;

To work with dates we will use the `{lubridate}` package, which we must install before we can use it.

```{r}
#| eval: false
install.packages("lubridate")
```

---

## Date variables

Once installed, of all the packages (books) that we have, we will indicate it to load this one concretely.

```{r}
library(lubridate) 
```

. . .

To [**convert to date type**]{.hl-yellow} we will use the `as_date()` function of the `{lubridate}` package (default in `yyyy-mm-dd` format).


&nbsp;

:::: columns
::: {.column width="50%"}

```{r}
#| error: true

# it's not a date, it's a text!
date_char + 1
class(date_char)
```

:::

::: {.column width="50%"}

```{r}
date <- as_date("2023-03-28")
date + 1
class(date)
```

:::

::::

---

## Date variables

In `as_date()` the default date format is `yyyy-mm-dd` so if the string is not entered correctly...

```{r}
as_date("28-08-2024")
```

. . .

For [**any other format we must specify it**]{.hl-yellow} in the optional argument `format = ...` such that `%d` represents days, `%m` months, `%Y` in 4-year format and `%y` in 2-year format.


```{r}
as_date("28-03-2023", format = "%d-%m-%Y")
as_date("28-03-23", format = "%d-%m-%y")
as_date("03-28-2023", format = "%m-%d-%Y")
as_date("28/03/2023", format = "%d/%m/%Y")
```


---

## Date variables

In this package we have very useful functions for [**date management**]{.hl-yellow}:

- With `today()` we can directly obtain the [**current date**]{.hl-purple}.

```{r}
today()
```

. . .

-  With `now()` we can obtain [**current date and time**]{.hl-purple}

```{r}
now()
```

. . .

- With `year()`, `month()` or `day()` we can [**extract year, month and day**]{.hl-purple}

```{r}
date_today <- today()
year(date_today)
month(date_today)
```

---

## Cheatsheets

![](img/lubridate.png)

::: callout-note
## More information

You have a pdf summary of the most important packages in the [**corresponding folder on campus**]{.hl-green}

:::

---

## 💻 It's your turn {#tu-turno-0-1-2}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

📝 Define a variable that stores your age (called `age`) and another with your name (called `name`).

```{r}
#| code-fold: true
age <- 34
name <- "Javi"
```

### [**Exercise 2**]{.hl-yellow}

📝 Check with this variable `age` if it is NOT 60 years old or if it is called `"Ornitorrinco"` (you must obtain logical variables as a result).

```{r}
#| code-fold: true
#| eval: false
age != 60 # different to
name == "Ornitorrinco" # equal to
```

### [**Exercise 3**]{.hl-yellow}

📝 Why does the lower code give an error?

```{r}
#| error: true
age + name
```


### [**Exercise 4**]{.hl-yellow}

📝 Define another variable called `siblings` that answers the question "do you have siblings?" and another variable that stores your date of birth (called `birth_date`).

```{r}
#| code-fold: true
siblings <- TRUE

library(lubridate) # if not before
birth_date <- as_date("1989-09-10")
```

### [**Exercise 5**]{.hl-yellow}

📝 Define another variable with your last name (called `surname`) and use `glue()` to have, in a single variable called `full_name`, your first and last name separated by a comma.

```{r}
#| code-fold: true
#| eval: false
surname <- "Álvarez Liébana"
full_name <- glue("{name}, {surname}")
full_name
```

### [**Exercise 6**]{.hl-yellow}

📝 From `birth_date` extract the month.

```{r}
#| code-fold: true
#| eval: false
month(birth_date)
```

### [**Exercise 7**]{.hl-yellow}

📝 Calculate the days that have passed since your birth date until today (with the birth date defined in Exercise 4).

```{r}
#| code-fold: true
#| eval: false
today() - birth_date
```
:::

# L2 : [databases]{.flow} {#clase-0-2}

[**Concatenating cells: vectors. First databases**]{style="color:#444442;"}

* [💻 Solved exercises: vectors](#tu-turno-0-2-1) 

* [💻 Solved exercises: matrix](#tu-turno-0-2-2) 

* [💻 Solved exercises: data.frame and tibble](#tu-turno-0-2-3) 

* [🐣 Workbook/case study I-II](#caso-practico-0-2-1)

* [📆 Planning](#planificacion)

---

## Vectors: concatenation

When working with data, we often have [**columns that represent variables**]{.hl-yellow}: we will refer to these as [**vectors**]{.hl-yellow}, which are a [**concatenation**]{.hl-purple} of cells (values) of the [**same type**]{.hl-purple} (similar to a column in a table).

. . .

The simplest way to create a vector is with the `c()` function (c stands for **concatenate**), and you just need to input the **elements within parentheses, separated by commas**.

```{r}
ages <- c(32, 27, 60, 61)
ages
```

. . .

::: callout-tip

An individual number `x <- 1` (or `x <- c(1)`) is actually a **vector of length one** --> everything we know how to [**do with a number, we can do with a vector of numbers**]{.hl-green}.

:::

---

## Vectors: concatenation

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}

As you can see now in the `environment`, we have a **collection of elements** stored.


```{r}
ages # ages = edades in spanish
```
:::
:::

. . .


The [**length of a vector**]{.hl-yellow} can be calculated with `length()`.


```{r}
length(ages)
```

. . .

We can also [**concatenate vectors**]{.hl-yellow} together (it repeats them one after another).

```{r}
c(ages, ages, 8)
```

---

## Numeric sequences

The most common type of vector is numeric, specifically, the well-known [**numeric sequences**]{.hl-yellow} (e.g., the days of the month), used among other things, to index loops.

. . .

The `seq(start, end)` function allows us to create a [**numeric sequence]**{.hl-yellow} from a starting element to an ending one, [**advancing one by one**]{.hl-purple}.


```{r}
seq(1, 31)
```

. . .

Note that if we try this with [**characters, it won't work**]{.hl-red} since there is no predefined order among text strings.

```{r}
#| error: true
"a":"z"
```

---

## Numeric sequences

A shortcut is the `1:n` command, which returns the same as `seq(1, n)`.


```{r}
1:7
```

If the starting element is greater than the ending one, it understands that the sequence is in [**descending order**]{.hl-purple}.

```{r}
7:-3
```

. . .

We can also define [**a different step**]{.hl-yellow} between consecutive elements with the `by = ...` argument.


```{r}
seq(1, 7, by = 0.5) # seq from 1 to 7, with a step of 0.5
```

---

## Numeric sequences

Sometimes we may want to define a [**sequence with a specific length**]{.hl-yellow}.


```{r}
seq(1, 50, l = 7) # seq from 1 to 50 with length equal to 7
```

. . .

We might also want to generate a vector of [**n repeated elements**]{.hl-yellow}.

```{r}
rep(0, 7) # vector of 7 0's
```

. . .

Since they are internally stored as numbers, we can also do this with [**dates**]{.hl-yellow}.


```{r}
seq(as_date("2023-09-01"), as_date("2023-09-10"), by = 1)
```


---

## String vectors

A vector is a **concatenation** of elements of the [**same type**]{.hl-yellow}, but they don't necessarily have to be numbers. Let's create a sample sentence.

```{r}
sentence <- "My name is Javi"
sentence
length(sentence)
```

. . .

In the previous case, it wasn't a vector, it was a single text element. To create a vector, we need to use `c()` again and separate elements with commas.


```{r}
sentence <- c("My", "name", "is", "Javi")
sentence
length(sentence)
```

---

## String vectors

What will happen if we [**concatenate elements of different types**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

Note that since all elements must be of the same type, what `R` does is [**convert**]{.hl-yellow} everything to text, violating the [**data integrity**]{.hl-red}.


. . .

```{r}
c(3, 4, TRUE, FALSE)
```

It's important to understand that logical values are actually [**internally stored as 0/1**]{.hl-yellow}.


---

## Operations with vectors

With numeric vectors, we can perform the same [**arithmetic operations**]{.hl-yellow} as with numbers → a [**number is a vector**]{.hl-purple} (of length one).

. . .

What will happen if we [**add or subtract a value**]{.hl-yellow} to a vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Warning

Unless otherwise specified, in `R`,  vector operations are always [**element by element**]{.hl-orange}.

:::

---

## Adding vectors

Vectors can also interact with each other, so we can define, for example, [**vector sums**]{.hl-yellow} (element by element).


```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Since the operation (e.g., a sum) is performed element by element, what will happen if we [**add two vectors of different lengths**]{.hl-yellow}?

. . .


```{r}
z <- c(1, 3, 5, 7)
x + z
```

What it does is [**recycle elements**]{.hl-yellow}: if we have a vector of 4 elements and we add another with 3 elements, it will recycle the elements from the shorter vector.

---

## Comparing vectors

A very common operation is to [**ask questions of the data**]{.hl-yellow} using [**logical conditions**]{.hl-purple}. For example, if we define a vector of temperatures...

[**Which days were below 22 degrees?**]{.hl-yellow}


```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

This will return a [**logical vector**]{.hl-yellow}, depending on whether **each element** meets the given condition (of the **same length** as the vector being queried).

. . .

If we had a [**missing value**]{.hl-yellow} (due to a sensor error that day), the evaluated condition would also be `NA`.


```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Comparing vectors

[**Logical conditions can be combined**]{.hl-yellow} in two ways:

- [**Intersection**]{.hl-yellow}: [**all**]{.hl-purple} concatenated conditions must be met ([**AND conjunction**]{.hl-purple} with `&`) to return `TRUE`.


```{r}
x < 30 & x > 15
```

- [**Union**]{.hl-yellow}: it is enough for [**at least one**]{.hl-purple} condition to be met ([**OR conjunction**]{.hl-purple} with `|`).


```{r}
x < 30 | x > 15
```

. . .

With `any()` and `all()`, we can check if [**all elements**]{.hl-yellow} satisfy the condition.

```{r}
any(x < 30)
all(x < 30)
```

---

## Getting elements

Another common operation is [**accessing or getting elements**]{.hl-yellow}. The simplest way is to use the `[i]`  operator (access the i-th element).

```{r}
ages <- c(20, 30, 33, NA, 61) 
ages[3] # get the age's third person
```

. . .

Since a number is just a vector of length one, this operation can also be applied using a [**vector of indices to select**]{.hl-yellow}.

```{r}
y <- c("hi", "how", "are", "you", "?")
y[c(1:2, 4)] # first, second and fourth element
```

. . .

::: callout-tip

To access the last element without worrying about its position, you can pass the vector's length as the index `x[length(x)]`.

:::

---

## Removing elements

Sometimes, instead of selecting, we may want to [**remove elements**]{.hl-yellow}. This is done with the same operation but using [**negative indexing**]{.hl-purple}: the opetator `[-i]` «un-select» the i-th element 

```{r}
y
y[-2] # everything except the second element
```


. . .

In many cases, we want to [**select or remove elements based on logical conditions**]{.hl-yellow}, depending on the values, so we will pass the condition itself as the index (remember, `x < 2` returns a logical vector).


```{r}
ages <- c(15, 21, 30, 17, 45)
names <- c("javi", "maría", "sandra", "carla", "luis")
names[ages < 18] # names of people under 18
```

---


## Stats operations

We can also make use of [**statistical operations**]{.hl-yellow}, such as `sum()`, which, given a vector, returns the sum of all its elements.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**What happens when a data point is missing?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

By default, if we have a missing data point, the [**operation will also result in a missing value**]{.hl-yellow}. To [**ignore that missing data**]{.hl-purple}, we use the optional argument `na.rm = TRUE`.


```{r}
sum(x, na.rm = TRUE)
```

---

## Stats operations

As we've mentioned, logical values are internally stored as 0 and 1, so we can use them in arithmetic operations.

For example, if we want to [**find out the number of elements that meet a condition**]{.hl-yellow} (e.g., less than 3), those that do will be assigned a 1 (`TRUE`), and those that don't will get a 0 (`FALSE`). Therefore, summing the logical vector will give us the number of elements that meet the condition.


```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Stats operations

Another common operation that can be useful is the [**cumulative sum**]{.hl-yellow} with `cumsum()`, which, given a vector, returns a vector where each element is the sum of the first, the first plus the second, the first plus the second plus the third, and so on.

```{r}
x <- c(1, 5, 2, -1, 8)
cumsum(x)
```

[**What happens when a data point is missing?**]{.hl-yellow}


```{r}
x <- c(1, -2, 3, NA, -1)
cumsum(x)
```

In the case of the cumulative sum, what happens is that [**from that point onward, all subsequent accumulated values will be missing**]{.hl-yellow}.

---

## Stats operations

Another common operation that can be useful is the [**difference (with delay)**]{.hl-yellow} with `diff()` which, given a vector, returns a vector with the second minus the first, the third minus the second, the fourth minus the third...and so on.


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x)
```

. . .

Using the argument `lag = ` we can indicate the [**delay**]{.hl-yellow} of this difference (e.g. `lag = 3` implies that the fourth minus the first, the fifth minus the second, etc.).


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x, lag = 3)
```

---

## Stats operations

Other common operations are [**mean**]{.hl-yellow}, [**median**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

- [**mean**]{.hl-yellow}: centrality measure that consists of adding all the elements and dividing by the number of elements added. The best known but the [**least robust**]{.hl-red}: given a set, if outliers (very large or very small values) are introduced, the mean is very easily perturbed.


```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Stats operations

Other common operations are [**mean**]{.hl-yellow}, [**median**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.


-   [**Median**]{.hl-yellow}: measure of centrality that consists of ordering the elements and keeping the one that occupies the middle.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Quantiles**]{.hl-yellow}: position measurements (they divide the data into equal parts).

```{r}
quantile(x) # by default quantiles/percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

---


## Sorting vectors

Finally, a common action is to know [**sort values**]{.hl-yellow}:

- `sort()`: returns the [**sorted vector**]{.hl-yellow}. By default from smallest to largest but with `decreasing = TRUE` we can change it.


```{r}
ages <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(ages)
sort(ages, decreasing = TRUE)
```

. . .

-   `order()`: returns the [**index vector**]{.hl-yellow} that we would have to use to have the vector ordered

```{r}
order(ages)
ages[order(ages)]
```

---

## 💻 It's your turn {#tu-turno-0-2-1}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

📝 Define the vector `x` as the concatenation of the first 5 odd numbers. Calculate the length of the vector

```{r}
#| code-fold: true
#| eval: false
# Two ways
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Exercise 2**]{.hl-yellow}

📝 Access the third element of `x`. Access the last element (regardless of length, a code that can always be executed). Delete the first element.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Exercise 3**]{.hl-yellow}

📝 Get the elements of `x` greater than 4. Calculate the vector `1/x` and store it in a variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Exercise 4**]{.hl-yellow}

📝 Create a vector representing the names of 5 people, one of whom is unknown.

```{r}
#| code-fold: true
#| eval: false
names <- c("Javi", "Sandra", NA, "Laura", "Carlos")
names
```

### [**Exercise 5**]{.hl-yellow}

📝 Find from the vector `x` of exercises above the elements greater (strictly) than 1 and less (strictly) than 7. Find a way to find out if all the elements are positive or not.


```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Exercise 6**]{.hl-yellow}

📝 Given the vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, why does its mean return not a number but what is shown in the code below?

```{r}
x <- c(1, -5, 8, NA, 10, -3, 9)
mean(x)
```

### [**Exercise 7**]{.hl-yellow}

📝 Given the vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extract the elements occupying the locations 1, 2, 5, 6. 

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
x[-2]
```

### [**Exercise 8**]{.hl-yellow}

📝 Given the `x` vector of the previous exercise, which ones have a missing data? Hint: the `is.something()` functions check if the element is of type `something` (press tab).


```{r}
#| code-fold: true
#| eval: false
is.na(x)
```


### [**Exercise 9**]{.hl-yellow}

📝 Define the vector `x` as the concatenation of the first 4 even numbers. Calculate the number of elements of `x` strictly less than 5.

```{r}
#| code-fold: true
#| eval: false
x[x < 5] 
sum(x < 5)
```


### [**Exercise 10**]{.hl-yellow}

📝 Calculate the vector `1/x` and obtain the ordered version (from smallest to largest) in the two possible ways

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Exercise 11**]{.hl-yellow}

📝 Calculate min and max of previous `x` vector

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Exercise 12**]{.hl-yellow}

📝 Find of the vector `x` the elements greater (strictly) than 1 and less (strictly) than 6. Find a way to find out if all the elements are negative or not.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

:::


---

## More with string variables

Although we cannot do arithmetic operations with them, some [**operations we can do with the text strings**]{.hl-yellow} will be important.

For that we will use in the future the `{stringr}` package (within the same `{lubridate}` "universe of packages", which we will talk about later).

```{r}
library(stringr)

# Find a correct phone format
phone_number <- c("611093", "292039", "628810585", "600917043")
str_detect(phone_number, pattern = "[6]{1}[0-9]{8}")
```

---

## First databases

When analyzing data we usually have [**several variables**]{.hl-yellow} for each individual: we need a "table" to collect them. The most immediate option is [**matrices**]{.hl-yellow}: concatenation of variables of [**same type and equal length**]{.hl-purple}.

Imagine we have heights and weights of 4 people. How to [**create a dataset with the two variables**]{.hl-yellow}?

. . .

The most common option is to use `cbind()`: [**concatenate (bind) vectors in the form of columns (c)**]{.hl-yellow}

```{r}
#| code-line-numbers: "3"
h <- c(150, 160, 170, 180)
w <- c(63, 70, 85, 95)
data_mat <- cbind(h, w)
data_mat 
```

---

## First databases

We can also [**build the matrix by rows**]{.hl-yellow} with the `rbind()` function (concatenate - bind - by rows - r), although it is [**recommended to have each variable in column**]{.hl-green} and individual in row as we will see later.

```{r}
rbind(h, w) # Matrix by rows
```

. . .

- We can [**"view" the matrix**]{.hl-yellow} with `View(matrix)`.

. . .

-   We can [**check dimensions**]{.hl-yellow} with `dim()`, `nrow()` and `ncol()`: matrices are a type of **tabular data** (organized in rows and columns).

```{r}
dim(data_mat)
nrow(data_mat)
ncol(data_mat)
```

---

## First databases

We can also [**"flip" (transposed matrix)**]{.hl-yellow} with `t()`.

```{r}
t(data_mat)
```

. . .

Since we now have two dimensions in our data, to [**access elements with `[]`**]{.hl-yellow} we must provide **two comma-separated indexes**: row and column indexes 

```{r}
data_mat[2, 1] # second row, first column
data_mat[1, 2] # first row, second column
```

---

## First databases

In some cases we will want to get the [**total data for an individual**]{.hl-yellow} (a particular row but all columns) or the values of [**a whole variable**]{.hl-yellow} for all individuals (a particular column but all rows). To do so, we leave [**one of the indexes**]{.hl-yellow} unfilled.

```{r}
data_mat[2, ] # second individual
data_mat[, 1] # first variable
```

. . .

Much of what we have learned with vectors we can do with matrices, so we can for example access multiple rows and/or columns using the [**sequences of integers 1:n**]{.hl-yellow}


```{r}
data_mat[c(1, 3), 1] # first variable for first and third individual
```


---

## First databases

We can also define a [**matrix from a numeric vector**]{.hl-yellow}, rearranging the values in the form of a matrix (knowing that the elements are [**placed by columns**]{.hl-purple}).

```{r}
z <- matrix(1:9, ncol = 3) 
z
```

. . .

We can even [**define an array of constant values**]{.hl-yellow}, e.g. of zeros (to be filled later)


```{r}
matrix(0, nrow = 2, ncol = 3)
```


---

## Matrix operations

With matrices it is the same as with vectors: when we apply an [**arithmetic operation we do it element by element**]{.hl-yellow}

```{r}
z/5
```

. . .

To perform [**operations in a matrix sense**]{.hl-yellow} we must add `%%%`, for example, to multiply matrices it will be `%*%`.

```{r}
z * t(z)
z %*% t(z)
```


---

## Matrix operations

We can also [**perform operations by columns/rows**]{.hl-yellow} without loops with the `apply()` function, and we will indicate as **arguments**

- the matrix
- the sense of the operation (`MARGIN = 1` for rows, `MARGIN = 2` for columns)
- the function to apply
- extra arguments needed by the function

. . .

For example, to apply an average to each variable, it will be `mean` applied with `MARGIN = 2` (same function for each column).

```{r}
# Mean for each column (MARGIN = 2)
apply(data_mat, MARGIN = 2, FUN = "mean")
```



---

## 💻 It's your turn {#tu-turno-0-2-2}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset

### [**Exercise 1**]{.hl-yellow}

📝 Modify the code below to define an `x` matrix of ones, with 3 rows and 7 columns.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Exercise 2**]{.hl-yellow}

📝 To the above matrix, add 1 to each number in the matrix and divide the result by 5. Then calculate its transpose

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
```

### [**Exercise 3**]{.hl-yellow}

📝 Why does the code below return such a warning message?

```{r}
#| warning: TRUE
matrix(1:15, nrow = 4)
```



### [**Exercise 4**]{.hl-yellow}

📝 Define the matrix `x <- matrix(1:12, nrow = 4)`. Then get the data of the first individual, the data of the third variable, and the element `(4, 1)`.

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # first row
x[, 3] # third column
x[4, 1] # (4, 1) element
```

### [**Exercise 5**]{.hl-yellow}

📝 Define a matrix of 2 variables and 3 individuals such that each variable captures the height and age of 3 persons, so that the age of the second person is unknown (absent). Then calculate the mean of each variable (we should get a number!).

```{r}
#| code-fold: true
#| eval: false
data <- cbind("age" = c(20, NA, 25), "h" = c(160, 165, 170))
apply(data, MARGIN = 2, FUN = "mean", na.rm = TRUE) # mean by columns

```

### [**Exercise 6**]{.hl-yellow}

📝 Why does the lower code return an error? What is wrong?

```{r}
#| error: true
mat <- cbind("age" = c(15, 20, 25), "names" = c("javi", "sandra", "carlos"))
mat
mat + 1
```

:::

---

## Second attempt: data.frame

Arrays have the same problem as vectors: if we put together data of different types, it [**data integrity is compromised**]{.hl-red} as it converts them (see the code below: the ages and the `TRUE/FALSE` are converted to text).


```{r}
#| code-line-numbers: "4-5"
ages <- c(14, 24, NA)
single <- c(TRUE, NA, FALSE)
names <- c("javi", "laura", "lucía")
mat <- cbind(ages, single, names)
mat
```

. . .

In fact, since they are not numbers, we can no longer perform arithmetic operations.

```{r}
#| error: true
mat + 1
```

---

## Second attempt: data.frame

In order to work with [**variables of different type**]{.hl-yellow} we have in `R` what is known as [**data.frame**]{.hl-yellow}: concatenation of variables of equal length but which can be of [**different type**]{.hl-purple}.

```{r}
table <- data.frame(ages, single, names)
class(table)
table
```

---

## Second attempt: data.frame

Since a `data.frame` is already an attempt at a `database` the variables are not mere mathematical vectors: [**they have a meaning**]{.hl-yellow} and we can (we must) [**give them names**]{.hl-purple} that describe their meaning.

```{r}
library(lubridate)
table <-
  data.frame("ages" = ages, "single" = single, "names" = names,
             "birth_date" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
table
```

---

## Second attempt: data.frame

[**We have our first data set!**]{.hl-yellow} (strictly speaking we can't talk about a database but for the moment it looks like one). You can visualize it by typing its name in console or with `View(table)`.

![](img/view_tabla.jpg)

---

## Get variables

If we want to access its elements, being again **tabulated data**, we can access as in the matrices ([**not recommended**]{.hl-red}): again [**we have two indexes**]{.hl-yellow} (rows and columns, leaving free the one we don't use)


```{r}
table[2, ]  # second row (all variables)
table[, 3]  # third column (all individuals)
table[2, 1] # first variable of the second individual
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}

But it also has the advantages of a [**database**]{.hl-yellow} : we can [**access the variables by name**]{.hl-purple} ([**recommended**]{.hl-green} since the variables can change position and now they have a meaning), putting the name of the table followed by the symbol `$` (with the **tab**, a menu of columns to choose from will appear).

:::
:::

---

## Ask functions

- `names()`: shows us the variable names

```{r}
names(table)
```

. . .

- `dim()`: shows dimensions (also `nrow()` and `ncol()`)

```{r}
dim(table)
```

. . .

-  Variables can be accessed by name

```{r}
table[c(1, 3), "names"]
table$names[c(1, 3)]
```

---

## Add a variable

If we have one already created and we want to [**add a column**]{.hl-yellow} it is as simple as using the `data.frame()` function we have already seen to concatenate the column. Let's add for example a new variable, the number of siblings of each individual.

```{r}
# add a new column
siblings <- c(0, 2, 3)
table <- data.frame(table, "n_sib" = siblings)
table
```

---

## Last attempt: tibble

Tables in `data.frame` format have some [**limitations**]{.hl-red}. The main one is that [**does not allow recursion**]{.hl-red}: imagine that we define a database with heights and weights, and we want a third variable with the BMI.


```{r}
#| error: true
data.frame("height" = c(1.7, 1.8, 1.6), "weight" = c(80, 75, 70),
           "BMI" = weight / (height^2))
```

. . .


Hereafter we will use the `tibble` ([**enhanced data.frame**]{.hl-yellow}) format from the `{tibble}` package.

```{r}
library(tibble)
data_tb <- 
  tibble("height" = c(1.7, 1.8, 1.6), "weight" = c(80, 75, 70), "BMI" = weight / (height^2))
class(data_tb)
data_tb
```

---

## Last attempt: tibble

```{r}
data_tb <- 
  tibble("height" = c(1.7, 1.8, 1.6), "weight" = c(80, 75, 70), "BMI" = weight / (height^2))
class(data_tb)
data_tb
```

Las tablas en formato `tibble` nos permitirá una [**gestión más ágil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

- [**Metainformation**]{.hl-yellow}: if you look at the header, it automatically tells us the number of rows and columns, and the type of each variable

. . .

- [**Recursivity**]{.hl-yellow}: allows you to define the variables sequentially (as we have seen)



---

## Last attempt: tibble

- [**Consistency**]{.hl-yellow}: if you access a column that does not exist, it warns you with a warning

```{r}
#| warning: true
data_tb$invent
```

. . .

- [**By rows**]{.hl-yellow}: create by rows (copy and paste from a table) with `tribble()`.

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
The `{datapasta}` package allows us to [**copy and paste**]{.hl-green} tables from web pages and simple documents.
:::


---


## In summary...

- Each [**cell can be of a different type**]{.hl-yellow}: numbers, text, dates, logical values, etc. A [**vector is a concatenation of cells**]{. hl-yellow} (the future columns of our tables) --> In `R` by default operations are done [**element to element**]{.hl-yellow}.

. . .

- A [**matrix**]{.hl-yellow} allows us to concatenate [**variables of the SAME type and SAME length**]{.hl-yellow} --> tabular data.

. . .

- A [**data.frame**]{.hl-yellow} allows us to concatenate [**variables of DIFFERENT type and SAME length**]{.hl-yellow} --> we will use [**tibble**]{.hl-yellow} as an enhanced database option.

---

## 💻 It's your turn {#tu-turno-0-2-3}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset

### [**Exercise 1**]{.hl-yellow}

📝 Load from the `{datasets}` package the `airquality` dataset (New York air quality variables from May through September 1973). Is the airquality dataset of type tibble? If not, convert it to tibble (look in the package documentation at <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Exercise 2**]{.hl-yellow}

📝 Once converted to `tibble` get the name of the variables and the dimensions of the data set. How many variables are there? How many days have been measured?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```


### [**Exercise 3**]{.hl-yellow}

📝 Filters only the data of the fifth observation

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, ]
```

### [**Exercise 4**]{.hl-yellow}

📝 Filter only the data for the month of August. How to tell it that we want only the rows that meet a specific condition?

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, ]
```

### [**Exercise 5**]{.hl-yellow}

📝 Select those data that are not from July or August.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month != 7 & Month != 8, ]
airquality_tb[!(Month %in% c(7, 8)), ]
```

### [**Exercise 6**]{.hl-yellow}

📝 Modify the following code to keep only the ozone and temperature variables (no matter what position they are).

```{r}
#| eval: false
airquality_tb[, 3]
```

### [**Exercise 7**]{.hl-yellow}

📝 Select the temperature and wind data for August. 

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, c("Temp", "Wind")]
```

### [**Exercise 8**]{.hl-yellow}

📝 Translate the name of the variables into your native language.


```{r}
#| code-fold: true
#| eval: false
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```

:::


---

## 🐣 Case study I {#caso-practico-0-2-1}

In the `{datasets}` package (already installed by default) we have several datasets and one of them is `airquality`. Below I have extracted 3 variables from that dataset (note that it is done with `data$variable`, that dollar will be important in the future).The data captures [**daily measurements (n = 153 observations) of air quality**]{.hl-yellow} in New York, from May to September 1973. Six **6 variables** were measured: ozone levels, solar radiation, wind, temperature, month and day.

```{r}
library(datasets)
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

Try to answer the questions posed in the [**workbook**](https://javieralvarezliebana.quarto.pub/intro-r-base-tibbles-mucss/)


---

## 🐣 Case study II {#caso-practico-0-2-2}

We will consider the `surveys.RData` file in which we have all poll surveys for Spain from 1982 to 2019.

```{r}
load(file = "./data/surveys.RData")
survey_data
```


Try to answer the questions posed in the [**workbook**](https://javieralvarezliebana.quarto.pub/intro-r-base-tibbles-mucss/)



# L3: [functions, flow and Quarto]{.flow} {#clase-0-3}

[**Flow structures: if-else and loops. Functions in R. Quarto**]{style="color:#444442;"}

* [💻 Solved exercises: if-else](#tu-turno-0-3-1) 

* [💻 Solved exercises: loops](#tu-turno-0-3-2)

* [💻 Solved exercises: functions](#tu-turno-0-3-3)

* [🐣 Workbook/case study I-II-III](#caso-practico-0-3-1)

* [📆 Planning](#planificacion)

---

## Flow structures

A [**flow or control structure**]{.hl-yellow} consists of a series of commands oriented to [**decide the path**]{.hl-yellow} that your code must follow

* If condition A is met, what happens?

* What if B happens?

* How can I repeat the same expression (depending on a variable)?

. . .

If you have programmed before, you may be familiar with what are known as [**conditional structures**]{.hl-yellow} such as `if (bla bla) {...} else {...}` or [**loops**]{.hl-yellow} `for/while` (to be avoided whenever possible).

---

## If

One of the most famous control structures are those known as [**conditional structures**]{.hl-yellow} `if`.

> IF a set of conditions is met (TRUE), then execute whatever is inside the curly brackets.


For example, the structure `if (x == 1) { code A }` what it will do is [**execute code A in braces**]{.hl-yellow} but [**ONLY IF**]{.hl-purple} the [**condition in brackets is true**]{.hl-purple} (only if `x` is 1). In any other case, it will do nothing

. . .

For example, let's define a vector of ages of 8 people


```{r}
ages <- c(14, 17, 24, 56, 31, 20, 87, 73)
ages < 18
```

---

## If


Our conditional structure will do the following: [**if there is a minor, it will print**]{.hl-yellow} a message.

```{r}
if (any(ages < 18)) { 
  
  print("There is a minor")
  
}
```

---

## If

```{r}
#| eval: false
if (any(ages < 18)) { 
  
  print("There is a minor")
  
}
```


In case the [**conditions are not true**]{.hl-yellow} inside `if()` (`FALSE`), nothing happens.


```{r}
if (all(ages >= 18)) { 
  
  print("All of them are of legal age")
  
}
```

**We get no message** because the condition `all(ages >= 18)` is not `TRUE`, so it does not execute anything.

---

## If-else

The structure `if (condition) { code A }` can be combined with an `else { code B }`: when the [**condition is not checked**]{.hl-yellow}, it will [**execute the alternative code B**]{. hl-yellow} inside `else { }`, allowing us to decide what happens when it is satisfied and when it is not

. . .

For example, `if (x == 1) { code A } else { code B }` will execute A if `x` is equal to 1 and B in any other case.

```{r}
if (all(ages >= 18)) { 
  
  print("All of them are of legal age")
  
} else {
  
  print("There is a minor")
}
```

---

## If-else

Esta estructura `if - else` puede ser [**anidada**]{.hl-yellow}: imagina que queremos ejecutar un código si todos son menores; si no sucede, pero todos son mayores de 16, hacer otra cosa; en cualquier otra cosa, otra acción.

```{r}
if (all(ages >= 18)) { 
  
  print("All of them are of legal age")
  
} else if (all(ages >= 16)) {
  
  print("There is a minor but all of them are greater or equal to 16 years old")
  
} else { print("There are any persons under 16 years of age") }
```

::: callout-note
## Tip

You can **collapse the structures** by clicking on the left arrow in your script.

:::


---

## If-else vectorized


This conditional structure can be [**vectorized**]{.hl-yellow} (in a single line) with `if_else()` (from the `{dplyr}` package), whose arguments are

* the condition to evaluate

* what happens when it is met and when not

* an optional argument for when the condition to evaluate is `NA`

We will label without are greater/lesser and an `unknown` when we don't know.

```{r}
library(dplyr)
ages <- c(NA, ages)
if_else(ages >= 18, "legal age", "minor", missing = "unknown")
```

In `R` base there is `ifelse()`: it does not let you specify what to do with the absent ones but allows you to specify different types of data in `TRUE` and `FALSE`.

---

## 💻 It's your turn {#tu-turno-0-3-1}


[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset

### [**Exercise 1**]{.hl-yellow}

📝 What will be the output of the following code?

```{r}
#| eval: false
if_else(sqrt(9) < 2, sqrt(9), 0)
```

```{r}
#| eval: false
#| code-fold: true

The output is 0 since sqrt(9) equals 3, and since it is not less than 2, it returns the second argument which is 0.
```

### [**Exercise 2**]{.hl-yellow}

📝 What will be the output of the following code?

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true

The output is the vector c(0, NA, NA, 1) since sqrt(1) is less than 2, sqrt(9) is not, and in the case of both sqrt(NA) (root of absent) and sqrt(-1) (returns NaN, not a number), its square root cannot be checked whether it is less than 2 or not, so the output is NA.
```


### [**Exercise 3**]{.hl-yellow}

📝 Modify the code below so that, when the square root of a number cannot be verified to be less than 2, it returns -1.

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1, missing = -1)
```


### [**Exercise 4**]{.hl-yellow}

📝 What are the values of `x` and `y` of the lower code for `z <- 1`, `z <- -1` and `z <- -5`?

```{r}
#| eval: false
z <- -1
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
In the first case x = 1 and y = -1. In the second case x = 1 and y = 1. In the third case -1 and 2.
```


### [**Exercise 5**]{.hl-yellow}

📝 What will happen if we execute the code below?

```{r}
#| eval: false
z <- "a"
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| code-fold: true
#| eval: false

# will give error since it is not a numeric argument
Error in z^3 : non-numeric argument to binary operator
```


### [**Exercise 6**]{.hl-yellow}

📝 From the `{lubridate}` package, the `hour()` function returns the time of a given date, and the `now()` function returns the date and time of the current time. With both functions, have `cat()` (`cat()`) print “good night” only after 21:00.

```{r}
#| code-fold: true
#| eval: false

# loading library
library(lubridate)

# Current date-time
current_dt <- now()

# If structure
if (hour(current_dt) > 21) {
  
  cat("Good night") # print or cat (two ways of printing)
}
```


:::

---

## Loops

Although in most occasions they can be replaced by other more efficient and readable structures, it is important to know one of the most famous control expressions: the [**loops**]{.hl-yellow}.

* `for { }`: allows [**repeating the same code**]{. hl-yellow} in a [**prefixed and known number**]{.hl-purple} of times.

* `while { }`: allows [**repeating the same code**]{.hl-yellow} but in an [**undetermined number of times**]{.hl-purple} (until a **condition** is no longer fulfilled).


---

## For loop {auto-animate="true"}

A [**for**]{.hl-yellow} loop is a structure that allows to [**repeat**]{.hl-yellow} a set of commands a [**finite, prefixed and known number of times**]{.hl-purple} given a set of indices.

Let's define a vector `x <- c(0, -7, 1, 4)` and another empty variable `y`. After that we will define a for loop with `for () { }`: inside the brackets we will indicate an index and some values to traverse, inside the braces the code to execute in each iteration (in this case, fill `y` as `x + 1`).


```{r}
x <- c(0, -7, 1, 4)
y <- c()
```

---

## For loop {auto-animate="true"}

A [**for**]{.hl-yellow} loop is a structure that allows to [**repeat**]{.hl-yellow} a set of commands a [**finite, prefixed and known number of times**]{.hl-purple} given a set of indices.

Let's define a vector `x <- c(0, -7, 1, 4)` and another empty variable `y`. After that we will define a for loop with `for () { }`: inside the brackets we will indicate an index and some values to traverse, inside the braces the code to execute in each iteration (in this case, fill `y` as `x + 1`).


```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  
}
```

---

## For loop {auto-animate="true"}

A [**for**]{.hl-yellow} loop is a structure that allows to [**repeat**]{.hl-yellow} a set of commands a [**finite, prefixed and known number of times**]{.hl-purple} given a set of indices.

Let's define a vector `x <- c(0, -7, 1, 4)` and another empty variable `y`. After that we will define a for loop with `for () { }`: inside the brackets we will indicate an index and some values to traverse, inside the braces the code to execute in each iteration (in this case, fill `y` as `x + 1`).


```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
```

---

## For loop

Note that because `R` works in a [**default vector**]{.hl-yellow} manner, the loop is the same as doing `x + 1` directly.

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
y

y2 <- x + 1
y2
```

---

## For loop

Another common option is to indicate the indexes “automatically”: from the first `1` to the last (corresponding to the length of x `length(x)`).

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:length(x)) {
  y[i] <- x[i] + 1
}
y

```


---

## For loop

Thus the [**general structure of a for-loop**]{.hl-yellow} will always be as follows

```{r}
#| eval: false
for (index in set) { 
  código (usually depending on index)
}
```

In the case of for loops [**ALWAYS**]{.hl-green} we know how many iterations we have (as many as there are elements in the set to be indexed).

---

## Avoiding loop

As we have already learned with the `{microbenchmark}` package, we can check how [**loops are usually very inefficient**]{.hl-yellow} (hence we should avoid them in most occasions)

```{r}
library(microbenchmark)
x <- 1:1000
microbenchmark(y <- x^2, 
               for (i in 1:100) { y[i] <- x[i]^2 },
               times = 500)
```

---
 
## For loop


We can see another example of a [**combining numbers and text**]{.hl-yellow} loop: we define a vector of ages and names, and print the i-th name and age.

```{r}
names <- c("Javi", "Sandra", "Carlos", "Marcos", "Marta")
ages <- c(33, 27, 18, 43, 29)

for (i in 1:5) { 
  
  print(glue("{names[i]} are {ages[i]} old")) 
  
}
```


---

## For loop

Although they are usually indexed with numeric vectors, loops can be [**indexed on any vector structure**]{.hl-yellow}, regardless of the type of the set.

```{r}
library(stringr)
week_days <- c("monday", "tuesday", "wednesday", "thursday",
               "friday", "saturday", "sunday")

for (days in week_days) {
  
  print(days)
}
```

---

## For + if-else

Let's **combine conditional structures and loops**: using the `swiss` set of the `{datasets}` package, let's assign `NA` if the fertility values are greater than 80.

```{r}
for (i in 1:nrow(swiss)) {
  
  if (swiss$Fertility[i] > 80) { 
    
    swiss$Fertility[i] <- NA
    
  }
}
```

. . .

This is «the same» as a vectorized `if_else()`.

```{r}
data("swiss")
swiss$Fertility <- if_else(swiss$Fertility > 80, NA, swiss$Fertility)
```


---

## While loop

Another way to create a loop is with the `while { }` structure, which will loop [**an unknown number of times**]{.hl-yellow}, until a condition [**stops being met**]{.hl-yellow} (in fact it may never end). For example, we will inialize a variable `times <- 1`, which we will increment at each step, and we will not exit the loop until `times > 3`.

```{r}
times <- 1
while(times <= 3) {
  
  print(glue("Not yet, we are in the {times}-th iteration")) 
  times <- times + 1
  
}
print(glue("Now! We are in the {times}-th iteration")) 
```

---

## While loop

A `while` loop will always look like this

```{r}
#| eval: false
while(condition) {
  
  code to be executed while condition is TRUE
  # usually some variable is updated here
  
}
```

---
  
## While loop

What happens when the [**condition is never FALSE**]{.hl-yellow}? Try it yourself

```{r}
#| eval: false
while (1 > 0) {
  
  print("Press ESC to exit")
  
}
```

&nbsp;

::: callout-warning
## Warning

A `while { }` loop can be quite “dangerous” if we do not control well how to stop it.

:::

---

## While loop

We have two reserved commands to [**abort a loop or force it forward**]{.hl-yellow}:

* `break`: allows [**abort a loop**]{.hl-yellow} even if its end has not been reached

```{r}
for(i in 1:10) {
  if (i == 3) {
    
    break # if i = 3, we abort
    
  }
  print(i)
}
```

---

## While loop

We have two reserved commands to [**abort a loop or force it forward**]{.hl-yellow}:

* `next`: [**forces a loop to advance to the next iteration**]{.hl-yellow} 

```{r}
for(i in 1:5) {
  if (i == 3) {
    
    next # if i = 3, we advance to the next iteration
    
  }
  print(i)
}
```


---


## 💻 It's your turn {#tu-turno-0-3-2}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}


::: panel-tabset

### [**Exercise 1**]{.hl-yellow}

📝 Modify the code below to print a message on the screen if and only if all the data in `airquality` is for a month other than January.

```{r}
#| eval: false
library(datasets)
months <- airquality$Month

if (months == 2) {
  print("No data in January")
}
```

```{r}
#| code-fold: true
#| eval: false
library(datasets)
months <- airquality$Month

if (all(months != 1)) {
  print("No data in January")
}
```


### [**Exercise 2**]{.hl-yellow}

📝 Modify the code below to store in a variable called `temp_high` a `TRUE` if any of the records has a temperature above 90 degrees Fahrenheit and `FALSE` in any other case.

 
```{r}
#| eval: false
temp <- airquality$Temp

if (temp == 100) {
  print("Some of the records have temperatures in excess of 90 degrees Fahrenheit")
}
```

 
```{r}
#| eval: false
#| code-fold: true
# Option 1
temp <- airquality$Temp
temp_high <- FALSE
if (any(temp > 90)) {
   temp_high <- TRUE
}

# Option 2
temp_high <- any(airquality$Temp > 90)
```

### [**Exercise 3**]{.hl-yellow}

📝 Modify the code below to design a `for` loop of 5 iterations that only loops through the first 5 odd (and at each step of the loop prints them)

```{r}
#| eval: false
for (i in 1:5) {
  
  print(i)
}
```

```{r}
#| eval: false
#| code-fold: true
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i)
}
```

### [**Exercise 4**]{.hl-yellow}

📝 Modify the code below to design a `while` loop that starts with a counter `count <- 1` and stops when it reaches 6

```{r}
#| eval: false
count <- 1
while (count == 2) {
  
  print(count)
}
```

```{r}
#| eval: false
#| code-fold: true
count <- 1
while (count < 6) {
  
  print(count)
  count <- count + 1
  
}
```


:::


---

## Own functions {auto-animate="true"}

Not only can we use **default functions** that come already loaded in packages, we can also [**create our own functions**]{.hl-yellow} to **automate tasks**. How to [**create our own function**]{.hl-purple}? Let's look at its **basic scheme**:

* [**Name**]{.hl-yellow}: for example `name_fun` (no spaces or strange characters). To the name we [**assign the reserved word**]{.hl-yellow} `function()`.

* Define [**input arguments**]{.hl-yellow} (inside `function()`).

* [**Body**]{.hl-yellow} of the function inside `{ }`.

* We end the function with the [**output arguments**]{.hl-yellow} with `return()`.


```{r}
#| eval: false
name_fun <- function() {
  
}
```

---

## Own functions {auto-animate="true"}

Not only can we use **default functions** that come already loaded in packages, we can also [**create our own functions**]{.hl-yellow} to **automate tasks**. How to [**create our own function**]{.hl-purple}? Let's look at its **basic scheme**:

* [**Name**]{.hl-yellow}: for example `name_fun` (no spaces or strange characters). To the name we [**assign the reserved word**]{.hl-yellow} `function()`.

* Define [**input arguments**]{.hl-yellow} (inside `function()`).

* [**Body**]{.hl-yellow} of the function inside `{ }`.

* We end the function with the [**output arguments**]{.hl-yellow} with `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
}
```

---

## Own functions {auto-animate="true"}

Not only can we use **default functions** that come already loaded in packages, we can also [**create our own functions**]{.hl-yellow} to **automate tasks**. How to [**create our own function**]{.hl-purple}? Let's look at its **basic scheme**:

* [**Name**]{.hl-yellow}: for example `name_fun` (no spaces or strange characters). To the name we [**assign the reserved word**]{.hl-yellow} `function()`.

* Define [**input arguments**]{.hl-yellow} (inside `function()`).

* [**Body**]{.hl-yellow} of the function inside `{ }`.

* We end the function with the [**output arguments**]{.hl-yellow} with `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  code to be executed
  
}
```

---


## Own functions {auto-animate="true"}

Not only can we use **default functions** that come already loaded in packages, we can also [**create our own functions**]{.hl-yellow} to **automate tasks**. How to [**create our own function**]{.hl-purple}? Let's look at its **basic scheme**:

* [**Name**]{.hl-yellow}: for example `name_fun` (no spaces or strange characters). To the name we [**assign the reserved word**]{.hl-yellow} `function()`.

* Define [**input arguments**]{.hl-yellow} (inside `function()`).

* [**Body**]{.hl-yellow} of the function inside `{ }`.

* We end the function with the [**output arguments**]{.hl-yellow} with `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  code to be executed
  
  return(var_output)
  
}
```


---

## Own functions

* `arg1, arg2, ...`: will be the [**input arguments**]{.hl-yellow}, the arguments that the function takes to execute the code inside.

* `code`: lines of code that we want to [**execute the function**]{.hl-yellow}.

* `return(var_output)`: the [**output arguments**]{.hl-yellow} will be entered.


```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # Code to be executed
  code
  
  # Output
  return(var_output)
  
}
```

::: callout-important
## Important

All variables that we define inside the function are [**LOCAL variables: they will only exist inside the function**]{.hl-yellow} unless we specify otherwise.

:::

---

## Own functions {auto-animate="true"}

Let's look at a very simple example of a function for [**calculating the area of a rectangle**]{.hl-yellow}.

Since the area of a rectangle is calculated as the **product of its sides**, we will need just that, its sides: those will be the [**input arguments**]{.hl-yellow} and the [**value to return**]{.hl-purple} will be just its **area** ($side_1 * side_2$).

```{r}
# We define the name of function and input arguments
compute_area <- function(side_1, side_2) {
  
}
```

---


## Own functions {auto-animate="true"}

Let's look at a very simple example of a function for [**calculating the area of a rectangle**]{.hl-yellow}.

Since the area of a rectangle is calculated as the **product of its sides**, we will need just that, its sides: those will be the [**input arguments**]{.hl-yellow} and the [**value to return**]{.hl-purple} will be just its **area** ($side_1 * side_2$).

```{r}
# We define the name of function and input arguments
compute_area <- function(side_1, side_2) {
  
  area <- side_1 * side_2
  
}
```

---


## Own functions {auto-animate="true"}

Let's look at a very simple example of a function for [**calculating the area of a rectangle**]{.hl-yellow}.

Since the area of a rectangle is calculated as the **product of its sides**, we will need just that, its sides: those will be the [**input arguments**]{.hl-yellow} and the [**value to return**]{.hl-purple} will be just its **area** ($side_1 * side_2$).

```{r}
# We define the name of function and input arguments
compute_area <- function(side_1, side_2) {
  
  area <- side_1 * side_2
  return(area)
  
}
```

---

## Own functions

We can also make a direct definition of variables **without storing along the way**.

```{r}
# We define the name of function and input arguments
compute_area <- function(side_1, side_2) {
  
  return(side_1 * side_2)
  
}
```

. . .

[**How to apply our function?**]{.hl-yellow}

```{r}
compute_area(5, 3) # area of 5 x 3 rectangle
compute_area(1, 5) # area of 1 x 5 rectangle
```

---

## Own functions

::: callout-tip

Although it is not necessary, it is [**recommendable to make explicit the calling of the arguments**]{.hl-green}, specifying in the code what value is for each argument so that it does not depend on its order, making the code more readable.

:::


```{r}
compute_area(side_1 = 5, side_2 = 3) # area of 5 x 3 rectangle
compute_area(side_2 = 3, side_1 = 5) # area of 5 x 3 rectangle
```

---

## Default arguments

magine now that we realize that 90% of the time we use such a function to [**default calculate the area of a square**]{.hl-yellow} (i.e., we only need one side). To do this, we can define [**default arguments**]{.hl-yellow} in the function: they will take that value unless we assign another one.

Why not assign `side_2 = side_1` **default**, to save lines of code and time?

. . .

```{r}
compute_area <- function(side_1, side_2 = side_1) {
  
  # Code to be executed
  area <- side_1 * side_2
  
  # Output
  return(area)
  
}
```

---

## Default arguments


```{r}
compute_area <- function(side_1, side_2 = side_1) {
  
  # Code to be executed
  area <- side_1 * side_2
  
  # Output
  return(area)
  
}
```


Now [**default**]{.hl-yellow} the second side will be equal to the first (if added it will use both).


```{r}
compute_area(side_1 = 5) # square
compute_area(side_1 = 5, side_2 = 7) # rectangle
```

---
 

## Multiple outputs

Let's complicate the function a bit and add in the output the values of each side, labeled `side_1` and `side_2`, [**packing the output in a vector**]{.hl-yellow}.

```{r}
#| code-line-numbers: "7-8"
compute_area <- function(side_1, side_2 = side_1) {
  
  # Code
  area <- side_1 * side_2
  
  # Output
  return(c("area" = area, "side_1" = side_1, "side_2" = side_2))
  
}
```

---

## Multiple outputs

We can complicate the output a little more by adding a fourth variable that tells us, depending on the arguments, [**whether rectangle or square**]{.hl-yellow}, having to add a character (or logic) variable in the output.

```{r}
#| code-line-numbers: "7-9"
compute_area <- function(side_1, side_2 = side_1) {
  
  # Code
  area <- side_1 * side_2
  
  # Output
  return(c("area" = area, "side_1" = side_1, "side_2" = side_2,
           "type" = if_else(side_1 == side_2, "square", "rectangle")))
  
}
compute_area(5, 3)
```

. . .

[**Problem**]{.hl-red}: when trying to put numbers and text together, it converts everything to numbers. We could store it all in a `tibble()` as we have learned or in an object known in `R` as [**lists**]{.hl-yellow} (we will see it later).

---

## Order of arguments

Before we did not care about the order of the arguments, but now the [**order of the input arguments matters**]{.hl-yellow}, since we include `side_1` and `side_2` in the output. 

. . .

::: callout-note
## Tip

As mentioned, it is highly recommended to make the function call [**explicitly setting the arguments**]{.hl-yellow} to improve **legibility and interpretability**.

```{r}
# Equivalent to compute_area(5, 3)
compute_area(side_1 = 5, side_2 = 3)
```

:::

---

## Generating knowledge

It seems silly what we have done but we have crossed an important frontier: we have gone from [**consuming knowledge**]{.hl-yellow} (code from other packages, elaborated by others), to [**generating knowledge**]{.hl-purple}, creating our own functions.

. . .

Functions are going to be key in your day-to-day work because they will allow you to automate code that you are going to repeat over and over again: by packaging that code under an alias (function name) you will [**be able to use it over and over again without programming it (so doing twice as much work will not imply working twice as much)**]{.hl-yellow}

---

## Local vs global variables

An important aspect to think about with functions: what happens if we [**name a variable inside**]{.hl-yellow} a function to which we have **forgotten to assign** a value inside the function.

. . .

We must be cautious when using functions in `R`, since due to the [**"lexicographic rule ”**]{.hl-yellow}, if a variable is not defined inside the function, `R` will [**look for that variable in the environment**]{.hl-purple} of variables.


```{r}
x <- 1
fun_example <- function() {
    
  print(x) # No output, just doing an action
}
fun_example()
```

---

## Local vs global variables

If a variable [**is already defined outside the function (global environment)**]{.hl-yellow}, and is also used inside changing its value, the value [**only changes inside**]{.hl-yellow} but [**not in the global environment**]{.hl-red}.

```{r}
x <- 1
fun_example <- function() {
    
  x <- 2
  print(x) # value inside of function
}
```

```{r}
# value inside of function (local)
fun_example()
# value output of function (global)
print(x)
```

---

## Local vs global variables


If we want it to change locally as well as [**globally**]{.hl-yellow} we must use the [**double assignment**]{.hl-yellow} (`<<-`).

```{r}
x <- 1
y <- 2
fun_example <- function() {
  
  # no change in a global way, just locally
  x <- 3 
  # change in a global way
  y <<- 0 #<<
  
  print(x)
  print(y)
}

fun_example() # value inside function (local)
x # global value
y # global value
```

---


## 💻 It's your turn {#tu-turno-0-3-3}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset

### [**Ex 1**]{.hl-yellow}

📝 Modify the code below to define a function called `sum_function`, so that given two elements, it returns their sum.

```{r}
#| eval: false
name <- function(x, y) {
  sum_output <- # code
  return()
}
# we apply the function
sum_function(3, 7)
```

```{r}
#| code-fold: true
#| eval: false
sum_function<- function(x, y) {
  sum_output <- x + y
  return(sum_output)
}
sum_function(3, 7)
```

### [**Ex 2**]{.hl-yellow}

📝 Modify the code below to define a function called `product_function`, so that given two elements, it returns their product, but by default it calculates the square

```{r}
#| eval: false
name <- function(x, y) {
  prod_output <- # code
  return()
}
product_function(3)
product_function(3, -7)
```

```{r}
#| code-fold: true
#| eval: false
product_function <- function(x, y = x) {
  
  prod_output <- x * y
  return(prod_output)
  
}
product_function(3)
product_function(3, -7)
```

### [**Ex 3**]{.hl-yellow}

📝 Define a function called `equal_names` that, given two names, tells us if they are equal or not. Do this by considering case-sensitive, and case-insensitive. Use the `{stringr}` package.

```{r}
#| code-fold: true
#| eval: false
# Case-sensitive
equal_names <- function(person_1, person_2) {
  
  return(person_1 == person_2)
  
}
equal_names("Javi", "javi")
equal_names("Javi", "Lucía")

# Case-insensitive
equal_names <- function(person_1, person_2) {
  
  return(toupper(person_1) == toupper(person_2))
  
}
equal_names("Javi", "javi")
equal_names("Javi", "Lucía")
```

### [**Ex 4**]{.hl-yellow}

📝 Create a function called `compute_BMI` that, given two arguments (weight and height in meters) and a name, returns a list with the BMI ($weight/(height^2)$) and the name.

```{r}
#| code-fold: true
#| eval: false
compute_BMI <- function(name, weight, height) {
  
  return(list("name" = name, "BMI" = weight/(height^2)))
  
}
```

### [**Ex 5**]{.hl-yellow}

📝 Repeat the previous exercise but with another optional argument called units (by default, `units = “meters”`). Develop the function so that it does the right thing if `units = “meters”` and if `units = “centimeters”`.

```{r}
#| code-fold: true
#| eval: false
compute_BMI <- function(name, weight, height, units = "meters") {
  
  return(list("name" = name,
              "BMI" = weight / (if_else(units == "meters", height, height/100)^2)))
  
}
```

 
### [**Ex 6**]{.hl-yellow}

📝 Create a fictitious tibble of 7 persons, with three variables (invent name, and simulate weight, height in centimeters), and apply the defined function so that we obtain a fourth column with their BMI.

```{r}
#| code-fold: true
#| eval: false
data <-
  tibble("name" = c("javi", "sandra", "laura",
                       "ana", "carlos", "leo", NA),
         "weight" = rnorm(n = 7, mean = 70, sd = 1),
         "height" = rnorm(n = 7, mean = 168, sd = 5))

data |> 
  mutate(BMI = compute_BMI(name, weight, height, units = "centimeters")$BMI)
```


### [**Ex 7**]{.hl-yellow}

📝 Create a function called `shortcut` that has two numeric arguments `x` and `y`. If both are equal, you should return `equal` and have the function terminate automatically (think about when a function exits). WARNING: `x` and `y` could be vectors. If they are different (of equal length) calculate the proportion of different elements. If they are different (being of different length), it returns the elements that are not common.

```{r}
#| code-fold: true
#| eval: false
shortcut <- function(x, y) {
  
  if (all(x == y) & length(x) == length(y)) { return("equal") }
  else {
   
    if (length(x) == length(y)) {
      
      n_diff <- sum(x != y) / length(x)
      return(n_diff)
      
    } else {
      
      diff_elem <- unique(c(setdiff(x, y), setdiff(y, x)))
      return(diff_elem)
    }
    
  }
}
```


:::


---

## Communicate: rmd and Quarto

One of the [**main strengths**]{.hl-yellow} of `R` is the [**easiness to generate reports, books, webs, notes and even slides**]{.hl-yellow} (this same material for example). To do this, [**install**]{.hl-purple} before

::: columns
::: {.column width="40%"}
- the `{rmarkdown}` package (to generate `.rmd` files)

```{r}
#| eval: false
install.packages("rmarkdown")
```

- install [**Quarto**](https://quarto.org/docs/get-started/) (if you already knew `R`, the “new” `.rmd` now as `.qmd`)

:::

::: {.column width="60%"}
![](img/quarto.png)
:::
:::

---

## Communicate: rmd and Quarto

So far we have only programmed in scripts (`.R` files) within projects, but in many occasions [**we will not work alone**]{.hl-yellow} and we will need to [**communicate the results**]{.hl-yellow} in different formats:

- notes (for ourselves)
- slides
- web
- reports


For all this we will use [**Quarto**]{.hl-yellow} (see more in <https://ivelasq.quarto.pub/intro-to-quarto/>)

---

## Communicate: rmd and Quarto

The `.qmd` (or `.rmd` before) extension files will allow us to easily combine:- [**Markdown**]{.hl-yellow}: 

- [**typed language**]{.hl-purple} that allows us to create simple content (wordpress type, with text, **bold**, _cursives_, etc) with a readable layout.

. . .

- [**Math (latex)**]{. hl-yellow}: language for writing mathematical notation such as $x^2$ or $\sqrt{y}$ or $\int_{a}^{b} f(x) dx$.

. . .

- [**Code and outputs**]{.hl-yellow}: we can not only show the final step but also the code you have been doing (in `R`, `Python`, `C++`, `Julia`, ...), with [**code boxes called CHUNKS**]{.hl-purple}.

. . .

- Images, [**graphs**]{.hl-yellow}, tables, styles (css, js), etc.

---

## Communicate: rmd and Quarto

The main advantage of making this type of material in Quarto/Rmarkdown is that, by doing it from `RStudio`, you can generate a [**report or presentation without leaving the programming environment**]{.hl-yellow} in which you are working. This way you can analyze the data, summarize it and at the same time communicate it with the same tool.


. . .

Recently the `RStudio` team developed [**Quarto**]{.hl-yellow}, an improved version of Rmarkdown (`.qmd` files), with a slightly more aesthetic and simpler format. You have all the documentation and examples at [**https://quarto.org/**](https://quarto.org/)

---

## Quarto examples

::: panel-tabset
### Webs

![](./img/website.png){height="350"}

### Books

![](./img/book.png){height="350"}

### Blogs

![](./img/blog.png){height="350"}

### Slides

![](./img/presentation.png){height="350"}

### Journals

![](https://user-images.githubusercontent.com/163582/42351114-e5deaa1c-8078-11e8-90de-2aff57bba255.png){height="350"}
:::

Images obtained from <https://ivelasq.quarto.pub/intro-to-quarto/#/working-with-the-rstudio-visual-editor>

---

## Our first report

::: columns
::: {.column width="55%"}
![](img/quarto-create.png)
:::

::: {.column width="45%"}
We are going to create the [**first rmarkdown file with Quarto**]{.hl-yellow} with extension `.qmd`. For this we will only need to click on

`File << New File << Quarto Document`
:::
:::

---

## Our first report

:::: columns
::: {.column width="45%"}
![](img/quarto-format.png)
:::

::: {.column width="55%"}
After doing so, several [**output format options**]{.hl-yellow}:

- `.pdf` file

- `.html` file ([**recommendable**]{.hl-yellow}): dynamic document, allows user interaction, like a “web page”.

- `.doc` file (not recommended).


:::
::::

. . .

For the moment we will leave the [**default HTML format**]{.hl-yellow} checked, and we will write the [**title**]{.hl-yellow} of our document. After that we will have our [**file .qmd**]{.hl-yellow} (it is no longer an .R script like the ones we have opened so far).
---

## Our first report

:::: columns
::: {.column width="60%"}
![](img/quarto-example.png)
:::

::: {.column width="40%"}

You should have something similar to the image capture with [**two editing modes**]{.hl-yellow}: `Source` (with code, the recommended option until you master it) and `Visual` (more like a blog).

:::
::::

To [**run the WHOLE document**]{.hl-yellow} you must click `Render on Save` and hit save.

---

## Quarto output format

![](img/quarto-prueba-html.png)

You should have obtained an [**html output similar to this**]{.hl-yellow} (and a [**html file**]{.hl-yellow} has been generated on your computer).

---

## Editor: source vs visual

As indicated, you have two ways of working: with pure code and something similar to a Notion (blog).

![](./img/rstudio-source-visual.png)

Image retrieved from <https://ivelasq.quarto.pub/intro-to-quarto/#/working-with-the-rstudio-visual-editor>

---

## Our first report

:::: columns
::: {.column width="50%"}
![](img/quarto-example.png)

:::

::: {.column width="50%"}

A `.qmd` file is [**basically divided into three parts**]{.hl-yellow}:

* [**Header**]{.hl-yellow}: the part you have at the beginning between `---`.

* [**Text**]{. hl-yellow}: which we can format and enhance with bold (written as **bold**, with double asterisk at the beginning and end), italics (_cursive_, with underscore at the beginning and end) or highlight function or variable names from R. You can add equations like $x^2$ (I have written `$x^2$`, between dollars).

* [**R code**]{.hl-yellow}

:::
::::

---

## Header {auto-animate="true"}

The [**header is in YAML**]{.hl-yellow} format and contains the [**metadata**]{.hl-yellow} of the document.

:::: columns
::: {.column width="60%"}

* `title` and `subtitle`: the title/subtitle of the document
* `author`: author of the document
* `format`: output format (we can customize)
  * `theme`: if you have any style file
  * `toc`: if you want index or not
  * `toc-location`: index position
  * `toc-title`: index title
* `editor`: if you are in visual or source mode.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
format:
  html:
editor: visual
---
```

:::
::::

---

## Header {auto-animate="true"}

The [**header is in YAML**]{.hl-yellow} format and contains the [**metadata**]{.hl-yellow} of the document.

:::: columns
::: {.column width="60%"}

* `title` and `subtitle`: the title/subtitle of the document
* `author`: author of the document
* `format`: output format (we can customize)
  * `theme`: if you have any style file
  * `toc`: if you want index or not
  * `toc-location`: index position
  * `toc-title`: index title
* `editor`: if you are in visual or source mode.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier álvarez liébana"
format:
  html:
editor: visual
---
```

:::
::::

---

## Header {auto-animate="true"}

The [**header is in YAML**]{.hl-yellow} format and contains the [**metadata**]{.hl-yellow} of the document.

:::: columns
::: {.column width="60%"}

* `title` and `subtitle`: the title/subtitle of the document
* `author`: author of the document
* `format`: output format (we can customize)
  * `theme`: if you have any style file
  * `toc`: if you want index or not
  * `toc-location`: index position
  * `toc-title`: index title
* `editor`: if you are in visual or source mode.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier álvarez liébana"
format:
  html:
    style: style.css
    toc: true
editor: visual
---
```

:::
::::

---

## Header {auto-animate="true"}

The [**header is in YAML**]{.hl-yellow} format and contains the [**metadata**]{.hl-yellow} of the document.

:::: columns
::: {.column width="60%"}

* `title` and `subtitle`: the title/subtitle of the document
* `author`: author of the document
* `format`: output format (we can customize)
  * `theme`: if you have any style file
  * `toc`: if you want index or not
  * `toc-location`: index position
  * `toc-title`: index title
* `editor`: if you are in visual or source mode.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier álvarez liébana"
format:
  html:
    style: style.css
    toc: true
    toc-location: left
editor: visual
---
```

:::
::::

---

## Header {auto-animate="true"}

The [**header is in YAML**]{.hl-yellow} format and contains the [**metadata**]{.hl-yellow} of the document.

:::: columns
::: {.column width="60%"}

* `title` and `subtitle`: the title/subtitle of the document
* `author`: author of the document
* `format`: output format (we can customize)
  * `theme`: if you have any style file
  * `toc`: if you want index or not
  * `toc-location`: index position
  * `toc-title`: index title
* `editor`: if you are in visual or source mode.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier álvarez liébana"
format:
  html:
    style: style.css
    toc: true
    toc-location: left
    toc-title: Índice
editor: visual
---
```

:::
::::


---

## Text

Regarding typing there is only one [**important thing**]{.hl-yellow}: unless we indicate otherwise, [**EVERYTHING we are going to type is (normal)**]{.hl-yellow} text; no R code.

:::: columns
::: {.column width="35%"}
![](img/quarto-prueba-qmd2.png){width=350}
![](img/quarto-prueba-html2.png){width=320}
:::

::: {.column width="65%"}
We are going to start by writing a section at the beginning (`# Intro` and behind it, for example, the sentence

> This material has been designed by Professor Javier Álvarez Liébana, professor at the Complutense University of Madrid

In addition to the `Running Code` we will add a `#` pad: the [**outside-chunks**]{.hl-yellow} pads will help us create [**epigraphs (sections)**]{.hl-yellow} in the document.


:::
::::


---

## Index

:::: columns
::: {.column width="40%"}
![](img/quarto-indice-qmd-2.png){width=370}
![](img/quarto-indice-html2.png){width=370}
:::

::: {.column width="60%"}

To make the [**index capture those sections**]{.hl-yellow} we will modify the header of the file as shown in the image (you can change the location of the index and the title if you want to test).

:::
::::

---

## Text

Let's [**customize the text**]{.hl-yellow} a bit by doing the following:

:::: columns
::: {.column width="50%"}
![](img/quarto-texto-mejorado-qmd.png){width=370}
![](img/quarto-texto-mejorado-html.png){width=370}
:::

::: {.column width="50%"}

* We will add [**bold to the name**]{.hl-yellow} (putting ** at the beginning and at the end).

* We will add [**cursive**]{.hl-yellow} to the word material (putting _ at the beginning and at the end).

* We will add a [**link**]{.hl-yellow} <https://www.ucm.es>, associating it to the name of the University. To do this we put the title in square brackets and just behind the link in brackets `[“Universidad Complutense de Madrid”](https://www.ucm.es)`.

:::
::::

---

## Code

To [**include R code**]{.hl-yellow} we must create our [**code boxes called chunks**]{.hl-yellow}: high in the path in our markdown text where we can include code from almost any language (and its outputs).

&nbsp;

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-qmd.png){width=470}
:::

::: {.column width="50%"}

To include one you must go [**header**]{.hl-yellow} as follows you have a shortcut `Command + Option + I` (Mac) or `Ctrl + Shift + I` (Windows)

:::

::::

---

## Code

Inside this box (which now has a different color in the document) [**write code R**]{.hl-yellow} as we have been doing so far in the scripts.

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-1-qmd.png){width=410}
![](img/quarto-chunk-1-html.png){width=410}
:::

::: {.column width="50%"}

Let's for example define two variables and their sum in the following way, writing this code in our `.qmd` (inside that chunk)
 
```{r}
# R code
x <- 1
y <- 2
x + y
```

:::

::::


---

## Running chunks


:::: columns
::: {.column width="50%"}
![](img/quarto-tag-chunks-qmd.png){width=400}
![](img/quarto-tag-chunks-html.png){width=400}
:::

::: {.column width="50%"}

Chunks can have a [**name or tag**]{.hl-yellow}, so that we can reference them again to avoid repeating code.

:::
::::


---

## Running chunks

:::: columns
::: {.column width="40%"}
![](img/quarto-inline-qmd.png){width=400}
![](img/quarto-inline-html.png){width=380}
:::

::: {.column width="60%"}

In each chunk there are [**two buttons**]{.hl-yellow}:

* [**play**]{.hl-yellow} button: activates the [**play and exit of that particular chunk**]{.hl-yellow} (you can view it within your own `RStudio`)

* [**rewind**]{.hl-yellow} button: activates the [**play and exit of all chunks up to that one**]{.hl-yellow} (without reaching it).


&nbsp;

In addition we can [**include R code inside the text line**]{.hl-yellow} (instead of displaying the text x execute the R code displaying the variable).

:::
::::



---

## Customizing chunks

The [**chunks can be customized**]{.hl-yellow} with options at the beginning of the chunk preceded by `#|`:

* `#| echo: false`: [**execute code**]{.hl-green} and [**show result**]{.hl-green} but [**does not display code**]{.hl-red} in the output. hl-red} on output.

* `#| include: false`: [**executes code**]{.hl-green} but [**does not display result**]{.hl-red} and [**does not display code**]{.hl-red} on output.

* `#| eval: false`: [**does not execute code**]{. hl-red}, [**does not display result**]{.hl-red} but [**does display code**]{.hl-green} on output.

* `#| message: false`: [**executes code**]{.hl-green} but [**does not display output messages**]{.hl-red}.

* `#| warning: false`: [**runs code**]{.hl-green} but [**does not display warning messages**]{.hl-red}.

* `#| error: true`: [**runs code**]{.hl-green} and [**allows errors**]{.hl-green} displaying the error message in the output.


![](img/quarto-options-chunk.png){width=380}

These options can be applied chunk by chunk or set globally with `knitr::opts_chunk$set()` at the beginning of the document (within a chunk).

---

## Customizing chunks

If we want to apply the **option to all chunks by default** we must include it at the end of the header, as [**run options**]{.hl-yellow}

``` yaml
---
title: "¡Hola!"
format: html
editor: visual
execute:
  echo: false
---
```

---

## Organizing

In addition to text and code we can enter the following:

* [**Equations**]{.hl-yellow}: you can also add equations like $x^2$ (I have written `$x^2$`, the equation between dollars).

* [**Lists**]{. hl-yellow}: you can itemize elements by putting `* Step 1: ... *Step 2: ...`

* [**Cross-references**]{.hl-yellow}: you can tag parts of the document (the tag is constructed with `{#section-name}`) and then call them with `[Section](@section-name)`.

---

## Figures and images

:::: columns
::: {.column width="50%"}
![](img/quarto-fig-qmd.png){width=340}
![](img/quarto-fig-html.png){width=390}
:::

::: {.column width="50%"}


Finally, we can also [**add captions to graphics or images**]{.hl-yellow} by adding `#| fig-cap: "..."`.

:::
::::

. . .

:::: columns
::: {.column width="65%"}

Notice that the [**caption is in the margin**]{.hl-yellow} (for example). You can change it by entering [**header settings**]{.hl-yellow} (everything about figures starts with `fig-`, and you can see the options by tabbing). You have more information at **<https://quarto.org/>**

:::

::: {.column width="35%"}
![](img/quarto-cabecera-desplegable.png){width=400}
:::
::::

---

## Styles

:::: columns
::: {.column width="50%"}
![](img/quarto-estilos-qmd.png){width=400}
![](img/quarto-estilos-html.png){width=400}
:::

::: {.column width="50%"}

Finally you can add a [**custom theme**]{.hl-yellow} including a [**style file**]{.hl-yellow} (`.scss` or `.css` file). I have left one for you at <https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material>.

::: callout-important
## Important

The style file must be in the same folder as the `.qmd` file.

:::
:::
::::

---

## Styles

You can also do it in a simple way [**adding a bit of HTML**]{.hl-yellow} to the text. For example, to customize the color of a text it goes between square brackets and right after the text, between braces, the style options

``` html
This word is [red]{style="color:red;"} ...
```

``` html
... and this is [green in bold]{style="color:green; font-weight: bold;"}
```

. . .

This word is [red]{style="color:red;"} ...

... and this is [green in bold]{style="color:green; font-weight: bold;"}

---

## Revealjs

You can add some “animations” using what is known as Revealjs (javascript), specifying it in the header and using [**blocks**]{.hl-yellow} of that language delimited by `:::` at the beginning and end, and the word of the “tool” to use. For example `{.incremental}` transitions the elements.


``` yaml
format:
  revealjs
```
&nbsp;

``` revealjs
::: {.incremental}
- I
- am
- Javi
:::
```


::: {.incremental}
- I
- am
- Javi
:::

---

## Call blocks

You can also use the [**callout-blocks**]{.hl-yellow} which by default are `note`, `tip`, `warning`, `caution` and `important` (although you can create and customize them). To do this, just use `::{.callout-type}` and the type you want to use

``` html
:::{.callout-tip}

Note that there are five types of callouts, including: 
`note`, `tip`, `warning`, `caution`, and `important`.

:::
```

. . .

:::{.callout-tip}

Note that there are five types of callouts, including: 
`note`, `tip`, `warning`, `caution`, and `important`.

:::

. . .

:::{.callout-caution}

Use them wisely, sometimes a lot of aesthetic resources can be dizzying.

:::

---

## Multiple columns layout

With `:::: columns` we can define a layout of [**multiple columns**]{.hl-yellow} where each one is defined by `::: {.column width=“65%”} something :::`, indicating next to the percentage how much you want each column to occupy (be careful not to leave spaces!).

``` html
:::: columns
::: {.column width="65%"}
This is how to define a vector
:::
::: {.column width="35%"}
x <- c(1, 2, 3)
x
:::
::::
```
&nbsp;

. . .

:::: columns
::: {.column width="65%"}
This is how to define a vector
:::

::: {.column width="35%"}
```{r}
x <- c(1, 2, 3)
x
```
:::
::::


---

## Non-R code

In addition `{reticulate}` allows us to create `python` chunks inside a Quarto in `R` (see <https://quarto.org/docs/computations/python.html> to create jupyter notebooks directly from Quarto).


```{r}
#| echo: false
library(reticulate)
```

```{r}
#| eval: false
# install.packages("reticulate")
library(reticulate)

install_python("3.9.12") # Installing python if you have not done before

# Installing Python libraries
reticulate::py_install("numpy")
reticulate::py_install("matplotlib")
```

:::: columns
::: {.column width="60%"}

```{python}
#| eval: false
import numpy as np
import matplotlib.pyplot as plt
r = np.arange(0, 2, 0.05)
theta = 2 * np.pi * r
fig, ax = plt.subplots(
  subplot_kw = {'projection': 'polar'} 
)
ax.plot(theta, r)
plt.show()
```

:::

::: {.column width="40%"}

```{python}
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
r = np.arange(0, 2, 0.05)
theta = 2 * np.pi * r
fig, ax = plt.subplots(
  subplot_kw = {'projection': 'polar'} 
)
ax.plot(theta, r)
plt.show()
```

:::
::::

---


## 🐣 Case study I: flow structures {#caso-practico-0-3-1}

To practice control structures we are going to perform a [**simulation exercise**]{.hl-yellow}

&nbsp;

Try to answer the questions posed in the [**workbook**](https://javieralvarezliebana.quarto.pub/flow-structure)

---

## 🐣 Case study II: functions {#caso-practico-0-3-2}

Define a function called `temperature_converter` that, given a temperature in Fahrenheit, Celsius or Kelvin, converts it to any of the others

&nbsp;

Try to answer the questions posed in the [**workbook**](https://javieralvarezliebana.quarto.pub/flow-structures-functions)

---

## 🐣 Case study III: mock task {#caso-practico-0-3-3}

Let's perform a small simulation before delivery using the `starwars` dataset from the `{dplyr}` package.

![](https://sm.ign.com/t/ign_latam/screenshot/default/baby-yoda-nombre_3x56.1280.jpg)

---

## 🐣 Case study III: mock task

```{r}
library(dplyr)
starwars
```

We have **different variables of the Star Wars characters**, with characteristics of their hair, skin, height, name, etc.

---

## 🐣 Case study III: mock task

> Create a `.qmd` document with name, title, format and index. Each subsequent Exercise will be a subsection of the document. Run the chunks you consider and comment on the outputs to answer each question

. . .

> Exercise 1. How many characters are stored in the database? How many characteristics have been measured for each one?

. . .

> Exercise 2. Extract in two different variables `names` and `ages` the corresponding variables from the table. What type is the variable name? And the variable birth_year?

. . . 

> Exercise 3. Obtain the vector of names of the characters sorted from oldest to youngest.


---

## 🐣 Case study III: mock task

> Exercise 4. Get help from the unique() function. Use it to find out what modalities the qualitative variable for eye color has. How many different ones are there?

. . .

>  Exercise 5. Are there ANY missing values in the eye color variable?

. . .

> Exercise 6. Calculate the mean and standard deviation of the height and weight variables (watch out for missing values). Define a new tibble with these two variables and incorporate a third variable called “BMI” that calculates the body mass index. Incorporate with `$ $` the formula used for BMI.


# Final task: [foundations of R base]{.flow} {#clase-0-4}

[**Final task (70%)**: 10/09/2024 from 15:00 to 16:10]{style="color:#444442;"}

---

## Final task (intro R)

The day of the submission you will have uploaded a [**submission template**]{.hl-yellow} in `.qmd` format on campus.

1. **Unzip the folder** (important! if you don't unzip, even if you can edit the `.qmd`, you won't be able to generate the `. html`)

2. **Edit the header** with your name and ID

3. You must **fill in each chunk** with the code you consider (in some I have left hints) and **change** from `#| eval: false` to `#| eval: true` (if you remove them directly, by default it is already true)

4. You must **comment** with normal text what you consider to answer the questions.

5. It will be [**MANDATORY**]{.hl-yellow} to upload the generated `.html` file (only that file will be corrected) so render as you fill in the document, don't leave it to the end.




