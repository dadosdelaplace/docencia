---
title: "Series temporales"
subtitle: "Análisis de series temporales en R"
title-slide-attributes:
  data-background-image: img/time-series.jpg
  data-background-size: cover
  data-background-opacity: "0.35"
author: "Grado en Estadística Aplicada • Javier Álvarez Liébana"
affiliation: Facultad de Estudios Estadísticos (UCM)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier Álvarez Liébana</strong>](...) • Grado en Estadística Aplicada (UCM)"
    slide-number: c/t
execute:
  echo: true
---

::: r-fit-text
[¡Bienvenidos a la nave del tiempo!]{.flow}
:::

[**Dejad vuestras regresiones a un lado**]{style="color:#444442;"}

---

## ¡Buenas!

[**Correo**]{.hl-green}: **<javalv09@ucm.es>**. [**Despacho**]{.hl-green}: 722 (3ª planta). [**Tutorías (curso 2024-2025)**]{.hl-green}: ...

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
-   [**Javier Álvarez Liébana**]{.hl-yellow}, de Carabanchel (Bajo).

-   Licenciado en Matemáticas (UCM). [**Doctorado en estadística**]{.hl-yellow} (UGR).

-   Encargado de la [**visualización y análisis de datos covid**]{.hl-yellow} del Principado de Asturias (2021-2022).

-   Miembro de la [**Sociedad Española de Estadística e IO**]{.hl-yellow} y la [**Real Sociedad Matemática Española**]{.hl-yellow}.
:::
:::
:::


Actualmente, [**investigador y docente en la Facultad de Estadística de la UCM**]{.hl-yellow}. Divulgando por [**Twitter**](https://twitter.com/dadosdelaplace) e [**Instagram**](https://instagram.com/javieralvarezliebana)


---

## Objetivos

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
- Entender el [**concepto de serie temporal y sus diferencias con la regresión**]{.hl-yellow} → lo que te equivocaste ayer influye en lo que te equivocarás hoy

- Entender conceptos teóricos básicos de [**procesos estocásticos**]{.hl-yellow}

- Aprender a manejar [**paquetes estadísticos de R**]{.hl-yellow} de series temporales → la aplicabilidad de la teoría será tu valor en el futuro

- Introducirnos en la [**metodología Box-Jenkins**]{.hl-yellow} → los datos deben ser estacionarios



:::
:::
:::

---

## Evaluación


-   [**Evaluación continua**]{.hl-yellow}: [**3 entregas individuales a ordenador en clase (20%-25%-35%)**]{.hl-purple}, y una [**entrega individual teórica a papel en clase (20%)**]{.hl-purple}. [**Asistencia**]{.hl-yellow} no obligatoria pero se [**valorará positivamente**]{.hl-purple} la participación.

. . .

* [**Examen final**]{.hl-yellow}: la nota ponderará en función de tu evaluación continua.

  - [**Más de un 7**]{.hl-purple} -> podrás decidir **peso del final entre un 0% y un 100%** de la nota (es decir, [**no será obligatorio el final**]{.hl-yellow}).
  - [**Entre 6 y 7**]{.hl-purple} -> podrás decidir **peso del final entre un 35% y un 100%**.
  - [**Entre 5 y 6**]{.hl-purple} -> podrás decidir **peso del final entre un 60% y un 100%**.
  - [**Entre 3.5 y 5**]{.hl-purple} -> podrás decidir **peso del final entre un 80% y un 100%**.
  - [**Por debajo del 3.5**]{.hl-purple} -> el **peso del final será del 100%**
  
Si tienes que hacer el examen final, será **obligatorio presentarse y sacar más de un 3** para aprobar.

---

## Planificación entregas

* [**Entrega I (20%)**]{.hl-yellow}: 8 de octubre (120 minutos).

* [**Entrega II (25%)**]{.hl-yellow}: ... (120 minutos).

* [**Entrega III (35%)**]{.hl-yellow}: ... (120 minutos).

* [**Entrega teórica (20%)**]{.hl-yellow}: ... (120 minutos).

&nbsp;

* [**Examen final**]{.hl-yellow}: 14 de enero (10:00-13:30)

&nbsp;

Se podrán modificar las fechas por saturación con otras asignaturas siempre y cuando el/la delegado/a lo solicite con **más de 7 días de antelación**.



---

## Planificación {#planificacion}

::: column-screen-inset-right
::: {style="font-size:20px"}
|  CLASE | SEMANA | FECHAS | TOPIC | EJ. | WORKBOOK | ENTREGA | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
| [1-2](#clase-1) | S1 | 9-12 sep | Repaso de R | [💻](#tu-turno-1-1) [💻](#tu-turno-1-2) [💻](#tu-turno-1-3) [💻](#tu-turno-1-4) [💻](#tu-turno-1-5) | [🐣](#caso-practico-1-1) [🐣](#caso-practico-1-2) [🐣](#caso-practico-1-3) |  | 
| [3](#clase-2) | S1 | 12 sep | Repaso de estadística | [💻](#tu-turno-2-1) [💻](#tu-turno-2-2) |  [🐣](#caso-practico-2) |  |
:::
:::

---

## Materiales

* [**Diapositivas**]{.hl-yellow}: diapositivas en `Quarto` disponibles y actualizadas en **<https://javieralvarezliebana.es/docencia/time-series>**. En el menú de las diapositivas (abajo a la izquierda) tienes una [**opción para descargarlas en pdf**]{.hl-yellow} en `Tools`
  
&nbsp;

* [**Material**]{.hl-yellow}: [**cuadernos de trabajo**](https://javieralvarezliebana.es/docencia/time-series/material/) y materiales extras y **resúmenes de paquetes**

* [🗃 **Datos**]{.hl-yellow}: datasets que usaremos a lo largo de la asignatura, disponibles en **<https://javieralvarezliebana.es/docencia/time-series/material>**

* [📚 **Recursos de apoyo**]{.hl-yellow}: en inglés <https://r4ds.had.co.nz/> y en castellano <https://cdr-book.github.io/>, y <https://ivelasq.quarto.pub/intro-to-quarto/> para Quarto.

---

## Datasets

* [🗃 **Datos**]{.hl-yellow}: datasets que usaremos a lo largo de la asignatura, disponibles en **<https://javieralvarezliebana.es/docencia/time-series/material>**

&nbsp;

* `airquality` del paquete `{datasets}` (ya instalado por defecto):
medidas diarias (153 observaciones) de la calidad del aire en Nueva York, de mayo a septiembre de 1973. Se midieron **6 variables**: ozono, radiación solar, viento, temperatura, mes y día.


# Clases 1 y 2: [objetivos y repaso R]{.flow} {#clase-1}



[**Objetivos. Repaso de R**]{style="color:#444442;"}


* [💻 Ejercicios resueltos: repaso R](#tu-turno-1-1). [💻 Ejercicios resueltos: manejo de tibble](#tu-turno-1-2)
* [🐣 Workbook/caso práctico I](#caso-practico-1-1)
* [💻 Ejercicios resueltos: if-else y bucles](#tu-turno-1-3)
* [🐣 Workbook/caso práctico II](#caso-practico-1-2)
* [💻 Ejercicios resueltos: funciones](#tu-turno-1-4). [💻 Ejercicios resueltos: tidy data](#tu-turno-1-5)
* [🐣 Workbook/caso práctico III](#caso-practico-1-3)
* [📆 Planificación](#planificacion)

---

## ¿Qué es una serie temporal?

Durante la carrera es probable que hayas tratado con multitud de datos pero hay uno muy especial que trataremos en esta asignatura de manera diferente: las [**series temporales**]{.hl-yellow}.

. . .

Vamos a cargar el fichero `retiro_temp.csv` donde tenemos los datos de temperaturas diarios (AEMET) desde 1980 hasta 2024 de la estación instalada en El Retiro (Madrid).

```{r}
#| code-fold: true
library(readr) # de tidyverse
# en tidyverse, read_ en lugar de read.
# tendremos datos en formato tibble en lugar de data.frame
retiro <- read_csv(file = "./datos/retiro_temp.csv")
retiro
```

---

## ¿Qué es una serie temporal?


¿Qué analizar de estos datos?

. . .

:::: columns
::: {.column width="20%"}

Podemos por ejemplo visualizar un [**boxplot de las temperaturas medias de cada día**]{.hl-yellow} durante estos últimos 44 años...

:::

::: {.column width="80%"}

```{r}
#| code-fold: true
library(tidyverse)
ggplot(retiro) +
  geom_boxplot(aes(y = tmed)) +
  scale_y_continuous(labels =
                       scales::label_number(suffix = "ºC")) +
  theme_minimal() +
  labs(title = "Temperatura desde 1980 hasta 2024",
       x = "Cuatrimestre", y = "Temperatura media diaria")
```

:::
::::

---

## ¿Qué es una serie temporal?

:::: columns
::: {.column width="20%"}

... la densidad de la temperatura durante todo ese tiempo...

:::

::: {.column width="80%"}

```{r}
#| code-fold: true
ggplot(retiro) +
  geom_density(aes(x = tmed)) +
  scale_x_continuous(labels =
                       scales::label_number(suffix = "ºC")) +
  theme_minimal() +
  labs(title = "Temperatura desde 1980 hasta 2024",
       x = "Temperatura media diaria")
```

:::
::::

---

## ¿Qué es una serie temporal?

:::: columns
::: {.column width="20%"}

... pero también podríamos querer [**relacionar la temperatura media con el mes**]{.hl-yellow} (por ejemplo con una regresión)...

:::

::: {.column width="80%"}

```{r}
#| code-fold: true
ggplot(retiro |> 
         mutate(mes = as_factor(lubridate::month(fecha))) |> 
         summarise(mean_temp = mean(tmed, na.rm = TRUE),
                   .by = "mes")) +
  geom_col(aes(x = mes, y = mean_temp)) +
  theme_minimal() +
  labs(title = "Temperatura media por mes",
       x = "Mes", y = "ºC (media)")
```

:::
::::

---

## ¿Qué es una serie temporal?

:::: columns
::: {.column width="20%"}

... o analizar cómo la [**temperatura media va incrementándose en cada década**]{.hl-yellow}...

:::

::: {.column width="80%"}

```{r}
#| code-fold: true
ggplot(retiro |> 
         mutate(periodo =
                  if_else(fecha < as_date("1990-01-01"),
                          "1980-1990",
                          if_else(fecha < as_date("2000-01-01"),
                                  "1990-2000",
                                  if_else(fecha < as_date("2010-01-01"),
                                          "2000-2010",
                                          if_else(fecha < as_date("2020-01-01"),
                                          "2010-2020", "después de 2020")))))) +
  geom_boxplot(aes(x = periodo, y = tmed)) +
  theme_minimal() +
  labs(title = "Temperatura media según periodo",
       x = "periodo", y = "ºC (media)")
```

:::
::::

---

## ¿Qué es una serie temporal?

En todos ejemplos anteriores hemos analizado una [**variable continua (temperatura)**]{.hl-yellow} en función de una [**variable discreta o de grupo**]{.hl-purple} (periodo, década, etc). 

&nbsp;

. . .

¿Pero y si queremos relacionarla con una [**variable temporal "continua"**]{.hl-yellow} como es la propia fecha?

---

## ¿Qué es una serie temporal?

```{r}
#| code-fold: true
ggplot(retiro) +
  geom_line(aes(x = fecha, y = tmed), linewidth = 0.3, alpha = 0.7) +
  theme_minimal() +
  labs(title = "Temperatura media como SERIE TEMPORAL",
       x = "t (fecha)", y = "ºC (media)")
```

---

## ¿Qué es una serie temporal?


Fíjate bien...¿qué elementos detectas?

```{r}
#| code-fold: true
ggplot(retiro) +
  geom_line(aes(x = fecha, y = tmed), linewidth = 0.3, alpha = 0.7) +
  theme_minimal() +
  labs(title = "Temperatura media como SERIE TEMPORAL",
       x = "t (fecha)", y = "ºC (media)")
```

---

## ¿Qué es una serie temporal?

* [**Tendencia**]{.hl-yellow}: lo que ajustarías con un modelo clásico (por ejemplo, una regresión lineal) y representa el [**comportamiento global de la serie**]{.hl-purple}, algo así como un **nivel base respecto al que la serie oscila**.

(en nuestro caso: la temperatura global aumenta con el paso de los años)

```{r}
#| code-fold: true
ggplot(retiro, aes(x = fecha, y = tmed)) +
  geom_line(linewidth = 0.3, alpha = 0.7) +
  geom_smooth(method = "lm", se = FALSE) +
  theme_minimal() +
  labs(title = "Temperatura media como SERIE TEMPORAL",
       x = "t (fecha)", y = "ºC (media)")
```

---

## ¿Qué es una serie temporal?

* [**Estacionalidad**]{.hl-yellow}: al margen de esa tendencia general, si hacemos zoom, en muchas series podemos observar un [**patrón que se repite cada x unidades temporales**]{.hl-purple}. En el caso de la temperatura, hay un patrón anual: diciembre hace más frío que en agosto.

```{r}
#| code-fold: true
ggplot(retiro |> 
         filter(between(fecha, as_date("2020-01-01"), as_date("2023-12-31"))),
                aes(x = fecha, y = tmed)) +
  geom_line(linewidth = 0.3, alpha = 0.7) +
  geom_smooth(method = "loess") +
  theme_minimal() +
  labs(title = "Temperatura media diaria de 2020 a 2023",
       x = "t (fecha)", y = "ºC (media)")
```

---

## ¿Qué es una serie temporal?

* [**Atípicos**]{.hl-yellow}: como sucede siempre en estadística será importantísimo analizar y tratar los [**datos atípicos muy alejados de lo esperado**]{.hl-purple}. Por ejemplo, en nuestro caso, Filomena.

```{r}
#| code-fold: true
ggplot(retiro |> 
         filter(between(fecha, as_date("2020-01-01"), as_date("2023-12-31"))) |>
         mutate(filomena = between(fecha, as_date("2020-12-25"), as_date("2021-01-22"))),
                aes(x = fecha, y = tmed)) +
  geom_line(linewidth = 0.3, alpha = 0.7) +
  geom_point(aes(alpha = filomena), color = "#991545") +
  scale_alpha_manual(values = c(0, 1)) +
  guides(alpha = "none") +
  theme_minimal() +
  labs(title = "Temperatura media diaria de 2020 a 2023",
       x = "t (fecha)", y = "ºC (media)")
```

---

## ¿Qué es una serie temporal?

* [**Intervenciones**]{.hl-yellow}: incluso podría suceder que la serie tuviese un [**corte o salto en su comportamiento**]{.hl-purple}. Por ejemplo, imagina que de repente el aparato de medición empieza a medir +25 grados de la temperatura real.

```{r}
#| code-fold: true
ggplot(retiro |> 
         filter(between(fecha, as_date("2020-01-01"), as_date("2023-12-31"))) |>
         mutate(tmed = if_else(fecha <= "2021-12-31", tmed, tmed + 25))) +
  geom_line(aes(x = fecha, y = tmed), linewidth = 0.3, alpha = 0.7) +
  guides(alpha = "none") +
  theme_minimal() +
  labs(title = "Temperatura media diaria de 2020 a 2023",
       subtitle = "Error de +25ºC a partir de 2022",
       x = "t (fecha)", y = "ºC (media)")
```


---

## Ejemplos de series

En esta asignatura será fundamental un concepto: [**estacionariedad**]{.hl-yellow}. Diremos que una [**serie es estacionaria si oscila de manera estable con una media y varianza constante**]{.hl-yellow}.

![](https://estrategiastrading.com/wp-content/plugins/phastpress/phast.php/c2VydmljZT1pbWFnZXMmc3JjPWh0dHBzJTNBJTJGJTJGZXN0cmF0ZWdpYXN0cmFkaW5nLmNvbSUyRndwLWNvbnRlbnQlMkZ1cGxvYWRzJTJGMjAxNiUyRjEyJTJGbWVkaWFfZXN0YWNpb25hcmlhLnBuZyZjYWNoZU1hcmtlcj0xNjMyOTAyOTc5LTc5NjQmdG9rZW49M2Y0ZTg4NWMyZjM0NmE2MA.q.png)

![](https://estrategiastrading.com/wp-content/plugins/phastpress/phast.php/c2VydmljZT1pbWFnZXMmc3JjPWh0dHBzJTNBJTJGJTJGZXN0cmF0ZWdpYXN0cmFkaW5nLmNvbSUyRndwLWNvbnRlbnQlMkZ1cGxvYWRzJTJGMjAxNiUyRjEyJTJGaG9tb3NjZWRhc3RpY2lkYWQucG5nJmNhY2hlTWFya2VyPTE2MzI5MDI5NzktOTA0MyZ0b2tlbj1mNjhiMDIwYjg2NGE1M2Rl.q.png)

---

## Distintos objetivos

- [**Análisis descriptivo**]{.hl-yellow}
  - Visualización: ¿cómo son los datos? ¿Existe algún ausente o valor atípico?
  - ¿Se puede descomponer la serie en series más sencillas?
  
. . .

- [**Análisis probabilístico**]{.hl-yellow}:
  - ¿Existe un modelo teórico tal que lo que observamos sea simplemente una muestra dicho modelo probabilístico?
  - Aunque los datos sean aleatorios, ¿podemos modelizar de manera teórica alguna de sus característica?

. . .
 
- [**Predicción**]{.hl-yellow}
  - Conociendo su comportamiento pasado, ¿cuánto valdrá su valor mañana?
  - ¿Cuánto me estoy equivocando? ¿Cómo medir ese error?

---

## Bloques del curso

- [**Bloque I**]{.hl-yellow}: analisis exploratorio. [**Descomposición y suavizado**]{.hl-purple}

. . .

- [**Bloque II**]{.hl-yellow}: ¿qué son los [**prcesos estocásticos**]{.hl-purple}?

. . .

- [**Bloque III**]{.hl-yellow}: metodología [**Box-Jenkins**]{.hl-purple}

 . . .
 
- [**Bloque IV**]{.hl-yellow}: problemas ([**intervención, atípicos**]{.hl-purple}, ausentes, heterocedasticidad, ...


---

## Instalación de R

El lenguaje `R` será nuestra [**gramática y ortografía**]{.hl-yellow} (nuestras reglas de juego)

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra en <https://cran.r-project.org/> y selecciona tu sistema operativo.

-   [**Paso 2**]{.hl-yellow}: para Mac basta con que hacer click en el **archivo .pkg**, y abrirlo una vez descargado. Para sistemas Windows, debemos clickar en **install R for the first time** y después en **Download R for Windows**. Una vez descargado, abrirlo como cualquier archivo de instalación.

-   [**Paso 3**]{.hl-yellow}: abrir el ejecutable de instalación.
:::

. . .

::: callout-warning
Siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), [**asegúrate de tener conexión a internet**]{.hl-orange}.
:::


---

## Instalación de R Studio

`RStudio` será el [**Word**]{.hl-yellow} que usaremos para escribir (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra la [web oficial de RStudio](https://posit.co/download/rstudio-desktop/) (ahora llamado Posit) y selecciona la descarga gratuita.

-   [**Paso 2**]{.hl-yellow}: selecciona el ejecutable que te aparezca acorde a tu sistema operativo.

-   [**Paso 3**]{.hl-yellow}: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro y dejar que termine la instalación.
:::


---

## Scripts (documentos .R)


::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}
Un [**script**]{.hl-yellow} será el documento en el que programamos, nuestro archivo `.doc` (aquí con extensión `.R`) donde escribiremos las órdenes. Para **abrir nuestro primero script**, haz click en el menú en `File < New File < R Script`.

::: callout-warning
## Cuidado

Es importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habrás perdido**]{.hl-orange}.
:::

:::
:::



::: callout-warning
## Cuidado

`R` es [**case-sensitive**]{.hl-orange}: es sensible a mayúsculas y minúsculas por lo que `x` y `X` representa variables distintas.
:::


---

## Ejecutando el primer script

Ahora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros códigos**]{.hl-yellow}. ¿Cómo ejecutarlo?

. . .

1.  **Escribimos** el código a ejecutar.

. . .

2.  **Guardamos** el archivo .R haciendo click en `Save current document`.

. . .

3.  El código no se ejecuta salvo que se lo indiquemos. Tenemos **tres opciones de ejecutar un script**:

-   [**Copiar y pegar**]{.hl-yellow} en consola.
-   [**Seleccionar líneas**]{.hl-yellow} y `Ctrl+Enter`
-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el código **completo**.

---


## Sé organizado: proyectos

De la misma manera que en el ordenador solemos trabajar de manera [**ordenada por carpetas**]{.hl-yellow}, en `RStudio` podemos hacer lo mismo para trabajar de [**manera eficaz creando proyectos**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
Un [**proyecto será una «carpeta»**]{.hl-yellow} dentro de `RStudio`, de manera que nuestro directorio raíz automáticamente será la propia carpeta de proyecto (pudiendo pasar de un proyecto a otro con el menu superior derecho).

Podemos crear uno en una carpeta nueva o en una carpeta ya existente.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::


---

## Buenas prácticas


* [**Tip 1**]{.hl-green}: [**asignar, evaluar y comparar no es lo mismo**]{.hl-yellow}. Si te has fijado en `R` estamos usando `<-` para asignar valores a variables. Usaremos `=` para evaluar argumentos en funciones y `==` para saber si dos elementos son iguales.

```{r}
#| eval: false
x <- 1 # asignar
x = 1 # evaluar
x == 1 # comparar
```

. . .

* [**Tip 2**]{.hl-green}: programa como escribes. Al igual que cuando redactas en castellano, acostúmbrate a incorporar [**espacios y saltos de línea**]{.hl-yellow} paranoquedarteciego (es una buena práctica y no un requisito porque `R` no procesa los espacios)

```{r}
#| eval: false
x <- 1 # óptimo
x<-1 # regu
x<- 1 # peor (decídete)
```

---

## Buenas prácticas


* [**Tip 3**]{.hl-green}: no seas caótico, [**estandariza nombres**]{.hl-yellow}, acostúmbrate siempre a hacerlo igual. El único requisito es que **debe empezar siempre por una letra** (y sin tildes). La forma más recomendable es la conocida como `snake_case`

```{r}
#| eval: false
variable_en_modo_snake_case
otraFormaMasDificilDeLeer
hay.gente.que.usa.esto
Incluso_Haygente.Caotica_que.NoMereceNuestraATENCION
```

. . .

* [**Tip 4**]{.hl-green}: facilita la lectura y escritura, [**pon márgenes**]{.hl-yellow}. En `Tools < Global Options` puedes personalizar algunas opciones de `RStudio`. En `Code < Display` podemos indicarle en `Show margin`  (no interacciona con el código).

![](img/show_margin.jpg){height="200"}


---

## Buenas prácticas

* [**Tip 5**]{.hl-green}: el [**tabulador es tu mejor amigo**]{.hl-yellow}. En `RStudio` tenemos una herramienta maravillosa: si escribes parte del nombre de una variable o función y tabulas, `RStudio` te autocompleta

![](img/tab-autocompletar.png)  


---

## Buenas prácticas

* [**Tip 6**]{.hl-green}: ni un paréntesis soltero. Siempre que abras un paréntesis deberás cerrarlo. Para facilitar esta tarea entra en `Tools < Global Options < Code < Display` y activa la opción `Rainbow parentheses`

![](img/rainbow-parentheses.jpg)



---

## Buenas prácticas

* [**Tip 7**]{.hl-green}: fíjate en el lateral izquierdo. No solo podrás ver la línea de código por la que vas sino que, en caso de estar cometiendo un [**error de sintaxis**]{.hl-red}, el propio `RStudio` te avisará.

![](img/rstudio-error-sintaxis.png)

* [**Tip 8**]{.hl-green}: intenta [**trabajar siempre por proyectos**]{.hl-yellow} (para esta clase, crea un script `clase2.R` en el proyecto que creamos en la anterior clase)

&nbsp;

Ver más tips en <https://r4ds.had.co.nz/workflow-basics.html#whats-in-a-name>

---

## Tipos de datos

¿Existen [**variables más allá de los números en la ciencia de datos**]{.hl-yellow}? Piensa por ejemplo en los datos que podrías guardar de una persona:

::: {.fragment .fade-up}
-   La edad o el peso será un [**número**]{.hl-yellow}.

```{r}
edad <- 33
```
:::

::: {.fragment .fade-up}
-   Su nombre será una cadena de [**texto (conocida como string o char)**]{.hl-yellow}.

```{r}
nombre <- "javi"
```
:::

::: {.fragment .fade-up}
-   A la pregunta «¿estás matriculado en la Facultad?» la respuesta será lo que llamamos una [**variable lógica**]{.hl-yellow} (`TRUE` si está matriculado o `FALSE` en otro caso).

```{r}
matriculado <- TRUE
```
:::

::: {.fragment .fade-up}
-   Su fecha de nacimiento será precisamente eso, una [**fecha**]{.hl-yellow}, un tipo de variable **crucial en esta asignatura**
:::

---


## Variables de fecha

Un tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.

```{r}
fecha_char <- "2021-04-21"
```

Parece una simple cadena de texto pero [**debería representar un instante en el tiempo**]{.hl-yellow}. ¿Qué debería suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?

. . .

```{r}
#| error: true
fecha_char + 1
```


Las fechas [**NO pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha.

. . .

&nbsp;

Para trabajar con fechas usaremos el paquete `{lubridate}`, que deberemos instalar antes de poder usarlo.

```{r}
#| eval: false
install.packages("lubridate")
```

---

## Variables de fecha

Una vez instalado, de todos los paquetes (libros) que tenemos, le indicaremos que nos cargue ese concretamente.

```{r}
library(lubridate) # instala si no lo has hecho
```

. . .

Para [**convertir a tipo fecha**]{.hl-yellow} usaremos la función `as_date()` del paquete `{lubridate}` (por defecto en formato `yyyy-mm-dd`)

&nbsp;

:::: columns
::: {.column width="50%"}

```{r}
#| error: true
# ¡no es una fecha, es un texto!
fecha_char + 1
class(fecha_char)
```

:::

::: {.column width="50%"}

```{r}
fecha <- as_date("2023-03-28")
fecha + 1
class(fecha)
```

:::

::::

---

## Variables de fecha

En `as_date()` el formato de fecha por defecto es `yyyy-mm-dd` así si la cadena de texto no se introduce de manera adecuada...

```{r}
as_date("28-03-2023")
```

. . .

Para [**cualquier otro formato debemos especificarlo**]{.hl-yellow} en el argumento opcional `format = ...` tal que `%d` representa días, `%m` meses, `%Y` en formato de 4 años y `%y` en formato de 2 años.

```{r}
as_date("28-03-2023", format = "%d-%m-%Y")
as_date("28-03-23", format = "%d-%m-%y")
as_date("03-28-2023", format = "%m-%d-%Y")
as_date("28/03/2023", format = "%d/%m/%Y")
```


---

## Variables de fecha

En dicho paquete tenemos funciones muy útiles para [**manejar fechas**]{.hl-yellow}:

-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.

```{r}
today()
```

. . .

-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}

```{r}
now()
```

. . .

-   Con `year()`, `month()` o `day()` podemos [**extraer el año, mes y día**]{.hl-purple}

```{r}
fecha <- today()
year(fecha)
month(fecha)
```

---

## Resúmenes de paquetes

![](img/lubridate.png)

::: callout-note
## Amplia contenido

Tienes un resumen en pdf de los paquetes más importantes en la [**carpeta correspondiente en el campus**]{.hl-green}
:::

---

## Vectores: concatenar

Cuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenación**]{.hl-purple} de celdas (valores) del [**mismo tipo**]{.hl-purple} (lo que sería una columna de una tabla).

. . .

La forma más sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus **elementos entre paréntesis y separados por comas**

```{r}
edades <- c(32, 27, 60, 61)
edades
```

. . .

::: callout-tip
Un número individual `x <- 1` (o bien `x <- c(1)`) es en realidad un **vector de longitud uno** --> todo lo que sepamos [**hacer con un número podemos hacerlo con un vector de ellos**]{.hl-green}.
:::


---

## 💻 Tu turno {#tu-turno-1-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Define el vector `x` como la concatenación de los 5 primeros números impares. Calcula la longitud del vector

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Accede al tercer elemento de `x`. Accede al último elemento (sin importar la longitud, un código que pueda ejecutarse siempre). Elimina el primer elemento.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Obtén los elementos de `x` mayores que 4. Calcula el vector `1/x` y guárdalo en una variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Crea un vector que represente los nombres de 5 personas, de los cuales uno es desconocido.

```{r}
#| code-fold: true
#| eval: false
nombres <- c("Javi", "Sandra", NA, "Laura", "Carlos")
nombres
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Encuentra del vector `x` de ejercicios anteriores los elementos mayores (estrictos) que 1 Y ADEMÁS menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Ejercicio 6**]{.hl-yellow}

📝 Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`,  ¿por qué su media no devuelve un número sino lo que se muestra en el código inferior?

```{r}
x <- c(1, -5, 8, NA, 10, -3, 9)
mean(x)
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6. 

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
x[-2]
```

### [**Ejercicio 8**]{.hl-yellow}

📝 Dado el vector `x` del ejercicio anterior, ¿cuales tienen un dato ausente? Pista: las funciones `is.algo()` comprueban si el elemento es tipo `algo` (tabula)

```{r}
#| code-fold: true
#| eval: false
is.na(x)
```


### [**Ejercicio 9**]{.hl-yellow}

📝 Define el vector `x` como la concatenación de los 4 primeros números pares. Calcula el número de elementos de `x` menores estrictamente que 5.

```{r}
#| code-fold: true
#| eval: false
x[x < 5] 
sum(x < 5)
```


### [**Ejercicio 10**]{.hl-yellow}

📝 Calcula el vector `1/x` y obtén la versión ordenada (de menor a mayor) de las dos formas posibles

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```


### [**Ejercicio 11**]{.hl-yellow}

📝 Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 6. Encuentra una forma de averiguar si todos los elementos son o no negativos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

:::

---

## Primera base de datos

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una «tabla» que las recopile. La opción más inmediata son las [**matrices**]{.hl-yellow}: concatenación de variables del [**mismo tipo e igual longitud**]{.hl-purple}.

Imagina que tenemos estaturas y pesos de 4 personas. ¿Cómo [**crear un dataset con las dos variables**]{.hl-yellow}?

. . .


La opción más habitual es usando `cbind()`: [**concatenamos (bind) vectores en forma de columnas (c)**]{.hl-yellow}

```{r}
#| code-line-numbers: "3"
estaturas <- c(150, 160, 170, 180)
pesos <- c(63, 70, 85, 95)
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

---

## Primer intento: matrices

También podemos [**construir la matriz por filas**]{.hl-yellow} con la función `rbind()` (concatenar - bind - por filas  - rows), aunque lo [**recomendable es tener cada variable en columna**]{.hl-green} e individuo en fila como luego veremos.

```{r}
rbind(estaturas, pesos) # Construimos la matriz por filas
```

. . .

-   Podemos [**comprobar las dimensiones**]{.hl-yellow} con `dim()`, `nrow()` y `ncol()`: las matrices son un tipo de **datos tabulados** (organizados en filas y columnas)

```{r}
dim(datos_matriz)
nrow(datos_matriz)
ncol(datos_matriz)
```

---

## Segundo intento: data.frame

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte (fíjate en el código inferior: las edades y los `TRUE/FALSE` los ha convertido a texto)

```{r}
#| code-line-numbers: "4-5"
edades <- c(14, 24, NA)
soltero <- c(TRUE, NA, FALSE)
nombres <- c("javi", "laura", "lucía")
matriz <- cbind(edades, soltero, nombres)
matriz
```

. . .

De hecho al no ser números ya no podemos realizar operaciones aritméticas

```{r}
#| error: true
matriz + 1
```

---

## Segundo intento: data.frame

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos en `R` lo que se conoce como [**data.frame**]{.hl-yellow}: concatenación de variables de igual longitud pero que pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
tabla <- data.frame(edades, soltero, nombres)
class(tabla)
tabla
```

---

## Segundo intento: data.frame

Dado que un `data.frame` es ya un intento de «base de datos» las variables no son meros vectores matemáticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple} que describan su significado

```{r}
library(lubridate)
tabla <-
  data.frame("edad" = edades, "estado" = soltero, "nombre" = nombres,
             "f_nacimiento" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
tabla
```


---

## Intento final: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}. La principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```

. . .


En adelante usaremos el formato `tibble` ([**data.frame mejorado**]{.hl-yellow}) del paquete `{tibble}`

```{r}
library(tibble)
datos_tb <- 
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
class(datos_tb)
datos_tb
```

---

## Intento final: tibble

```{r}
datos_tb <-
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
datos_tb
```

Las tablas en formato `tibble` nos permitirá una [**gestión más ágil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

-   [**Metainformación**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya automáticamente el número de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

---

## Intento final: tibble

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
datos_tb$invent
```

. . .

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de páginas web y documentos sencillos
:::


---


## Recapitulando

-   Cada [**celda puede ser de un tipo diverso**]{.hl-yellow}: números, texto, fechas, valores lógicos, etc

. . .

-   Un [**vector es una concatenación de celdas**]{.hl-yellow} (las futuras columnas de nuestras tablas) --> En `R` por defecto las operaciones se hacen [**elemento a elemento**]{.hl-yellow}

. . .

-   Una [**matriz**]{.hl-yellow} nos permite concatenar [**variables del MISMO tipo y MISMA longitud**]{.hl-yellow} --> datos tabulados

. . .

-   Un [**data.frame**]{.hl-yellow} nos permite concatenar [**variables de DISTINTO tipo y MISMA longitud**]{.hl-yellow} --> usaremos [**tibble**]{.hl-yellow} como una opción mejorada de base de datos

---

## 💻 Tu turno (tb/df) {#tu-turno-1-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 Carga del paquete `{datasets}` el conjunto de datos `airquality` (variables de la calidad del aire de Nueva York desde mayo hasta septiembre de 1973). ¿Es el conjunto de datos airquality de tipo tibble? En caso negativo, conviértelo a tibble (busca en la documentación del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Una vez convertido a `tibble` obtén el nombre de las variables y las dimensiones del conjunto de datos. ¿Cuántas variables hay? ¿Cuántos días se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```


### [**Ejercicio 3**]{.hl-yellow}

📝 Filtra solo los datos de la quinta observación

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, ]
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Filtra solo los datos del mes de agosto. ¿Cómo indicarle que queremos solo las filas que cumplan una condición concreta? (pista: en realidad todo son vectores "formateados")

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, ]
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Selecciona aquellos datos que no sean ni de julio ni de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month != 7 & Month != 8, ]
airquality_tb[!(Month %in% c(7, 8)), ]
```

### [**Ejercicio 6**]{.hl-yellow}

📝 Modifica el siguiente código para quedarte solo con las variable de ozono y temperatura (sin importar qué posición ocupen)

```{r}
#| eval: false
airquality_tb[, 3]
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Selecciona los datos de temperatura y viento de agosto. 

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, c("Temp", "Wind")]
```

### [**Ejercicio 8**]{.hl-yellow}

📝 Traduce a castellano el nombre de las variables.


```{r}
#| code-fold: true
#| eval: false
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```

:::




---

## 🐣 Caso práctico I: tibble {#caso-practico-1-1}

Del paquete `{Biostatistics}` usaremos el conunto de datos `pinniped`, que guarda los **datos de peso de cuerpo y cerebro** (desagregado por sexo y mono/poligamia) de 33 especies de mamíferos marinos.


```{r}
Biostatistics::pinniped
```


Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/repaso-r-ts/)



---

## Comunicar: rmd y Quarto

Una de las [**principales fortalezas**]{.hl-yellow} de `R` es la [**facilidad para generar informes, libros, webs, apuntes y hasta diapositivas**]{.hl-yellow} (este mismo material por ejemplo). Para ello [**instalaremos**]{.hl-purple} antes

::: columns
::: {.column width="40%"}
-   el paquete `{rmarkdown}` (para generar archivos `.rmd`)

```{r}
#| eval: false
install.packages("rmarkdown")
```

- instalar [**Quarto**](https://quarto.org/docs/get-started/) (si ya conocías `R`, el «nuevo» `.rmd` ahora como `.qmd`)
:::

::: {.column width="60%"}
![](img/quarto.png)
:::
:::

---

## Comunicar: rmd y Quarto

Hasta ahora solo hemos programado en scripts (archivos `.R`) dentro de proyectos, pero en muchas ocasiones [**no trabajaremos solos**]{.hl-yellow} y necesitaremos [**comunicar los resultados**]{.hl-yellow} en diferentes formatos:

- apuntes (para nosotros mismos)
- diapositivas
- web
- informes


Para todo ello usaremos [**Quarto**]{.hl-yellow} (ver más en <https://ivelasq.quarto.pub/intro-to-quarto/>)


---

## Comunicar: rmd y Quarto

Los archivos de extensión `.qmd` (o `.rmd` antes) nos permitirán fácilmente combinar:

-   [**Markdown**]{.hl-yellow}: [**lenguaje tipado**]{.hl-purple} que nos permite crear contenido simple (tipo wordpress, con texto, **negritas**, _cursivas_, etc) con un diseño legible.

. . .

-   [**Matemáticas (latex)**]{.hl-yellow}: lenguaje para escribir notación matemática como $x^2$ o $\sqrt{y}$ o $\int_{a}^{b} f(x) dx$

. . .

-   [**Código y salidas**]{.hl-yellow}: podremos no solo mostrar el paso final sino el código que has ido realizando (en `R`, `Python`, `C++`, `Julia`, ...), con [**cajitas de código llamadas CHUNKS**]{.hl-purple}.

. . .

-   Imágenes, [**gráficas**]{.hl-yellow}, tablas, estilos (css, js), etc.

---

## Comunicar: rmd y Quarto

La principal ventaja de realizar este tipo de material en Quarto/Rmarkdown es que, al hacerlo desde `RStudio`, puedes generar un [**informe o una presentación sin salirte del entorno de programación**]{.hl-yellow} en el que estás trabajando

De esta forma podrás analizar los datos, resumirlos y a la vez comunicarlos con la misma herramienta.

. . .

Recientemente el equipo de `RStudio` desarrolló [**Quarto**]{.hl-yellow}, una versión mejorada de Rmarkdown (archivos `.qmd`), con un formato un poco más estético y simple. Tienes toda la documentación y ejemplos en [**https://quarto.org/**](https://quarto.org/)

---

## Usos de Quarto

::: panel-tabset
### Webs

![](./img/website.png){height="350"}

### Libros

![](./img/book.png){height="350"}

### Blogs

![](./img/blog.png){height="350"}

### Presentaciones

![](./img/presentation.png){height="350"}

### Revistas

![](https://user-images.githubusercontent.com/163582/42351114-e5deaa1c-8078-11e8-90de-2aff57bba255.png){height="350"}
:::

Imágenes obtenidas de <https://ivelasq.quarto.pub/intro-to-quarto/#/working-with-the-rstudio-visual-editor>

---

## Nuestro primer informe

::: columns
::: {.column width="55%"}
![](img/quarto-create.png)
:::

::: {.column width="45%"}
Vamos a crear el [**primer fichero rmarkdown con Quarto**]{.hl-yellow} con extensión `.qmd`. Para ello solo necesitaremos hacer click en

`File << New File << Quarto Document`
:::
:::

---

## Nuestro primer informe

:::: columns
::: {.column width="45%"}
![](img/quarto-format.png)
:::

::: {.column width="55%"}
Tras hacerlo nos aparecerán varias [**opciones de formatos de salida**]{.hl-yellow}:

-   archivo `.pdf`
-   archivo `.html` ([**recomendable**]{.hl-yellow}): documento dinámico, permite la interacción con el usuario, como una «página web».
-   archivo `.doc` (nada recomendable)
:::
::::

. . .

De momento dejaremos marcado el [**formato HTML que viene por defecto**]{.hl-yellow}, y escribiremos el [**título**]{.hl-yellow} de nuestro documento. Tras ello tendremos nuestro [**archivo .qmd**]{.hl-yellow} (ya no es un script .R como los que hemos abierto hasta ahora).

---

## Nuestro primer informe

:::: columns
::: {.column width="60%"}
![](img/quarto-example.png)
:::

::: {.column width="40%"}

Deberías tener algo similar a la captura de la imagen con [**dos modos de edición**]{.hl-yellow}: `Source` (con código, la opción recomendada hasta que lo domines) y `Visual` (más parecido a un blog)

:::
::::

Para [**ejecutar TODO el documento**]{.hl-yellow} debes clickar `Render on Save` y darle a guardar.

---

## Salida de Quarto

![](img/quarto-prueba-html.png)

Deberías haber obtenido una [**salida en html similar a esta**]{.hl-yellow} (y se te ha generado en tu ordenador un [**archivo html**]{.hl-yellow})

---

## Editor: source vs visual

Como se indicaba, tienes dos formas de trabajar: con código puro y algo parecido a un Notion (blog)

![](./img/rstudio-source-visual.png)

Imagen obtenida de <https://ivelasq.quarto.pub/intro-to-quarto/#/working-with-the-rstudio-visual-editor>

---

## Nuestro primer informe

:::: columns
::: {.column width="50%"}
![](img/quarto-example.png)

:::

::: {.column width="50%"}

Un fichero `.qmd` se [**divide básicamente en tres partes**]{.hl-yellow}:

* [**Cabecera**]{.hl-yellow}: la parte que tienes al inicio entre `---`.

* [**Texto**]{.hl-yellow}: que podremos formatear y mejorar con negritas (escrito como **negritas**, con doble astérisco al inicio y final), cursivas (_cursivas_, con barra baja al inicio y final) o destacar nombres de funciones o variables de R. Puedes añadir ecuaciones como $x^2$ (he escrito `$x^2$`, entre dólares).

* [**Código R**]{.hl-yellow}

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera están en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el título/subtítulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes algún archivo de estilos
  * `toc`: si quieres índice o no
  * `toc-location`: posición del índice
  * `toc-title`: título del índice
* `editor`: si estás en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
format:
  html:
editor: visual
---
```

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera están en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el título/subtítulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes algún archivo de estilos
  * `toc`: si quieres índice o no
  * `toc-location`: posición del índice
  * `toc-title`: título del índice
* `editor`: si estás en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier álvarez liébana"
format:
  html:
editor: visual
---
```

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera están en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el título/subtítulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes algún archivo de estilos
  * `toc`: si quieres índice o no
  * `toc-location`: posición del índice
  * `toc-title`: título del índice
* `editor`: si estás en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier álvarez liébana"
format:
  html:
    style: style.css
    toc: true
editor: visual
---
```

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera están en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el título/subtítulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes algún archivo de estilos
  * `toc`: si quieres índice o no
  * `toc-location`: posición del índice
  * `toc-title`: título del índice
* `editor`: si estás en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier álvarez liébana"
format:
  html:
    style: style.css
    toc: true
    toc-location: left
editor: visual
---
```

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera están en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el título/subtítulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes algún archivo de estilos
  * `toc`: si quieres índice o no
  * `toc-location`: posición del índice
  * `toc-title`: título del índice
* `editor`: si estás en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier álvarez liébana"
format:
  html:
    style: style.css
    toc: true
    toc-location: left
    toc-title: Índice
editor: visual
---
```

:::
::::


---

## Texto de un qmd

Respecto a la escritura solo hay una [**cosa importante**]{.hl-yellow}: salvo que indiquemos lo contrario, [**TODO lo que vamos a escribir es texto (normal)**]{.hl-yellow}. No código R.

:::: columns
::: {.column width="35%"}
![](img/quarto-prueba-qmd2.png){width=350}
![](img/quarto-prueba-html2.png){width=320}
:::

::: {.column width="65%"}
Vamos a empezar escribiendo una sección al inicio (`# Intro` y detrás por ej. la frase

> Este material ha sido diseñado por el profesor Javier Álvarez Liébana, docente en la Universidad Complutense de Madrid

Además al `Running Code` le añadiremos una almohadilla `#`: las [**almohadillas FUERA DE CHUNKS**]{.hl-yellow} nos servirán para crear [**epígrafes (secciones)**]{.hl-yellow} en el documento


:::
::::


---

## Índice de un qmd

:::: columns
::: {.column width="40%"}
![](img/quarto-indice-qmd-2.png){width=370}
![](img/quarto-indice-html2.png){width=370}
:::

::: {.column width="60%"}
Para que el [**índice capture dichas secciones**]{.hl-yellow} modificaremos la cabecera del archivo como se observa en la imagen (puedes cambiar la localización del índice y el título si quieres para probar).

:::
::::

---

## Texto en un qmd

Vamos a [**personalizar un poco el texto**]{.hl-yellow} haciendo lo siguiente:


:::: columns
::: {.column width="50%"}
![](img/quarto-texto-mejorado-qmd.png){width=370}
![](img/quarto-texto-mejorado-html.png){width=370}
:::

::: {.column width="50%"}
* Vamos a añadir [**negrita al nombre**]{.hl-yellow} (poniendo ** al inicio y al final).

* Vamos añadir [**cursiva**]{.hl-yellow} a la palabra material (poniendo _ al inicio y al final).

* Vamos añadir un [**enlace**]{.hl-yellow} <https://www.ucm.es>, asociándolo al nombre de la Universidad. Para ello el título lo ponemos entre corchetes y justo detrás el enlace entre paréntesis `[«Universidad Complutense de Madrid»](https://www.ucm.es)`

:::
::::

---

## Código en un qmd

Para [**añadir código R**]{.hl-yellow} debemos crear nuestras [**cajas de código llamadas chunks**]{.hl-yellow}: altos en el camino en nuestro texto markdown donde podremos incluir código de casi cualquier lenguaje (y sus salidas).

&nbsp;

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-qmd.png){width=470}
:::

::: {.column width="50%"}

Para incluir uno deberá de ir [**encabezado**]{.hl-yellow} de la siguiente forma tienes un atajo `Command + Option + I` (Mac) o `Ctrl + Shift + I` (Windows)
:::

::::

---

## Código en un qmd

Dentro de dicha cajita (que tiene ahora otro color en el documento) [**escribiremos código R**]{.hl-yellow} como lo veníamos haciendo hasta ahora en los scripts.

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-1-qmd.png){width=410}
![](img/quarto-chunk-1-html.png){width=410}
:::

::: {.column width="50%"}

 Vamos por ejemplo a definir dos variables y su suma de la siguiente manera, escribiendo dicho código en nuestro `.qmd` (dentro de ese chunk)

```{r}
# Código R
x <- 1
y <- 2
x + y
```

:::

::::


---

## Etiquetando chunks


:::: columns
::: {.column width="50%"}
![](img/quarto-tag-chunks-qmd.png){width=400}
![](img/quarto-tag-chunks-html.png){width=400}
:::

::: {.column width="50%"}
Los chunks pueden tener un [**nombre o etiqueta**]{.hl-yellow}, de forma que podamos referenciarlos de nuevo para no repetir código.
:::
::::


---

## Ejecutando chunks

:::: columns
::: {.column width="40%"}
![](img/quarto-inline-qmd.png){width=400}
![](img/quarto-inline-html.png){width=380}
:::

::: {.column width="60%"}
En cada chunk aparecen [**dos botones**]{.hl-yellow}:

* botón de [**play**]{.hl-yellow}: activa la [**ejecución y salida de ese chunk particular**]{.hl-yellow} (lo puedes visualizar dentro de tu propio `RStudio`)

* botón de [**rebobinar**]{.hl-yellow}: activa la [**ejecución y salida de todos los chunk hasta ese**]{.hl-yellow} (sin llegar a él)

&nbsp;

Además podemos [**incluir código R dentro de la línea de texto**]{.hl-yellow} (en lugar de mostrar el texto x ejecuta el código R mostrando la variable).
:::
::::



---

## Personalización de chunks

Los [**chunks podemos personalizarlos**]{.hl-yellow} con opciones al inicio del chunk precedido de `#|`:

* `#| echo: false`: [**ejecuta código**]{.hl-green} y se [**muestra resultado**]{.hl-green} pero [**no visualiza código**]{.hl-red} en la salida.

* `#| include: false`: [**ejecuta código**]{.hl-green} pero [**no muestra resultado**]{.hl-red} y [**no visualiza código**]{.hl-red} en la salida.

* `#| eval: false`: [**no ejecuta código**]{.hl-red}, [**no muestra resultado**]{.hl-red} pero [**sí visualiza código**]{.hl-green} en la salida.

* `#| message: false`: [**ejecuta código**]{.hl-green} pero [**no muestra mensajes de salida**]{.hl-red}.

* `#| warning: false`: [**ejecuta código**]{.hl-green} pero [**no muestra mensajes de warning**]{.hl-red}.

* `#| error: true`: [**ejecuta código**]{.hl-green} y [**permite que haya errores**]{.hl-green} mostrando el mensaje de error en la salida.


![](img/quarto-options-chunk.png){width=380}

Estas opciones podemos aplicarlas chunk a chunk o fijar los parámetros de forma global con `knitr::opts_chunk$set()` al inicio del documento (dentro de un chunk).

---

## Personalizando chunks

Si queremos que aplique la **opción a todos los chunks por defecto** debemos incluirlo al final de la cabecera, como [**opciones de ejecución**]{.hl-yellow}

``` yaml
---
title: "¡Hola!"
format: html
editor: visual
execute:
  echo: false
---
```

---

## Organizando qmd

Además de texto y código podemos introducir lo siguiente:

* [**Ecuaciones**]{.hl-yellow}: puedes añadir además ecuaciones como $x^2$ (he escrito `$x^2$`, la ecuación entre dólares).

* [**Listas**]{.hl-yellow}: puedes itemizar elementos poniendo `*`

`* Paso 1: ...`

`* Paso 2: ...`

* [**Cross-references**]{.hl-yellow}: puedes etiquetar partes del documento (la etiqueta se construye con `{#nombre-seccion}`) y llamarlas luego con `[Sección](@nombre-seccion)`

---

## Gráficas/imágenes en qmd

:::: columns
::: {.column width="50%"}
![](img/quarto-fig-qmd.png){width=340}
![](img/quarto-fig-html.png){width=390}
:::

::: {.column width="50%"}
Por último, también podemos [**añadir pies de gráficas o imágenes**]{.hl-yellow} añadiendo `#| fig-cap: "..."`
:::
::::

. . .

:::: columns
::: {.column width="65%"}
Fíjate que el [**caption está en el margen**]{.hl-yellow} (por ejemplo). Puedes cambiarlo introduciendo [**ajustes en la cabecera**]{.hl-yellow} (todo lo relativo a figuras empieza por `fig-`, y puedes ver las opciones tabulando). Tienes más información en **<https://quarto.org/>**
:::

::: {.column width="35%"}
![](img/quarto-cabecera-desplegable.png){width=400}
:::
::::

---

## Añadir estilos

:::: columns
::: {.column width="50%"}
![](img/quarto-estilos-qmd.png){width=400}
![](img/quarto-estilos-html.png){width=400}
:::

::: {.column width="50%"}
Por último puedes añadir un [**tema personalizado**]{.hl-yellow} incluyendo un [**archivo de estilos**]{.hl-yellow} (archivo en formato `.scss` o `.css`). Te he dejado uno en <https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material>.

::: callout-important
## Importante

El archivo de estilos debe estar en la misma carpeta que el archivo `.qmd`
:::
:::
::::

---

## Añadir estilos

También puedes hacerlo de manera sencilla [**añadiendo a los textos un poco de HTML**]{.hl-yellow}. Por ejemplo, para personalizar el color de un texto va entre corchetes y justo tras el texto, entre llaves, las opciones de estilo

``` html
Esta palabra es [roja]{style="color:red;"} ...
```

``` html
... y esta [verde y en negrita]{style="color:green; font-weight: bold;"}
```

. . .

Esta palabra es [roja]{style="color:red;"} ...

... y esta [verde y en negrita]{style="color:green; font-weight: bold;"}

---

## Revealjs

Puedes añadir algunas «animaciones» usando lo que se conoce como Revealjs (javascript), especifcándolo en la cabecera y usando [**bloques**]{.hl-yellow} de dicho lenguaje delimitados por `:::` al inicio y final, y la palabra de la «herramienta» a usar. Por ejemplo `{.incremental}` hace una transición de los elementos.

``` yaml
format:
  revealjs
```
&nbsp;

``` revealjs
::: {.incremental}
- Me
- llamo
- Javi
:::
```


::: {.incremental}
- Me
- llamo
- Javi
:::

---

## Bloques de llamada

También puedes usar los [**bloques de llamada**]{.hl-yellow} que por defecto son `note`, `tip`, `warning`, `caution` e `important` (aunque los puedes crear y personalizar). Para ello basta con usar `:::{.callout-tipo}` y el tipo que quieras

``` html
:::{.callout-tip}

Note that there are five types of callouts, including: 
`note`, `tip`, `warning`, `caution`, and `important`.

:::
```

. . .

:::{.callout-tip}

Recuerda que los 5 tipos son `note`, `tip`, `warning`, `caution` e `important`.

:::

. . .

:::{.callout-caution}

Úsalos con cabeza, a veces mucho recursos estético puede marear.

:::

---

## Código ajeno a R

Además `{reticulate}` nos permite crear chunks de `python` dentro de un Quarto en `R` (ver <https://quarto.org/docs/computations/python.html> para crear jupyter notebooks directamente desde Quarto)

```{r}
#| echo: false
#| eval: false
library(reticulate)
```

```{r}
#| eval: false
# install.packages("reticulate")
library(reticulate)

install_python("3.9.12") # Instalar python en PC sino lo tienes

# Instalar paquetes de Python
reticulate::py_install("numpy")
reticulate::py_install("matplotlib")
```

:::: columns
::: {.column width="60%"}

```{python}
#| eval: false
import numpy as np
import matplotlib.pyplot as plt
r = np.arange(0, 2, 0.05)
theta = 2 * np.pi * r
fig, ax = plt.subplots(
  subplot_kw = {'projection': 'polar'} 
)
ax.plot(theta, r)
plt.show()
```

:::

::: {.column width="40%"}

```{python}
#| echo: false
#| eval: false
import numpy as np
import matplotlib.pyplot as plt
r = np.arange(0, 2, 0.05)
theta = 2 * np.pi * r
fig, ax = plt.subplots(
  subplot_kw = {'projection': 'polar'} 
)
ax.plot(theta, r)
plt.show()
```

:::
::::

---



## Ejemplo de entrega

Vamos a realizar un pequeño simulacro antes de la entrega usando el dataset `starwars` del paquete `{dplyr}`

![](https://sm.ign.com/t/ign_latam/screenshot/default/baby-yoda-nombre_3x56.1280.jpg)

---

## Ejemplo de entrega

```{r}
library(dplyr)
starwars
```

En él tenemos **diferentes variables de los personajes de Star Wars**, con características de su pelo, piel, altura, nombre, etc.


---

## Ejemplo de entrega

> Crea un documento `.qmd` con nombre, título, formato e índice. Cada ejercicio posterior será una subsección del documento. Ejecuta los chunks que consideres y comenta las salidas para responder a cada pregunta

. . .

> Ejercicio 1. ¿Cuántos personajes hay guardados en la base de datos? ¿Cuántas características se han medido de cada uno?

. . .

> Ejercicio 2. Extrae en dos variables distintas `nombres` y `edades` las variables correspondientes de la tabla. ¿De qué tipo es la variable nombre? ¿Y la variable birth_year?

. . .

> Ejercicio 3. Obtén el vector de nombres de los personajes ordenados de mayores a jóvenes.


---

## Ejemplo de entrega

> Ejercicio 4. Busca ayuda de la función unique(). Úsala para saber que modalidades tiene la variable cualitativa correspondiente al color de ojos. ¿Cuántos distintos hay?

. . .

> Ejercicio 5. ¿Existe ALGÚN valor ausente en la variable de color ojos? 

. . .

> Ejercicio 6.  Calcula la media y desviación típica de las variables de estatura y peso (cuidado con los ausentes). Define un nuevo tibble con esas dos variables e incorpora una tercera variable que se llame “IMC” que calcule el índice de masa corporal. Incorpora con `$ $` la fórmula usada para el IMC.


---

## Estructuras de control

Una [**estructura de control**]{.hl-yellow} se compone de una serie de comandos orientados a  [**decidir el camino**]{.hl-yellow} que tu código debe recorrer

* Si se cumple la condición A, ¿qué sucede?

* ¿Y si sucede B?

* ¿Cómo puedo repetir una misma expresión (dependiendo de una variable)?

. . .

Si has programado antes, quizás te sea familiar las conocidas como [**estructuras condicionales**]{.hl-yellow} tales como `if (blabla) {...} else {...}`  o [**bucles**]{.hl-yellow} `for/while` (a evitar siempre que podamos).

---

## Estructura If

Una de las estructuras de control más famosas son las conocidas como [**estructuras condicionales**]{.hl-yellow} `if`.

> SI (IF) un conjunto de condiciones se cumple (TRUE), entonces ejecuta lo que haya dentro de las llaves

Por ejemplo, la estructura `if (x == 1) { código A }` lo que hará será [**ejecutar el código A entre llaves**]{.hl-yellow} pero [**SOLO SI**]{.hl-purple} la [**condición entre paréntesis es cierta**]{.hl-purple} (solo si `x` es 1). En cualquier otro caso, no hará nada.

. . .

Por ejemplo, definamos un vector de edades de 8 personas

```{r}
edad <- c(14, 17, 24, 56, 31, 20, 87, 73)
edad < 18
```

---

## Estructura If


Nuestra estructura condicional hará lo siguiente: [**si existe algún menor de edad, imprimirá**]{.hl-yellow} por pantalla un mensaje.

```{r}
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```

---

## Estructura If

```{r}
#| eval: false
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```


En caso de que las [**condiciones no sean ciertas**]{.hl-yellow} dentro de `if()` (`FALSE`), no sucede nada


```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
}
```

**No obtenemos ningún mensaje** porque la condición `all(edad >= 18)` no es `TRUE`, así que no ejecuta nada.

---

## Estructura If-else

La estructura `if (condicion) { código A }` puede combinarse con un `else { código B }`: cuando la [**condición no está verificada**]{.hl-yellow}, se [**ejecutará el código alternativo B**]{.hl-yellow} dentro de `else { }`, permitiéndonos decidir que sucede cuando se cumple y cuando no.

. . .

Por ejemplo, `if (x == 1) { código A } else { código B }` ejecutará A si `x` es igual a 1 y B en cualquier otro caso.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else {
  
  print("Existe alguna persona menor de edad")
}
```

---

## Estructura If-else

Esta estructura `if - else` puede ser [**anidada**]{.hl-yellow}: imagina que queremos ejecutar un código si todos son menores; si no sucede, pero todos son mayores de 16, hacer otra cosa; en cualquier otra cosa, otra acción.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else if (all(edad >= 16)) {
  
  print("Hay algún menor de edad pero todos con 16 años o más")
  
} else { print("Hay alguna persona con menos de 16 años") }
```

::: callout-note
## Truco

Puedes **colapsar las estructuras** haciendo click en la flecha a la izquierda que aparece en tu script.

:::


---

## If-else vectorizado



Esta estructura condicional se puede [**vectorizar**]{.hl-yellow} (en una sola línea) con `if_else()` (del paquete `{dplyr}`), cuyos argumentos son

* la condición a evaluar
* lo que sucede cuando se cumple y cuando no
* un argumento opcional para cuando la condición a evaluar es `NA`

Vamos a etiquetar sin son mayores/menores y un "desconocido" cuando no conocemos

```{r}
library(dplyr)
edad <- c(NA, edad)
if_else(edad >= 18, "mayor", "menor", missing = "desconocido")
```

En `R` base existe `ifelse()`: no deja especificar que hacer con los ausentes pero permite especificar distintos tipos de datos en `TRUE` y en `FALSE`.


---

## Bucles

Aunque en la mayoría de ocasiones se pueden reemplazar por otras estructuras más eficientes y legibles, es importante conocer una de las expresiones de control más famosas: los [**bucles**]{.hl-yellow}.

* `for { }`: permite [**repetir el mismo código**]{.hl-yellow} en un [**número prefijado y conocido**]{.hl-purple} de veces.

* `while { }`: permite [**repetir el mismo código**]{.hl-yellow} pero en un [**número indeterminado de veces**]{.hl-purple} (hasta que una **condición** deje de cumplirse).

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de órdenes un número [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de índices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacía `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los paréntesis indicaremos un índice y unos valores a recorrer, dentro de las llaves el código a ejecutar en cada iteración (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()
```

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de órdenes un número [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de índices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacía `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los paréntesis indicaremos un índice y unos valores a recorrer, dentro de las llaves el código a ejecutar en cada iteración (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  
}
```

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de órdenes un número [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de índices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacía `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los paréntesis indicaremos un índice y unos valores a recorrer, dentro de las llaves el código a ejecutar en cada iteración (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
```

---

## Bucles for

Fíjate que debido a que `R` funciona de manera [**vectorial por defecto**]{.hl-yellow}, el bucle es lo mismo que hacer `x + 1` directamente.

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
y

y2 <- x + 1
y2
```

---

## Bucles for

Otra opción habitual es indicar los índices de manera «automática»: desde el primero `1` hasta el último (que corresponde con la longitud de x `length(x)`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:length(x)) {
  y[i] <- x[i] + 1
}
y

```


---

## Bucles for

Así la [**estructura general de un bucle for**]{.hl-yellow} será siempre la siguiente

```{r}
#| eval: false
for (índice in conjunto) { 
  código (dependiente de i)
}
```

[**SIEMPRE**]{.hl-green} sabemos cuántas iteraciones tenemos (tantas como elementos haya en el conjunto a indexar)

---

## Evitando bucles


Como ya hemos aprendido con el paquete`{microbenchmark}` podemos chequear como [**los bucles suelen ser muy ineficientes**]{.hl-yellow} (de ahí que debamos evitarlos en la mayoría de ocasiones

```{r}
library(microbenchmark)
x <- 1:1000
microbenchmark(y <- x^2, 
               for (i in 1:100) { y[i] <- x[i]^2 },
               times = 500)
```

---
 
## Bucles for


Podemos ver otro ejemplo de bucle  [**combinando números y textos**]{.hl-yellow}: definimos un vector de edades y de nombres, e imprimimos el nombre y edad i-ésima.

```{r}
nombres <- c("Javi", "Sandra", "Carlos", "Marcos", "Marta")
edades <- c(33, 27, 18, 43, 29)
library(glue)
for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} años")) 
  
}
```


---

## Bucles for

Aunque normalmente se suelen indexar con vectors numéricos, los bucles pueden ser [**indexados sobre cualquier estructura vectorial**]{.hl-yellow}, da igual de que tipo sea el conjunto

```{r}
library(stringr)
week_days <- c("monday", "tuesday", "wednesday", "thursday",
               "friday", "saturday", "sunday")

for (days in week_days) {
  
  print(str_to_upper(days))
}
```

---

## Bucles y condicionales

Vamos a **combinar las estructuras condicionales y los bucles**: usando el conjunto `swiss` del paquete `{datasets}`, vamos a asignar `NA`  si los valores de fertilidad son mayores de 80.

```{r}
for (i in 1:nrow(swiss)) {
  
  if (swiss$Fertility[i] > 80) { 
    
    swiss$Fertility[i] <- NA
    
  }
}
```

. . .

Esto es exactamente igual a un `if_else()` vectorizado

```{r}
data("swiss")
swiss$Fertility <- if_else(swiss$Fertility > 80, NA, swiss$Fertility)
```


---

## Bucles while

Otra forma de crear un bucle es con la estructura `while { }`, que nos ejecutará un bucle [**un número desconocido de veces**]{.hl-yellow}, hasta que una condición [**deje de cumplirse**]{.hl-yellow} (de hecho puede que nunca termine). Por ejemplo, vamos a inializar una variable `ciclos <- 1`, que incrementaremos en cada paso, y no saldremos del bucle hasta que `ciclos > 4`.

```{r}
ciclos <- 1
while(ciclos <= 4) {
  
  print(glue("No todavía, vamos por el ciclo {ciclos}")) 
  ciclos <- ciclos + 1
  
}
```

---

## Bucles while

Un bucle `while` será siempre como sigue

```{r}
#| eval: false
while(condición) {
  
  código a hacer mientras la condición sea TRUE
  # normalmente aquí se actualiza alguna variable
  
}
```

---
  
## Bucles while

¿Qué sucede cuando la [**condición nunca es FALSE**]{.hl-yellow}? Pruébalo tu mismo

```{r}
#| eval: false
while (1 > 0) {
  
  print("Presiona ESC para salir del bucle")
  
}
```

&nbsp;

::: callout-warning
## Cuidado

Un bucle `while { }` puede ser bastante «peligroso» sino controlamos bien cómo pararlo.

:::

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `break`: permite [**abortar un bucle**]{.hl-yellow} incluso si no se ha llegado a su final

```{r}
for(i in 1:10) {
  if (i == 3) {
    
    break # si i = 3, abortamos bucle
    
  }
  print(i)
}
```

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `next`: [**fuerza un bucle a avanzar a la siguiente iteración**]{.hl-yellow} 

```{r}
for(i in 1:5) {
  if (i == 3) {
    
    next # si i = 3, la obvia y continua al siguiente
    
  }
  print(i)
}
```



---

## 💻 Tu turno {#tu-turno-1-3}


[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 ¿Cuál es la salida del siguiente código?

```{r}
#| eval: false
if_else(sqrt(9) < 2, sqrt(9), 0)
```

```{r}
#| eval: false
#| code-fold: true

La salida es 0 ya que sqrt(9) es igual 3, y dado que no es menor que 2, devuelve el segundo argumento que es 0
```

### [**Ejercicio 2**]{.hl-yellow}

📝 ¿Cuál es la salida del siguiente código?

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true

La salida es el vector c(0, NA, NA, 1) ya que sqrt(1) sí es menor que 2, sqrt(9) no lo es, y tanto en el caso de sqrt(NA) (raíz de ausente) como sqrt(-1) (devuelve NaN, not a number), su raíz cuadrada no puede verificarse si es menor que 2 o no, así que la salida es NA.
```


### [**Ejercicio 3**]{.hl-yellow}

📝 Modifica el código inferior para que, cuando no se pueda verificar si la raíz cuadrada de un número es menor que 2, devuelva -1

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1, missing = -1)
```


### [**Ejercicio 4**]{.hl-yellow}

📝 ¿Cuál es son los valores de `x` e `y` del código inferior para `z <- 1`, `z <- -1` y `z <- -5`?

```{r}
#| eval: false
z <- -1
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
En primero caso x = 1 e y = -1. En el segundo caso x = 1 e y = 1. En el tercer caso -1 y 2
```


### [**Ejercicio 5**]{.hl-yellow}

📝 ¿Qué sucederá si ejecutamos el código inferior?

```{r}
#| eval: false
z <- "a"
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| code-fold: true
#| eval: false

# dará error ya que no es un argumento numérico
Error in z^3 : non-numeric argument to binary operator
```


### [**Ejercicio 6**]{.hl-yellow}

📝 Del paquete `{lubridate}`, la función `hour()` nos devuelve la hora de una fecha dada, y la función `now()` nos devuelve fecha y hora del momento actual. Con ambas funciones haz que se imprima por pantalla (`cat()`) "buenas noches" solo a partir de las 21 horas.

```{r}
#| code-fold: true
#| eval: false

# Cargamos librería
library(lubridate)

# Fecha-hora actual
fecha_actual <- now()

# Estructura if
if (hour(fecha_actual) > 21) {
  
  cat("Buenas noches") # print/cat dos formas de imprimir por pantalla
}
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Modifica el código inferior para que se imprima un mensaje por pantalla si y solo si todos los datos de `airquality` son con mes distinto a enero

```{r}
#| eval: false
library(datasets)
months <- airquality$Month

if (months == 2) {
  print("No hay datos de enero")
}
```

```{r}
#| code-fold: true
#| eval: false
library(datasets)
months <- airquality$Month

if (all(months != 1)) {
  print("No hay datos de enero")
}
```


### [**Ejercicio 8**]{.hl-yellow}

📝 Modifica el código inferior para guardar en una variable llamada `temp_alta` un `TRUE` si alguno de los registros tiene una temperatura superior a 90 grados Farenheit y `FALSE` en cualquier otro caso
 
```{r}
#| eval: false
temp <- airquality$Temp

if (temp == 100) {
  print("Algunos de los registros tienen temperaturas superiores a 90 grados Farenheit")
}
```

 
```{r}
#| eval: false
#| code-fold: true
# Option 1
temp <- airquality$Temp
temp_alta <- FALSE
if (any(temp > 90)) {
   temp_alta <- TRUE
}

# Option 2
temp_alta <- any(airquality$Temp > 90)
```

### [**Ejercicio 9**]{.hl-yellow}

📝 Modifica el código inferior para diseñar un bucle `for` de 5 iteraciones que solo recorra los primeros 5 impares (y en cada paso del bucle los imprima)

```{r}
#| eval: false
for (i in 1:5) {
  
  print(i)
}
```

```{r}
#| eval: false
#| code-fold: true
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i)
}
```

### [**Ejercicio 10**]{.hl-yellow}

📝 Modifica el código inferior para diseñar un bucle `while` que empiece con un contador `count <- 1` y pare cuando llegue a 6

```{r}
#| eval: false
count <- 1
while (count == 2) {
  
  print(count)
}
```

```{r}
#| eval: false
#| code-fold: true
count <- 1
while (count < 6) {
  
  print(count)
  count <- count + 1
  
}
```


:::

---

## 🐣 Caso práctico II {#caso-practico-1-2}


Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/repaso-r-ts/) donde tendrás que diseñar algunos estudios de simulación haciendo uso de **bucles y estructuras condicionales**


---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, además podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¿Cómo [**crear nuestra propia función**]{.hl-purple}? Veamos su **esquema básico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraños). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la función dentro de `{ }`.

* Finalizamos la función con los [**argumentos de salida**]{.hl-yellow} con `return()`.



```{r}
#| eval: false
name_fun <- function() {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, además podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¿Cómo [**crear nuestra propia función**]{.hl-purple}? Veamos su **esquema básico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraños). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la función dentro de `{ }`.

* Finalizamos la función con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, además podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¿Cómo [**crear nuestra propia función**]{.hl-purple}? Veamos su **esquema básico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraños). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la función dentro de `{ }`.

* Finalizamos la función con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  código a ejecutar
  
}
```

---


## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, además podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¿Cómo [**crear nuestra propia función**]{.hl-purple}? Veamos su **esquema básico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraños). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la función dentro de `{ }`.

* Finalizamos la función con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  código a ejecutar
  
  return(var_salida)
  
}
```


---

## Creando funciones

* `arg1, arg2, ...`: serán los [**argumentos de entrada**]{.hl-yellow}, los argumentos que toma la función para ejecutar el código que tiene dentro

* `código`: líneas de código que queramos que [**ejecute la función**]{.hl-yellow}. 

* `return(var_salida)`: se introducirán los [**argumentos de salida**]{.hl-yellow}.


```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # Código que queramos ejecutar
  código
  
  # Salida
  return(var_salida)
  
}
```

::: callout-important
## Importante

Todas las variables que definamos dentro de la función son [**variables LOCALES: solo existirán dentro de la función**]{.hl-yellow} salvo que especifiquemos lo contrario.

:::

---

## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de función para [**calcular el área de un rectángulo**]{.hl-yellow}.

Dado que el área de un rectángulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serán los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} será justo su **área** ($lado_1 * lado_2$).

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
}
```

---


## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de función para [**calcular el área de un rectángulo**]{.hl-yellow}.

Dado que el área de un rectángulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serán los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} será justo su **área** ($lado_1 * lado_2$).

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  
}
```

---


## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de función para [**calcular el área de un rectángulo**]{.hl-yellow}.

Dado que el área de un rectángulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serán los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} será justo su **área** ($lado_1 * lado_2$).

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  return(area)
  
}
```

---

## Uso de funciones

También podemos hacer una definición directa de las variables **sin almacenar por el camino**.

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  return(lado_1 * lado_2)
  
}
```

. . .

[**¿Cómo aplicar la función?**]{.hl-yellow}

```{r}
calcular_area(5, 3) # área de un rectángulo 5 x 3 
calcular_area(1, 5) # área de un rectángulo 1 x 5
```

---

## Uso de funciones

::: callout-tip

Aunque no sea necesario, es [**recomendable hacer explícita la llamada de los argumentos**]{.hl-green}, especificando en el código qué valor es para cada argumento para que no dependa de su orden, haciendo el código más legible
:::


```{r}
calcular_area(lado_1 = 5, lado_2 = 3) # área de un rectángulo 5 x 3 
calcular_area(lado_2 = 3, lado_1 = 5) # área de un rectángulo 5 x 3 
```

---

## Argumentos por defecto

Imagina ahora que nos damos cuenta que el 90% de las veces usamos dicha función para [**calcular por defecto el área de un cuadrado**]{.hl-yellow} (es decir, solo necesitamos un lado). Para ello, podemos definir [**argumentos por defecto**]{.hl-yellow} en la función: tomarán dicho valor salvo que le asignemos otro.

¿Por qué no asignar `lado_2 = lado_1` **por defecto**, para ahorrar líneas de código y tiempo?

. . .

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

---

## Argumentos por defecto


```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```


Ahora [**por defecto**]{.hl-yellow} el segundo lado será igual al primero (si se lo añadimos usará ambos).


```{r}
calcular_area(lado_1 = 5) # cuadrado
calcular_area(lado_1 = 5, lado_2 = 7) # rectángulo
```

---
 

## Salida múltiple

Compliquemos un poco la función y añadamos en la salida los valores de cada lado, etiquetados como `lado_1` y `lado_2`, [**empaquetando la salida en una vector**]{.hl-yellow}.

```{r}
#| code-line-numbers: "7-8"
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

---

## Salida múltiple

Podemos complicar un poco más la salida añadiendo una cuarta variable que nos diga, en función de los argumentos, [**si rectángulo o cuadrado**]{.hl-yellow}, teniendo que añadir en la salida una variable que de tipo caracter (o lógica).

```{r}
#| code-line-numbers: "7-9"
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rectángulo")))
  
}
calcular_area(5, 3)
```

. . .

[**Problema**]{.hl-red}: al intentar juntar números y texto, lo convierte todo a números. Podríamos guardarlo todo en un `tibble()` como hemos aprendido o en un objeto conocido en `R` como [**listas**]{.hl-yellow}


---

## Orden de los argumentos

Antes nos daba igual el orden de los argumentos pero ahora el [**orden de los argumentos de entrada importa**]{.hl-yellow}, ya que en la salida incluimos `lado_1` y `lado_2`. 

. . .

::: callout-note
## Recomendación

Como se comentaba, altamente recomendable hacer la llamada a la función [**indicando explícitamente los argumentos**]{.hl-yellow} para mejorar **legibilidad e interpretabilidad**.

```{r}
# Equivalente a calcular_area(5, 3)
calcular_area(lado_1 = 5, lado_2 = 3)
```

:::


---

## Variables locales vs globales

Un aspecto importante sobre el que reflexionar con las funciones: ¿qué sucede si [**nombramos a una variable dentro**]{.hl-yellow} de una función a la que se nos ha **olvidado asignar** un valor dentro de la misma?

. . .

Debemos ser cautos al usar funciones en `R`, ya que debido a la [**«regla lexicográfica»**]{.hl-yellow}, si una variable no se define dentro de la función, `R` [**buscará dicha variable en el entorno**]{.hl-purple} de variables.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  print(x) # No devuelve nada, solo realiza la acción 
}
funcion_ejemplo()
```

---

## Variables locales vs globales

Si una variable  [**ya está definida fuera de la función (entorno global)**]{.hl-yellow}, y además es usada dentro de cambiando su valor, el valor [**solo cambia dentro**]{.hl-yellow} pero [**no en el entorno global**]{.hl-red}.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  x <- 2
  print(x) # lo que vale dentro
}
```

```{r}
# lo que vale dentro
funcion_ejemplo() #<<
# lo que vale fuera
print(x) #<<
```

---

## Variables locales vs globales


Si queremos que además de cambiar localmente lo haga [**globalmente**]{.hl-yellow} deberemos usar la [**doble asignación**]{.hl-yellow} (`<<-`).

```{r}
x <- 1
y <- 2
funcion_ejemplo <- function() {
  
  # no cambia globalmente, solo localmente
  x <- 3 
  # cambia globalmente
  y <<- 0 #<<
  
  print(x)
  print(y)
}

funcion_ejemplo() # lo que vale dentro
x # lo que vale fuera
y # lo que vale fuera
```

---


## 💻 Tu turno {#tu-turno-1-4}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ej 1**]{.hl-yellow}

📝 Modifica el código inferior para definir una función llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.

```{r}
#| eval: false
nombre <- function(x, y) {
  suma <- # código a ejecutar
  return()
}
# Aplicamos la función
suma(3, 7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_suma <- function(x, y) {
  suma <- x + y
  return(suma)
}
funcion_suma(3, 7)
```

### [**Ej 2**]{.hl-yellow}

📝 Modifica el código inferior para definir una función llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado

```{r}
#| eval: false
nombre <- function(x, y) {
  producto <- # código de la multiplicación
  return()
}
producto(3)
producto(3, -7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_producto <- function(x, y = x) {
  producto <- x * y
  return(producto)
}
funcion_producto(3)
funcion_producto(3, -7)
```

### [**Ej 3**]{.hl-yellow}

📝 Define una función llamada `igualdad_nombres` que, dados dos nombres, nos diga si son iguales o no. Hazlo considerando importantes las mayúsculas, y sin que importen las mayúsculas. Usa el paquete `{stringr}`.

```{r}
#| code-fold: true
#| eval: false
# Distinguiendo mayúsculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Lucía")

# Sin importar mayúsculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(toupper(persona_1) == toupper(persona_2))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Lucía")
```

### [**Ej 4**]{.hl-yellow}

📝 Crea una función llamada `calculo_IMC` que, dados dos argumentos (peso y estatura en metros) y un nombre, devuelva una lista con el IMC ($peso/(estatura_m^2)$) y el nombre.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura) {
  
  return(list("nombre" = nombre, "IMC" = peso/(estatura^2)))
}
```

### [**Ej 5**]{.hl-yellow}

📝 Repite el ejercicio anterior pero con otro argumento opcional que se llame unidades (por defecto, `unidades = "metros"`). Desarrolla la función de forma que haga lo correcto si `unidades = "metros"` y si `unidades = "centímetros"`.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  
  return(list("nombre" = nombre,
              "IMC" = peso/(if_else(unidades == "metros", estatura, estatura/100)^2)))
}
```

 
### [**Ej 6**]{.hl-yellow}

📝 Crea un tibble ficticio de 7 personas, con tres variables (inventa nombre, y simula peso, estatura en centímetros), y aplica la función definida de forma que obtengamos una cuarta columna con su IMC.

```{r}
#| code-fold: true
#| eval: false
datos <-
  tibble("nombres" = c("javi", "sandra", "laura",
                       "ana", "carlos", "leo", NA),
         "peso" = rnorm(n = 7, mean = 70, sd = 1),
         "estatura" = rnorm(n = 7, mean = 168, sd = 5))

datos |> 
  mutate(IMC = calculo_IMC(nombres, peso, estatura, unidades = "centímetros")$IMC)
```


### [**Ej 7**]{.hl-yellow}

📝 Crea una función llamada `atajo` que tenga dos argumentos numéricos `x` e `y`. Si ambos son iguales, debes devolver `"iguales"` y hacer que la función acaba automáticamente (piensa cuándo una función sale). OJO: `x` e `y` podrían ser vectores. Si son distintos (de igual de longitud) calcula la proporción de elementos  diferentes. Si son distintos (por ser distinta longitud), devuelve los elementos que no sean comunes.

```{r}
#| code-fold: true
#| eval: false
atajo <- function(x, y) {
  
  if (all(x == y) & length(x) == length(y)) { return("iguales") }
  else {
   
    if (length(x) == length(y)) {
      
      n_diff <- sum(x != y) / length(x)
      return(n_diff)
      
    } else {
      
      diff_elem <- unique(c(setdiff(x, y), setdiff(y, x)))
      return(diff_elem)
    }
    
  }
}
```


:::


---


## R base vs Tidyverse

Hasta ahora todo lo que hemos repasado en `R` lo hemos realizado en el paradigma de programación conocido como [**R base**]{.hl-yellow}. Y es que cuando `R` nació como lenguaje, muchos de los que programaban en él imitaron formas y metodologías heredadas de otros lenguajes, basado en el uso de

-   Bucles [**for**]{.hl-yellow}

-   Bucles [**while**]{.hl-yellow}

-   Estructuras [**if-else**]{.hl-yellow}


Y aunque conocer dichas estructuras puede sernos en algunos casos interesantes, en la [**mayoría de ocasiones han quedado caducas y vamos a poder evitarlas**]{.hl-red} (en especial los bucles) ya que `R` está especialmente [**diseñado para trabajar de manera funcional**]{.hl-yellow} (en lugar de elemento a elemento).

---

## ¿Qué es tidyverse?

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

En ese contexto de programación funcional, hace una década nacía `{tidyverse}`, un [**«universo» de paquetes**]{.hl-yellow} para garantizar un flujo de trabajo eficiente, coherente y lexicográficamente sencillo de entender, basado en la idea de que [**nuestros datos están limpios y ordenados (tidy)**]{.hl-purple}

---

## ¿Qué es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)

-   `{lubridate}` manejo de fechas
-   `{rvest}`: web scraping
-   `{tidymodels}`: modelización/predicción

:::

::: {.column width="55%"}
-   `{tibble}`: optimizando data.frame
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv), `{readxl}` para importar archivos .xls y .xlsx
-   `{dplyr}`: gramática para depurar
-   `{stringr}`: manejo de textos
-   `{purrr}`: manejo de listas
-   `{forcats}`: manejo de cualitativas
-   `{ggplot2}`: visualización de datos



:::
:::



---

## ¿Qué es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)

-   `{lubridate}` manejo de fechas
-   `{rvest}`: web scraping
-   `{tidymodels}`: modelización/predicción


:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}
-   `{readr}`: carga datos rectangulares (.csv), `{readxl}` para importar archivos .xls y .xlsx
-   `{dplyr}`: gramática para depurar
-   `{stringr}`: manejo de textos
-   `{purrr}`: manejo de listas
-   `{forcats}`: manejo de cualitativas
-   `{ggplot2}`: visualización de datos

:::
:::


---

## Filosofía base: tidy data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

El [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducida por **Hadley Wickham** (el Dios al que rezamos) de [**estandarizar**]{.hl-yellow} el formato de los datos para

::: incremental
-   [**sistematizar**]{.hl-green} la depuración
-   hacer más [**sencillo**]{.hl-green} su manipulación.
-   código [**legible**]{.hl-green}
:::

---

## Reglas del tidy data

Lo primero por tanto será entender qué son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos están estandarizados.

::: columns
::: {.column width="50%"}
::: {.fragment .fade-in}
1.  Cada [**variable**]{.hl-yellow} en una [**única columna**]{.hl-purple}
:::

::: {.fragment .fade-in}
2.  Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}
:::

::: {.fragment .fade-in}
3.  Cada [**celda**]{.hl-yellow} con un [**único valor**]{.hl-purple}
:::

::: {.fragment .fade-in}
4.  Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5.  Si queremos cruzar [**múltiples tablas**]{.hl-yellow} debemos tener una [**columna común**]{.hl-purple}
:::
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
:::

---

## Tubería (pipe)

En `{tidyverse}` será clave el [**operador pipe (tubería)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): será una [**tubería que recorre los datos**]{.hl-yellow} y los transforma.

. . .

::: columns
::: {.column width="50%"}
En R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, sería

```{r}
#| eval: false
third(second(first(datos)))
```
:::

::: {.column width="50%"}
En `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones

```{r}
#| eval: false
datos |> first() |> second() |> third()
```
:::
:::


. . .

::: callout-caution
## Apunte importante

Desde la versión 4.1.0 de `R` disponemos de `|>`, un pipe **nativo** disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que dependía del paquete `{magrittr}` (bastante problemático).
:::

---

## Tubería (pipe)

La principal ventaja es que el [**código sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas código.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::

::: {.column width="50%"}
<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
:::

---

## Datos SUCIOS: messy data

¿Pero qué aspecto tienen los [**datos no tidy**]{.hl-yellow}? Vamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).


```{r}
library(tidyr)
table4a
```


[**¿Qué puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="40%"}
```{r}
table4a
```
:::

::: {.column width="60%"}
❎ Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) → las columnas `1999` y `2000` en realidad deberían ser en sí [**valores de una variable**]{.hl-yellow} y no nombres de columnas.
:::
:::

. . .

Incluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el año y otra que guarde el valor de la variable de interés en cada uno de esos años. Y lo haremos con la función `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="50%"}
```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
               values_to = "cases")
```
:::

::: {.column width="50%"}
![](img/table4a.jpg)
:::
:::



-   `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}
-   `names_to`: nombre de la nueva variable a la quemandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).
-   `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table2`


```{r}
table2
```


[**¿Qué puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_wider()

::: columns
::: {.column width="60%"}
```{r}
#| echo: false
table2
```
:::

::: {.column width="40%"}
❎ Cada [**observación está dividido en dos filas**]{.hl-red} → los [**registros con el mismo año deberían ser el mismo**]{.hl-yellow}
:::
:::

. . .

Lo que haremos será lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table3`


```{r}
table3
```


[**¿Qué puede estar fallando?**]{.hl-red}

---

## Separar: separate()

::: columns
::: {.column width="60%"}
```{r}
table3
```
:::

::: {.column width="40%"}
❎ Cada [**celda contiene varios valores**]{.hl-red}
:::
:::

. . .

Lo que haremos será hacer uso de la función `separate()` para mandar [**separar cada valor**]{.hl-yellow} a una columna diferente.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

---

## Separar: separate()

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

Fíjate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deberían ser variables numéricas. Para ello podemos añadir el argumento opcional `convert = TRUE`

. . .

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

---

## Datos SUCIOS: messy data

Veamos el último ejemplo con la tabla `table5`


```{r}
table5
```


[**¿Qué puede estar fallando?**]{.hl-red}

---

## Unir unite()

::: columns
::: {.column width="50%"}
```{r}
table5
```
:::

::: {.column width="50%"}
❎ Tenemos [**mismos valores divididos en dos columnas**]{.hl-red}
:::
:::

. . .

Usaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y año en una misma columna

```{r}
table5 |> unite(col = year_completo, century, year, sep = "")
```

---

## Ejemplo: relig_income

Vamos a realizar un ejemplo juntos con la tabla `relig_income` del paquete `{tidyr}`. Como se indica en la ayuda `? relig_income`, la tabla representa la cantidad de personas que hay en cada tramo de ingresos anuales (20k = 20 000$) y en cada religión.

```{r}
relig_income
```

---

## Ejemplo: relig_income

```{r}
relig_income
```

[**¿Es tidydata?**]{.hl-yellow} 

---

## Ejemplo: relig_income

```{r}
relig_income
```

No lo es ya que en realidad [**solo deberíamos tener una variable de ingresos**]{.hl-red} y la tenemos dividida en 11: todas ellas es la misma variable solo que adopta un valor diferente.  [**¿Cómo convertirla a tidy data?**]{.hl-green}

---

## Ejemplo: relig_income


La idea es [**pivotar todas las columnas de ingresos**]{.hl-yellow} para que acaben en una sola columna llamada `income`, y los valores (el número de personas) en otra llamada `people` (por ejemplo). La tabla la haremos más larga y menos ancha así que...

. . .

```{r}
relig_tidy <-
  relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused", names_to = "income",
               values_to = "people")
relig_tidy 
```

---

## Ejemplo: relig_income

Vamos a hilar más fino: ahora mismo en la variable `income` en realidad tenemos dos valores, el límite inferior y el superior de la renta. Vamos a [**separar dicha variable e ingresos**]{.hl-yellow} en dos, llamadas `income_inf` y `income_sup`

```{r}
relig_tidy 
```

---

## Ejemplo: relig_income

Vamos a hilar más fino: ahora mismo en la variable `income` en realidad tenemos dos valores, el límite inferior y el superior de la renta. Vamos a [**separar dicha variable e ingresos**]{.hl-yellow} en dos, llamadas `income_inf` y `income_sup`


```{r}
relig_tidy |>
  # Separamos por -
  separate(income, into = c("income_inf", "income_sup"), sep = "-")
```

. . .

¿Está ya bien? Fíjate bien...

---

## Ejemplo: relig_income

```{r}
relig_tidy |>
  # Separamos por -
  separate(income, into = c("income_inf", "income_sup"), sep = "-")
```

Si te fijas la primera columna el `"$10k"` debería ser una cota superior, no inferior. ¿Cómo indicarle que separe bien ese caso?

---

## Ejemplo: relig_income

Le indicaremos que separe si encuentra `"-"` o `"<"` (usamos `|` para separar ambas opciones)

```{r}
relig_tidy |>
  # Separamos por -
  separate(income, into = c("income_inf", "income_sup"), sep = "-|<")
```

---

## Ejemplo: relig_income

```{r}
relig_tidy <-
  relig_tidy |>
  # Separamos por -
  separate(income, into = c("income_inf", "income_sup"), sep = "-|<")
relig_tidy
```

Piensa ahora como podemos [**convertir los límites de ingresos a numéricas (eliminando símbolos, letras, etc)**]{.hl-yellow}

---

## Ejemplo: relig_income

Para ello usaremos el paquete `{stringr}`, en concreto la función `str_remove_all()`, a la que le podemos pasar los caracteres que queremos eliminar (fíjate que `$` al ser un caracter reservado en `R` hay que indicárselo con `\\$`)

```{r}
relig_tidy$income_inf <-
  str_remove_all(relig_tidy$income_inf, "\\$|>|k")
relig_tidy$income_sup <-
  str_remove_all(relig_tidy$income_sup, "\\$|>|k")

relig_tidy
```

---

## Ejemplo: relig_income

Fíjate que tenemos `"Don't now/refused"`. ¿Qué deberíamos tener?

. . .

Debería ser un [**dato ausente**]{.hl-yellow} así que usaremos `if_else()`: si contiene dicha frase, `NA`, en caso contrario su valor (consejo: `str_detect()` para detectar patrones en textos, y evitar tener que escribir toda la palabra sin errores)

```{r}
relig_tidy$income_inf <-
  if_else(str_detect(relig_tidy$income_inf, "refused"), NA, relig_tidy$income_inf)
relig_tidy$income_sup <-
  if_else(str_detect(relig_tidy$income_sup, "refused"), NA, relig_tidy$income_sup)
relig_tidy
```

---

## Ejemplo: relig_income

```{r}
relig_tidy
```

En la primera línea, ese `""` también debería ser `NA``

```{r}
relig_tidy$income_inf <-
  if_else(relig_tidy$income_inf == "", NA, relig_tidy$income_inf)
relig_tidy$income_suop <-
  if_else(relig_tidy$income_sup == "", NA, relig_tidy$income_sup)
```

---

## Ejemplo: relig_income

```{r}
relig_tidy
```

Además si te fijas los números son en realidad caracteres, así que vamos a [**convertirlos a números**]{.hl-yellow}



---

## Ejemplo: relig_income


Además si te fijas los números son en realidad caracteres, así que vamos a [**convertirlos a números**]{.hl-yellow}

```{r}
relig_tidy$income_inf <- as.numeric(relig_tidy$income_inf)
relig_tidy$income_sup <- as.numeric(relig_tidy$income_sup)
relig_tidy
```

---

## Ejemplo: relig_income

¿Se te ocurre alguna forma de **«cuantificar numéricamente»** los valores ausentes que tenemos en este caso?

. . .

Si te fijas en realidad cuando hay ausente en el límite inferior en realidad podríamos poner un 0 (nadie puede ganar menos de eso) y cuando lo tenemos en el límite superior sería `Inf`

```{r}
relig_tidy$income_inf <-
  if_else(is.na(relig_tidy$income_inf), 0, relig_tidy$income_inf)
relig_tidy$income_sup <-
  if_else(is.na(relig_tidy$income_sup), Inf, relig_tidy$income_sup)
relig_tidy
```

---

## Ejemplo: relig_income

Aunque nos haya llevado un rato este es el **código completo resumido**

```{r}
#| eval: false
relig_tidy <-
  relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused", names_to = "income",
               values_to = "people") |>
  separate(income, into = c("income_inf", "income_sup"), sep = "-|<")

relig_tidy$income_inf <- str_remove_all(relig_tidy$income_inf, "\\$|>|k")
relig_tidy$income_sup <- str_remove_all(relig_tidy$income_sup, "\\$|>|k")

relig_tidy$income_inf <-
  if_else(str_detect(relig_tidy$income_inf, "refused") |
            relig_tidy$income_inf == "", 0, as.numeric(relig_tidy$income_inf))
relig_tidy$income_sup <-
  if_else(str_detect(relig_tidy$income_sup, "refused") |
            relig_tidy$income_sup == "", Inf, as.numeric(relig_tidy$income_sup))
```

---

## Ejemplo: relig_income

¿Por qué era [**importante tenerlo en tidydata**]{.hl-yellow}? Lo veremos más adelante al visualizar los datos pero esto ya nos permite realizar filtros muy rápidos con muy poco código.

Por ejemplo: ¿cuántas personas agnósticas con ingresos superiores (o iguales) a 30 tenemos?

. . .

```{r}
# una línea de código
sum(relig_tidy$people[relig_tidy$religion == "Agnostic" & relig_tidy$income_inf >= 30])
```

---

## 💻 Tu turno {#tu-turno-1-5}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 Usa el dataset original `relig_income` y trata de responder a la última pregunta:  ¿cuántas personas agnósticas con ingresos superiores (o iguales) a 30 tenemos? Compara el código a realizar cuando tenemos tidydata a cuando no. ¿Cuál es más legible si no supieses `R`? ¿Cuál tiene mayor probabilidad de error?

```{r}
#| code-fold: true
#| eval: false

sum(relig_income[relig_income$religion == "Agnostic",
             c("$30-40k", "$40-50k", "$50-75k", "$75-100k", "$100-150k", ">150k")])
```


### [**Ejercicio 2**]{.hl-yellow}

📝 Usando `relig_tidy` determina quién tiene más ingresos medios, ¿católicos (`Catholic`) o agnósticos (`Agnostic`)? Crea antes una variable `avg_income` (ingresos medios por intervalo): si hay 5 personas entre 20 y 30, y 3 personas entre 30 y 50, la media sería $(25*5 + 40*3)/8$ (si es `Inf` por arriba, `NA`)

```{r}
#| code-fold: true
#| eval: false
relig_tidy$avg_income <- 
  if_else(is.infinite(relig_tidy$income_sup), NA, (relig_tidy$income_sup + relig_tidy$income_inf)/2)

# Agnosticos vs catolicos
sum((relig_tidy$avg_income[relig_tidy$religion == "Agnostic"] * relig_tidy$people[relig_tidy$religion == "Agnostic"]), na.rm = TRUE) /
  sum(relig_tidy$people[relig_tidy$religion == "Agnostic"], na.rm = TRUE)

sum((relig_tidy$avg_income[relig_tidy$religion == "Catholic"] * relig_tidy$people[relig_tidy$religion == "Catholic"]), na.rm = TRUE) /
  sum(relig_tidy$people[relig_tidy$religion == "Catholic"], na.rm = TRUE)
```


### [**Ejercicio 3**]{.hl-yellow}

📝 Si debemos elegir budismo (`Buddhist`) e hinduismo (`Hindu`), ¿cuál de las dos es la religión mayoritaria entre los que ganan más de 50 000$ anuales?

```{r}
#| code-fold: true
#| eval: false

greatest_income <-
  relig_tidy[relig_tidy$income_inf >= 50 & relig_tidy$religion %in% c("Buddhist", "Hindu"), ]

sum(greatest_income$people[greatest_income$religion == "Buddhist"], na.rm = TRUE)
sum(greatest_income$people[greatest_income$religion == "Hindu"], na.rm = TRUE)
```


### [**Ejercicio 4**]{.hl-yellow}

📝 Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```


### [**Ejercicio 5**]{.hl-yellow}

📝 Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```

:::

---

## 🐣 Caso práctico III {#caso-practico-1-3}

En el paquete `{tidyr}` contamos con el dataset `who2` (dataset de la Organización Mundial de la Salud). Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/repaso-r-ts/).

```{r}
who2
```

# Clase 3: [introducción a series]{.flow} {#clase-3}

[**Introducción al análisis descriptivo de series temporales**]{style="color:#444442;"}


* [📆 Planificación](#planificacion)

---

## ¿Qué es una serie temporal?

Como ya hemos visto, una [**serie temporal**]{.hl-yellow} se puede definir de manera informal como una [**muestra de una variable**]{.hl-yellow} (usualmente continua) recogida de manera [**secuencial en el tiempo**]{.hl-purple}

```{r}
#| code-fold: true
ggplot(retiro) +
  geom_line(aes(x = fecha, y = tmed), linewidth = 0.3, alpha = 0.7) +
  theme_minimal() +
  labs(title = "Temperatura media como SERIE TEMPORAL",
       x = "t (fecha)", y = "ºC (media)")
```

---

## Un poco de historia

Las [**primeras series temporales**]{.hl-yellow} aparecieron en el siglo XIX, cuando el matemático **Laplace** (matemático, profesor de Napoleón y luego ministro) se dedicaba a estudiar la [**relación entre las fases de La Luna y la presión**]{.hl-yellow} atmosférica (por el nivel del mar).

. . .

Aunque su primera aproximación fue un poco chapuza (intentó ajustar una función seno sin tener en cuenta el tiempo), [**Arthur Schuster decidió aplicar los trabajos de Fourier para que dichas sinusoidales dependiesen del tiempo**]{.hl-yellow} (Fourier había demostrado que toda función periódica podía descomponerse como suma de senos y cosenos).

---

## Un poco de historia

Treinta años más tarde, [**Yule y Slutsky aplicaron las ideas de la regresión**]{.hl-yellow} desarrollados por Galton y Pearson al estudio de procesos cuya variable regresora es ella misma en otro instante temporal (**procesos autoregresivos**), aunque no fue hasta la llegada de **Kolmogorov** cuando se formalizó su definición matemática en el contexto de los [**procesos estocásticos**]{.hl-yellow}.

. . .

Tras acabar la Segunda Guerra Mundial quedaron desclasificados algunos trabajos de Wiener, Kolmogorov, Bartlett y Tukey sobre la predicción de series temporales, así como su estudio  en función del análisis de las [**correlaciones**]{.hl-yellow}. Tras los trabajos de alisado de Holt y Winter en los años 60, en 1970 [**Box y Jenkins publican «La Biblia» de las series temporales**]{.hl-yellow}, un manual donde se presenta una metodología para la identificación, estimación y predicción de series temporales (los conocidos como **procesos SARIMA**)


---

## Métodos de análisis


* [**Métodos descriptivos o clásicos**]{.hl-yellow}: desarrollados entre 1940 y 1970, están enfocadas principalmente en la [**estimación de los valores de la serie**]{.hl-yellow}, siendo bastante [**malos en la predicción futura**]{.hl-red}.

  * [**Métodos de decomposición**]{.hl-purple} (tendencia-estacionalidad-error):
    * Suavizado clásico
    * STL (seasonal-trend decomposition procedure based on loess)
  * [**Métodos de alisado**]{.hl-purple} (dependencia del pasado disminuye con el tiempo):
    * Alisado exponencial simple
    * Alisado doble de Holt y triple de Holt-Winters
. . .

* [**Métodos probabilísticos**]{.hl-yellow}: enmarcados dentro del análisis de los procesos estocásticos, se considera que la serie temporal observada es solo una muestra de un proceso estocástico. Necesitaremos **hipótesis**.

---

## Métodos descriptivos

Los [**métodos descriptivos o clásicos**]{.hl-yellow} se basan en entender, de manera casi empírica, el comportamiento de la serie, pareciéndose más una interpolación que a una metodología rigurosa de estimación y predicción.

&nbsp;

Vamos a empezar denotando a la serie como $X = \left\lbrace X_t \right\rbrace_{t}$, de la cual observamos una **muestra** $\left(x_0, \ldots, x_{T} \right)$.

. . .

¿Cuál se te ocurre que sería el [**caso más sencillo de serie temporal**]{.hl-yellow}? 

---

## Descomposición clásica: sin tendencia

El caso más sencillo es considerar que la serie es [**completamente aleatoria**]{.hl-yellow}, es decir $X_t = \varepsilon_t$.

. . .

Al término $\left\lbrace \varepsilon_t \right\rbrace_{t \in T}$ le llamaremos [**error o innovación**]{.hl-purple} y, dado que se supone que no captura ningún patrón y que la serie debe [**ser finita**]{.hl-yellow}, tendríamos

$$X_t = \varepsilon_t, \quad {\rm E} \left[X_t \right] = {\rm E} \left[\varepsilon_t \right] = 0, \quad  {\rm Var} \left[\varepsilon_t \right] = \sigma_{\varepsilon}^{2} = cte < \infty$$
donde normalmente el error sigue una distribución normal de varianza finita.


. . .

Además dicho término de error cumplirá que el [**pasado no proporciona ningún tipo de información sobre el futuro**]{.hl-yellow}, es decir, 

$$\varepsilon_{t+1} | \left(\varepsilon_t, \varepsilon_{t-1}, \ldots, \varepsilon_0 \right)  \sim \varepsilon_{t+1} \sim N \left(0, \sigma_{\varepsilon}^{2} \right)$$

---

## Sin tendencia

💻 ¿Cómo podríamos simular dicha serie temporal? 


. . .

1. **Paso 1**: construye un tibble de 5 columnas, donde la primera columna contenga los valores $t=1, 2, \ldots, 1000$; y donde la segunda columna contenga valores simulados según una normal $N(0, \sigma = 0.5)$, la tercera con $\sigma = 1$, la cuarta con $\sigma = 2$ y la quinta con $\sigma = 4$.

```{r}
#| code-fold: true
n <- 1000
datos <-
  tibble("t" = 1:n,
         "sd_05" = rnorm(n, mean = 0, sd = 0.5), "sd_1" = rnorm(n, mean = 0, sd = 1),
         "sd_2" = rnorm(n, mean = 0, sd = 2), "sd_4" = rnorm(n, mean = 0, sd = 4))
```

---

## Sin tendencia

2. **Paso 2**: haz un gráfico (¿cuál harías?) solo considerando $t$ y la primera serie `sd_05`


. . .

```{r}
#| code-fold: true
ggplot(datos) +
  geom_line(aes(x = t, y = sd_05)) +
  theme_minimal() +
  labs(x = "t", y = "X_t",
       title = "Serie temporal X_t = eps_t con sd = 0.5")
```

---

## Sin tendencia


3. **Paso 3**: ¿cómo deberíamos de transformar los datos para poder pintar todas las series a la vez?  Hazte un borrador de cómo sería el código de ggplot para dibujarlo.

. . .

La idea es que si tenemos $p$ series, en lugar de tener $p$ variables distintas, tengamos una serie «debajo de» otra. Por ejemplo, vamos a definir la primera y pongamos debajo al segunda otra.

```{r}
n <- 1000
datos <- tibble("t" = 1:n, "X_t" = rnorm(n, mean = 0, sd = 0.5), "sd" = "sd_0.5")
datos_tidy <- 
  rbind(datos, tibble("t" = 1:n, "X_t" = rnorm(n, mean = 0, sd = 1), "sd" = "sd_1"))
datos_tidy
```

---

## Sin tendencia

El resto las iremos concatenando de la misma manera, añadiendo filas al `datos_tidy` que ya tenemos.

```{r}
datos_tidy <- 
  rbind(datos_tidy, tibble("t" = 1:n, "X_t" = rnorm(n, mean = 0, sd = 2), "sd" = "sd_2"))

datos_tidy <- 
  rbind(datos_tidy, tibble("t" = 1:n, "X_t" = rnorm(n, mean = 0, sd = 4), "sd" = "sd_4"))
```

. . .

Lo anterior se pueda hacer más "conciso" con `{tidyverse}` haciendo uso de `pivot_longer()`.

```{r}
#| eval: false
datos_tidy <-
  datos |>
  pivot_longer(cols = "sd_05":"sd_4", names_to = "sd", values_to = "X_t")
```

---


## Sin tendencia


```{r}
#| code-fold: true
ggplot(datos_tidy) +
  geom_line(aes(x = t, y = X_t, color = sd),
            alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~sd) +
  theme_minimal() +
  labs(x = "t", y = "X_t", color = "Desv. típica",
       title = "Serie temporal X_t = eps_t con distintas varianzas")
```



---

## Sin tendencia

4. **Paso 4**. Para automatizarlo, diseña una **función** tal que le introduzcas como argumento un tamaño muestral $n$, un $t$ y un vector de desviaciones típicas, y devuelva en formato tidy data los valores de las series temporales (tantas series como longitud tenga el vector de desviaciones)

```{r}
#| code-fold: true
time_series_error <- function(n, t = 1:n, sd_vec = 1) {
  
  datos_tidy <- tibble()
  
  for (i in 1:length(sd_vec)) {
    
    datos_tidy <- 
      datos_tidy |>
      rbind(datos_tidy,
            tibble("t" = t, "sd" = glue::glue("sd_{sd_vec[i]}"),
                   "X_t" = rnorm(n, mean = 0, sd = sd_vec[i])))
  }
  return(datos_tidy)
}
```

---

## Sin tendencia

Esta serie temporal $X_t = \varepsilon_t$ es la más sencilla que podemos imaginar y [**no podemos predecirla**]{.hl-red} ya que no hay ningún tipo de patrón determinístico que podamos capturar.

```{r}
#| code-fold: true
datos <- time_series_error(n = 1000, sd = c(0.5, 1, 2, 4))
ggplot(datos) +
  geom_line(aes(x = t, y = X_t, color = sd), alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~sd) +
  theme_minimal() +
  labs(x = "t", y = "X_t", color = "Desv. típica",
       title = "Serie temporal X_t = eps_t con distintas varianzas")
```

# Clase 4: [simulación error + tendencia]{.flow} {#clase-4}

[**Introducción al análisis descriptivo de series temporales**]{style="color:#444442;"}


* [💻 Ejercicios de simulación](#tu-turno-4-1)
* [📆 Planificación](#planificacion)


---

## Con tendencia

Normalmente una serie temporal suele ser más complejo y lleva al menos incorporada una [**componente de tendencia o nivel $\mu_t$**]{.hl-yellow} tal que

$$X_t = f \left(\mu_t, \varepsilon_t\right) =^{*} \mu_t + \varepsilon_t, \quad {\rm E} \left[X_t \right] = \mu_t$$
$*$ De momento estamos considerando una [**descomposición aditiva**]{.hl-yellow}

&nbsp;

Fíjate que ahora ${\rm E} \left[X_t \right] = \mu_t$ ya que la esperanza de la parte aleatoria (ruido) será asumida siempre nula: $\mu_t$ es el nivel de la serie respecto a la que oscila en el infinito.

---


## Con tendencia


$$X_t = f \left(\mu_t, \varepsilon_t\right) =^{*} \mu_t + \varepsilon_t, \quad {\rm E} \left[X_t \right] = \mu_t$$

Dicha tendencia $\mu_t$ puede ser a su vez modelada en función de $t$ y de un vector de parámetros $\beta$ tal que $\mu_t := f \left(t, \beta \right)$. Esa función $f \left( \cdot \right)$ puede ser cualquier función que se te ocurre pero algunas de las tendencias más habituales son:

- [**Constante**]{.hl-purple}: $\mu_t = \beta = \beta_0 = cte$ 

- [**Lineal**]{.hl-purple}: $\mu_t = \beta_0 + \beta_1 t$ 

- [**Polinómica (no lineal)**]{.hl-purple}: $\mu_t = \beta_0 + \beta_1 t + \ldots + \beta_r t^{r}$ 

- [**No polinómica**]{.hl-purple}: $\mu_t = \sin \left(\pi t \right)$ 


---

## Con tendencia

- [**Constante**]{.hl-purple}: $\mu_t = \beta = \beta_0 = cte$ 


$$X_t = f \left(\mu_t, \varepsilon_t\right) = \beta_0  + \varepsilon_t , \quad {\rm E} \left[X_t \right] = \beta_0, \quad \widehat{X}_{t + k} = \widehat{\beta}_0$$

```{r}
#| echo: false
trend <- 3
datos <-
  time_series_error(n = 1000, sd = 1) |> 
  mutate(X_t = X_t + trend)
ggplot(datos) +
  geom_line(aes(x = t, y = X_t), alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  theme_minimal() +
  labs(x = "t", y = "X_t",
       title = "Serie temporal X_t = mu_t + eps_t con mu_t = 3")
```

---

## Con tendencia

- [**Lineal**]{.hl-purple}: $\mu_t = \beta_0 + \beta_1 t$ 


$$X_t = f \left(\mu_t, \varepsilon_t\right) = \beta_0  + \beta_1 t + \varepsilon_t , \quad {\rm E} \left[X_t \right] = \beta_0  + \beta_1 t \to \pm \infty, \quad \widehat{X}_{t + k} = \widehat{\beta}_0 + \widehat{\beta}_1 \left(t + k \right)$$

```{r}
#| echo: false
trend <- c(-3, 0.01)
datos <-
  time_series_error(n = 1000, sd = 1) |> 
  mutate(X_t = X_t + trend[1] + trend[2]*t)
ggplot(datos) +
  geom_line(aes(x = t, y = X_t), alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  theme_minimal() +
  labs(x = "t", y = "X_t",
       title = "Serie temporal X_t = mu_t + eps_t con mu_t = -3 + 0.01*t")
```

---

## Con tendencia

- [**Polinómica (no lineal)**]{.hl-purple}: $\mu_t = \beta_0 + \beta_1 t + \ldots + \beta_r t^{r}$ 

$$X_t = f \left(\mu_t, \varepsilon_t\right) = \beta_0 + \beta_1 t + \ldots + \beta_r t^{r} + \varepsilon_t , \quad \widehat{X}_{t + k} = \widehat{\beta}_0 + \widehat{\beta}_1 \left(t + k \right) + \ldots + \widehat{\beta}_r \left(t + k \right)^r$$

```{r}
#| echo: false
trend <- c(-1, 0.01, 0.000001, -0.00000001)
datos <-
  time_series_error(n = 1000, sd = 1) |> 
  mutate(X_t = X_t + trend[1] + trend[2]*t + trend[3]*t^2 + trend[4]*t^3)
ggplot(datos) +
  geom_line(aes(x = t, y = X_t), alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  theme_minimal() +
  labs(x = "t", y = "X_t",
       title = "Serie temporal X_t = mu_t + eps_t con mu_t = -1 + 0.01*t + 0.000001*t^2 -0.00000001*t^3")
```

---

## Con tendencia

Si nuestra tendencia está definida de forma **paramétrica**, para la predicción de los valores en un tiempo futuro $t + k$ simplemente necesitamos realizar la [**estimación del vector de parámetros $\widehat{\beta}$**]{.hl-yellow}. Para ello recurriremos al [**método de los minimos cuadrados**]{.hl-yellow}. Por ejemplo, en el caso de tendencia polinómica

$$\widehat{\beta} = \arg \min_{\beta \in \mathbb{R}^{r+1}} \sum_{t = 0}^{T} \left(x_t - \widehat{x}_t \right)^2 = \arg \min_{\beta \in \mathbb{R}^{r+1}} \sum_{t = 0}^{T} \left(x_t - \left(\beta_0 + \beta_1 t \ldots \beta_r t^r \right) \right)^2$$

. . .

Como suele ser habitual, para encontrar el mínimo basta con **derivar respecto a los parámetros e igualar a 0**. Por ejemplo...

- [**Constante**]{.hl-purple}: $\frac{\partial \sum_{t=0}^{T} \left(x_t - \beta_0 \right)^2}{\partial \beta_0} = T \beta_0 - \sum_{t=0}^{T} x_t = 0$ -> $\widehat{\beta}_0 = \overline{x}_{t=0, ..., T}$


---

## 💻 Tu turno {#tu-turno-4-1}

### [**Ejercicio 1**]{.hl-yellow}

💻 Si aún no lo has hecho, haz una función llamada `time_series_error` que [**simule una serie temporal solo con error**]{.hl-yellow}. Los argumentos deben ser: tamaño muestral `n`, un vector temporal `t` y la desv típica `sd` (debes permitir que pueda ser un vector para simular varias a la vez, ya colocadas en tidydata)


```{r}
#| code-fold: true
#| eval: false
time_series_error <- function(n, t = 1:n, sd_vec = 1) {
  
  datos_tidy <- tibble()
  for (i in 1:length(sd_vec)) {
    datos_tidy <- 
      datos_tidy |>
      rbind(datos_tidy,
            tibble("t" = t, "sd" = glue::glue("sd_{sd_vec[i]}"),
                   "X_t" = rnorm(n, mean = 0, sd = sd_vec[i])))
  }
  return(datos_tidy)
}
time_series_error(n = 100, sd = c(0.5, 2))
```

---

## 💻 Tu turno

### [**Ejercicio 2**]{.hl-yellow}


💻 Usando la función anterior, define  `time_series_trend_error()` que simule una serie temporal con **tendencia cte** y error, con solo 4 argumentos: `n`, `t`, desviación y la constante. Usa dicha función y dibuja.

```{r}
#| code-fold: true
time_series_trend_error <- function(n = 1000, t = 1:n, beta_0 = 0, sd = 1) {
  # modo R base
  datos <- time_series_error(n = n, t = t, sd = sd)
  datos$X_t <- datos$X_t + beta_0
  
  # modo tidyverse
  # datos <- time_series_error(n = n, t = t, sd = sd) |> mutate(X_t = X_t + trend)
  return(datos)
}

datos <- time_series_trend_error(n = 1000, beta_0 = 3, sd = 0.5)
ggplot(datos, aes(x = t, y = X_t)) +
  geom_line(alpha = 0.7) +
  geom_smooth(method = "lm", se = FALSE) +
  ggthemes::scale_color_colorblind() +
  theme_minimal() +
  labs(x = "t", y = "X_t", title = "Serie temporal X_t = mu_t + eps_t con mu_t = 3")
```

---

## 💻 Tu turno

### [**Ejercicio 3**]{.hl-yellow}

💻 Generaliza la función anterior para simular una [**serie temporal con error y tendencia lineal**]{.hl-yellow} (donde antes definíamos solo una constante ahora será un vector de coeficientes). Fíjate que la **línea de ajuste de ggplot es literal la estimación** que haríamos si solo consideramos error + tendencia.


```{r}
#| code-fold: true
time_series_trend_error <- function(n = 1000, t = 1:n, beta = c(1, -0.01), sd = 1) {
  
  datos <- time_series_error(n = n, t = t, sd = sd)
  datos$X_t <- datos$X_t + (beta[1] + beta[2]*datos$t)
  return(datos)
}

datos <- time_series_trend_error(n = 1000, beta = c(1, -0.01), sd = 0.5)
ggplot(datos, aes(x = t, y = X_t)) +
  geom_line(alpha = 0.7) +
  geom_smooth(method = "lm", se = FALSE) +
  ggthemes::scale_color_colorblind() +
  theme_minimal() +
  labs(x = "t", y = "X_t", title = "Serie temporal X_t = mu_t + eps_t con mu_t = 1 - 0.01*t")
```




# Clase 5: [simulación error + tendencia]{.flow} {#clase-5}

[**Introducción al análisis descriptivo de series temporales**]{style="color:#444442;"}

* [💻 Ejercicios de simulación](#tu-turno-5-1)
* [📆 Planificación](#planificacion)

---

## 💻 Tu turno {#tu-turno-5-1}


### [**Ejercicio 4**]{.hl-yellow}


💻 Generaliza la función anterior de manera que simule una [**serie temporal con error y tendencia polinómica**]{.hl-yellow} (que acepte un vector de parámetros general). 

```{r}
#| code-fold: true
time_series_trend_error <-
  function(n = 1000, t = 1:n, beta = c(1, -0.01, 0.001, -0.0001), sd = 1) {
  
  datos <- time_series_error(n = n, t = t, sd = sd)
  for (i in 1:length(beta)) {
    datos$X_t <- datos$X_t + beta[i]*(datos$t^(i - 1))
  } 
  return(datos)
}

datos <- time_series_trend_error(n = 1000, beta = c(1, 0.01, 0.000001, -0.00000001), sd = 0.5)
ggplot(datos, aes(x = t, y = X_t)) +
  geom_line(alpha = 0.7) +
  geom_smooth(formula = y ~ poly(x, 3), se = FALSE) +
  ggthemes::scale_color_colorblind() +
  theme_minimal() +
  labs(x = "t", y = "X_t", title = "Serie temporal X_t = mu_t + eps_t con mu_t cúbica")
```


---


## 💻 Tu turno

### [**Ejercicio 5**]{.hl-yellow}

💻 Diseña una función `estim_ts_trend_error()` que, dada una serie (un tibble de dos columnas `t` y `X_t`), nos devuelva la misma tabla pero con una **tercera columna con su estimación** asumiendo una tendencia polinómica (necesitamos dos argumentos: la tabla y el grado del polinomio; haz uso dentro de `poly()`, chequea en la ayuda de la función `? poly()`)

```{r}
#| code-fold: true
estim_ts_trend_error <- function(datos, degree = 1) {
  if (degree == 0) {
    modelo <- datos |> lm(formula = X_t ~ 1)
  } else {
    modelo <- datos |> lm(formula = X_t ~ poly(t, degree, raw = TRUE))
  }
  datos$X_hat <- predict(modelo, tibble("t" = datos$t))
  return(datos)
}
datos <- time_series_trend_error(n = 1000, beta = c(1, 0.01, 0.000001, -0.00000001), sd = 0.5)
# ajustamos un modelo polinómico de tendencia
modelo <- datos |> estim_ts_trend_error(degree = 3)
```

```{r}
#| echo: false
ggplot(modelo) +
  geom_line(aes(x = t, y = X_t), alpha = 0.7) +
  geom_line(aes(x = t, y = X_hat), alpha = 0.7, color = "red") +
  theme_minimal() +
  labs(x = "t", y = "X_t", title = "Serie temporal X_t = mu_t + eps_t con mu_t cúbica")
```



---

## Caso real: AEMET

Como ya te puedes estar imaginando, esta forma de estimar una serie temporal con un polinomio puede ser [**bastante imprecisa**]{.hl-red}, máxime si aparece en nuestra serie una [**componente estacional**]{.hl-yellow} (un patrón periódico).

Vamos a retomar por ejemplo nuestros **datos de temperatura del AEMET**

```{r}
#| code-fold: true
ggplot(retiro) +
  geom_line(aes(x = fecha, y = tmed), linewidth = 0.3, alpha = 0.7) +
  theme_minimal() +
  labs(title = "Temperatura media como SERIE TEMPORAL",
       x = "t (fecha)", y = "ºC (media)")
```

---

## Caso real: AEMET

💻 Aplica la función de estimación definida anteriormente a los datos reales del AEMET para incluir 3 nuevas columnas con los 3 métodos de estimación (tendencia constante, lineal y polinómica de grado 3)

. . .

```{r}
retiro_estim <-
  tibble("fecha" = retiro$fecha, "t" = 1:length(fecha), "X_t" = retiro$tmed) |>
  # aplicamos función y renombramos variable de salida de la estimación
  estim_ts_trend_error(degree = 0) |> rename(X_t_hat_0 = X_hat) |>
  estim_ts_trend_error(degree = 1) |> rename(X_t_hat_1 = X_hat) |> 
  estim_ts_trend_error(degree = 3) |> rename(X_t_hat_3 = X_hat) 
```


---

## Caso real: AEMET


:::: columns
::: {.column width="25%"}

Como observas las [**predicciones no son precisas cuando hay una componente estacional**]{.hl-red} ya que el ajuste realizado solo se fija en una tendencia con unos **coef ctes**.

&nbsp;


¿Se te ocurre alguna **idea para mejorar**?

:::

::: {.column width="75%"}

```{r}
#| code-fold: true
ggplot(retiro_estim |>
         pivot_longer(-c(fecha, t), names_to = "type", values_to = "pred")) +
  geom_line(aes(x = fecha, y = pred, color = type),
            linewidth = 0.4, alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  theme_minimal() +
  labs(title = "Temperatura media como SERIE TEMPORAL",
       x = "t (fecha)", y = "ºC (media)")
```

:::
::::



# Clase 6: [medias móviles]{.flow} {#clase-6}

[**Suavizado por medias móviles**]{style="color:#444442;"}

* [💻 Ejercicios](#tu-turno-6-1)
* [📆 Planificación](#planificacion)


---

## Recapitulando

Hasta ahora nos hemos centrado sobre todo en tres cosas

* Repasar lo que supiéramos de `R`

* Entender cómo simular y estimar series sencillas

* Visualizar dichas series

. . .

Pero a partir de ahora pulsaremos un poco el acelerador (así quién tenga muchos problemas en la parte de programación, deberá **empezar a usar del mail y las tutorías**)

---

## Recapitulando

¿Qué deberíamos saber hasta ahora?

* Deberíamos tener una función `ts_error()` parecida a esta para [**simular un ruido**]{.hl-yellow} de una varianza dada.

```{r}
ts_error <- function(n, t = 1:n, sd_vec = 1) {
  
  datos_tidy <- tibble()
  for (i in 1:length(sd_vec)) {
    datos_tidy <- 
      rbind(datos_tidy,
            tibble("t" = t, "sd" = glue::glue("sd_{sd_vec[i]}"),
                   "X_t" = rnorm(n, mean = 0, sd = sd_vec[i])))
  }
  return(datos_tidy)
}
ts_error(n = 100, sd = c(0.5, 2))
```

---

## Recapitulando

¿Qué deberíamos saber hasta ahora?

* Deberíamos tener una función `ts_trend_error` parecida a esta para [**simular una serie formada por tendencia polinómica más ruido**]{.hl-yellow}, con una varianza dada y un vector de coeficientes dado.

```{r}
ts_trend_error <-
  function(n = 1000, t = 1:n, beta = c(1, -0.01, 0.001, -0.0001), sd = 1) {
  
  datos <- ts_error(n = n, t = t, sd = sd)
  for (i in 1:length(beta)) {
    datos$X_t <- datos$X_t + beta[i]*(datos$t^(i - 1))
  } 
  return(datos)
}
datos <- ts_trend_error(n = 1000, beta = c(1, 0.01, 0.000001, -0.00000001), sd = 0.5)
```

---

## Recapitulando

¿Qué deberíamos saber hasta ahora?

* Deberías ser capaz de entender cómo [**organizar los datos**]{.hl-yellow} de manera que podamos visualizar de manera sencilla.

:::: columns
::: {.column width="47%"}

```{r}
#| eval: false
ggplot(datos) +
  geom_line(aes(x = t, y = X_t),
            alpha = 0.6) +
  ggthemes::scale_color_colorblind() +
  theme_minimal() +
  labs(x = "t", y = "X_t",
       title = "Serie temporal X_t = mu_t + eps_t (mu_t cúbica)")
```

:::

::: {.column width="53%"}

```{r}
#| echo: false
ggplot(datos) +
  geom_line(aes(x = t, y = X_t), alpha = 0.6) +
  ggthemes::scale_color_colorblind() +
  theme_minimal() +
  labs(x = "t", y = "X_t",
       title = "Serie temporal X_t = mu_t + eps_t (mu_t cúbica)")
```

:::

::::

---

## Recapitulando


* Y por último deberías tener una `estim_ts_trend_error()` similar a esta para que, dada una [**serie cualquiera**]{.hl-yellow}, con dos columnas para $t$ y $X_t$ (con cualquier nombre) haga la estimación. [**Fíjate de los argumentos `tag_estim` y `nuevos_valores` que hacen para facilitarnos la vida a futuro**]{.hl-purple}

```{r}
estim_ts_trend_error <-
  function(datos, degree = 1, tag_estim = paste0("estim_poly_", degree),
           col_t = "t", col_X_t = "X_t", nuevos_valores = NULL) {
    
    datos <- # versión tidyverse
      datos |> select(all_of(col_t), all_of(col_X_t)) |>
      rename(t = all_of(col_t), X_t = all_of(col_X_t))
    
    # R base normal
    # datos <- datos[, c(col_t, col_X_t)]
    # names(datos)[names(datos) == col_t] <- "t"
    # names(datos)[names(datos) == col_X_t] <- "X_t"

    if (degree == 0) {
      modelo <- datos |> lm(formula = X_t ~ 1)
    } else {
      modelo <- datos |> lm(formula = X_t ~ poly(t, degree, raw = TRUE))
    }
    datos[, tag_estim] <- predict(modelo, tibble("t" = datos$t))
    
    if (!is.null(nuevos_valores)) {
      nuevos_datos <- tibble("t" = nuevos_valores, "X_t" = NA)
      nuevos_datos[, tag_estim] <- predict(modelo, tibble("t" = nuevos_datos$t))
      datos <- rbind(datos, nuevos_datos)
    }
    return(datos)
}

```

---

## Caso real: AEMET

Con todo esto podemos aplicar nuestras funciones para [**estimar los datos reales del AEMET**]{.hl-yellow}, estimando bajo 4 hipótesis: solo ruido, ruido + tendencia cte, ruido + tendencia lineal y ruido + tendencia polinómica de grado 3.

. . .

```{r}
retiro_estim <-
  estim_ts_trend_error(retiro[, c("fecha", "tmed")], degree = 0,
                       col_t = "fecha", col_X_t = "tmed")
retiro_estim$estim_poly_1 <- 
  estim_ts_trend_error(retiro[, c("fecha", "tmed")], degree = 1,
                       col_t = "fecha", col_X_t = "tmed")$estim_poly_1
retiro_estim$estim_poly_3 <- 
  estim_ts_trend_error(retiro[, c("fecha", "tmed")], degree = 3,
                       col_t = "fecha", col_X_t = "tmed")$estim_poly_3
retiro_estim$estim_noise <- 0 # fíjate que el ruido la estimación es...0
retiro_estim_tidy <-
  retiro_estim |> 
  pivot_longer(cols = -t, names_to = "serie", values_to = "X_t")
```

---

## Caso real: AEMET

Fíjate que de cada `estim_ts_trend_error()` solo nos interesa la propia estimación ya que `t` y `X_t` es igual siempre, así que podríamos hacer un `left_join()` de las diferentes tablas.

```{r}
#| code-line-numbers: 4-9
retiro_estim <-
  estim_ts_trend_error(retiro[, c("fecha", "tmed")], degree = 0,
                       col_t = "fecha", col_X_t = "tmed") |> 
  left_join(estim_ts_trend_error(retiro[, c("fecha", "tmed")], degree = 1,
                                 col_t = "fecha", col_X_t = "tmed"),
            by = c("t", "X_t")) |> 
  left_join(estim_ts_trend_error(retiro[, c("fecha", "tmed")], degree = 3,
                                 col_t = "fecha", col_X_t = "tmed"),
            by = c("t", "X_t"))
retiro_estim$estim_noise <- 0 # fíjate que el ruido la estimación es...0
retiro_estim_tidy <-
  retiro_estim |> 
  pivot_longer(cols = -t, names_to = "serie", values_to = "X_t")
```

---

## Caso real: AEMET

Y también deberíamos saber ya visualizar todo

```{r}
#| code-fold: true
ggplot(retiro_estim_tidy) +
  geom_line(aes(x = t, y = X_t, color = serie,
                linewidth = serie, alpha = serie, linetype = serie)) +
  ggthemes::scale_color_colorblind() +
  scale_alpha_manual(values = c(0.85, 0.85, 0.85, 0.85, 1)) +
  scale_linewidth_manual(values = c(1.1, 1.1, 1.1, 1.1, 0.1)) +
  scale_linetype_manual(values = c("dotted", "dotted", "dotted", "dotted", "solid")) +
  theme_minimal() +
  labs(x = "t", y = "Temperatura (ºC)", title = "Estimación serie AEMET")
```

---

## Caso real: AEMET

La idea de los métodos de estimación es que podamos usarlos no solo para estimar sino también para [**predecir en instantes temporales futuros**]{.hl-yellow}, haciendo uso de esos **«nuevos valores»** que podemos usar en `estim_ts_trend_error()`.

. . .

Por ejemplo, en los datos tenemos solo hasta el 31 de agosto de 2024: [**¿cuál es la predicción de los distintos métodos para todo el mes de septiembre, octubre y noviembre?**]{.hl-purple}

---

## Caso real: AEMET


Por ejemplo, en los datos tenemos solo hasta el 31 de agosto de 2024: [**¿cuál es la predicción de los distintos métodos para lo que queda de 2024 y 2025?**]{.hl-purple}

```{r}
#| code-line-numbers: "1,6,9,13"
nuevos_valores <- seq(as_date("2024-09-01"), as_date("2025-12-31"), by = 1)

retiro_predict <-
  estim_ts_trend_error(retiro[, c("fecha", "tmed")], degree = 0,
                       col_t = "fecha", col_X_t = "tmed",
                       nuevos_valores = nuevos_valores) |> 
  left_join(estim_ts_trend_error(retiro[, c("fecha", "tmed")], degree = 1,
                                 col_t = "fecha", col_X_t = "tmed",
                                 nuevos_valores = nuevos_valores),
            by = c("t", "X_t")) |> 
  left_join(estim_ts_trend_error(retiro[, c("fecha", "tmed")], degree = 3,
                                 col_t = "fecha", col_X_t = "tmed",
                                 nuevos_valores = nuevos_valores),
            by = c("t", "X_t"))
retiro_predict$estim_noise <- 0 # fíjate que el ruido la predicción es...0

retiro_predict_tidy <-
  retiro_predict |> 
  pivot_longer(cols = -t, names_to = "serie", values_to = "X_t")
```

---


## Caso real: AEMET


```{r}
#| code-fold: true
# filtro un poco para que se vea mejor
ggplot(retiro_predict_tidy |> 
         filter(t > as_date("2015-01-01"))) +
  geom_line(aes(x = t, y = X_t, color = serie,
                linewidth = serie, alpha = serie, linetype = serie)) +
  geom_vline(xintercept = max(retiro$fecha), linetype = "twodash", color = "#a61d0f", alpha = 0.5, linewidth = 0.9) +
  ggthemes::scale_color_colorblind() +
  scale_alpha_manual(values = c(0.85, 0.85, 0.85, 0.85, 1)) +
  scale_linewidth_manual(values = c(1, 1, 1, 1, 0.2)) +
  scale_linetype_manual(values = c("dotted", "dotted", "dotted", "dotted", "solid")) +
  theme_minimal() +
  labs(x = "t", y = "Temperatura (ºC)", title = "Predicción serie AEMET")
```

---

## Tendencia «dinámica»

El problema del ajuste anterior es que, amén de la parte puramente estocástica y la tendencia (más o menos compleja que pueda tener), [**existe una parte ESTACIONAL**]{.hl-yellow}

. . .

Diremos que una serie tiene una [**componente estacional**]{.hl-yellow} siempre que presente un [**patrón que se repite en periodos (aprox.) fijos en el tiempo**]{.hl-yellow} tal que 

$$X_t = f \left(\mu_t, S_t, \varepsilon_t\right) =^{adit} \mu_t + S_t + \varepsilon_t, \quad X_t =^{mult} \mu_t * S_t * \varepsilon_t$$

. . .

Trataremos de **manera general con los modelos aditivos** ya que, en caso de ser multiplicativo, $\log \left(X_t\right) =\log \left( \mu_t \right) + \log \left(S_t \right) + \log \left( \varepsilon_t \right)$

---

## Medias móviles

Existen diferentes estrategias para tener en cuenta la estacionalidad, muchas de ellas basadas en la idea de considerar que la [**tendencia no es algo estático**]{.hl-yellow}

. . .

:::: columns
::: {.column width="35%"}

La más famosa (y sencilla) probablemente sea la idea de [**suavizado de medias móviles**]{.hl-yellow}: en lugar de suavizar la serie considerando una media global, vamos [**mirar la serie por una pequeña ventana**]{.hl-yellow} donde para cada $t$ solo observemos un pequeño trozo de la serie.

:::

::: {.column width="65%"}

![](img/window-ma.webp)
:::
::::

---

## Medias móviles


Imagina que tenemos la siguiente serie

```{r}
datos <- tibble("t" = 1:15,
                "x" = c(0.8, 1.3, 1.6, 1.5, 2.2, 2.3, 2.2, 2.4,
                        2, 1.5, 1.2, 1.3, 1.2, 1, 0.7))
```

```{r}
#| echo: false
ggplot(datos) +
  geom_line(aes(x = t, y = x)) +
  theme_minimal()
```


---

## Medias móviles


```{r}
datos <- tibble("t" = 1:15,
                "x" = c(0.8, 1.3, 1.6, 1.5, 2.2, 2.3, 2.2, 2.4,
                        2, 1.5, 1.2, 1.3, 1.2, 1, 0.7))
```

La idea de las [**medias móviles**]{.hl-yellow} es la siguiente:

. . .

1. Decide la [**anchura de tu ventana**]{.hl-yellow} (cuantos datos permites que entren), por ejemplo $5$.

. . .

2. Decide qué [**peso vas a asignar**]{.hl-yellow} a cada uno de los puntos (por ejemplo, $1/5$ en nuestro caso)

. . .

3. [**Avanza en la serie con tu ventana**]{.hl-yellow} en cada valor de $t$ y centra la ventana en cada punto (si lo tenemos)

---

## Medias móviles

$y_1 = \color{red}{x_1}$

. . .

$y_2 = \frac{x_1 + \color{red}{x_2} + x_3}{3}$

. . .

$y_3 = \frac{x_1 + x_2 + \color{red}{x_3} + x_4 + x_5}{5}$

. . .

$y_4 = \frac{x_2 + x_3 + \color{red}{x_4} + x_5 + x_6}{5}$

. . .

$y_5 = \frac{x_3 + x_4 + \color{red}{x_5} + x_6 + x_7}{5}$

. . .

$y_6 = \frac{x_4 + x_5 + \color{red}{x_6} + x_7 + x_8}{5}$

. . .

$y_7 = \frac{x_5 + x_6 + \color{red}{x_7} + x_8 + x_9}{5}$

. . .

En general llamaremos [**media móvil**]{.hl-yellow} a la tranformación **lineal** 

$$y_t = \sum_{r = -q}^{s} a_r x_{t+r}, \quad t = q + 1, \ldots, n-s, \quad \sum_{r = -q}^{s} a_r = 1$$

---

## Medias móviles

$$y_t = \sum_{r = -q}^{s} a_r x_{t+r}, \quad t = q + 1, \ldots, n-s, \quad \sum_{r = -q}^{s} a_r = 1$$

La transformación es una [**media ponderada**]{.hl-yellow} de $q + s + 1$ valores donde, según avanzamos, se **elimina el dato más antiguo y entra el más nuevo**

. . .

* Si los [**pesos son todos iguales**]{.hl-purple} $a_j = \frac{1}{N}$, con $N = q+s+1$, se conoce como **media móvil de orden N**.

. . .

* Si $q = s$ tal que $a_{-j} = a_j$, para todo $j=1,\ldots,q$ tal que $k = 2*q + 1$, se conoce como [**k MA (moving average simétrica)**]{.hl-yellow}

. . .

* El problema de determinar los primeros/últimos valores se conoce como [**problema de los efectos terminales**]{.hl-yellow}

---

## Medias móviles

Para calcular una [**media móvil de orden $k=2*q+1$**]{.hl-yellow} en `R` podemos hacerlo con `filter()` del paquete `{stats}` teniendo la variable ya **ordenada** ([**¡cuidado!**]{.hl-red}: si tienes cargado `{tidyverse}` debes especificar que `filter()` es)

```{r}
k <- 3
datos$x_linear <- predict(datos |> lm(formula = x ~ t), datos)

datos <- datos[order(datos$t), ]
datos$x_smooth_3ma <- stats::filter(datos$x, filter = rep(1/k, k))
datos
```

---

## Medias móviles

```{r}
#| code-fold: true
ggplot(datos |>
         pivot_longer(cols = -t, names_to = "var", values_to = "values")) +
  geom_line(aes(x = t, y = values, color = var, linetype = var),
            linewidth = 0.9, alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  theme_minimal()
```

Fíjate cómo ahora la curva queda [**suavizada pero de manera dinámica**]{.hl-yellow}

---

## Medias móviles

```{r}
datos$x_smooth_5ma <- stats::filter(datos$x, filter = rep(1/5, 5))
datos$x_smooth_7ma <- stats::filter(datos$x, filter = rep(1/7, 7))
datos$x_smooth_9ma <- stats::filter(datos$x, filter = rep(1/9, 9))
```

:::: columns
::: {.column width="25%"}

Fíjate que [**cuando aumenta $k$, la serie es más suavizada**]{.hl-green} (más agresiva con las fluctuaciones) pero [**hay más datos ausentes**]{.hl-red} (problema de efectos terminales)

:::

::: {.column width="75%"}

```{r}
#| code-fold: true
ggplot(datos |>
         pivot_longer(cols = -t, names_to = "var", values_to = "values")) +
  geom_line(aes(x = t, y = values, color = var),
            linewidth = 0.9, alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  theme_minimal()
```

:::
::::


---

## 💻 Tu turno {#tu-turno-6-1}

### [**Ejercicio 1**]{.hl-yellow}

💻 Realiza una estimación de la serie aplicando el suavizado de medias móviles con parámetro $k=7, 14, 28, 365$ a los datos AEMET e incluye las 4 nuevas columnas con los 4 nuevos métodos de estimación al conjunto `retiro_estim` que teníamos de clases anteriores. Importante: la serie que le pases a `stats::filter()` no puede tener ausentes.


```{r}
#| code-fold: true
#| eval: false
# versión tidyverse (en R base tabla$variable_nueva <- valor)
retiro_estim <-
  retiro_estim |>  drop_na(X_t) |> arrange(t) |> 
  mutate(x_smooth_7ma = stats::filter(X_t, filter = rep(1/7, 7)),
         x_smooth_14ma = stats::filter(X_t, filter = rep(1/14, 14)),
         x_smooth_28ma = stats::filter(X_t, filter = rep(1/28, 28)),
         x_smooth_365ma = stats::filter(X_t, filter = rep(1/365, 365)))

ggplot(retiro_estim |>
         pivot_longer(-c(fecha, t), names_to = "type", values_to = "pred") |>
         filter(between(fecha, as_date("2016-01-01"), as_date("2022-01-01")))) +
  geom_line(aes(x = fecha, y = pred, color = type),
            linewidth = 0.7, alpha = 0.85) +
  ggthemes::scale_color_colorblind() +
  theme_minimal() +
  labs(title = "Temperatura media como SERIE TEMPORAL",
       x = "t (fecha)", y = "ºC (media)")
```




# Clase 7: [estacionalidad]{.flow} {#clase-7}

[**Introduciendo y estimando la componente estacional**]{style="color:#444442;"}

* [💻 Ejercicios](#tu-turno-7-1)
* [📆 Planificación](#planificacion)

---

## Componente estacional

El problema todos los ajuste anteriores es que [**existe una parte ESTACIONAL**]{.hl-yellow} que estamos ignorandome deliberadamente. Diremos que una serie tiene una [**componente estacional $S_t$**]{.hl-yellow} siempre que presente un [**patrón que se repite en periodos (aprox.) fijos en el tiempo**]{.hl-yellow} tal que 

$$X_t = f \left(\mu_t, S_t, \varepsilon_t\right) =^{adit} \mu_t + S_t + \varepsilon_t, \quad X_t =^{mult} \mu_t * S_t * \varepsilon_t$$

. . .

Trataremos de **manera general con los modelos aditivos** ya que, en caso de ser multiplicativo, $\log \left(X_t\right) =\log \left( \mu_t \right) + \log \left(S_t \right) + \log \left( \varepsilon_t \right)$

. . .

Fíjate que ahora ${\rm E} \left[X_t \right] = \mu_t + S_t$ y por tanto nuestra [**estimación muestral**]{.hl-yellow} vendrá definida como

$$\widehat{X}_t = \widehat{\mu}_t + \widehat{S}_t$$

. . .

[**¿Qué significa que $S_t$ estacional (o periódico)?**]{.hl-purple}

---

## Componente estacional

En general, diremos que una función [**$S_t := S(t)$ es estacional (o periódica) de periodo $s$**]{.hl-yellow} siempre que $S_t = S_{t + s} = S_{t + 2s}$: si es estacional de **periodo $s$** significa que, cada $s$ valores, la función se repite.

. . .

Fíjate que si $S_t = S_{t + s}$ también entonces sucede que $S_t = S_{t - s}$.

. . .

::: callout-important
## Importante

Es importante entender que determinar el **periodo** no es solo determinar si es «anual» o «mensual»: el valor $s$ es el [**número de valores de la componente $S_t$ que pasan hasta que se repita**]{.hl-yellow}. Por ejemplo, una serie puede tener una periodicidad anual pero si los datos son recogidos de manera trimestral, $s = 4$; la misma periodicidad para unos datos recogidos de manera diaria será $s = 365$.

En el caso de los datos del AEMET, $s = 365$, no solo porque la temperatura tengan una periodicidad anual obviamente, sino porque los **datos son diarios** (la misma variable, recogida de manera mensual, tendría $s = 12$).

:::

---

## Componente estacional

¿Cómo [**estimar dicha componente estacional**]{.hl-yellow}? Los [**métodos de descomposición clásica**]{.hl-yellow} tienen la siguiente estructura:

1. [**Estimación de la tendencia**]{.hl-purple}. Dada la serie original $X_t$ se realiza una estimación de su nivel o tendencia $\mu_t$. Como hemos visto tenemos distintas alternativas:

- **medias móviles** (será clave **determinar la ventana $k$**)
- tendencia polinómica
- regresión local (conocida como [**regresión LOESS o LOWESS**]{.hl-yellow}: ajusta a los datos una **regresión polinómica pero de manera LOCAL**, en cada punto solo se utiliza un % de los datos). Ver <https://www.statology.org/lowess-smoothing-r/>

. . .

Tras estimar la tendencia se construye la [**serie centrada**]{.hl-yellow}

$$Y_t = X_t - \mu_t = S_t + \varepsilon_t, \quad \hat{Y}_t = X_t - \hat{\mu}_t$$

---

## Componente estacional

$$Y_t = X_t - \mu_t = S_t + \varepsilon_t, \quad \hat{Y}_t = X_t - \hat{\mu}_t$$

Fíjate que $\hat{Y}_t$ es ya una serie sin tendencia, y cuyos [**valores ya no representan la serie original sino la anomalía**]{.hl-yellow} que tendría cada $t$ respecto al nivel global (en el caso de las temperaturas, por ejemplo la anomalía promedio de temperatura entre los distintos días del año y el nivel general de la serie).

. . .

2. [**Estimar los coeficientes estacionales**]{.hl-purple}. El objetivo será obtener un conjunto de $s$ coeficientes $\left(S_1, S_2, \ldots, S_{s-2}, S_{s-1}, S_s \right)$ que cumplirán por definición dos condiciones:

* Se repiten cada $s$ valores (por solo necesitamos estimar un tramo).

* Su suma es cero (ya que representan las anomalías respecto al nivel general, por lo que si hay valores por encima tienen que existir por debajo)

---

## Componente estacional


2. [**Estimar los coeficientes estacionales**]{.hl-purple}. El objetivo será obtener un conjunto de $s$ coeficientes $\left(S_1, S_2, \ldots, S_{s-2}, S_{s-1}, S_s \right)$.

Para su estimación lo que haremos será calcular, con la serie centrada, la [**diferencia entre la media de cada periodo estacional**]{.hl-yellow} y la **media general**

$$\widehat{S}_j = \overline{Y}_j - \overline{Y}, \quad \overline{Y}_j = \frac{1}{n} \sum_{i=1}^{n} Y_{s*i + j}, \quad \overline{Y} = \frac{1}{T} \sum_{i=0}^{n-1} \sum_{j=1}^{s} Y_{s*i + j}, \quad j = 1, \ldots, s$$

::: callout-tip

## Datos AEMET

En el **caso del AEMET**: $\widehat{Y}_j$ representa la media (de la serie centrada) de todos los días $j=1, \ldots, 365$, es decir, la media de los 1-enero, sin importar el año; de los 2-enero, ..., de los 31-diciembre (la anomalía de temperatura que en promedio hace el 1-enero respecto a la tendencia general, y así para cada día del año). En este caso $n = 45$ ya que tenemos datos de 45 años (salvo el final de 2024).

:::

---

## Componente estacional

3. [**Estimar las innovaciones**]{.hl-purple}. Una vez estimada la tendencia y estacionalidad

$$\widehat{\varepsilon}_t = X_t - \widehat{X}_t, \quad \widehat{X}_t = \widehat{\mu}_t + \widehat{S}_t$$

. . .

Fíjate que la componente estacional estimada cumple también que $\widehat{S}_t = \widehat{S}_{t + s}$, es decir, **solo necesitamos $s$ coeficientes estimados** (fíjate en el subíndice del $\hat{S}$)

$$\widehat{\varepsilon}_{s*i + j} = X_{s*i + j} - \widehat{X}_{s*i + j}, \quad \widehat{X}_{s*i + j}= \widehat{\mu}_{s*i + j} + \widehat{S}_j, \quad j = 1,\ldots,s$$

. . .

* $\widehat{Y}_t$ representa la [**estimación de la serie centrada**]{.hl-green}: lo que falta [**por modelizar es componente estacional**]{.hl-yellow} 

* $X_t - \widehat{S}_t$ representa la [**estimación de la serie DESESTACIONALIZADA**]{.hl-green}: lo que falta [**por modelizar es tendencia sin tener en cuenta el efecto estacional**]{.hl-yellow} (ejemplo: tasa de paro sin el efecto que tienen periodos como verano o navidad)


---

## Algunas observaciones


::: callout-warning

El método descrito se conoce [**método clásico de descomposición**]{.hl-yellow} (o STL si se usa una regresión local para estimar la tendencia en lugar de medias móviles) pero la componente estacional podría ser también estimada por [**cualquier función periódica o armónica de periodo $s$**]{.hl-yellow}, por ejemplo, $sin(\frac{2 \pi t}{s})$, se repite cada $s$ valores).
:::

&nbsp;

::: callout-warning

Todo lo anterior también está diseñado bajo la [**hipótesis de que solo tenemos una periodicidad $s$**]{.hl-yellow}: nuestra serie podría tener distintas periodicidades superpuestas (Fourier: toda función periódica puede representarse como suma de funciones seno de distinta frecuencia y amplitud). De momento supondremos siempre un **único ciclo**.
:::


---

## 💻 Tu turno {#tu-turno-7-1}

### [**Ejercicio 1**]{.hl-yellow}

💻 Renombra la función de estimación de la tendencia polinómica que ya tenemos hecha como `estim_ts_trend_poly()`



```{r}
estim_ts_trend_poly <-
  function(datos, degree = 1, tag_estim = paste0("estim_poly_", degree),
           col_t = "t", col_X_t = "X_t", nuevos_valores = NULL) {
    
    # R base normal
    datos <- datos[, c(col_t, col_X_t)]
    names(datos)[names(datos) == col_t] <- "t"
    names(datos)[names(datos) == col_X_t] <- "X_t"

    if (degree == 0) {
      modelo <- datos |> lm(formula = X_t ~ 1)
    } else {
      modelo <- datos |> lm(formula = X_t ~ poly(t, degree, raw = TRUE))
    }
    datos[, tag_estim] <- predict(modelo, tibble("t" = datos$t))
    
    if (!is.null(nuevos_valores)) {
      nuevos_datos <- tibble("t" = nuevos_valores, "X_t" = NA)
      nuevos_datos[, tag_estim] <- predict(modelo, tibble("t" = nuevos_datos$t))
      datos <- rbind(datos, nuevos_datos)
    }
    return(datos)
}
```

---

## 💻 Tu turno 

### [**Ejercicio 2**]{.hl-yellow}

💻 Diseña una función general `estim_ts_trend()` que use `estim_ts_trend_poly()` que ya tenemos hecha. Dicha función debe tener los mismos parámetros que teníamos en esa función con dos argumentos extras: `tipo_trend_estim` (que haga la polinómica si `"poly"` y medias móviles si `"MA"`) y `k` (la anchura de la ventana; la haremos siempre simétrica y con pesos uniformes de momento).

```{r}
#| code-fold: true
estim_ts_trend <- 
  function(datos, degree = 1, k = NA, tipo_trend_estim = "poly",
           tag_estim =
             paste0("estim_", tipo_trend_estim, if_else(is.na(k), degree, k)),
           col_t = "t", col_X_t = "X_t", nuevos_valores = NULL) {
    
    if (tipo_trend_estim == "poly") {
      
      estim <- estim_ts_trend_poly(datos, degree, tag_estim,
                                   col_t, col_X_t, nuevos_valores)
    } else if (tipo_trend_estim == "MA") {
      
      estim <-
        datos |> 
        select(all_of(col_t), all_of(col_X_t)) |> 
        rename(t = col_t, X_t = col_X_t) |> 
        # hay que ordenar!
        arrange(t) |> 
        # con !! + := le indicamos que el nombre sale de una variable
        # (es una técnica llamada lazyeval)
        mutate(!!tag_estim := 
                 stats::filter(X_t, filter = rep(1/k, k), sides = 2))

    }
    return(estim)
  }
temp_retiro <- read_csv(file = "./datos/retiro_temp.csv")
ejemplo1 <-
  temp_retiro |> estim_ts_trend(degree = 1, tipo_trend_estim = "poly", col_t = "fecha", col_X_t = "tmed")
ejemplo2 <-
  temp_retiro |> estim_ts_trend(k = 7, tipo_trend_estim = "MA", col_t = "fecha", col_X_t = "tmed")
```

---

## 💻 Tu turno 

### [**Ejercicio 3**]{.hl-yellow}

💻 Diseña una función `ts_detrend()` que use `estim_ts_trend()` que ya tenemos hecha (por lo que tendrá que tener, mínimo, los mismos parámetros que teníamos en esa función), de manera que dado un conjunto de datos, devuelva una nueva columna con la tendencia estimada (según el método que decidamos) y una nueva columna con la serie centrada

```{r}
#| code-fold: true
ts_detrend <- 
  function(datos, degree = 1, k = NA, tipo_trend_estim = "poly",
           tag_estim = paste0("estim_", tipo_trend_estim, if_else(is.na(k), degree, k)),
           col_t = "t", col_X_t = "X_t", nuevos_valores = NULL) {
    
    estim <-
      # estimamos tendencia
      estim_ts_trend(datos, degree, k, tipo_trend_estim, tag_estim,
                     col_t, col_X_t, nuevos_valores) |> 
      # la llamamos siempre estim_trend
      rename(estim_trend = tag_estim) |> 
      # el tipo de estimación lo guardamos en otra variable aparte
      mutate("tipo_trend_estim" = tag_estim,
             # calculamos serie centrada
             # si es NA, ponemos la media global en la estimación de la tendencia
             "estim_trend" =
               if_else(is.na(estim_trend), mean(X_t, na.rm = TRUE), estim_trend),
             "detrend" = X_t - estim_trend)
    return(estim)
  }
ejemplo1 <- temp_retiro |> ts_detrend(degree = 1, col_t = "fecha", col_X_t = "tmed")
ejemplo2 <- temp_retiro |> ts_detrend(k = 365, tipo_trend_estim = "MA", col_t = "fecha", col_X_t = "tmed")
```



# Clase 8: [practicar con funciones]{.flow} {#clase-8}

[**Diseño de funciones para nuestra descomposición**]{style="color:#444442;"}

* [💻 Ejercicios](#tu-turno-8-1)
* [📆 Planificación](#planificacion)


---

## 💻 Tu turno {#tu-turno-8-1}

### [**Ejercicio 1**]{.hl-yellow}

💻 Diseña una función `ts_deseason()` que, dada una serie cualquiera y un periodo $s$, nos devuelva una nueva columna con los coeficientes estacionales estimados (con el método visto anteriormente) y una nueva columna con la serie desestacionalizada. Vas a necesitar darle
como argumento no solo el nombre de las columnas donde esté $t$ y $Y_t$ sino como se llamará la variable de grupo que debes crear dentro usando $s$.

```{r}
ts_deseason <- function(datos, s, col_group, col_t = "t", col_Y_t = "Y_t") {
  
  # primero renombramos como siempre y ordenamos
  estim <-
    datos |>
    rename(t = col_t, Y_t = col_Y_t) |> 
    arrange(t)
  
  # Contruimos variable de grupo
  estim <- 
    estim |>
    rowid_to_column(var = "id") |>
    mutate(!!col_group := ((id - 1) %% s) + 1) |> 
    select(-id)

  # Estimamos la estacionacionalidad
  estim_season <-
    estim |>
    summarise("season_coef" = mean(Y_t, na.rm = TRUE), .by = col_group) |>
    mutate("estim_season" = season_coef - mean(season_coef, na.rm = TRUE))
  
  # Lo únimos a los datos
  estim <- 
    estim |> 
    left_join(estim_season, by = col_group) |> 
    mutate("tipo_estim_season" = "clasica",
           "deseason" = Y_t - estim_season) 
  
  return(estim)
}
```


---

## 💻 Tu turno 

### [**Ejercicio 2**]{.hl-yellow}

💻 Tomando los datos de retiro: a) aplica la función `ts_detrend()` de manera que la tendencia sea estimada con $MA(k = 365)$; b) a esa tabla aplícale `ts_deseason()` para estimar $S_t$, donde la variable de grupo se llama `"mes_dia"`; c) tras acabar renombra `Y_t` como `detrend`


---

## 💻 Tu turno 

### [**Ejercicio 2**]{.hl-yellow}


```{r}
#| code-fold: true
estim_retiro <-
  temp_retiro |>
  ts_detrend(k = 365, tipo_trend_estim = "MA", col_t = "fecha", col_X_t = "tmed") |> 
  mutate("mes_dia" = paste0(day(t), "-", month(t))) |>
  ts_deseason(s = 365, col_group = "mes_dia", col_Y_t = "detrend") |> 
  rename(detrend = Y_t)
```

---

## 💻 Tu turno 

### [**Ejercicio 3**]{.hl-yellow}

💻 Con `estim_retiro` del ejercicio anterior, calcula una última columna que sea la estimación total de la serie `estim_X_t` (estimación de la tendencia + estimación de la estacionalidad). Tras ello pivota como consideres para poder dibujar en la misma gráfica la serie real y la estimación

---

## 💻 Tu turno 

### [**Ejercicio 3**]{.hl-yellow}

```{r}
estim_retiro |> 
  mutate("estim_X_t" = estim_trend + estim_season) |> 
  # solo queremos dos de las curvas
  select(t, X_t, estim_X_t) |> 
  pivot_longer(cols = -t, names_to = "serie", values_to = "X_t") |>
  ggplot() +
  geom_line(aes(x = t, y = X_t, color = serie, alpha = serie)) +
  ggthemes::scale_color_colorblind() +
  scale_alpha_manual(values = c(0.9, 0.35)) +
  theme_minimal() + 
  labs(x = "fecha", y = "Temperatura (ºC)",
       title = "Estimación decomposición clásica",
       subtitle = "Tendencia estimada con MA(k = 365)")
```

---

## 💻 Tu turno 

### [**Ejercicio 4**]{.hl-yellow}

💻 Con `estim_retiro` del ejercicio 2, calcula una última columna que sea la estimación total de la serie `estim_X_t` (estimación de la tendencia + estimación de la estacionalidad) pero ahora selecciona y pivota como consideres para poder hacer luego una visualización de 6 gráficas (por separado pero en el mismo plot): i) la serie real, ii) la estimación de la tendencia, iii) la estimación de la estacionalidad, iv) la serie sin tendencia, v) la serie sin tendencia ni estacionalidad, vi) la estimación

---

## 💻 Tu turno 

### [**Ejercicio 4**]{.hl-yellow}


```{r}
estim_retiro |> 
  mutate("estim_X_t" = estim_trend + estim_season) |> 
  # solo queremos dos de las curvas
  select(t, X_t, estim_trend, detrend, estim_season, deseason, estim_X_t) |> 
  pivot_longer(cols = -t, names_to = "serie", values_to = "X_t") |>
  ggplot() +
  geom_line(aes(x = t, y = X_t, color = serie)) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~serie, scales = "free_y") +
  theme_minimal() + 
  labs(x = "fecha", y = "Temperatura (ºC)",
       title = "Estimación decomposición clásica",
       subtitle = "Tendencia estimada con MA(k = 365)")
```

---

## 💻 Tu turno 

### [**Ejercicio 6**]{.hl-yellow}

💻 Repite los ejercicios anteriores pero haciendo una pequeña modificación en la función que estima la estacionalidad, permitiendo que pueda estimarla de manera clásica o de manera sinuosoidal $\widehat{S}_t = \sin(2 \pi t/s)$.


# Clase 9: [métricas de error]{.flow} {#clase-9a}

[**Calibrando nuestra estimación: train/validación y errores**]{style="color:#444442;"}

* [💻 Ejercicios](#tu-turno-8-1)
* [📆 Planificación](#planificacion)





# Clase 10: [métodos de alisado]{.flow} {#clase-10}


---

## Limitaciones

Hasta ahora todo lo que hemos hecho ha sido suponer que el comportamiento de nuestra  [**serie temporal se podía explicar en términos de subpatrones o conductas**]{.hl-yellow}, que en su forma aditiva, pueden tener la siguiente estructura

$$X_t = T_t + S_t + \varepsilon_t, \quad \widehat{X}_t = \widehat{T}_t + \widehat{S}_t$$

* $\widehat{T}_t$ la hemos estimado mediante un polinomio o medias móviles

* $\widehat{S}_t$ la hemos estimado asumiendo que **solo hay un periodo**

. . .

Siempre hemos [**ponderado las observaciones por igual**]{.hl-red} pero...¿no tendríamos que dar [**más importancia a los datos más recientes**]{.hl-green}?

---

## Clasificación de Pegel

![](img/pegel.jpg)

Imagen extraída de González Velasco, M., & Puerto García, I. M. del. (2009). Series temporales. Universidad de Extremadura.

**Estacionalidad multiplicativa = serie heterocedástica (varianza no constante)**

---

## Alisado exponencial

Para superar esas limitaciones, en los años 50 y 60 se propusieron una serie de métodos que, más allá de asumir una estructura en los datos, su objetivo era [**describir la serie en términos de sus propios cambios**]{.hl-yellow}.

&nbsp;

El objetivo de los distintos métodos de alisado/suavizado será [**intuir la inercia de la serie, eliminando sus posibles fluctuaciones aleatorias**]{.hl-yellow}, asumiendo que si la tendencia de la serie es ascendente, probablemente la serie siga subiendo, teniendo en consideración la pendiente con la que crece o decrece.

. . .

El nombre de [**alisado/suavizado EXPONENCIAL**]{.hl-yellow} se debe a que vamos a ponderar el pasado de la serie con un conjunto de pesos que, normalmente, decrecerán de manera exponencial (ejemplo: si la observación inmediatamente anterior tiene un peso de $0.5$, la siguiente tendrá un peso de $0.5^2 = 0.25$)

---


## Alisado simple

Imagina que tenemos el valor de la serie en $X_t$ y su estimación $\widehat{X}_t$... ¿cómo poder [**predecir $\widehat{X}_{t+1}$ solo usando ambos valores**]{.hl-yellow}?

. . .

La idea que tuvo **Holt (1956)** fue la de hacer una [**media ponderada del valor real $X_t$ y su estimación $\widehat{X}_t$**]{.hl-yellow} 

$$\widehat{X}_{t+1} = \theta \widehat{X}_t + \left( 1 - \theta \right)X_t = X_t + \theta \left(\widehat{X}_t - X_t \right) = X_t + \theta \widehat{\varepsilon}_t , \quad 0 < \theta < 1$$

. . .

* Si [**$\theta \to 1$**]{.hl-purple}, entonces $\widehat{X}_{t+1} \to \widehat{X}_t$ el [**modelo de alisado produce predicciones casi constantes**]{.hl-yellow} sin muchas variaciones

. . .

* Si [**$\theta \to 0$**]{.hl-purple}, entonces $\widehat{X}_{t+1} \to X_t$ el [**modelo de alisado produce predicciones muy variables dependientes del último valor observado**]{.hl-yellow} (con mucha fluctuación causada por la propia aleatoriedad de la serie)

---

## Alisado simple

Si hacemos lo mismo para la estimación en $X_t$ tenemos

$$\begin{eqnarray}\widehat{X}_{t+1} &=& \theta \left( \theta \widehat{X}_{t-1} + \left( 1 - \theta \right)X_{t-1} \right) + \left( 1 - \theta \right)X_t \nonumber \\ &=& \theta^2 \widehat{X}_{t-1} + \theta   \left( 1 - \theta \right) X_{t-1}  + \left( 1 - \theta \right) X_t \end{eqnarray}$$

. . .

Si hacemos lo mismo para la estimación en $X_{t-1}$

$$\begin{eqnarray}\widehat{X}_{t+1} &=& \theta^2 \left(\theta \widehat{X}_{t-2} + \left( 1 - \theta \right)X_{t-2} \right) +  \left( 1 - \theta \right) \left(X_t + \theta X_{t-1} \right) \nonumber \\ &=&
\theta^3 \widehat{X}_{t-2} + \theta^2 \left( 1 - \theta \right)X_{t-2} +  \theta \left( 1 - \theta \right)X_{t-1} + \left( 1 - \theta \right) X_t \nonumber \\ &=&
\theta^3 \widehat{X}_{t-2} + \left( 1 - \theta \right) \left(\theta^2 X_{t-2} +  \theta X_{t-1} +  X_t \right) \end{eqnarray}$$

---

## Alisado simple


Si repetimos el [**proceso iterativo**]{.hl-yellow} con $\widehat{X}_{t-1}$, $\widehat{X}_{t-2}$...

$$\widehat{X}_{t+1} =  \theta^t \widehat{X}_{1} + \left( 1 - \theta \right) \left(X_t + \theta X_{t-1}  +   \ldots + \theta^{t-1} X_{1}\right) = \theta^{t}\widehat{X}_{1} + \left(1 - \theta \right) \sum_{j=0}^{t-1} \theta^{j} X_{t-j}$$

[**¿Qué sucede cuando $t \to \infty$?**]{.hl-yellow}


. . . 

Dado que $\theta < 1$, entonces

$$\lim_{t \to \infty} \widehat{X}_{t+1} = \left( 1 - \theta \right) \sum_{j=0}^{\infty} \theta^j X_{t-j}$$

Fíjate en la **serie geométrica** $\sum_{j=0}^{\infty} \theta^j$. ¿Recuerdas cuál era la [**suma de una serie geométrica cuya razón es menor que 1**]{.hl-yellow}?

---

## Alisado simple


Dado que $\theta < 1$, tenemos que $\sum_{j=0}^{\infty} \theta^j = \frac{1}{1 - \theta} \rightarrow \left( 1 - \theta \right) \sum_{j=0}^{\infty} \theta^j = 1$, así que $\left( 1 - \theta \right) \sum_{j=0}^{t-1} \theta^j X_{t-j}$ representa una [**media ponderada del pasado (pesos decrecientes geométricamente con suma 1 en el infinito)**]{.hl-yellow}.

. . .

:::: columns
::: {.column width="35%"}

Si te fijas además [**todas las observaciones son influyentes**]{.hl-yellow} pero su influencia va decreciendo. 

:::

::: {.column width="65%"}

```{r}
#| echo: false
theta <- tibble("x" = rep(1:30, 3),
                "theta" = c(0.9^(1:30), 0.6^(1:30), 0.3^(1:30)),
                "pesos" = c(rep("theta = 0.9", 30), rep("theta = 0.6", 30),
                            rep("theta = 0.3", 30)))
ggplot(theta) +
  geom_line(aes(x = x, y = theta, color = pesos), linewidth = 1.2) +
  ggthemes::scale_color_colorblind() +
  theme_minimal() +
  labs(title = "Decrecimiento exponencial de pesos")
```

:::
::::

---

## Alisado simple


Fíjate que la fórmula anterior se puede [**generalizar**]{.hl-yellow} para [**predicción a horizonte $h$**]{.hl-yellow}: si solo disponemos de información hasta el instante $t$, tenemos que

$$\begin{eqnarray}\widehat{X}_{t+1|t} &=&  \theta \widehat{X}_{t|t-1} + \left( 1 - \theta \right)X_t = \theta^{t}\widehat{X}_{1} + \left(1 - \theta \right) \sum_{j=0}^{t-1} \theta^{j} X_{t-j}, \nonumber \\ \widehat{X}_{t+2|t} &=&  \theta \widehat{X}_{t+1|t} + \left( 1 - \theta \right)X_{t+1} \simeq \theta \widehat{X}_{t+1|t} + \left( 1 - \theta \right)\widehat{X}_{t+1|t} = \widehat{X}_{t+1|t}, \nonumber \\ ...  \nonumber \\ \widehat{X}_{t+h|t} &=&\widehat{X}_{t+1|t} \quad \text{para todo h}
\end{eqnarray}$$

. . .

El [**método de alisado simple produce «flat predictions»**]{.hl-yellow}: siempre devuelve a horizonte $h$ el último valor  predicho $\widehat{X}_{t+1|t}$ (asume que la tendencia es localmente constante).

---

## Alisado simple

Fíjate que el método de alisado simple es una simple media ponderada, de una forma muy particular, pero que podríamos considerar [**otro tipo de métodos basados en promedios**]{.hl-yellow}:


* Si consideramos el conocido como [**método naive o trivial**]{.hl-yellow}, tenemos que la [**predicción a horizonte $h$**]{.hl-yellow} (con la información disponible hasta $t$) es  

$$\widehat{X}_{t+h|t} = X_t$$

la **única observación importante es la última**. Esto es [**equivalente a un alisado simple con $\theta = 0$**]{.hl-yellow}

---

## Alisado simple

Fíjate que el método de alisado simple es una simple media ponderada, de una forma muy particular, pero que podríamos considerar [**otro tipo de métodos basados en promedios**]{.hl-yellow}:


* Si consideramos el conocido como [**mean method**]{.hl-yellow}, lo que hemos llamado `poly0` (hace simplemente la media cte de todos los valores), la [**predicción a horizonte $h$**]{.hl-yellow} (con la información disponible hasta $t$) es 

$$\widehat{X}_{t+h|t} = \frac{1}{t} \sum_{j=1}^{t}X_j$$

todas las observaciones pasadas son **igual de importantes**.



---

## Alisado simple

El modelo de alisado simple anterior en realidad equivale a asumir que la [**estructura de nuestra serie es localmente constante**]{.hl-yellow}


$$X_t = T_t + \varepsilon_t, \quad T_t - T_{t-1} \simeq cte$$


una tendencia que va variando [**muy lentamente con el tiempo**]{.hl-yellow} (ya que el futuro se parece más a los valores pasados inmediatos que a los valores más lejanos).

. . .

Para el método de alisado simple [**necesitamos conocer el valor inicial y encontrar el mejor $\theta$**]{.hl-yellow} (por ejemplo, mediante mínimos cuadrados de los errores observados para distintos valores).

&nbsp;

Supondremos [**$\theta$ constante**]{.hl-yellow} pero existen métodos (ver [aquí](https://robjhyndman.com/forecasting/)) para considerar que $\theta$ se adapta a su vez a lo largo del tiempo

---

## Ejemplo en R

Vamos a trabajar con el paquete `{tsibbledata}` que nos permite usar varios [**ejemplos de series temporales**]{.hl-yellow}. En concreto vamos a usar el dataset `global_economy` que contiene distintas estadísticas económicas para distintos años países, y nos vamos a centrar solo en **datos de exportaciones de Algeria**


```{r}
library(tsibbledata)
library(tsibble)
algeria_economy <-
  global_economy |>
  filter(Country == "Algeria") |>
  # solo hay un país, eliminamos key
  update_tsibble(key = NULL)
algeria_economy
```

---


## Ejemplo en R

Si observamos la serie [**no se aprecia una tendencia clara ni una estacionalidad evidente**]{.hl-yellow}, perfecto para nuestro método de alisado simple.

```{r}
#| code-fold: true
ggplot(algeria_economy) +
  geom_line(aes(x = Year, y = Exports)) +
  scale_x_continuous(n.breaks = 20) +
  theme_minimal()
```

---

## Ejemplo en R

[**¿Cómo realizar la estimación de alisado simple?**]{.hl-yellow}

. . .

Vamos a usar el universo de paquetes `{tidyverts}` (una forma de trabajar en modo tidyverse con series temporales), de los cuales ya conocemos `{tsibbledata}` y `{tsibble}`. Vamos a instalar también el paquete [`{fable}`](https://fable.tidyverts.org/) que nos [**proporciona herramientas para la predicción de series temporales**]{.hl-yellow}

```{r}
library(fable)
```

---

## Ejemplo en R

Dentro de este paquete existe una función llamada `model()` que nos permite [**ajustar distintos modelos a los datos**]{.hl-yellow}.

* `ETS(var_objetivo ~ componentes del modelo)`: para ajustar los [**métodos de alisado/suavizado exponencial**]{.hl-yellow} necesitamos especificarle dentro de `model()` que nuestro modelo es de tipo `ETS()` (exponential time-series smoothing model)

```{r}
#| eval: false
#| code-line-numbers: "4"
# NO EJECUTES QUE ESTÁ AÚN SIN COMPLETAR
fit_algeria <-
  algeria_economy |>
  model(ETS(Exports ~ ...))
```

---

## Ejemplo en R


Una vez que hemos determinado nuestra variable objetivo, las [**componentes del modelo se pueden incorporar**]{.hl-yellow} con las [**funciones `error()`, `trend()` y `season()`**]{.hl-purple}

```{r}
#| eval: false
#| code-line-numbers: "4"
fit_algeria <-
  algeria_economy |>
  model(ETS(Exports ~
              error(tipo) + trend(tipo) + season(tipo)))
```

. . .

Cada una de las funciones admite dentro los siguientes tipos:

* `"A"`: [**aditivo**]{.hl-yellow} 
* `"M"`: [**multiplicativo**]{.hl-yellow} 
* `"N"`: [**ninguno**]{.hl-yellow} (sin esa componente)

---


## Ejemplo en R


En nuestro caso hemos visto que el alisado simple es para predecir una serie asumiendo que **no hay tendencia ni estacionalidad** (`"N"` en ambos)

```{r}
fit_algeria <-
  algeria_economy |> # fíjate que le podemos poner nombre al modelo
  model(alisado_simple = ETS(Exports ~ error("A") + trend("N") + season("N")))
fit_algeria
```

---

## Ejemplo en R

Se [**guarda en un objeto de tipo modelo**]{.hl-yellow} (`mdl_df` o `mable`): para poder ver la info en un **formato tabulado basta hacer `augment()`**: `.fitted` guarda las estimaciones, `.resid` residuales estimados (en este caso coincide con `.innov`)

```{r}
#| code-line-numbers: "2"
fit_algeria |>
  augment()
```


---

## Ejemplo en R


Tras modelizar la serie podemos predecir el futuro con `forecast(h = n_instantes_futuros)` indicándole los **valores futuros** (para convertirlo a un **formato tabla**, dado que ya no es un modelo como antes, debemos convertirlo con `as_tibble()` o `as_tsibble()`)

Fíjate que en el [**caso de alisado simple todas las predicciones son la misma**]{.hl-yellow} (ya que asume que es localmente constante)

```{r}
#| eval: false
#| code-line-numbers: "3"
predict_algeria <-
  fit_algeria |>
  forecast(h = 7) # 7 instantes futuros
predict_algeria |> as_tsibble()
```

```{r}
#| echo: false
predict_algeria <-
  fit_algeria |>
  forecast(h = 7) # 7 instantes futuros
predict_algeria |> select(.model, Year, .mean, Exports)
```


---

## Ejemplo en R

Podemos [**visualizar el ajuste (del pasado)**]{.hl-yellow} haciendo `augment() + pivot_longer()` (seleccionándole antes las columnas a pivotar)

```{r}
#| code-fold: true
fit_algeria |>
  augment() |>
  as_tibble() |> 
  select(Year, Exports, .fitted) |> 
  rename(export_real = Exports, export_fit = .fitted) |> 
  pivot_longer(cols = -Year, names_to = "serie", values_to = "X_t") |> 
  ggplot() +
  geom_line(aes(x = Year, y = X_t, color = serie)) +
  ggthemes::scale_color_colorblind() +
  scale_x_continuous(n.breaks = 20) +
  theme_minimal() +
  labs(y = "% del PIB", title = "Exports: Algeria")
```

. . .

Fíjate como el [**alisado simple "llega tarde" a los cambios**]{.hl-red} ya que lo que hace es asumir que todo va a seguir igual


---

## Ejemplo en R

Podemos [**unir las predicciones futuras a los valores ajustados del pasado**]{.hl-yellow} con un `full_join()` (conviertiendo lsa tablas a tibble, seleccionando las columnas que nos interesa y renombrándolas)

```{r}
#| code-line-numbers: "5-6"
fit_predict_algeria <-
  fit_algeria |>
  augment() |>
  as_tibble() |> 
  full_join(predict_algeria |> as_tibble() |> select(Year, .mean),
            by = "Year") |> 
  select(Year, Exports, .fitted, .mean) |> 
  rename(export_real = Exports, export_fit = .fitted, export_predict = .mean)
fit_predict_algeria
```

---

## Ejemplo en R

Tras ello podemos visualizar (haciendo un `pivot_longer()` previo as usual)

```{r}
#| code-fold: true
fit_predict_algeria |>
  pivot_longer(cols = -Year, names_to = "serie", values_to = "X_t") |> 
  ggplot() +
  geom_line(aes(x = Year, y = X_t, color = serie)) +
  ggthemes::scale_color_colorblind() +
  scale_x_continuous(n.breaks = 20) +
  theme_minimal() +
  labs(y = "% del PIB", title = "Exports: Algeria")
```


---

## Ejemplo en R

También podemos simplificar el código de la visualización haciendo [**uso de autoplot()**]{.hl-yellow}, que te incluye además unos **intervalos de confianza**. 

```{r}
#| code-fold: true
predict_algeria |>
  autoplot(algeria_economy) +
  geom_line(data = fit_algeria |> augment(),
            aes(y = .fitted), col = "#D55E00") +
  scale_x_continuous(n.breaks = 20) +
  theme_minimal() +
  labs(y = "% del PIB", title = "Exports: Algeria")
```

# Clase 11: [modelos con fable]{.flow} {#clase-11}

---


## Modelos con fable: MEAN()

No solo vamos a poder aplicar el alisado en esta nueva lógica de programación, sino que vamos a poder [**programar de manera sencilla los modelos que hemos investigado hasta ahora**]{.hl-yellow}

. . .

* `MEAN(var_objetivo)`: la predicción a horizonte $h$ se define como la [**media de todos los valores**]{.hl-yellow} conocidos de la serie $\widehat{X}_{t+h|t} = \frac{1}{t} \sum_{j=1}^{t} X_t$ hasta el instante $t$ (predicción constante, la que antes llamábamos `poly0`)

```{r}
#| code-line-numbers: "5"
airpass <- AirPassengers |> as_tsibble()
fit_airpass <-
  airpass |>
  model(alisado_simple = ETS(value ~ error("A") + trend("N") + season("N")),
        mean_cte = MEAN(value))
```

---

## Modelos con fable: TSLM()


* `TSLM(var_objetivo ~ formula)`: la predicción a horizonte $h$ se define como una [**regresión polinómica**]{.hl-yellow} tal que $\widehat{X}_{t+h|t} = \beta_0 + \sum_{j=1}^{p} \beta_j (t+h)^p$

```{r}
#| code-line-numbers: "5"
fit_airpass <-
  airpass |>
  model(alisado_simple = ETS(value ~ error("A") + trend("N") + season("N")),
        mean_cte = MEAN(value),
        reg_poly = TSLM(value ~ index))
```


---

## Modelos con fable: RW()


* `RW(var_objetivo ~ drift())`: modelo conocido como [**random walk**]{.hl-yellow} o paseo aleatorio con [**drift o tendencia**]{.hl-yellow} tal que  $X_{t+1} = c +  X_{t} + \varepsilon_t$. La predicción a horizonte $h$ se define entonces como

$$\widehat{X}_{t+h|t} = c + X_{(t+h-1)|t} \simeq c + \widehat{X}_{(t+h-1)|t} \simeq 2*c +  \widehat{X}_{(t+h-2)|t} \simeq ... \simeq c*h + X_{t}$$

```{r}
#| code-line-numbers: "6"
fit_airpass <-
  airpass |>
  model(alisado_simple = ETS(value ~ error("A") + trend("N") + season("N")),
        mean_cte = MEAN(value),
        reg_poly = TSLM(value ~ index),
        rw_drift = RW(value ~ drift()))
```

---

## Modelos con fable: NAIVE()


* `NAIVE(var_objetivo)`: el [**modelo naive o trivial**]{.hl-yellow} es una simplificación del random walk con $c=0$ (sin tendencia, de hecho `NAIVE()` y `RW()` sin drift hacen lo mismo. La predicción a horizonte $h$ se define entonces como simplemente el último valor conocido en tiempo $t$.

$$\widehat{X}_{t+h|t} =  X_{t}$$

```{r}
#| code-line-numbers: "7"
fit_airpass <-
  airpass |>
  model(alisado_simple = ETS(value ~ error("A") + trend("N") + season("N")),
        mean_cte = MEAN(value),
        reg_poly = TSLM(value ~ index),
        rw_drift = RW(value ~ drift()),
        naive = NAIVE(value))
```

---

## Modelos con fable: SNAIVE()

* `SNAIVE(var_objetivo ~ lag())`: similar al modelo anterior solo que en lugar de repetir el último valor [**repite los últimos valores estacionales**]{.hl-yellow} (por ejemplo, el último mes, el último año, etc).

La predicción a horizonte $h$ se define entonces como

$$\widehat{X}_{t+h|t} =  X_{\left(t+h \right) - s*(k+1)}$$

* $s$ es el periodo

* $k$ es la parte entera de $(h-1)/s$ (el número de periodos completos que han pasado hasta $t+h$). Por ejemplo, si $h = 26$ y $s = 12$, $(h-1)/s = 25/12 = 2.08333$, cuya parte entera es $k = 2$ (han pasado 2 años completos hasta $h = 26$). Si $s = 12$, la predicción de cualquier de los enero futuros será igual a la predicción del último enero conocido.

---

## Modelos con fable: SNAIVE()

* `SNAIVE(var_objetivo ~ lag())`: similar al modelo anterior solo que en lugar de repetir el último valor [**repite los últimos valores estacionales**]{.hl-yellow} (por ejemplo, el último mes, el último año, etc).

```{r}
#| code-line-numbers: "8"
fit_airpass <-
  airpass |>
  model(alisado_simple = ETS(value ~ error("A") + trend("N") + season("N")),
        mean_cte = MEAN(value),
        reg_poly = TSLM(value ~ index),
        rw_drift = RW(value ~ drift()),
        naive = NAIVE(value),
        season_naive = SNAIVE(value ~ lag(12)))
```


---

## Modelos con fable

Así de toda la colección anterior de modelos podemos [**obtener las estimaciones**]{.hl-yellow} de manera sencilla con `augment()`

```{r}
estimaciones <- fit_airpass |> augment()

# Tenemos 144 estimaciones para cada uno de esos modelos
estimaciones |> 
  count(.model)
```

---

## Modelos con fable

Así de toda la colección anterior de modelos podemos [**obtener las estimaciones**]{.hl-yellow} de manera sencilla con `augment()`

```{r}
estimaciones
```


---

## Visualización estimaciones

Podemos [**visualizar el ajuste (del pasado)**]{.hl-yellow}

```{r}
#| code-fold: true
estimaciones |>
  ggplot() +
  geom_line(aes(x = index, y = value), color = "black",
            linewidth = 1.2, alpha = 0.7) +
  geom_line(aes(x = index, y = .fitted, color = .model),
            linewidth = 0.75, alpha = 0.8, linetype = 2) +
  scale_color_manual(values = ggthemes::colorblind_pal()(7)[-1]) +
  scale_x_yearquarter(date_breaks = "24 months") +
  theme_minimal()
```

---

## Visualización predicciones

Podemos [**visualizar las predicciones futuras**]{.hl-yellow} con `forecast() + autoplot()` (con `level = NULL` anulamos los intervalos de confianza).

```{r}
fit_airpass |>
  forecast(h = 24) |> 
  autoplot(airpass, level = NULL) +
  scale_color_manual(values = ggthemes::colorblind_pal()(7)[-1]) +
  scale_x_yearquarter(date_breaks = "24 months") +
  theme_minimal()
```

---

## Métodos de decomposición

También podemos con el paquete `{feasts}` hacer uso de las [**decomposiciones que hemos aprendido**]{.hl-yellow}

* `classical_decomposition(var_objetivo ~ season(s),  type = ...)`: [**descomposición clásica**]{.hl-yellow} aprendida de tipo multiplicativa o aditiva. La predicción a horizonte $h$ se define tal que

$$\widehat{X}_{t+h|t} = \widehat{T}_{t+h|t} + \widehat{S}_{t+h|t} \quad \text{type = "additive"}$$

$$\widehat{X}_{t+h|t} = \widehat{T}_{t+h|t} * \widehat{S}_{t+h|t} \quad \text{type = "mult"}$$

```{r}
#| code-line-numbers: "4"
library(feasts)
fit_airpass <-
  airpass |>
  model(cts = classical_decomposition(value ~ season(12), type = "additive"))
```

---

## Métodos de decomposición

Para este tipo particular de métodos (**métodos de decomposición**) existe una función `components()` que automáticamente nos devuelve la tendencia estimada (`trend`), la estacionalidad (`seasonal`), el residuo estimado (`random`) y la serie desestacionalizada (`season_adjust`, serie - seasonal)

```{r}
#| code-line-numbers: "4"
fit_airpass <-
  airpass |>
  model(cts = classical_decomposition(value ~ season(12), type = "additive"))
fit_airpass |> components()
```

---

## Métodos de decomposición

Con `autoplot()` nos [**visualiza cada componente**]{.hl-yellow}

```{r}
#| code-line-numbers: "5-6"
fit_airpass <-
  airpass |>
  model(cts = classical_decomposition(value  ~ season(12), type = "additive"))
fit_airpass |>
  components() |> 
  autoplot()
```

---

## Métodos de decomposición

Así quedaría en [**modo multiplicativo**]{.hl-yellow}

```{r}
#| code-line-numbers: "3"
fit_airpass <-
  airpass |>
  model(cts = classical_decomposition(value ~ season(12), type = "mult"))
fit_airpass |>
  components() |> 
  autoplot()
```

---

## Métodos de decomposición

Fíjate que el [**modo multiplicativo es equivalente a tomar el logaritmo del valor objetivo**]{.hl-yellow}

```{r}
#| code-line-numbers: "3"
fit_airpass <-
  airpass |>
  model(cts = classical_decomposition(log(value) ~ season(12), type = "additive"))
fit_airpass |>
  components() |> 
  autoplot()
```

---

## Métodos de decomposición

* `STL(var_objetivo ~ trend(window = ..., degre = ...) + season(period = ..., window = "periodic"))`:  la predicción a horizonte $h$ se define también como una [**descomposición clásica en tendencia y estacionalidad**]{.hl-yellow} pero ahora la [**tendencia es estimada mediante una regresión local**]{.hl-yellow} conocida como **regresión LOESS o LOWESS**. Dicha regresión ajusta a los datos una **regresión polinómica (degree) pero de manera LOCAL**, en cada punto solo se utiliza un número `window` de observaciones).


```{r}
#| code-line-numbers: "4"
library(feasts)
fit_airpass <-
  airpass |>
  model(stl = STL(value ~ trend(window = 7, degree = 1) + season(period = 12, window = "periodic")))
```

---

## Métodos de decomposición

Para este tipo particular de métodos (**métodos de decomposición STL**) `components()` nos devuelve la tendencia estimada (`trend`), la estacionalidad (`season_s`), el residuo estimado (`remainder`) y la serie desestacionalizada (`season_adjust`, serie - season_s)

```{r}
#| code-line-numbers: "4"
fit_airpass <-
  airpass |>
  model(stl = STL(log(value) ~ trend(window = 7, degree = 1) + season(period = 12, window = "periodic")))
fit_airpass |> components()
```

---

## Métodos de decomposición

```{r}
#| code-line-numbers: "3"
fit_airpass |>
  components() |> 
  autoplot()
```

---

## Métodos de decomposición


Fíjate que a menor valor en `window = ...` más errática es la tendencia...

```{r}
#| code-line-numbers: "3"
fit_airpass <-
  airpass |>
  model(stl = STL(log(value) ~ trend(window = 3, degree = 1) + season(period = 12, window = "periodic")))
fit_airpass |>
  components() |> 
  autoplot()
```

---

## Métodos de decomposición


... y a mayor valor en `window = ...` más "recta" se convierte.

```{r}
#| code-line-numbers: "3"
fit_airpass <-
  airpass |>
  model(stl = STL(log(value) ~ trend(window = 30, degree = 1) + season(period = 12, window = "periodic")))
fit_airpass |>
  components() |> 
  autoplot()
```

---

## 💻 Tu turno


### [**Ejercicio 1**]{.hl-yellow}

💻 Repite el proceso de creación de modelos (los fable y los feast) y predicción (y su visualización) para los conjuntos de datos

* `retiro`
* `global_economy` (solo para España) del paquete  `{tsibbledata}`
* `beer_ts` del paquete `{timeSeriesDataSets}`
* `elec_ts` del paquete `{timeSeriesDataSets}`
* `pedestrian` (variable `count`) del paquete `{timeSeriesDataSets}`

Determina a cual de los 9 tipos de series de Pegel pertenece cada una.


# Clase 12: [métodos de alisado]{.flow} {#clase-12}

---

## Alisado doble (lineal) de Holt

Como hemos visto el método anterior de alisado solo ajusta bien la [**hipótesis de que nuestros datos son localmente constantes**]{.hl-yellow} tal que

$$\widehat{X}_{t+1|t} = \theta \widehat{X}_{t|t-1} + \left( 1 - \theta \right)X_t = \theta^{t}\widehat{X}_{1} + \left(1 - \theta \right) \sum_{j=0}^{t-1} \theta^{j} X_{t-j}$$

. . .

A ese **primer valor** disponible se le conoce como [**nivel de la serie**]{.hl-yellow} y lo denotaremos como $\ell_0$

$$\widehat{X}_{t+1|t} = \theta^{t}\widehat{X}_{1} + \left(1 - \theta \right) \sum_{j=0}^{t-1} \theta^{j} X_{t-j} = \theta^{t}\ell_0 +  \sum_{j=0}^{t-1} \left(1 - \theta \right) \theta^{j} X_{t-j}$$

---


## Alisado doble (lineal) de Holt

$$\widehat{X}_{t+1|t} = \theta^{t}\widehat{X}_{1} + \left(1 - \theta \right) \sum_{j=0}^{t-1} \theta^{j} X_{t-j} = \theta^{t}\ell_0 +  \sum_{j=0}^{t-1} \left(1 - \theta \right) \theta^{j} X_{t-j}$$

La ecuación anterior la podemos [**expresar de manera iterativa**]{.hl-yellow} como
 
$$\begin{eqnarray}\widehat{X}_{t+h|t} &=& \ell_t \quad \text{predicción en base a componentes} \nonumber \\ \ell_t &=& \theta \ell_{t-1}+ \left( 1 - \theta \right)X_t \quad \text{suavizado de componentes} \end{eqnarray}$$


---

## Alisado doble (lineal) de Holt

$$\begin{eqnarray}\widehat{X}_{t+h|t} &=& \ell_t \quad \text{predicción (en base a componentes)} \nonumber \\ \ell_t &=& \theta \ell_{t-1}+ \left( 1 - \theta \right)X_t \quad \text{suavizado de componentes} \end{eqnarray}$$

En 1957 Holt propuso extender este método a [**datos con tendencia**]{.hl-yellow}, incluyendo ahora dos componentes: nivel $\ell_t$ y tendencia $\mu_t$ (realizando un [**doble suavizado iterativo**]{.hl-yellow})

$$\begin{eqnarray}\color{red}{\widehat{X}_{t+h|t}} &=& \color{red}{\ell_t + h*\mu_t} \quad \text{predicción (en base a componentes)} \nonumber \\ \color{purple}{\ell_{t}} &=& \color{purple}{\theta_1 \widehat{X}_{t|t-1} + \left( 1 - \theta_1 \right)X_t = \theta_1 \left( \ell_{t-1}+ \mu_{t-1} \right) + \left( 1 - \theta_1 \right)X_t} \quad \text{suavizado nivel} \nonumber \\ \color{green}{\mu_{t}} &=& \color{green}{\theta_2 \mu_{t-1}  + \left( 1 - \theta_2 \right)\widehat{\mu}_{t} = \theta_2 \mu_{t-1}  + \left( 1 - \theta_2 \right) \left( \ell_t - \ell_{t-1} \right)} \quad \text{suavizado tendencia} \end{eqnarray}$$

---

## Alisado doble (lineal) de Holt


$$\begin{eqnarray}\color{red}{\widehat{X}_{t+h|t}} &=& \color{red}{\ell_t + h*\mu_t} \quad \text{predicción (en base a componentes)} \nonumber \\ \color{purple}{\ell_{t}} &=& \color{purple}{\theta_1 \widehat{X}_{t|t-1} + \left( 1 - \theta_1 \right)X_t = \theta_1 \left( \ell_{t-1}+ \mu_{t-1} \right) + \left( 1 - \theta_1 \right)X_t} \quad \text{suavizado nivel} \nonumber \\ \color{green}{\mu_{t}} &=& \color{green}{\theta_2 \mu_{t-1}  + \left( 1 - \theta_2 \right)\widehat{\mu}_{t} = \theta_2 \mu_{t-1}  + \left( 1 - \theta_2 \right) \left( \ell_t - \ell_{t-1} \right)} \quad \text{suavizado tendencia} \end{eqnarray}$$

. . .

* [**Predicción a horizonte $h$**]{.hl-red}: último nivel conocido más $h$ veces la última tendencia conocida (en $h$ instantes avanza $h$ veces la tendencia)

. . .

* [**Estimación nivel**]{.hl-purple}: media ponderada entre el último valor de la serie y $\widehat{X}_{t|t-1}$ (predicción a horizonte $h = 1$ en tiempo $t$)

. . .

* [**Estimación tendencia**]{.hl-green}: media ponderada entre el último valor de la tendencia y la estimación de la tendencia a tiempo $t$ (diferencia de nivel $\ell_t$ y $\ell_{t-1}$)


---

## Alisado doble (lineal) de Holt

Para ello simplemente debemos usar `ETS()` incluyendo ahora tendencia aditiva `trend("A")`

```{r}
airpass <- AirPassengers |> as_tsibble()
fit_airpass <-
  airpass |>
  model(alisado_simple = ETS(value ~ error("A") + trend("N") + season("N")),
        alisado_doble = ETS(value ~ error("A") + trend("A") + season("N")))

estimaciones <- fit_airpass |> augment()
predicciones <- fit_airpass |> forecast(h = 12)
estimaciones
```

---

## Alisado doble (lineal) de Holt

```{r}
#| code-fold: true
predicciones |> 
  autoplot(airpass, level = NULL) +
  geom_line(data = estimaciones, aes(x = index, y = .fitted, color = .model)) +
  geom_line(data = predicciones, aes(x = index, y = .mean, color = .model)) +
  scale_color_manual(values = ggthemes::colorblind_pal()(3)[-1]) +
  theme_minimal()
```


---


## Alisado doble de Gardner-McKenzie

Las predicciones generadas por el alisado doble de Holt nos dan una [**tendencia constante (creciente o decreciente) indefinidamente hacia el infinito**]{.hl-yellow}. Sin embargo, la evidencia empírica indica que estos métodos [**tienden a sobrepronosticar a horizontes de previsión más largos**]{.hl-yellow}.

. . .

Para solventar esto Gardner y McKenzie (1985) introdujeron un [**parámetro de amortiguación $\phi$**]{.hl-yellow}: la [**predicción a futuro empieza siendo una línea recta que termina doblándose**]{.hl-yellow} hasta acabar en una recta.

---

## Alisado doble de Gardner-McKenzie


$$\begin{eqnarray}\color{red}{\widehat{X}_{t+h|t}} &=& \color{red}{\ell_t} + \color{blue}{\left( \phi+\phi^2 + \dots + \phi^{h}\right)*\mu_t} \quad \text{predicción (en base a componentes)} \nonumber \\ \color{purple}{\ell_{t}} &=& \color{purple}{\theta_1 ( \ell_{t-1}+} \color{blue}{\phi}\color{purple}{\mu_{t-1} ) + \left( 1 - \theta_1 \right)X_t} \quad \text{suavizado nivel} \nonumber \\ \color{green}{\mu_{t}} &=& \color{green}{\theta_2} \color{blue}{\phi\mu_{t-1}} \color{green}{+ \left( 1 - \theta_2 \right) \left( \ell_t - \ell_{t-1} \right)} \quad \text{suavizado tendencia} \end{eqnarray}$$

con $\color{blue}{0 < \phi < 1}$.

. . .

* [**Predicción a horizonte $h$**]{.hl-red}: último nivel conocido más un amortiguamiento de nivel $h$ de la última tendencia conocida

Así cuando $h \to infty$ tenemos que la predicción acaba siendo una constante.

$$\begin{eqnarray}\lim_{h \to \infty} \widehat{X}_{t+h|t} &=& \ell_t + \lim_{h \to \infty} \left( \phi+\phi^2 + \dots + \phi^{h}\right)*\mu_t \nonumber \\
&=& \ell_t + \frac{\phi}{1-\phi}\mu_t\end{eqnarray}$$

---

## Alisado doble de Gardner-McKenzie

Para ello simplemente debemos usar `ETS()` incluyendo ahora tendencia aditiva `trend("Ad")` (additive dumped)

```{r}
airpass <- AirPassengers |> as_tsibble()
fit_airpass <-
  airpass |>
  model(alisado_simple = ETS(value ~ error("A") + trend("N") + season("N")),
        alisado_doble = ETS(value ~ error("A") + trend("A") + season("N")),
        alisado_doble_amortiguado = ETS(value ~ error("A") + trend("Ad", phi = 0.4) + season("N")))

estimaciones <- fit_airpass |> augment()
predicciones <- fit_airpass |> forecast(h = 8)
estimaciones
```

---

## Alisado doble de Gardner-McKenzie

```{r}
#| code-fold: true
predicciones |> 
  autoplot(airpass, level = NULL) +
  geom_line(data = estimaciones, aes(x = index, y = .fitted, color = .model)) +
  geom_line(data = predicciones, aes(x = index, y = .mean, color = .model)) +
  scale_color_manual(values = ggthemes::colorblind_pal()(4)[-1]) +
  theme_minimal()
```


---


## Alisado triple de Holt-Winters

Unos años más tarde, Holt y Winters (1960) ampliaron los métodos anteriores para [**poder capturar la estacionalidad**]{.hl-yellow}. Se conoce como [**alisado triple**]{.hl-yellow} ya que tendremos ahora tres ecuaciones de suavizado: suavizado del nivel, suavizado de la tendencia y suavizado de la componente estacional.

. . .

Ahora tendremos 4 parámetros:

* parámetros de suavizado $\left(\theta_1, \theta_2, \theta_3 \right)$ 

* parámetro de estacionalidad $s$

. . .

Y tendremos [**dos tipos de formas de incluir la estacionalidad**]{.hl-yellow}: aditivo (varianza constante a lo largo del tiempo, la componente estacional se expresa en términos absolutos) y multiplicativo (la componente estacional se expresa en términos relativos, en porcentajes).

---

## Alisado triple de Holt-Winters


---

## Escenarios

```{r}
#| eval: false
#| echo: false
fit_airpass <-
  airpass |>
  model(reg_poly = TSLM(value ~ index),
        rw_drift = RW(value ~ drift()),
        naive = NAIVE(value),
        season_naive = SNAIVE(value ~ lag(12)))

ultimo_year <- 
  airpass |>
  slice_max(index, n = 12) |> 
  mutate(incremento = 1.25*value,
         descenso = 0.75*value)

future_scenarios <-
  scenarios(incremento =
              new_data(airpass, 12) |>
              mutate("value" =
                       ultimo_year |> pull(incremento)),
            descenso =
              new_data(airpass, 12) |>
              mutate("value" =
                       ultimo_year |> pull(descenso)))

predicciones <-
  fit_airpass |> 
  forecast(new_data = future_scenarios)

airpass |> 
  autoplot(.vars = value) +
  autolayer(predicciones) +
  ggthemes::scale_fill_colorblind() +
  labs(title = "US consumption", y = "% change")

predicciones |> 
  autoplot(value, level = NULL) +
  scale_color_manual(values = ggthemes::colorblind_pal()(7)[-1]) +
  scale_x_yearquarter(date_breaks = "24 months") +
  theme_minimal()
us_change |>
  autoplot(Consumption) +
  autolayer(fc) +
  labs(title = "US consumption", y = "% change")

```


---

## pendiente

* train/test
* scenarios
* acf feasts
* evaluación

---




---

## Alisado triple de Holt-Winters

con estacionalidad aditiva + multipicativa





# Clase 13: [evaluación y diagnosis]{.flow} {#clase-13}


---

## dasda


# Clases 14-15-16-17: [procesos estocásticos y arima]{.flow} {#clase-14}

---

## dasda




