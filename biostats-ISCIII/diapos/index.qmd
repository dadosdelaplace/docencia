---
title: "Bioestad√≠stica en R"
subtitle: "Introducci√≥n a la estad√≠stica en R"
title-slide-attributes:
  data-background-image: img/data-science-2.jpeg
  data-background-size: cover
  data-background-opacity: "0.2"
author: "M√°ster de Bioinform√°tica ‚Ä¢ Javier √Ålvarez Li√©bana"
affiliation: Instituto de Salud Carlos III (ISCIII)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier √Ålvarez Li√©bana</strong>](...) ‚Ä¢ M√°ster de Bioinform√°tica (ISCIII)"
    slide-number: c/t
execute:
  echo: true
---

::: r-fit-text
[¬°Bienvenidos a R!]{.flow}
:::

[**Dejad vuestras hojas de c√°lculo y SPSS a un lado**]{style="color:#444442;"}

---

## ¬°Buenas!

[**Correo**]{.hl-green}: **<javalv09@ucm.es>**. [**Despacho**]{.hl-green}: 722 (3¬™ planta de la Facultad de Estudios Estad√≠sticos de la UCM). 

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
-   [**Javier √Ålvarez Li√©bana**]{.hl-yellow}, de Carabanchel (Bajo).

-   Licenciado en Matem√°ticas (UCM). [**Doctorado en estad√≠stica**]{.hl-yellow} (UGR).

-   Encargado de la [**visualizaci√≥n y an√°lisis de datos covid**]{.hl-yellow} del Principado de Asturias (2021-2022).

-   Miembro de la [**Sociedad Espa√±ola de Estad√≠stica e IO**]{.hl-yellow} y la [**Real Sociedad Matem√°tica Espa√±ola**]{.hl-yellow}.
:::
:::
:::


Actualmente, [**investigador y docente en la Facultad de Estad√≠stica de la UCM**]{.hl-yellow}. Divulgando por [**Twitter**](https://twitter.com/dadosdelaplace) e [**Instagram**](https://instagram.com/javieralvarezliebana)


---

## Objetivos

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
-   Quitarnos el [**miedo a los errores en programaci√≥n**]{.hl-yellow} ‚Üí a programar se aprende programando

-   Entender los [**conceptos b√°sicos de R**]{.hl-yellow} desde cero ‚Üí aprender a abstraer ideas y algoritmos

-   Utilidad de programar ‚Üí flujos de trabajo [**reproducibles**, **transparentes**]{.hl-yellow} y mantenibles

-   Introducci√≥n al [**an√°lisis y preprocesamiento**]{.hl-yellow} de datos ‚Üí `{tidyverse}`

-   Adquirir habilidades en la [**visualizaci√≥n de datos**]{.hl-yellow} ‚Üí `{ggplot2}`

-   Adquirir habilidades en la [**modelizaci√≥n lineal**]{.hl-yellow} 

:::
:::
:::


---

## Planificaci√≥n {#planificacion}

::: column-screen-inset-right
::: {style="font-size:20px"}
|  CLASE | SEMANA | FECHAS | TOPIC | EJ. | WORKBOOK | ENTREGA | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
| [1](#clase-1) | S1 | 17 oct | Primeros pasos. Tipos de datos y vectores | [üíª](#tu-turno-1-1) [üíª](#tu-turno-1-2) [üíª](#tu-turno-1-3) | [üê£](#caso-practico-1-1)  |  | 
| [2](#clase-2) | S2 | 22 oct | Primeras bases de datos |  [üíª](#tu-turno-2-1) [üíª](#tu-turno-2-2) |   [üê£](#caso-practico-2-1)  [üê£](#caso-practico-2-2) [üê£](#caso-practico-2-3)  |  |
| [3](#clase-3) | S2 | 24 oct | Estructuras de control y Quarto | [üíª](#tu-turno-3-1) [üíª](#tu-turno-3-2) | [üê£](#caso-practico-3-1)  | |
| [4](#clase-4) | S3 | 29 oct | Funciones y ggplot | [üíª](#tu-turno-4-1) [üíª](#tu-turno-4-2) | [üê£](#caso-practico-4-1) [üê£](#caso-practico-4-2)  | |
:::
:::

---

## Materiales

* [**Diapositivas**]{.hl-yellow}: diapositivas en `Quarto` disponibles y actualizadas en **<https://javieralvarezliebana.es/docencia/biostats-ISCII>**. En el men√∫ de las diapositivas (abajo a la izquierda) tienes una [**opci√≥n para descargarlas en pdf**]{.hl-yellow} en `Tools`
  
&nbsp;

* [**Material**]{.hl-yellow}: [**cuadernos de trabajo**](https://javieralvarezliebana.es/docencia/biostats-ISCII/material/) y materiales extras y **res√∫menes de paquetes**

* [üóÉ **Datos**]{.hl-yellow}: datasets que usaremos a lo largo de la asignatura, disponibles en **<https://javieralvarezliebana.es/docencia/biostats-ISCII/material>**

* [üìö **Recursos de apoyo**]{.hl-yellow}: en ingl√©s <https://r4ds.had.co.nz/> y en castellano <https://cdr-book.github.io/>, y <https://ivelasq.quarto.pub/intro-to-quarto/> para Quarto.


# Clase 1: [primeros pasos]{.flow} {#clase-1}

[**Instalando R y RStudio. Primeros pasos: ¬øqu√© tipos de celdas (datos) existen?**]{style="color:#444442;"}


* [üíª Ejercicios resueltos: R y RStudio](#tu-turno-1-1)
* [üíª Ejercicios resueltos: tipos de datos](#tu-turno-1-2)
* [üíª Ejercicios resueltos: vectores](#tu-turno-1-3) 
* [üê£ Workbook/caso pr√°ctico I](#caso-practico-1-1)
* [üìÜ Planificaci√≥n](#planificacion)

---

## Requisitos

Para el curso los √∫nicos requisitos ser√°n:

1.  [**Conexi√≥n a internet**]{.hl-yellow} (para la descarga de algunos datos y paquetes).

. . .

2.  [**Instalar R**]{.hl-yellow}: ser√° nuestro lenguaje. La descarga la haremos (gratuitamente) desde <https://cran.r-project.org/>

. . .

3.  [**Instalar RStudio**]{.hl-yellow} desde <https://posit.co/download/rstudio-desktop/>


::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="420"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="420"}
:::
:::

---

## R vs RStudio

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="360"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="430"}
:::
:::

::: {.fragment .fade-in-then-out}
Programaremos como escribimos (castellano, por ejemplo) ‚Üí `R` es [**lenguaje**]{.hl-yellow}
:::

::: {.fragment .fade-up}
-   Necesitaremos una [**gram√°tica, un lenguaje**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}
-   Y un entorno, por ejemplo un [**Word**]{.hl-yellow} (`RStudio`), para escribirlo
:::
:::

---

## Instalaci√≥n de R

El lenguaje `R` ser√° nuestra [**gram√°tica y ortograf√≠a**]{.hl-yellow} (nuestras reglas de juego)

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra en <https://cran.r-project.org/> y selecciona tu sistema operativo.

-   [**Paso 2**]{.hl-yellow}: para Mac basta con que hacer click en el **archivo .pkg**, y abrirlo una vez descargado. Para sistemas Windows, debemos clickar en **install R for the first time** y despu√©s en **Download R for Windows**. Una vez descargado, abrirlo como cualquier archivo de instalaci√≥n.

-   [**Paso 3**]{.hl-yellow}: abrir el ejecutable de instalaci√≥n.
:::

. . .

::: callout-warning
Siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), [**aseg√∫rate de tener conexi√≥n a internet**]{.hl-orange}.
:::

---

## Primera operaci√≥n {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalaci√≥n, tras abrir `R`, deber√≠as ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**Primer c√≥digo**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el c√≥digo en la consola y daremos ¬´enter¬ª). Tras ello haremos la suma `a + b`.

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## Primera operaci√≥n {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalaci√≥n, tras abrir `R`, deber√≠as ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Primer c√≥digo**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el c√≥digo en la consola y daremos ¬´enter¬ª). Tras ello haremos la suma `a + b`.


```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

---

## Primera operaci√≥n {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalaci√≥n, tras abrir `R`, deber√≠as ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Primer c√≥digo**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el c√≥digo en la consola y daremos ¬´enter¬ª). Tras ello haremos la suma `a + b`.


```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

. . .

::: callout-note
## F√≠jate que...

En la consola aparece un n√∫mero `[1]`: simplemente es un contador de elementos (como contar filas en un Word)
:::

---

## Instalaci√≥n de R Studio

`RStudio` ser√° el [**Word**]{.hl-yellow} que usaremos para escribir (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra la [web oficial de RStudio](https://posit.co/download/rstudio-desktop/) (ahora llamado Posit) y selecciona la descarga gratuita.

-   [**Paso 2**]{.hl-yellow}: selecciona el ejecutable que te aparezca acorde a tu sistema operativo.

-   [**Paso 3**]{.hl-yellow}: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro y dejar que termine la instalaci√≥n.
:::

---

## Organizaci√≥n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo c√≥digo que antes (la suma de las variables) en ella. La consola ser√° donde **ejecutaremos √≥rdenes y mostraremos resultados**.

![](img/consola_rstudio.jpg){width="420"}

---

## Organizaci√≥n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Environment**]{.hl-yellow}: la pantalla peque√±a (puedes ajustar los m√°rgenes con el rat√≥n a tu gusto) que tenemos en la parte superior derecha. Nos mostrar√° las **variables que tenemos definidas**.

![](img/environment.jpg){width="420"}

---

## Organizaci√≥n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha no servir√° para buscar **ayuda de funciones**, adem√°s de para **visualizar gr√°ficos**.

![](img/multiusos.jpg){width="420"}

---

## ¬øQu√© es R? ¬øPor qu√© R?

![](img/meme_barco.jpg)

---


## ¬øQu√© es R? ¬øPor qu√© R?

![](img/incel_excel.png)

`R` es la evoluci√≥n del trabajo de los laboratorios Bell con el lenguaje `S`, que fue llevado al mundo del software libre por Ross Ihaka y Robert Gentleman en los a√±os 90. La version `R 1.0.0` se public√≥ el 29 de febrero de 2000.


---

## ¬øQu√© es R? ¬øPor qu√© R?

`R` es el [**lenguaje estad√≠stico por excelencia**]{.hl-yellow}, creado por y para estad√≠sticos/as, con 6 ventajas fundamentales [**frente a Excel, SAS, Stata o SPSS**]{.hl-red}:

. . .

-   [**Lenguaje de programaci√≥n**]{.hl-yellow}: la obviedad ‚Üí an√°lisis [**replicables**]{.hl-purple}

. . .

-   [**Gratuito**]{.hl-yellow}: la filosof√≠a de la comunidad de `R` es el compartir c√≥digo bajo **copyleft** ‚Üí **uso √©tico de dinero y algoritmos**

. . .

-   [**Software libre**]{.hl-yellow}: no solo es gratis sino que permite acceder libremente a c√≥digo ajeno, incluso al **propio c√≥digo fuente** ‚Üí [**flexibilidad y transparencia**]{.hl-purple} (Free and Open Source Software FOSS)

---

## ¬øQu√© es R? ¬øPor qu√© R?

`R` es el [**lenguaje estad√≠stico por excelencia**]{.hl-yellow}, creado por y para estad√≠sticos/as, con 6 ventajas fundamentales [**frente a Excel, SAS, Stata o SPSS**]{.hl-red}:


-   [**Lenguaje modular**]{.hl-yellow}: hemos instalado lo m√≠nimo, pero existen c√≥digos de otras personas que podemos reusar (casi 20 000 [**paquetes**]{.hl-yellow}) ‚Üí [**ahorro de tiempo**]{.hl-purple} e [**innovaci√≥n inmediata**]{.hl-purple}

. . .

-   [**Lenguaje de alto nivel**]{.hl-yellow}: facilita la programaci√≥n (como Python) ‚Üí [**menor curva de aprendizaje**]{.hl-purple}

. . .

- [**Comunidad y empleabilidad**]{.hl-yellow}: junto con Python es el lenguaje m√°s utilizado en el campo de la estad√≠stica y la ciencia de datos en investigaci√≥n, docencia, empresas (L√≠nea Directa, Mapfre, Telef√≥nica, Orange, Apple, Spotify, Netflix, El Pa√≠s, Civio, HP, etc) y organismos p√∫blicos (ISCIII, CNIC, CNIO, INE, IGN, CIS, CEO, DGT, AEMET, RTVE, etc) 


---

## ¬øPor qu√© programar?

-   [**Automatizar**]{.hl-yellow} ‚Üí te permitir√° automatizar tareas recurrentes.

-   [**Replicabilidad**]{.hl-yellow} ‚Üí podr√°s replicar tu an√°lisis siempre de la misma manera.

-   [**Flexibilidad**]{.hl-yellow} ‚Üí podr√°s adaptar el software a tus necesidades.

-   [**Transparencia**]{.hl-yellow} ‚Üí ser auditado por la comunidad.

![](img/the_general_problem.png)

---

## Idea fundamental: paquetes

Una de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: c√≥digos que otras personas han implementado para **resolver un problema**

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}
-   [**Instalaci√≥n**]{.hl-yellow}: descargamos los c√≥digos de la web (necesitamos internet) ‚Üí [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)

```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}
-   [**Carga**]{.hl-yellow}: con el paquete descargado, indicamos qu√© paquetes queremos usar cada vez que abramos `RStudio` ‚Üí [**traer el libro de la estanter√≠a**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::
:::
:::

---

## Idea fundamental: paquetes

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
Una vez instalado, hay **dos manera de usar un paquete** (traerlo de la estanter√≠a)

::: {.fragment fragment-index="1"}
-   [**Paquete entero**]{.hl-yellow}: con `library()`, usando el nombre del paquete sin comillas, cargamos en la sesi√≥n [**todo el libro**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}
-   [**Funciones concretas**]{.hl-yellow} usando `paquete::funcion` le √≠ndicamos que solo queremos una [**p√°gina concreta de ese libro**]{.hl-purple}

```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## Te vas equivocar

Durante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera ‚Üí [**te vas equivocar**]{.hl-yellow}. No solo ser√° importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.

. . .

-   [**Mensajes de error**]{.hl-red}: precedidos de **¬´Error in...¬ª** y ser√°n aquellos fallos que [**impidan la ejecuci√≥n**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Mensajes de warning**]{.hl-orange}: precedidos de **¬´Warning in...¬ª** son los (posibles) fallos m√°s delicados ya que son incoherencias que [**no impiden la ejecuci√≥n**]{.hl-orange}

```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```

---

## Scripts (documentos .R)


::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}
Un [**script**]{.hl-yellow} ser√° el documento en el que programamos, nuestro archivo `.doc` (aqu√≠ con extensi√≥n `.R`) donde escribiremos las √≥rdenes. Para **abrir nuestro primero script**, haz click en el men√∫ en `File < New File < R Script`.

::: callout-warning
## Cuidado

Es importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habr√°s perdido**]{.hl-orange}.
:::

:::
:::



::: callout-warning
## Cuidado

`R` es [**case-sensitive**]{.hl-orange}: es sensible a may√∫sculas y min√∫sculas por lo que `x` y `X` representa variables distintas.
:::


---

## Ejecutando el primer script

Ahora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros c√≥digos**]{.hl-yellow}. ¬øC√≥mo ejecutarlo?

. . .

1.  **Escribimos** el c√≥digo a ejecutar.

. . .

2.  **Guardamos** el archivo .R haciendo click en `Save current document`.

. . .

3.  El c√≥digo no se ejecuta salvo que se lo indiquemos. Tenemos **tres opciones de ejecutar un script**:

-   [**Copiar y pegar**]{.hl-yellow} en consola.
-   [**Seleccionar l√≠neas**]{.hl-yellow} y `Ctrl+Enter`
-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el c√≥digo **completo**.

---


## S√© organizado: proyectos

De la misma manera que en el ordenador solemos trabajar de manera [**ordenada por carpetas**]{.hl-yellow}, en `RStudio` podemos hacer lo mismo para trabajar de [**manera eficaz creando proyectos**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
Un [**proyecto ser√° una ¬´carpeta¬ª**]{.hl-yellow} dentro de `RStudio`, de manera que nuestro directorio ra√≠z autom√°ticamente ser√° la propia carpeta de proyecto (pudiendo pasar de un proyecto a otro con el menu superior derecho).

Podemos crear uno en una carpeta nueva o en una carpeta ya existente.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::


---

## üíª Tu turno {#tu-turno-1-1}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Crea en tu ordenador una carpeta de la asignatura y crea dentro de ella el proyecto de `RStudio`: es ah√≠ donde vas a guardar todo lo que hagamos a lo largo de este curso.Tras crear el proyecto tendr√°s un archivo `R Project`. A continuaci√≥n crea en dicha carpeta dos subcarpetas: `datos` (es ah√≠ donde ir√°s guardando los distintos datasets que usaremos) y `scripts` (es ah√≠ donde ir√°s guardando los archivos `.R` de cada clase)

### [**Ejercicio 2**]{.hl-yellow}

üìù Dentro del proyecto crea un script `ejercicios-clase1.R` (dentro de la carpeta `scripts`). Una vez creado define en √©l una variable de nombre `a` y cuyo valor sea -1. Ejecuta el c√≥digo de las 3 maneras explicadas.

```{r}
#| code-fold: true
a <- -1
```

### [**Ejercicio 3**]{.hl-yellow}

üìù A√±ade debajo otra l√≠nea para definir una variable `b` con el valor 5. Tras ello guarda la multiplicaci√≥n de ambas variables. Ejecuta el c√≥digo como consideres.

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # sin guardar
multiplicacion <- a * b # guardado
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables y guarda el resultado.

```{r}
#| eval: false
c <- # deber√≠as asignarle el valor 3
d <- # deber√≠as asignarle el valor -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d # sin guardar
division <- c / d # guardado
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Asigna un valor positivo a `x` y calcula su ra√≠z cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la funci√≥n `abs()`.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

::: callout-note
## Toma nota

Comandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: l√≠neas de c√≥digo que hemos ¬´encapsulado¬ª bajo un nombre, y dado unos argumentos de entrada, ejecuta las √≥rdenes (una especie de atajo). En las funciones los [**argumentos ir√°n SIEMPRE entre par√©ntesis**]{.hl-yellow}
:::


### [**Ejercicio 6**]{.hl-yellow}

üìù Usando la variable `x` ya definida, completa/modifica el c√≥digo inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.

```{r}
#| eval: false
z <- ? - ? # completa el c√≥digo
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```

### [**Ejercicio 7**]{.hl-yellow}

üìù Define una variable `x` y as√≠gnale el valor `-1`. Define otra `y` y as√≠gnale el valor `0`. Tras ello realiza las operaciones a) `x` entre `y`; b) ra√≠z cuadrada de `x`. ¬øQu√© obtienes?



```{r}
#| code-fold: true
#| eval: false
x <- -1
y <- 0

x / y
sqrt(x)
```

### [**Ejercicio 8**]{.hl-yellow}

üìù Escribe el c√≥digo inferior en tu script. ¬øPor qu√© crees que no funciona?


```{r}
#| error: true
x <- -1
y <- 0

X + y
```

:::



---

## De la CELDA a la TABLA

¬øQu√© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg)

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenaci√≥n** de valores del mismo tipo ([**vectores en R**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenaci√≥n de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

---

## Pero antes...buenas pr√°cticas

Antes de seguir, es importante que sepas algo cu√°nto antes: [**empezar en la programaci√≥n puede ser frustrante**]{.hl-yellow}

. . .

Al igual que cuando aprendes un idioma nuevo, el primer obst√°culo a solventar no es tanto qu√© decir sino c√≥mo decirlo de manera correcta. Y en `R` pasa lo mismo, as√≠ que vamos a [**normalizar nuestra forma de programar**]{.hl-yellow} lo m√°ximo posible para evitar errores futuros.

. . .

* [**Tip 1**]{.hl-green}: [**asignar, evaluar y comparar no es lo mismo**]{.hl-yellow}. Si te has fijado en `R` estamos usando `<-` para asignar valores a variables. Usaremos `=` para evaluar argumentos en funciones y `==` para saber si dos elementos son iguales.

```{r}
#| eval: false
x <- 1 # asignar
x = 1 # evaluar
x == 1 # comparar
```



---

## Pero antes...buenas pr√°cticas

* [**Tip 2**]{.hl-green}: programa como escribes. Al igual que cuando redactas en castellano, acost√∫mbrate a incorporar [**espacios y saltos de l√≠nea**]{.hl-yellow} paranoquedarteciego (es una buena pr√°ctica y no un requisito porque `R` no procesa los espacios)

```{r}
#| eval: false
x <- 1 # √≥ptimo
x<-1 # regu
x<- 1 # peor (dec√≠dete)
```

. . .

* [**Tip 3**]{.hl-green}: no seas ca√≥tico/a, [**estandariza nombres**]{.hl-yellow}. Acost√∫mbrate siempre a nombrar las variables de la misma manera. El √∫nico requisito es que **debe empezar siempre por una letra** (y sin tildes). La forma m√°s recomendable es la conocida como `snake_case`

```{r}
#| eval: false
variable_en_modo_snake_case
otraFormaMasDificilDeLeer
hay.gente.que.usa.esto
Incluso_Haygente.Caotica_que.NoMereceNuestraATENCION
```

---

## Pero antes...buenas pr√°cticas

* [**Tip 4**]{.hl-green}: facilita la lectura y escritura, [**pon l√≠mites**]{.hl-yellow}. En `Tools < Global Options` puedes personalizar algunas opciones de `RStudio`. En `Code < Display` podemos indicarle en `Show margin` que los scripts nos muestren un margen "imaginario" (no interacciona con el c√≥digo) para "forzarnos" a realizar un salto de l√≠nea.

![](img/show_margin.jpg)


---

## Pero antes...buenas pr√°cticas

* [**Tip 5**]{.hl-green}: el [**tabulador es tu mejor amigo**]{.hl-yellow}. En `RStudio` tenemos una herramienta maravillosa: si escribes parte del nombre de una variable o funci√≥n y tabulas, `RStudio` te autocompleta

![](img/tab-autocompletar.png)  


---

## Pero antes...buenas pr√°cticas

* [**Tip 6**]{.hl-green}: ni un par√©ntesis soltero. Siempre que abras un par√©ntesis deber√°s cerrarlo. Para facilitar esta tarea entra en `Tools < Global Options < Code < Display` y activa la opci√≥n `Rainbow parentheses`

![](img/rainbow-parentheses.jpg)



---

## Pero antes...buenas pr√°cticas

* [**Tip 7**]{.hl-green}: f√≠jate en el lateral izquierdo. No solo podr√°s ver la l√≠nea de c√≥digo por la que vas sino que, en caso de estar cometiendo un [**error de sintaxis**]{.hl-red}, el propio `RStudio` te avisar√°.

![](img/rstudio-error-sintaxis.png)

* [**Tip 8**]{.hl-green}: intenta [**trabajar siempre por proyectos**]{.hl-yellow} (para esta clase, crea un script `clase2.R` en el proyecto que creamos en la anterior clase)

&nbsp;

Ver m√°s tips en <https://r4ds.had.co.nz/workflow-basics.html#whats-in-a-name>

---

## Celdas: tipos de datos

¬øExisten [**variables m√°s all√° de los n√∫meros en la ciencia de datos**]{.hl-yellow}? Piensa por ejemplo en los datos que podr√≠as guardar de una persona:

::: {.fragment .fade-up}
-   La edad o el peso ser√° un [**n√∫mero**]{.hl-yellow}.

```{r}
edad <- 33
```
:::

::: {.fragment .fade-up}
-   Su nombre ser√° una cadena de [**texto (conocida como string o char)**]{.hl-yellow}.

```{r}
nombre <- "javi"
```
:::

::: {.fragment .fade-up}
-   A la pregunta ¬´¬øest√°s matriculado en la Facultad?¬ª la respuesta ser√° lo que llamamos una [**variable l√≥gica**]{.hl-yellow} (`TRUE` si est√° matriculado o `FALSE` en otro caso).

```{r}
matriculado <- TRUE
```
:::

::: {.fragment .fade-up}
-   Su fecha de nacimiento ser√° precisamente eso, una [**fecha**]{.hl-yellow}.
:::

---

## Variables num√©ricas {auto-animate="true"}

El dato m√°s sencillo (ya lo hemos usado) ser√°n las [**variables num√©ricas**]{.hl-yellow}. Para saber la [**clase de dato en R**]{.hl-yellow}  de una variable tenemos la funci√≥n `class()`

```{r}
#| eval: false
#| code-line-numbers: "1"
a <- 5
```



---

## Variables num√©ricas {auto-animate="true"}

El dato m√°s sencillo (ya lo hemos usado) ser√°n las [**variables num√©ricas**]{.hl-yellow}. Para saber la [**clase de dato en R**]{.hl-yellow}  de una variable tenemos la funci√≥n `class()`


```{r}
#| eval: false
#| code-line-numbers: "2"
a <- 5
class(a)
```

. . .

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

Para saber su [**tipolog√≠a (naturaleza o formato)**]{.hl-yellow} variable tenemos `typeof()`

```{r}
typeof(1) # 1 pero almacenado como un valor real (double, con decimales)
typeof(as.integer(1)) # 1 pero almacenado como un entero.
```

::: callout-note
## F√≠jate que...

En `R` tenemos una colecci√≥n de funciones que empiezan por `as.x()` y que sirven como [**funciones de conversi√≥n**]{.hl-yellow}: un dato que era de un tipo, lo convertimos a tipo `x`.
:::

---


## Variables num√©ricas


Adem√°s de los n√∫meros ¬´normales¬ª tendremos el [**valor m√°s/menos infinito**]{.hl-yellow} codificado como `Inf` o `-Inf`

```{r}
1/0
```

```{r}
-1/0
```

. . .

Y valores que [**no son n√∫meros reales**]{.hl-yellow} _not a number_ (indeterminaciones, complejos, etc) codificado como `NaN`

```{r}
0/0
```

```{r}
sqrt(-2)
```



---

## Variables num√©ricas

Con las variables num√©ricas podemos realizar las [**operaciones aritm√©ticas**]{.hl-yellow} de una calculadora: sumar (`+`)...

```{r}
a + b
```

. . .

...ra√≠z cuadrada (`sqrt()`)...

```{r}
sqrt(a)
```

. . .

... potencias (`^2`, `^3`)...

```{r}
a^2
```

. . .

...valor absoluto (`abs()`), etc.

```{r}
abs(a)
```





---

## Variables de texto

Imagina que adem√°s de la edad de una persona queremos guardar su nombre: ahora la variable ser√° de tipo `character`

```{r}
nombre <- "Javier"
class(nombre)
```

. . .

Las [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones aritm√©ticas**]{.hl-red} (s√≠ otras operaciones como pegar o localizar patrones).

```{r}
#| error: true
nombre + 1 # error al sumar n√∫mero a texto
```

. . .

::: callout-warning
## Recuerda que...

Las variables de tipo texto (character o string) van [**SIEMPRE entre comillas**]{.hl-orange}: no es lo mismo `TRUE` (valor l√≥gico, binario) que `"TRUE"` (texto).
:::

---

## Primera funci√≥n: paste

Como hemos comentado `R` llamaremos [**funci√≥n**]{.hl-yellow} a un trozo de [**c√≥digo encapsulado**]{.hl-yellow} bajo un nombre, y que depende de unos [**argumentos**]{.hl-yellow} de entrada. Nuestra primera funci√≥n ser√° `paste()`: dadas dos cadenas de texto nos permite pegarlas.

```{r}
paste("Javier", "√Ålvarez")
```

. . .

F√≠jate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos a√±adir un [**argumento opcional**]{.hl-yellow} para indicarle el separador (en `sep = ...`). 

```{r}
paste("Javier", "√Ålvarez", sep = "*")
```

---

## Primera funci√≥n: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}
¬øC√≥mo saber [**qu√© argumentos necesita una funci√≥n**]{.hl-yellow}? Escribiendo en consola `? paste` te aparecer√° una [**ayuda**]{.hl-yellow} en el panel multiusos.

En dicha ayuda podr√°s ver en su cabecera que argumentos ya tiene [**asignados por defecto**]{.hl-yellow} la funci√≥n
:::
:::

. . .

Existe una funci√≥n similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).

```{r}
paste0("Javier", "√Ålvarez")
```

---

## Primera funci√≥n: paste

Los argumentos (y su detalle) tambi√©n pueden ser consultado **tabulando (detras una coma)**.

![](img/tab-functions.png)

--- 

## Funciones: argumentos por defecto

Es muy importante entender el concepto de [**argumento por defecto de una funci√≥n**]{.hl-yellow} en `R`: es un valor que la funci√≥n usa pero a veces podemos no ver porque [**ya tiene un valor asignado**]{.hl-yellow}. 

```{r}
# Hacen lo mismo
paste("Javier", "√Ålvarez")
paste("Javier", "√Ålvarez", sep = " ")
```

. . .

::: callout-note
## Toma nota

El operador `=` lo [**reservaremos para asignar argumentos**]{.hl-yellow} dentro de funciones. Para todas las dem√°s asignaciones usaremos `<-`
:::

---

## Primer paquete: glue

Una forma m√°s intuitiva de trabajar con textos es usar el paquete `{glue}`: lo primero que haremos ser√° ¬´comprar el libro¬ª (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue") # solo la primra vez
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

Con la funci√≥n `glue()` de dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, ¬´la edad es de ... a√±os¬ª, donde la edad est√° guardada en una variable.

```{r}
edad <- 33
glue("La edad es de {edad} a√±os")
```

. . .

Dentro de las llaves tambi√©n podemos [**ejecutar operaciones**]{.hl-yellow}

```{r}
unidades <- "d√≠as"
glue("La edad es de {edad * 365} {unidades}")
```

---

## Variables l√≥gicas

Otro tipo fundamental ser√°n las [**variables l√≥gicas o binarias**]{.hl-yellow} (**dos valores**):

-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.
-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.

```{r}
soltero <- TRUE # ¬øEs soltero? --> S√ç
class(soltero)
```

. . .

Dado que internamente est√°n guardados como variables binarias, podemos [**realizar operaciones aritm√©ticas**]{.hl-yellow} con ellas

```{r}
2 * TRUE
FALSE - 1
```

---

## Variables l√≥gicas

Como veremos en breve, las variables l√≥gicas en realidad puede tomar un tercer valor: `NA` o [**dato ausente**]{.hl-yellow}, representando las siglas de *not available*, y ser√° muy habitual encontrarlo dentro de una base de datos.

```{r}
ausente <- NA
ausente + 1
```


. . .

::: callout-important
## Importante

Las variables l√≥gicas [**NO son variables de texto**]{.hl-red}: `"TRUE"` es un texto, `TRUE` es un valor l√≥gico.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Condiciones l√≥gicas

Los valores l√≥gicos suelen ser resultado de [**evaluar condiciones l√≥gicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos [**comprobar**]{.hl-yellow} si una persona se llama Javi.

```{r}
nombre <- "Mar√≠a"
```


. . .

Con el [**operador l√≥gico**]{.hl-yellow} `==` preguntamos s√≠ lo que tenemos guardado a la izquierda es [**igual que**]{.hl-purple} lo que tenemos a la derecha: es una [**pregunta**]{.hl-yellow}

```{r}
nombre == "Javi"
```

. . .

Con su opuesto `!=` preguntamos [**si es distinto**]{.hl-purple}.

```{r}
nombre != "Javi"
```

. . .

::: callout-note
## F√≠jate que...

No es lo mismo `<-` ([**asignaci√≥n**]{.hl-yellow}) que `==` (estamos [**preguntando**]{.hl-yellow}, es una comparaci√≥n l√≥gica).
:::

---

## Condiciones l√≥gicas

Adem√°s de las comparaciones ¬´igual a¬ª frente ¬´distinto¬ª, tambi√©n comparaciones de orden como [**menor que**]{.hl-purple} `<`, [**mayor que**]{.hl-purple} `>`,  `<=` o `>=`.

**¬øTiene la persona menos de 32 a√±os?**

```{r}
edad <- 34
edad < 32 # ¬øEs la edad menor de 32 a√±os?
```

. . .

**¬øLa edad es mayor o igual que 38 a√±os?**

```{r}
edad >= 38
```

. . .

**¬øEl nombre guardado es Javi?**

```{r}
nombre <- "Javi"
nombre == "Javi"
```

---

## Variables de fecha

Un tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.

```{r}
fecha_char <- "2021-04-21"
```

Parece una simple cadena de texto pero [**deber√≠a representar un instante en el tiempo**]{.hl-yellow}. ¬øQu√© deber√≠a suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?

. . .

```{r}
#| error: true
fecha_char + 1
```


Las fechas [**NO pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha.

. . .

&nbsp;

Para trabajar con fechas usaremos el paquete `{lubridate}`, que deberemos instalar antes de poder usarlo.

```{r}
#| eval: false
install.packages("lubridate")
```

---

## Variables de fecha

Una vez instalado, de todos los paquetes (libros) que tenemos, le indicaremos que nos cargue ese concretamente.

```{r}
library(lubridate) # instala si no lo has hecho

```

. . .

Para [**convertir a tipo fecha**]{.hl-yellow} usaremos la funci√≥n `as_date()` del paquete `{lubridate}` (por defecto en formato `yyyy-mm-dd`)

&nbsp;

:::: columns
::: {.column width="50%"}

```{r}
#| error: true
# ¬°no es una fecha, es un texto!
fecha_char + 1
class(fecha_char)
```

:::

::: {.column width="50%"}

```{r}
fecha <- as_date("2023-03-28")
fecha + 1
class(fecha)
```

:::

::::

---

## Variables de fecha

En `as_date()` el formato de fecha por defecto es `yyyy-mm-dd` as√≠ si la cadena de texto no se introduce de manera adecuada...

```{r}
as_date("28-03-2023")
```

. . .

Para [**cualquier otro formato debemos especificarlo**]{.hl-yellow} en el argumento opcional `format = ...` tal que `%d` representa d√≠as, `%m` meses, `%Y` en formato de 4 a√±os y `%y` en formato de 2 a√±os.

```{r}
as_date("28-03-2023", format = "%d-%m-%Y")
as_date("28-03-23", format = "%d-%m-%y")
as_date("03-28-2023", format = "%m-%d-%Y")
as_date("28/03/2023", format = "%d/%m/%Y")
```


---

## Variables de fecha

En dicho paquete tenemos funciones muy √∫tiles para [**manejar fechas**]{.hl-yellow}:

-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.

```{r}
today()
```

. . .

-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}

```{r}
now()
```

. . .

-   Con `year()`, `month()` o `day()` podemos [**extraer el a√±o, mes y d√≠a**]{.hl-purple}

```{r}
fecha <- today()
year(fecha)
month(fecha)
```

---

## Res√∫menes de paquetes

![](img/lubridate.png)

::: callout-note
## Amplia contenido

Tienes un resumen en pdf de los paquetes m√°s importantes en la [**carpeta correspondiente en el campus**]{.hl-green}
:::

---

## üíª Tu turno {#tu-turno-1-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Define una variable que guarde tu edad (llamada `edad`) y otra con tu nombre (llamada `nombre`)

```{r}
#| code-fold: true
edad <- 33
nombre <- "Javi"
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Comprueba con dicha variable `edad` si NO tiene 60 a√±os o si se llama `"Ornitorrinco"` (debes obtener variables l√≥gicas como resultado)

```{r}
#| code-fold: true
#| eval: false
edad != 60 # distinto de
nombre == "Ornitorrinco" # igual a
```

### [**Ejercicio 3**]{.hl-yellow}

üìù ¬øPor qu√© el c√≥digo inferior da error?

```{r}
#| error: true
edad + nombre
```


### [**Ejercicio 4**]{.hl-yellow}

üìù Define otra variable llamada `hermanos` que responda la pregunta ¬´¬øtienes hermanos?¬ª y otra variable que almacene tu fecha de nacimiento (llamada `fecha_nacimiento`).

```{r}
#| code-fold: true
hermanos <- TRUE

library(lubridate) # sino lo ten√≠as ya cargado
fecha_nacimiento <- as_date("1989-09-10")
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Define otra variable con tus apellidos (llamada `apellidos`) y usa `glue()` para tener, en una sola variable  llamada `nombre_completo`, tu nombre y apellidos separando nombre y apellido por una coma

```{r}
#| code-fold: true
#| eval: false
apellidos <- "√Ålvarez Li√©bana"
glue("{nombre}, {apellidos}")
```

### [**Ejercicio 6**]{.hl-yellow}

üìù De `fecha_nacimiento` extrae el mes.

```{r}
#| code-fold: true
#| eval: false
month(fecha_nacimiento)
```

### [**Ejercicio 7**]{.hl-yellow}

üìù Calcula los d√≠as que han pasado desde la fecha de tu nacimiento hasta hoy (con la fecha de nacimiento definida en el ejercicio 4).

```{r}
#| code-fold: true
#| eval: false
today() - fecha_nacimiento
```
:::

---

## Vectores: concatenar

Cuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenaci√≥n**]{.hl-purple} de celdas (valores) del [**mismo tipo**]{.hl-purple} (lo que ser√≠a una columna de una tabla).

. . .

La forma m√°s sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus **elementos entre par√©ntesis y separados por comas**

```{r}
edades <- c(32, 27, 60, 61)
edades
```

. . .

::: callout-tip
Un n√∫mero individual `x <- 1` (o bien `x <- c(1)`) es en realidad un **vector de longitud uno** --> todo lo que sepamos [**hacer con un n√∫mero podemos hacerlo con un vector de ellos**]{.hl-green}.
:::

---

## Vectores: concatenar

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}
Como ves ahora en el `environment` tenemos una **colecci√≥n de elementos** guardada

```{r}
edades
```
:::
:::

. . .



La [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`

```{r}
length(edades)
```

. . .

Tambi√©n podemos [**concatenar vectores**]{.hl-yellow} entre s√≠ (los repite uno tras otro)

```{r}
c(edades, edades, 8)
```

---

## Secuencias num√©ricas

El vector m√°s famoso ser√° el de tipo num√©rico, y en concreto, las conocidas como [**secuencias num√©ricas**]{.hl-yellow} (por ejemplo, los d√≠as del mes), usadas para, entre otras cosas, indexar bucles.

. . .

El comando `seq(inicio, fin)` nos permite crear una [**secuencia num√©rica**]{.hl-yellow} desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.

```{r}
seq(1, 31)
```

. . .

F√≠jate que si hacemos eso con [**caracteres no podremos hacerlo**]{.hl-red} ya que no hay un orden a priori entre textos.

```{r}
#| error: true
"a":"z"
```

---

## Secuencias num√©ricas


Un atajo es el comando `1:n`, que nos devuelve lo mismo que `seq(1, n)`

```{r}
1:7
```

Si el elemento inicial es mayor que el final, entender√° que la secuencia es [**en orden decreciente**]{.hl-purple}.

```{r}
7:-3
```

. . .

Tambi√©n podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos con el argumento `by = ...`

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

---

## Secuencias num√©ricas


Otras veces nos interesar√° definir una [**secuencia con una longitud concreta**]{.hl-yellow}

```{r}
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```

. . .

Incluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}

```{r}
rep(0, 7) # vector de 7 ceros
```

. . .


Dado que internamente son guardados como n√∫meros tambi√©n podremos hacer esto con [**fechas**]{.hl-yellow}.

```{r}
seq(as_date("2023-09-01"), as_date("2023-09-10"), by = 1)
```


---

## Vectores de caracteres

Un vector es una **concatenaci√≥n** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente n√∫meros. Vamos a crear una frase de ejemplo.

```{r}
frase <- "Me llamo Javi"
frase
length(frase)
```

. . .

En el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas

```{r}
vector <- c("Me", "llamo", "Javi")
vector
length(vector)
```

---

## Vectores de caracteres

¬øQu√© suceder√° si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

F√≠jate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}

. . .

```{r}
c(3, 4, TRUE, FALSE)
```

Es importante entender que los valores l√≥gicos en realidad est√°n [**almacenados internamente como 0/1**]{.hl-yellow}

---

## Operaciones con vectores

Con los vectores num√©ricos podemos hacer las mismas [**operaciones aritm√©ticas**]{.hl-yellow} que con los n√∫meros ‚Üí un [**n√∫mero es un vector**]{.hl-purple} (de longitud uno)

. . .

¬øQu√© suceder√° si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Cuidado

Salvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}
:::

---

## Suma de vectores

Los vectores tambi√©n pueden interactuar entre ellos, as√≠ que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)

```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Dado que la operaci√≥n (por ejemplo, una suma) se realiza elemento a elemento, ¬øqu√© suceder√° si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?

. . .

```{r}
z <- c(1, 3, 5, 7)
x + z
```

Lo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que har√° ser√° reciclar del vector con menor longitud.

---

## Comparar vectores

Una operaci√≥n muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones l√≥gicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...

[**¬øQu√© d√≠as hizo menos de 22 grados?**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

Nos devolver√° un [**vector l√≥gico**]{.hl-yellow}, en funci√≥n de si **cada elemento** cumple o no la condici√≥n pedida (de **igual longitud** que el vector preguntado)

. . .

Si tuvi√©ramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese d√≠a), la condici√≥n evaluada tambi√©n ser√≠a `NA`

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Comparar vectores

Las [**condiciones l√≥gicas pueden ser combinadas**]{.hl-yellow} de dos maneras:

-   [**Intersecci√≥n**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunci√≥n y**]{.hl-purple} con `&`) para devolver un `TRUE`

```{r}
x < 30 & x > 15
```

-   [**Uni√≥n**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunci√≥n o**]{.hl-purple} con `|`)

```{r}
x < 30 | x > 15
```

. . .

Con `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen

```{r}
any(x < 30)
all(x < 30)
```

---

## Acceder a elementos

Otra operaci√≥n muy habitual es la de [**acceder a elementos**]{.hl-yellow}. La forma m√°s sencilla es usar el operador `[i]` (acceder al elemento i-√©simo)

```{r}
edades <- c(20, 30, 33, NA, 61) 
edades[3] # accedemos a la edad de la tercera persona 
```

. . .


Dado que un n√∫mero no es m√°s que un vector de longitud uno, esta operaci√≥n tambi√©n la podemos aplicar usando un [**vector de √≠ndices a seleccionar**]{.hl-yellow}

```{r}
y <- c("hola", "qu√©", "tal", "est√°s", "?")
y[c(1:2, 4)] # primer, segundo y cuarto elemento
```

. . .

::: callout-tip
Para acceder al √∫ltimo, sin preocuparnos de cu√°l es, podemos pasarle como √≠ndice la propia longitud `x[length(x)]`
:::

---

## Eliminar elementos

Otras veces no querremos seleccionar sino [**eliminar algunos elementos**]{.hl-yellow}. Deberemos repetir la misma operaci√≥n pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-√©simo del vector sino que lo ¬´des-selecciona¬ª

```{r}
y
y[-2]
```


. . .

En muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones l√≥gicas**]{.hl-yellow}, en funci√≥n de los valores, as√≠ que pasaremos como √≠ndice la propia condici√≥n (recuerda, `x < 2` nos devuelve un vector l√≥gico)

```{r}
edades <- c(15, 21, 30, 17, 45)
nombres <- c("javi", "mar√≠a", "laura", "carla", "luis")
nombres[edades < 18] # nombres de los menores de edad
```

---


## Sumar vectores

Tambi√©n podemos hacer uso de [**operaciones estad√≠sticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**¬øQu√© sucede cuando falta un dato (ausente)?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

Por defecto, si tenemos un dato ausente, la [**operaci√≥n tambi√©n ser√° ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`

```{r}
sum(x, na.rm = TRUE)
```

---

## Sumar vectores

Como hemos comentado que los valores l√≥gicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritm√©ticas.


Por ejemplo, si queremos [**averiguar el n√∫mero de elementos que cumplen una condici√≥n**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendr√°n asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar dicho vector l√≥gico para obtener el n√∫mero de elementos que cumplen

```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Suma acumulada

Otra operaci√≥n habitual que puede sernos √∫til es la [**suma acumulada**]{.hl-yellow} con `cumsum()` que, dado un vector, nos devuelve un vector a su vez con el primero, el primero m√°s el segundo, el primero m√°s el segundo m√°s el tercero...y as√≠ sucesivamente.

```{r}
x <- c(1, 5, 2, -1, 8)
cumsum(x)
```

[**¬øQu√© sucede cuando falta un dato (ausente)?**]{.hl-yellow}


```{r}
x <- c(1, -2, 3, NA, -1)
cumsum(x)
```

En el caso de la suma acumulada lo que sucede es que [**a partir de ese valor, todo lo acumulado posterior ser√° ausente**]{.hl-yellow}.

---

## Diferencia

Otra operaci√≥n habitual que puede sernos √∫til es la [**diferencia (con retardo)**]{.hl-yellow} con `diff()` que, dado un vector, nos devuelve un vector con el segundo menos el primero, el tercero menos el segundo, el cuarto menos el tercero...y as√≠ sucesivamente.


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x)
```

. . .

Con el argumento `lag = ` podemos indicar el [**retardo**]{.hl-yellow} de dicha diferencia (por ejemplo, `lag = 3` implica que se resta el cuarto menos el primero, el quinto menos el segundo, etc)


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x, lag = 3)
```

---

## Media

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La m√°s conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores at√≠picos o outliers (valores muy grandes o muy peque√±os), la media se perturba con mucha facilidad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Percentiles

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.


-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Percentiles**]{.hl-yellow}: medidas de posici√≥n (nos dividen en partes iguales los datos).

```{r}
quantile(x) # por defecto percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

---


## Ordenar vectores

Por √∫ltimo, una acci√≥n habitual es saber [**ordenar valores**]{.hl-yellow}:

-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(edades)
sort(edades, decreasing = TRUE)
```

. . .

-   `order()`: devuelve el [**vector de √≠ndices**]{.hl-yellow} que tendr√≠amos que usar para tener el vector ordenado

```{r}
order(x)
x[order(x)]
```

---

## üíª Tu turno {#tu-turno-1-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Define el vector `x` como la concatenaci√≥n de los 5 primeros n√∫meros impares. Calcula la longitud del vector

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Accede al tercer elemento de `x`. Accede al √∫ltimo elemento (sin importar la longitud, un c√≥digo que pueda ejecutarse siempre). Elimina el primer elemento.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Obt√©n los elementos de `x` mayores que 4. Calcula el vector `1/x` y gu√°rdalo en una variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Crea un vector que represente los nombres de 5 personas, de los cuales uno es desconocido.

```{r}
#| code-fold: true
#| eval: false
nombres <- c("Javi", "Sandra", NA, "Laura", "Carlos")
nombres
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Encuentra del vector `x` de ejercicios anteriores los elementos mayores (estrictos) que 1 Y ADEM√ÅS menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Ejercicio 6**]{.hl-yellow}

üìù Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`,  ¬øpor qu√© su media no devuelve un n√∫mero sino lo que se muestra en el c√≥digo inferior?

```{r}
x <- c(1, -5, 8, NA, 10, -3, 9)
mean(x)
```

### [**Ejercicio 7**]{.hl-yellow}

üìù Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6. 

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
x[-2]
```

### [**Ejercicio 8**]{.hl-yellow}

üìù Dado el vector `x` del ejercicio anterior, ¬øcuales tienen un dato ausente? Pista: las funciones `is.algo()` comprueban si el elemento es tipo `algo` (tabula)

```{r}
#| code-fold: true
#| eval: false
is.na(x)
```


### [**Ejercicio 9**]{.hl-yellow}

üìù Define el vector `x` como la concatenaci√≥n de los 4 primeros n√∫meros pares. Calcula el n√∫mero de elementos de `x` menores estrictamente que 5.

```{r}
#| code-fold: true
#| eval: false
x[x < 5] 
sum(x < 5)
```


### [**Ejercicio 10**]{.hl-yellow}

üìù Calcula el vector `1/x` y obt√©n la versi√≥n ordenada (de menor a mayor) de las dos formas posibles

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Ejercicio 11**]{.hl-yellow}

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Ejercicio 12**]{.hl-yellow}

üìù Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 6. Encuentra una forma de averiguar si todos los elementos son o no negativos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

:::


## üê£ Caso pr√°ctico I: vectores {#caso-practico-1-1}

En el paquete `{datasets}` (ya instalado por defecto) tenemos diversos conjuntos de datos y uno de ellos es `airquality`. Debajo te he extra√≠do 3 variables de dicho dataset (f√≠jate que se hace con `datos$variable`, ese dolar ser√° importante en el futuro).

Los datos capturan [**medidas diarias (n = 153 observaciones) de la calidad del aire**]{.hl-yellow} en Nueva York, de mayo a septiembre de 1973. Se midieron **6 variables**: niveles de ozono, radiaci√≥n solar, viento, temperatura, mes y d√≠a.

```{r}
library(datasets)
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/intro-r-vectores-isciii/)


# Clase 2: [primeras bases de datos]{.flow} {#clase-2}

[**Primera base de datos: matrices, data.frame y tibble**]{style="color:#444442;"}

* [üíª Ejercicios resueltos: matrices](#tu-turno-2-1)
* [üíª Ejercicios resueltos: data.frame y tibble](#tu-turno-2-2) 
* [üê£ Workbook/caso pr√°ctico: tibble](#caso-practico-2-1)
* [üê£ Workbook/caso pr√°ctico: Quarto](#caso-practico-2-2)
* [üìÜ Planificaci√≥n](#planificacion)


---

## Primera base de datos

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una ¬´tabla¬ª que las recopile. La opci√≥n m√°s inmediata son las [**matrices**]{.hl-yellow}: concatenaci√≥n de variables del [**mismo tipo e igual longitud**]{.hl-purple}.

Imagina que tenemos estaturas y pesos de 4 personas. ¬øC√≥mo [**crear un dataset con las dos variables**]{.hl-yellow}?

. . .


La opci√≥n m√°s habitual es usando `cbind()`: [**concatenamos (bind) vectores en forma de columnas (c)**]{.hl-yellow}

```{r}
#| code-line-numbers: "3"
estaturas <- c(150, 160, 170, 180)
pesos <- c(63, 70, 85, 95)
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

---

## Primer intento: matrices

Tambi√©n podemos [**construir la matriz por filas**]{.hl-yellow} con la funci√≥n `rbind()` (concatenar - bind - por filas  - rows), aunque lo [**recomendable es tener cada variable en columna**]{.hl-green} e individuo en fila como luego veremos.

```{r}
rbind(estaturas, pesos) # Construimos la matriz por filas
```

. . .

- Podemos [**¬´visualizar¬ª la matriz**]{.hl-yellow} con `View(matriz)`.

. . .

-   Podemos [**comprobar las dimensiones**]{.hl-yellow} con `dim()`, `nrow()` y `ncol()`: las matrices son un tipo de **datos tabulados** (organizados en filas y columnas)

```{r}
dim(datos_matriz)
nrow(datos_matriz)
ncol(datos_matriz)
```

---

## Primer intento: matrices

Tambi√©n podemos [**¬´darle vuelta¬ª (matriz transpuesta)**]{.hl-yellow} con `t()`.

```{r}
t(datos_matriz)
```

. . .

Dado que ahora tenemos dos dimensiones en nuestros datos, para [**acceder a elementos con `[]`**]{.hl-yellow} deberemos proporcionar **dos √≠ndices separados por comas**: √≠ndice de la fila y de la columna 

```{r}
datos_matriz[2, 1] # segunda fila, primera columna
datos_matriz[1, 2] # primera fila, segunda columna 
```

---

## Primer intento: matrices

En algunas casos querremos obtener los [**datos totales de un individuo**]{.hl-yellow} (una fila concreta pero todas las columnas) o los valores de [**toda una variable**]{.hl-yellow} para todos los individuos (una columna concreta pero todas las filas). Para ello dejaremos [**sin rellenar uno de los √≠ndices**]{.hl-yellow}

```{r}
datos_matriz[2, ] # segundo individuo
datos_matriz[, 1] # primera variable
```

. . .

Mucho de lo aprendido con vectores podemos hacerlo con matrices, as√≠ podemos por ejemplo acceder a varias filas y/o columnas haciendo uso de las [**secuencias de enteros 1:n**]{.hl-yellow}

```{r}
datos_matriz[c(1, 3), 1] # primera variable para el primer y tercer individuo
```


---

## Primer intento: matrices

Tambi√©n podemos definir una [**matriz a partir de un vector num√©rico**]{.hl-yellow}, reorganizando los valores en forma de matriz (sabiendo que los elementos se van [**colocando por columnas**]{.hl-purple}).

```{r}
z <- matrix(1:9, ncol = 3) 
z
```

. . .

Incluso podemos [**definir una matriz de valores constantes**]{.hl-yellow}, por ejemplo de ceros (para luego rellenar)

```{r}
matrix(0, nrow = 2, ncol = 3)
```


---

## Operaciones con matrices

Con las matrices sucede como con los vectores: cuando aplicamos una [**operaci√≥n aritm√©tica lo hacemos elemento a elemento**]{.hl-yellow}

```{r}
z/5
```

. . .

Para realizar [**operaciones en un sentido matricial**]{.hl-yellow} deberemos a√±adir `%%`, por ejemplo, para multiplicar matrices ser√° `%*%`


```{r}
z * t(z)
z %*% t(z)
```


---

## Operaciones con matrices

Tambi√©n podemos [**realizar operaciones por columnas/filas**]{.hl-yellow} sin recurrir a bucles con la funci√≥n `apply()`, y le indicaremos como **argumentos**

-   la matriz
-   el sentido de la operaci√≥n (`MARGIN = 1` por filas, `MARGIN = 2` por columnas)
-   la funci√≥n a aplicar
- argumentos extra que necesite la funci√≥n

. . .

Por ejemplo, para aplicar una media a cada variable, ser√° `mean` aplicada con `MARGIN = 2` (misma funci√≥n para cada columna)

```{r}
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")
```



---

## üíª Tu turno (matrices) {#tu-turno-2-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para definir una matriz `x` de unos, de 3 filas y 7 columnas.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Ejercicio 2**]{.hl-yellow}

üìù A la matriz anterior, suma un 1 a cada n√∫mero de la matriz y divide el resultado entre 5. Tras ello calcula su transpuesta

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù ¬øPor qu√© el c√≥digo inferior nos devuelve dicho mensaje de aviso?

```{r}
#| warning: TRUE
matrix(1:15, nrow = 4)
```



### [**Ejercicio 4**]{.hl-yellow}

üìù Define la matriz `x <- matrix(1:12, nrow = 4)`. Tras ello obt√©n los datos del primer individuo, los datos de la tercera variable, y el elemento `(4, 1)`.

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # primera fila
x[, 3] # tercera columna
x[4, 1] # elemento (4, 1)
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Define una matriz de 2 variables y 3 individuos tal que cada variable capture la estatura y la edad 3 personas, de manera que la edad de la segunda persona sea desconocida (ausente). Tras ello calcula la media de cada variable (¬°nos debe de volver un n√∫mero!)

```{r}
#| code-fold: true
#| eval: false
datos <- cbind("edad" = c(20, NA, 25), "estatura" = c(160, 165, 170))
apply(datos, MARGIN = 2, FUN = "mean", na.rm = TRUE) # media por columnas

```

### [**Ejercicio 6**]{.hl-yellow}

üìù ¬øPor qu√© devuelve error el c√≥digo inferior? ¬øQu√© est√° mal?

```{r}
#| error: true
matriz <- cbind("edad" = c(15, 20, 25), "nombres" = c("javi", "sandra", "carlos"))
matriz
matriz + 1
```



:::

---

## Segundo intento: data.frame

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte (f√≠jate en el c√≥digo inferior: las edades y los `TRUE/FALSE` los ha convertido a texto)

```{r}
#| code-line-numbers: "4-5"
edades <- c(14, 24, NA)
soltero <- c(TRUE, NA, FALSE)
nombres <- c("javi", "laura", "luc√≠a")
matriz <- cbind(edades, soltero, nombres)
matriz
```

. . .

De hecho al no ser n√∫meros ya no podemos realizar operaciones aritm√©ticas

```{r}
#| error: true
matriz + 1
```

---

## Segundo intento: data.frame

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos en `R` lo que se conoce como [**data.frame**]{.hl-yellow}: concatenaci√≥n de variables de igual longitud pero que pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
tabla <- data.frame(edades, soltero, nombres)
class(tabla)
tabla
```

---

## Segundo intento: data.frame

Dado que un `data.frame` es ya un intento de ¬´base de datos¬ª las variables no son meros vectores matem√°ticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple} que describan su significado

```{r}
library(lubridate)
tabla <-
  data.frame("edad" = edades, "estado" = soltero, "nombre" = nombres,
             "f_nacimiento" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
tabla
```

---

## Segundo intento: data.frame

[**¬°TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} (estrictamente no podemos hablar de base de datos pero de momento como lo si fuesen). Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

![](img/view_tabla.jpg)

---

## Acceso a variables

Si queremos acceder a sus elementos, al ser de nuevo **datos tabulados**, podemos acceder como en las matrices ([**no recomendable**]{.hl-red}): de nuevo [**tenemos dos √≠ndices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera caracter√≠stica de la segunda persona
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
Pero tambi√©n tiene las ventajas de una [**¬´base¬ª de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} ([**lo recomendable**]{.hl-green} ya que las variables pueden cambiar de posici√≥n y ahora s√≠ tienen un significado), poniendo el nombre de la tabla seguido del s√≠mbolo `$` (con el **tabulador**, nos aparecer√° un men√∫ de columnas a elegir)
:::
:::

---

## Funciones de consulta

-   `names()`: nos muestra los nombres de las variables

```{r}
names(tabla)
```

. . .

-   `dim()`: nos muestra las dimensiones (tambi√©n `nrow()` y `ncol()`)

```{r}
dim(tabla)
```

. . .

-   Podemos acceder a las variables por su nombre

```{r}
tabla[c(1, 3), "nombre"]
tabla$nombre[c(1, 3)]
```

---

## A√±adir variable

Si tenemos uno ya creado y queremos [**a√±adir una columna**]{.hl-yellow} es tan simple como usar la funci√≥n `data.frame()` que ya hemos visto para concatenar la columna. Vamos a√±adir por ejemplo una nueva variable, el n√∫mero de hermanos de cada individuo.

```{r}
# A√±adimos una nueva columna con n¬∫ de hermanos/as
hermanos <- c(0, 2, 3)
tabla <- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

---

## Intento final: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}. La principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```

. . .


En adelante usaremos el formato `tibble` ([**data.frame mejorado**]{.hl-yellow}) del paquete `{tibble}`

```{r}
library(tibble)
datos_tb <- 
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
class(datos_tb)
datos_tb
```

---

## Intento final: tibble

```{r}
datos_tb <-
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
datos_tb
```

Las tablas en formato `tibble` nos permitir√° una [**gesti√≥n m√°s √°gil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

-   [**Metainformaci√≥n**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya autom√°ticamente el n√∫mero de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

---

## Intento final: tibble

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
datos_tb$invent
```

. . .

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de p√°ginas web y documentos sencillos
:::


---


## Recapitulando

-   Cada [**celda puede ser de un tipo diverso**]{.hl-yellow}: n√∫meros, texto, fechas, valores l√≥gicos, etc

. . .

-   Un [**vector es una concatenaci√≥n de celdas**]{.hl-yellow} (las futuras columnas de nuestras tablas) --> En `R` por defecto las operaciones se hacen [**elemento a elemento**]{.hl-yellow}

. . .

-   Una [**matriz**]{.hl-yellow} nos permite concatenar [**variables del MISMO tipo y MISMA longitud**]{.hl-yellow} --> datos tabulados

. . .

-   Un [**data.frame**]{.hl-yellow} nos permite concatenar [**variables de DISTINTO tipo y MISMA longitud**]{.hl-yellow} --> usaremos [**tibble**]{.hl-yellow} como una opci√≥n mejorada de base de datos

---

## üíª Tu turno (tb/df) {#tu-turno-2-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Carga del paquete `{datasets}` el conjunto de datos `airquality` (variables de la calidad del aire de Nueva York desde mayo hasta septiembre de 1973). ¬øEs el conjunto de datos airquality de tipo tibble? En caso negativo, convi√©rtelo a tibble (busca en la documentaci√≥n del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Una vez convertido a `tibble` obt√©n el nombre de las variables y las dimensiones del conjunto de datos. ¬øCu√°ntas variables hay? ¬øCu√°ntos d√≠as se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```


### [**Ejercicio 3**]{.hl-yellow}

üìù Filtra solo los datos de la quinta observaci√≥n

```{r}
#| code-fold: true
#| eval: false
airquality_tb[5, ]
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para filtrar solo los datos del mes de agosto. ¬øC√≥mo indicarle que queremos solo las filas que cumplan una condici√≥n concreta? (pista: en realidad todo son vectores "formateados")

```{r}
#| eval: false
airquality_tb[Month == 8, ]
```

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, ]
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Selecciona aquellos datos que no sean ni de julio ni de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month != 7 & airquality_tb$Month != 8, ]

# otra forma
airquality_tb[!(airquality_tb$Month %in% c(7, 8)), ]
```

### [**Ejercicio 6**]{.hl-yellow}

üìù Modifica el siguiente c√≥digo para quedarte solo con las variable de ozono y temperatura (sin importar qu√© posici√≥n ocupen)

```{r}
#| eval: false
airquality_tb[, 3]
```

### [**Ejercicio 7**]{.hl-yellow}

üìù Selecciona los datos de temperatura y viento de agosto. 

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, c("Temp", "Wind")]
```

### [**Ejercicio 8**]{.hl-yellow}

üìù Traduce a castellano el nombre de las variables.


```{r}
#| code-fold: true
#| eval: false
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```

:::




---

## üê£ Caso pr√°ctico I: tibble {#caso-practico-2-1}

Del paquete `{Biostatistics}` usaremos el conjunto de datos `pinniped`, que guarda los **datos de peso de cuerpo y cerebro** (desagregado por sexo y mono/poligamia) de 33 especies de mam√≠feros marinos.


```{r}
Biostatistics::pinniped
```


Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/matrices-tibble-isciii)

---

## üê£ Caso pr√°ctico II: Taylor Swift {#caso-practico-2-2}

Del paquete `{taylor}` vamos a usar el conjunto de datos `taylor_album_songs` para poner en pr√°ctico lo aprendido sobre bases de datos y manejo de variables. Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/matrices-tibble-isciii)


```{r}
library(taylor)
taylor_album_songs
```



# Clase 3: [if-elses, bucles y Quarto]{.flow} {#clase-3}

[**Estructuras condicionales, bucles y Quarto**]{style="color:#444442;"}

* [üíª Ejercicios resueltos: estructuras condicionales](#tu-turno-3-1) 
* [üíª Ejercicios resueltos: bucles](#tu-turno-3-2) 
* [üê£ Workbook/caso pr√°ctico: bucles y condicionales](#caso-practico-3-1)
* [üìÜ Planificaci√≥n](#planificacion)

---

## Estructuras de control

Una [**estructura de control**]{.hl-yellow} se compone de una serie de comandos orientados a  [**decidir el camino**]{.hl-yellow} que tu c√≥digo debe recorrer

* Si se cumple la condici√≥n A, ¬øqu√© sucede?

* ¬øY si sucede B?

* ¬øC√≥mo puedo repetir una misma expresi√≥n (dependiendo de una variable)?

. . .

Si has programado antes, quiz√°s te sea familiar las conocidas como [**estructuras condicionales**]{.hl-yellow} tales como `if (blabla) {...} else {...}`  o [**bucles**]{.hl-yellow} `for/while` (a evitar siempre que podamos).

---

## Estructura If

Una de las estructuras de control m√°s famosas son las conocidas como [**estructuras condicionales**]{.hl-yellow} `if`.

> SI (IF) un conjunto de condiciones se cumple (TRUE), entonces ejecuta lo que haya dentro de las llaves

Por ejemplo, la estructura `if (x == 1) { c√≥digo A }` lo que har√° ser√° [**ejecutar el c√≥digo A entre llaves**]{.hl-yellow} pero [**SOLO SI**]{.hl-purple} la [**condici√≥n entre par√©ntesis es cierta**]{.hl-purple} (solo si `x` es 1). En cualquier otro caso, no har√° nada.

. . .

Por ejemplo, definamos un vector de edades de 8 personas

```{r}
edad <- c(14, 17, 24, 56, 31, 20, 87, 73)
edad < 18
```

---

## Estructura If


Nuestra estructura condicional har√° lo siguiente: [**si existe alg√∫n menor de edad, imprimir√°**]{.hl-yellow} por pantalla un mensaje.

```{r}
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```

---

## Estructura If

```{r}
#| eval: false
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```


En caso de que las [**condiciones no sean ciertas**]{.hl-yellow} dentro de `if()` (`FALSE`), no sucede nada


```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
}
```

**No obtenemos ning√∫n mensaje** porque la condici√≥n `all(edad >= 18)` no es `TRUE`, as√≠ que no ejecuta nada.

---

## Estructura If-else

La estructura `if (condicion) { c√≥digo A }` puede combinarse con un `else { c√≥digo B }`: cuando la [**condici√≥n no est√° verificada**]{.hl-yellow}, se [**ejecutar√° el c√≥digo alternativo B**]{.hl-yellow} dentro de `else { }`, permiti√©ndonos decidir que sucede cuando se cumple y cuando no.

. . .

Por ejemplo, `if (x == 1) { c√≥digo A } else { c√≥digo B }` ejecutar√° A si `x` es igual a 1 y B en cualquier otro caso.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else {
  
  print("Existe alguna persona menor de edad")
}
```

---

## Estructura If-else

Esta estructura `if - else` puede ser [**anidada**]{.hl-yellow}: imagina que queremos ejecutar un c√≥digo si todos son menores; si no sucede, pero todos son mayores de 16, hacer otra cosa; en cualquier otra cosa, otra acci√≥n.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else if (all(edad >= 16)) {
  
  print("Hay alg√∫n menor de edad pero todos con 16 a√±os o m√°s")
  
} else { print("Hay alguna persona con menos de 16 a√±os") }
```

::: callout-note
## Truco

Puedes **colapsar las estructuras** haciendo click en la flecha a la izquierda que aparece en tu script.

:::


---

## If-else vectorizado



Esta estructura condicional se puede [**vectorizar**]{.hl-yellow} (en una sola l√≠nea) con `if_else()` (del paquete `{dplyr}`), cuyos argumentos son

* la condici√≥n a evaluar
* lo que sucede cuando se cumple y cuando no
* un argumento opcional para cuando la condici√≥n a evaluar es `NA`

Vamos a etiquetar sin son mayores/menores y un "desconocido" cuando no conocemos

```{r}
library(dplyr)
edad <- c(NA, edad)
if_else(edad >= 18, "mayor", "menor", missing = "desconocido")
```

En `R` base existe `ifelse()`: no deja especificar que hacer con los ausentes pero permite especificar distintos tipos de datos en `TRUE` y en `FALSE`.

---

## üíª Tu turno {#tu-turno-3-1}


[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù ¬øCu√°l es la salida del siguiente c√≥digo?

```{r}
#| eval: false
if_else(sqrt(9) < 2, sqrt(9), 0)
```

```{r}
#| eval: false
#| code-fold: true

La salida es 0 ya que sqrt(9) es igual 3, y dado que no es menor que 2, devuelve el segundo argumento que es 0
```

### [**Ejercicio 2**]{.hl-yellow}

üìù ¬øCu√°l es la salida del siguiente c√≥digo?

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true

La salida es el vector c(0, NA, NA, 1) ya que sqrt(1) s√≠ es menor que 2, sqrt(9) no lo es, y tanto en el caso de sqrt(NA) (ra√≠z de ausente) como sqrt(-1) (devuelve NaN, not a number), su ra√≠z cuadrada no puede verificarse si es menor que 2 o no, as√≠ que la salida es NA.
```


### [**Ejercicio 3**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para que, cuando no se pueda verificar si la ra√≠z cuadrada de un n√∫mero es menor que 2, devuelva -1

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1, missing = -1)
```


### [**Ejercicio 4**]{.hl-yellow}

üìù ¬øCu√°l es son los valores de `x` e `y` del c√≥digo inferior para `z <- 1`, `z <- -1` y `z <- -5`?

```{r}
#| eval: false
z <- -1
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
En primero caso x = 1 e y = -1. En el segundo caso x = 1 e y = 1. En el tercer caso -2.5 y 5
```

### [**Ejercicio 5**]{.hl-yellow}

üìù ¬øQu√© pasar√≠a si ejecutamos el siguiente c√≥digo? Spoiler: da error. ¬øPor qu√©? ¬øC√≥mo solucionarlo?

```{r}
#| eval: false
z <- c(-1, 1, 5)
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
Da error ya que en los `if (condici√≥n) { } else { }` "cl√°sicos" necesitamos que
la condici√≥n tenga longitud uno (un solo valor TRU/FALSE)
```

```{r}
#| eval: false
#| code-fold: true
# para arreglarlo podemos hacer un if_else vectorial
z <- c(-1, 1, -5)
library(dplyr)
x <- if_else(z > 0, z^3, if_else(abs(z) < 2, z^4, z/2))
y <- if_else(z > 0, -sqrt(z), if_else(abs(z) < 2, sqrt(-z), abs(z)))
```

### [**Ejercicio 6**]{.hl-yellow}

üìù ¬øQu√© suceder√° si ejecutamos el c√≥digo inferior?

```{r}
#| eval: false
z <- "a"
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| code-fold: true
#| eval: false

# dar√° error ya que no es un argumento num√©rico
Error in z^3 : non-numeric argument to binary operator
```


### [**Ejercicio 7**]{.hl-yellow}

üìù Del paquete `{lubridate}`, la funci√≥n `hour()` nos devuelve la hora de una fecha dada, y la funci√≥n `now()` nos devuelve fecha y hora del momento actual. Con ambas funciones haz que se imprima por pantalla (`cat()`) "buenas noches" solo a partir de las 21 horas.

```{r}
#| code-fold: true
#| eval: false

# Cargamos librer√≠a
library(lubridate)

# Fecha-hora actual
fecha_actual <- now()

# Estructura if
if (hour(fecha_actual) > 21) {
  
  cat("Buenas noches") # print/cat dos formas de imprimir por pantalla
}
```


:::

---

## Bucles

Aunque en la mayor√≠a de ocasiones se pueden reemplazar por otras estructuras m√°s eficientes y legibles, es importante conocer una de las expresiones de control m√°s famosas: los [**bucles**]{.hl-yellow}.

* `for { }`: permite [**repetir el mismo c√≥digo**]{.hl-yellow} en un [**n√∫mero prefijado y conocido**]{.hl-purple} de veces.

* `while { }`: permite [**repetir el mismo c√≥digo**]{.hl-yellow} pero en un [**n√∫mero indeterminado de veces**]{.hl-purple} (hasta que una **condici√≥n** deje de cumplirse).

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de √≥rdenes un n√∫mero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de √≠ndices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vac√≠a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los par√©ntesis indicaremos un √≠ndice y unos valores a recorrer, dentro de las llaves el c√≥digo a ejecutar en cada iteraci√≥n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()
```

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de √≥rdenes un n√∫mero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de √≠ndices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vac√≠a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los par√©ntesis indicaremos un √≠ndice y unos valores a recorrer, dentro de las llaves el c√≥digo a ejecutar en cada iteraci√≥n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  
}
```

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de √≥rdenes un n√∫mero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de √≠ndices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vac√≠a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los par√©ntesis indicaremos un √≠ndice y unos valores a recorrer, dentro de las llaves el c√≥digo a ejecutar en cada iteraci√≥n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
```

---

## Bucles for

F√≠jate que debido a que `R` funciona de manera [**vectorial por defecto**]{.hl-yellow}, el bucle es lo mismo que hacer `x + 1` directamente.

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
y

y2 <- x + 1
y2
```

---

## Bucles for

Otra opci√≥n habitual es indicar los √≠ndices de manera ¬´autom√°tica¬ª: desde el primero `1` hasta el √∫ltimo (que corresponde con la longitud de x `length(x)`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:length(x)) {
  y[i] <- x[i] + 1
}
y

```


---

## Bucles for

As√≠ la [**estructura general de un bucle for**]{.hl-yellow} ser√° siempre la siguiente

```{r}
#| eval: false
for (√≠ndice in conjunto) { 
  c√≥digo (dependiente de i)
}
```

[**SIEMPRE**]{.hl-green} sabemos cu√°ntas iteraciones tenemos (tantas como elementos haya en el conjunto a indexar)

---

## Evitando bucles


Como ya hemos aprendido con el paquete`{microbenchmark}` podemos chequear como [**los bucles suelen ser muy ineficientes**]{.hl-yellow} (de ah√≠ que debamos evitarlos en la mayor√≠a de ocasiones

```{r}
library(microbenchmark)
x <- 1:1000
microbenchmark(y <- x^2, 
               for (i in 1:100) { y[i] <- x[i]^2 },
               times = 500)
```

---
 
## Bucles for


Podemos ver otro ejemplo de bucle  [**combinando n√∫meros y textos**]{.hl-yellow}: definimos un vector de edades y de nombres, e imprimimos el nombre y edad i-√©sima.

```{r}
nombres <- c("Javi", "Sandra", "Carlos", "Marcos", "Marta")
edades <- c(33, 27, 18, 43, 29)

for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} a√±os")) 
  
}
```


---

## Bucles for

Aunque normalmente se suelen indexar con vectors num√©ricos, los bucles pueden ser [**indexados sobre cualquier estructura vectorial**]{.hl-yellow}, da igual de que tipo sea el conjunto

```{r}
library(stringr)
week_days <- c("monday", "tuesday", "wednesday", "thursday",
               "friday", "saturday", "sunday")

for (days in week_days) {
  
  print(str_to_upper(days))
}
```

---

## Bucles y condicionales

Vamos a **combinar las estructuras condicionales y los bucles**: usando el conjunto `swiss` del paquete `{datasets}`, vamos a asignar `NA`  si los valores de fertilidad son mayores de 80.

```{r}
for (i in 1:nrow(swiss)) {
  
  if (swiss$Fertility[i] > 80) { 
    
    swiss$Fertility[i] <- NA
    
  }
}
```

. . .

Esto es exactamente igual a un `if_else()` vectorizado

```{r}
data("swiss")
swiss$Fertility <- if_else(swiss$Fertility > 80, NA, swiss$Fertility)
```


---

## Bucles while

Otra forma de crear un bucle es con la estructura `while { }`, que nos ejecutar√° un bucle [**un n√∫mero desconocido de veces**]{.hl-yellow}, hasta que una condici√≥n [**deje de cumplirse**]{.hl-yellow} (de hecho puede que nunca termine). Por ejemplo, vamos a inializar una variable `ciclos <- 1`, que incrementaremos en cada paso, y no saldremos del bucle hasta que `ciclos > 4`.

```{r}
ciclos <- 1
while(ciclos <= 4) {
  
  print(glue("No todav√≠a, vamos por el ciclo {ciclos}")) 
  ciclos <- ciclos + 1
  
}
```

---

## Bucles while

Un bucle `while` ser√° siempre como sigue

```{r}
#| eval: false
while(condici√≥n) {
  
  c√≥digo a hacer mientras la condici√≥n sea TRUE
  # normalmente aqu√≠ se actualiza alguna variable
  
}
```

---
  
## Bucles while

¬øQu√© sucede cuando la [**condici√≥n nunca es FALSE**]{.hl-yellow}? Pru√©balo tu mismo

```{r}
#| eval: false
while (1 > 0) {
  
  print("Presiona ESC para salir del bucle")
  
}
```

&nbsp;

::: callout-warning
## Cuidado

Un bucle `while { }` puede ser bastante ¬´peligroso¬ª sino controlamos bien c√≥mo pararlo.

:::

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `break`: permite [**abortar un bucle**]{.hl-yellow} incluso si no se ha llegado a su final

```{r}
for(i in 1:10) {
  if (i == 3) {
    
    break # si i = 3, abortamos bucle
    
  }
  print(i)
}
```

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `next`: [**fuerza un bucle a avanzar a la siguiente iteraci√≥n**]{.hl-yellow} 

```{r}
for(i in 1:5) {
  if (i == 3) {
    
    next # si i = 3, la obvia y continua al siguiente
    
  }
  print(i)
}
```

---

## Bucles repeat

Aunque no es tan usado como las opciones anteriores, tambi√©n contamos con `repeat { }` que ejecuta un [**bucle de manera infinita hasta que se indique abortar**]{.hl-yellow} con un break

```{r}
count <- 0
repeat { 
  
  count <- count + 1
  if (count >= 100) { break }
  
}
count
```


---

## Replicate

Aunque no es formalmente un bucle, otra forma de [**repetir c√≥digo un n√∫mero de veces**]{.hl-yellow} es hacer uso de `replicate()`: simplemente permite repetir lo mismo [**n veces**]{.hl-yellow}

```{r}
x <- 1:3
replicate(n = 3, x^2)
```

---

## Replicate

La funci√≥n `replicate()` se suele usar para [**generar distintas repeticiones de elementos aleatorios**]{.hl-yellow}. Por ejemplo, imaginemos que queremos generar 3 muestras de distribuciones normales, en la que cada muestra tendr√° 7 elementos. Para generar una se usa `rnorm(n = 7)` (r de resample, norm de normal, y si no se dice nada es media 0 y desv 1).

```{r}
replicate(n = 3, rnorm(n = 7))
```

---


## üíª Tu turno {#tu-turno-3-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para que se imprima un mensaje por pantalla si y solo si todos los datos de `airquality` son con mes distinto a enero

```{r}
#| eval: false
library(datasets)
months <- airquality$Month

if (months == 2) {
  print("No hay datos de enero")
}
```

```{r}
#| code-fold: true
#| eval: false
library(datasets)
months <- airquality$Month

if (all(months != 1)) {
  print("No hay datos de enero")
}
```


### [**Ejercicio 2**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para guardar en una variable llamada `temp_alta` un `TRUE` si alguno de los registros tiene una temperatura superior a 90 grados Farenheit y `FALSE` en cualquier otro caso
 
```{r}
#| eval: false
temp <- airquality$Temp

if (temp == 100) {
  print("Algunos de los registros tienen temperaturas superiores a 90 grados Farenheit")
}
```

 
```{r}
#| eval: false
#| code-fold: true
# Option 1
temp <- airquality$Temp
temp_alta <- FALSE
if (any(temp > 90)) {
   temp_alta <- TRUE
}

# Option 2
temp_alta <- any(airquality$Temp > 90)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para dise√±ar un bucle `for` de 5 iteraciones que solo recorra los primeros 5 impares (y en cada paso del bucle los imprima)

```{r}
#| eval: false
for (i in 1:5) {
  
  print(i)
}
```

```{r}
#| eval: false
#| code-fold: true
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i)
}
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para dise√±ar un bucle `while` que empiece con un contador `count <- 1` y pare cuando llegue a 6

```{r}
#| eval: false
count <- 1
while (count == 2) {
  
  print(count)
}
```

```{r}
#| eval: false
#| code-fold: true
count <- 1
while (count < 6) {
  
  print(count)
  count <- count + 1
  
}
```


:::

---

## üê£ Caso pr√°ctico I {#caso-practico-3-1}


Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/if-else-bucles-funciones-isciii/) donde tendr√°s que dise√±ar algunos estudios de simulaci√≥n haciendo uso de **bucles y estructuras condicionales**


# Clase 4: [funciones y ggplot]{.flow} {#clase-4}

[**Funciones y ggplot**]{style="color:#444442;"}

* [üíª Ejercicios resueltos: funciones](#tu-turno-4-1) 
* [üíª Ejercicios resueltos: ggplot](#tu-turno-4-2) 
* [üê£ Workbook/caso pr√°ctico: funciones](#caso-practico-4-1)
* [üê£ Workbook/caso pr√°ctico: ggplot](#caso-practico-4-2)
* [üìÜ Planificaci√≥n](#planificacion)

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, adem√°s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¬øC√≥mo [**crear nuestra propia funci√≥n**]{.hl-purple}? Veamos su **esquema b√°sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extra√±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funci√≥n dentro de `{ }`.

* Finalizamos la funci√≥n con los [**argumentos de salida**]{.hl-yellow} con `return()`.



```{r}
#| eval: false
name_fun <- function() {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, adem√°s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¬øC√≥mo [**crear nuestra propia funci√≥n**]{.hl-purple}? Veamos su **esquema b√°sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extra√±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funci√≥n dentro de `{ }`.

* Finalizamos la funci√≥n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, adem√°s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¬øC√≥mo [**crear nuestra propia funci√≥n**]{.hl-purple}? Veamos su **esquema b√°sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extra√±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funci√≥n dentro de `{ }`.

* Finalizamos la funci√≥n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  c√≥digo a ejecutar
  
}
```

---


## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, adem√°s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¬øC√≥mo [**crear nuestra propia funci√≥n**]{.hl-purple}? Veamos su **esquema b√°sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extra√±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funci√≥n dentro de `{ }`.

* Finalizamos la funci√≥n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  c√≥digo a ejecutar
  
  return(var_salida)
  
}
```


---

## Creando funciones

* `arg1, arg2, ...`: ser√°n los [**argumentos de entrada**]{.hl-yellow}, los argumentos que toma la funci√≥n para ejecutar el c√≥digo que tiene dentro

* `c√≥digo`: l√≠neas de c√≥digo que queramos que [**ejecute la funci√≥n**]{.hl-yellow}. 

* `return(var_salida)`: se introducir√°n los [**argumentos de salida**]{.hl-yellow}.


```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # C√≥digo que queramos ejecutar
  c√≥digo
  
  # Salida
  return(var_salida)
  
}
```

::: callout-important
## Importante

Todas las variables que definamos dentro de la funci√≥n son [**variables LOCALES: solo existir√°n dentro de la funci√≥n**]{.hl-yellow} salvo que especifiquemos lo contrario.

:::

---

## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funci√≥n para [**calcular el √°rea de un rect√°ngulo**]{.hl-yellow}.

Dado que el √°rea de un rect√°ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos ser√°n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} ser√° justo su **√°rea** ($lado_1 * lado_2$).

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
}
```

---


## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funci√≥n para [**calcular el √°rea de un rect√°ngulo**]{.hl-yellow}.

Dado que el √°rea de un rect√°ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos ser√°n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} ser√° justo su **√°rea** ($lado_1 * lado_2$).

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  
}
```

---


## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funci√≥n para [**calcular el √°rea de un rect√°ngulo**]{.hl-yellow}.

Dado que el √°rea de un rect√°ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos ser√°n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} ser√° justo su **√°rea** ($lado_1 * lado_2$).

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  return(area)
  
}
```

---

## Uso de funciones

Tambi√©n podemos hacer una definici√≥n directa de las variables **sin almacenar por el camino**.

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  return(lado_1 * lado_2)
  
}
```

. . .

[**¬øC√≥mo aplicar la funci√≥n?**]{.hl-yellow}

```{r}
calcular_area(5, 3) # √°rea de un rect√°ngulo 5 x 3 
calcular_area(1, 5) # √°rea de un rect√°ngulo 1 x 5
```

---

## Uso de funciones

::: callout-tip

Aunque no sea necesario, es [**recomendable hacer expl√≠cita la llamada de los argumentos**]{.hl-green}, especificando en el c√≥digo qu√© valor es para cada argumento para que no dependa de su orden, haciendo el c√≥digo m√°s legible
:::


```{r}
calcular_area(lado_1 = 5, lado_2 = 3) # √°rea de un rect√°ngulo 5 x 3 
calcular_area(lado_2 = 3, lado_1 = 5) # √°rea de un rect√°ngulo 5 x 3 
```

---

## Argumentos por defecto

Imagina ahora que nos damos cuenta que el 90% de las veces usamos dicha funci√≥n para [**calcular por defecto el √°rea de un cuadrado**]{.hl-yellow} (es decir, solo necesitamos un lado). Para ello, podemos definir [**argumentos por defecto**]{.hl-yellow} en la funci√≥n: tomar√°n dicho valor salvo que le asignemos otro.

¬øPor qu√© no asignar `lado_2 = lado_1` **por defecto**, para ahorrar l√≠neas de c√≥digo y tiempo?

. . .

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

---

## Argumentos por defecto


```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```


Ahora [**por defecto**]{.hl-yellow} el segundo lado ser√° igual al primero (si se lo a√±adimos usar√° ambos).


```{r}
calcular_area(lado_1 = 5) # cuadrado
calcular_area(lado_1 = 5, lado_2 = 7) # rect√°ngulo
```

---
 

## Salida m√∫ltiple

Compliquemos un poco la funci√≥n y a√±adamos en la salida los valores de cada lado, etiquetados como `lado_1` y `lado_2`, [**empaquetando la salida en una vector**]{.hl-yellow}.

```{r}
#| code-line-numbers: "7-8"
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

---

## Salida m√∫ltiple

Podemos complicar un poco m√°s la salida a√±adiendo una cuarta variable que nos diga, en funci√≥n de los argumentos, [**si rect√°ngulo o cuadrado**]{.hl-yellow}, teniendo que a√±adir en la salida una variable que de tipo caracter (o l√≥gica).

```{r}
#| code-line-numbers: "7-9"
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rect√°ngulo")))
  
}
calcular_area(5, 3)
```

. . .

[**Problema**]{.hl-red}: al intentar juntar n√∫meros y texto, lo convierte todo a n√∫meros. Podr√≠amos guardarlo todo en un `tibble()` como hemos aprendido o en un objeto conocido en `R` como [**listas**]{.hl-yellow}

---

## Introducci√≥n a listas

Veamos un peque√±o resumen de los datos que ya conocemos:

* [**vectores**]{.hl-yellow}: colecci√≥n de elementos de igual tipo. Pueden ser n√∫meros, caracteres o valores l√≥gicos, entre otros.

* [**matrices**]{.hl-yellow}: colecci√≥n BIDIMENSIONAL de elementos de igual tipo e igual longitud.

* [**data.frame / tibble**]{.hl-yellow}: colecci√≥n BIDIMENSIONAL de elementos de igual longitud pero de cualquier tipo.

. . .

Las [**listas**]{.hl-yellow} ser√°n [**colecciones de variables de diferente tipo y diferente longitud**]{.hl-purple}, con estructuras totalmente heter√≥geneas (incluso una lista puede tener dentro a su vez otra lista).

---

## Introducci√≥n a listas


Vamos a crear [**nuestra primera lista**]{.hl-yellow} con `list()` con tres elementos: el nombre de nuestros padres/madres, nuestro lugar de nacimiento y edades de nuestros hermanos.

```{r}
var_1 <- c("Paloma", "Gregorio")
var_2 <- "Madrid"
var_3 <- c(25, 30, 26)

lista <- list("progenitores" = var_1, "lugar_nac" = var_2, "edad_hermanos" = var_3)
lista
```



---

## Introducci√≥n a listas

```{r}
length(lista)
```

Si observas el objeto que hemos definido como lista, su [**longitud**]{.hl-yellow} del es de 3 ya que tenemos **guardados tres elementos**: un vector de caracteres (de longitud 2), un caracter (vector de longitud 1), y un vector de n√∫meros (de longitud 3)

. . .

Tenemos guardados elementos de [**distinto tipo**]{.hl-yellow} (algo que ya pod√≠amos hacer) pero, adem√°s, de **longitudes dispares**.

```{r}
dim(lista) # devolver√° NULL al no tener dos dimensiones
class(lista) # de tipo lista
```

---

## Introducci√≥n a listas

Si los junt√°semos con un `tibble()`, al tener distinta longitud, obtendr√≠amos un [**error**]{.hl-red}.

```{r}
#| error: true
library(tibble)
tibble("progenitores" = var_1, "lugar_nac" = va_2, "edad_hermanos" = var_3)
```

---


## Introducci√≥n a listas

* [**Acceder por √≠ndice**]{.hl-yellow}: con el operador `[[i]]` accedemos al **elemento i-√©simo** de la lista.

```{r}
lista[[1]]
```

. . .

* [**Acceder por nombre**]{.hl-yellow}: con `$nombre_elemento` accedemos por su nombre.

```{r}
lista$progenitores
```

. . .

En contraposici√≥n, el [**corchete simple**]{.hl-yellow} nos permite acceder a [**varios elementos**]{.hl-yellow} a la vez

```{r}
# Varios elementos
lista[1:2]
```

---

## Salida m√∫ltiple: listas

```{r}
#| code-line-numbers: "7-9"
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rect√°ngulo")))
  
}
calcular_area(5, 3)
```

---

## Orden de los argumentos

Antes nos daba igual el orden de los argumentos pero ahora el [**orden de los argumentos de entrada importa**]{.hl-yellow}, ya que en la salida incluimos `lado_1` y `lado_2`. 

. . .

::: callout-note
## Recomendaci√≥n

Como se comentaba, altamente recomendable hacer la llamada a la funci√≥n [**indicando expl√≠citamente los argumentos**]{.hl-yellow} para mejorar **legibilidad e interpretabilidad**.

```{r}
# Equivalente a calcular_area(5, 3)
calcular_area(lado_1 = 5, lado_2 = 3)
```

:::

---

## Funciones: generando conocimiento

Parece una tonter√≠a lo que hemos hecho pero hemos cruzado una frontera importante: hemos pasado de [**consumir conocimiento**]{.hl-yellow} (c√≥digo de otros paquetes, elaborado por otros/as), a [**generar conocimiento**]{.hl-purple}, creando nuestras propias funciones.

. . .

Las funciones van a ser claves en tu d√≠a a d√≠a ya que te permitir√° automatizar c√≥digo que vas a repetir una y otra vez: empaquetando ese c√≥digo bajo un alias (nombre de la funci√≥n) vas a [**poder usarlo una y otra vez sin necesidad de programarlo (por lo que hacer el doble de trabajo no implicar√° trabajar el doble)**]{.hl-yellow}

---

## Variables locales vs globales

Un aspecto importante sobre el que reflexionar con las funciones: ¬øqu√© sucede si [**nombramos a una variable dentro**]{.hl-yellow} de una funci√≥n a la que se nos ha **olvidado asignar** un valor dentro de la misma?

. . .

Debemos ser cautos al usar funciones en `R`, ya que debido a la [**¬´regla lexicogr√°fica¬ª**]{.hl-yellow}, si una variable no se define dentro de la funci√≥n, `R` [**buscar√° dicha variable en el entorno**]{.hl-purple} de variables.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  print(x) # No devuelve nada, solo realiza la acci√≥n 
}
funcion_ejemplo()
```

---

## Variables locales vs globales

Si una variable  [**ya est√° definida fuera de la funci√≥n (entorno global)**]{.hl-yellow}, y adem√°s es usada dentro de cambiando su valor, el valor [**solo cambia dentro**]{.hl-yellow} pero [**no en el entorno global**]{.hl-red}.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  x <- 2
  print(x) # lo que vale dentro
}
```

```{r}
# lo que vale dentro
funcion_ejemplo() #<<
# lo que vale fuera
print(x) #<<
```

---

## Variables locales vs globales


Si queremos que adem√°s de cambiar localmente lo haga [**globalmente**]{.hl-yellow} deberemos usar la [**doble asignaci√≥n**]{.hl-yellow} (`<<-`).

```{r}
x <- 1
y <- 2
funcion_ejemplo <- function() {
  
  # no cambia globalmente, solo localmente
  x <- 3 
  # cambia globalmente
  y <<- 0 #<<
  
  print(x)
  print(y)
}

funcion_ejemplo() # lo que vale dentro
x # lo que vale fuera
y # lo que vale fuera
```

---


## üíª Tu turno {#tu-turno-3-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ej 1**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para definir una funci√≥n llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.

```{r}
#| eval: false
nombre <- function(x, y) {
  suma <- # c√≥digo a ejecutar
  return()
}
# Aplicamos la funci√≥n
suma(3, 7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_suma <- function(x, y) {
  suma <- x + y
  return(suma)
}
funcion_suma(3, 7)
```

### [**Ej 2**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para definir una funci√≥n llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado

```{r}
#| eval: false
nombre <- function(x, y) {
  producto <- # c√≥digo de la multiplicaci√≥n
  return()
}
producto(3)
producto(3, -7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_producto <- function(x, y = x) {
  producto <- x * y
  return(producto)
}
funcion_producto(3)
funcion_producto(3, -7)
```

### [**Ej 3**]{.hl-yellow}

üìù Define una funci√≥n llamada `igualdad_nombres` que, dados dos nombres, nos diga si son iguales o no. Hazlo considerando importantes las may√∫sculas, y sin que importen las may√∫sculas. Usa el paquete `{stringr}`.

```{r}
#| code-fold: true
#| eval: false
# Distinguiendo may√∫sculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Luc√≠a")

# Sin importar may√∫sculas (ver tambi√©n str_equal)
igualdad_nombres <- function(persona_1, persona_2) {
  return(str_to_upper(persona_1) == str_to_upper(persona_2))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Luc√≠a")
```

### [**Ej 4**]{.hl-yellow}

üìù Crea una funci√≥n llamada `calculo_IMC` que, dados dos argumentos (peso y estatura en metros) y un nombre, devuelva una lista con el IMC ($peso/(estatura_m^2)$) y el nombre.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura) {
  
  return(list("nombre" = nombre, "IMC" = peso/(estatura^2)))
}
```

### [**Ej 5**]{.hl-yellow}

üìù Repite el ejercicio anterior pero con otro argumento opcional que se llame unidades (por defecto, `unidades = "metros"`). Desarrolla la funci√≥n de forma que haga lo correcto si `unidades = "metros"` y si `unidades = "cent√≠metros"`.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  
  return(list("nombre" = nombre,
              "IMC" = peso/(if_else(unidades == "metros", estatura, estatura/100)^2)))
}
```

 
### [**Ej 6**]{.hl-yellow}

üìù Crea un tibble ficticio de 7 personas, con tres variables (inventa nombre, y simula peso, estatura en cent√≠metros), y adapta la funci√≥n `calculo_IMC()` de forma que obtengamos una cuarta columna con su IMC.

```{r}
#| code-fold: true
#| eval: false
datos <- tibble("nombres" = c("javi", "sandra", "eva", "ana", "carlos", "leo", NA),
                "peso" = rnorm(n = 7, mean = 70, sd = 1),
                "estatura" = rnorm(n = 7, mean = 168, sd = 5))

# IMPORTANTE. if_else trabaja de manera vectorial, elemento a elemento: la longitud de la
# condici√≥n (unidades == "metros" es un vector l√≥gico de longitud uno) debe ser igual que
# lo que le decimos que haga cuando es TRUE y FALSE (en este caso, condicion tiene longitud 1
# pero al aplicarla lo que devuelve es vector de tama√±o 7, por eso hay que usar ifelse (sin _))
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  return(list("nombre" = nombre,
              "IMC" = peso/(ifelse(unidades == "metros", estatura, estatura/100)^2)))
}
datos |> mutate(IMC = calculo_IMC(nombres, peso, estatura, unidades = "cent√≠metros")$IMC)
```


### [**Ej 7**]{.hl-yellow}

üìù Crea una funci√≥n llamada `atajo` que tenga dos argumentos num√©ricos `x` e `y`. Si ambos son iguales, debes devolver `"iguales"` y hacer que la funci√≥n acaba autom√°ticamente (piensa cu√°ndo una funci√≥n sale). OJO: `x` e `y` podr√≠an ser vectores. Si son distintos (de igual de longitud) calcula la proporci√≥n de elementos  diferentes. Si son distintos (por ser distinta longitud), devuelve los elementos que no sean comunes.

```{r}
#| code-fold: true
#| eval: false
atajo <- function(x, y) {
  
  if (all(x == y) & length(x) == length(y)) { return("iguales") }
  else {
   
    if (length(x) == length(y)) {
      
      n_diff <- sum(x != y) / length(x)
      return(n_diff)
      
    } else {
      
      diff_elem <- unique(c(setdiff(x, y), setdiff(y, x)))
      return(diff_elem)
    }
    
  }
}
```


:::


---

## üê£ Caso pr√°ctico I: conversor {#caso-practico-4-1}

Para practicar con funciones vamos a crear un completo **conversor de temperaturas** que, dada una temperatura en Fahrenheit, Celsius o Kelvin, la convierta a cualquiera de las otras

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/if-else-bucles-funciones-isciii/) hasta construirlo.


---

## Dataviz: historia


La aparici√≥n de gr√°ficos estad√≠sticos es [**relativamente reciente en la ciencia**]{.hl-yellow} ya que hasta la Edad Media la √∫nica visualizaci√≥n estaba en los [**mapas**]{.hl-yellow}. [^1] Las propias palabras _chart_ y _cartography_ derivan del mismo origen latino, _charta_, aunque el primer uso de coordenadas viene de los egipcios. [^2] [^3]

. . .

:::: columns
::: {.column width="55%"}

No es hasta la Edad Media, cuando la [**navegaci√≥n y la astronom√≠a**]{.hl-yellow} empezaban a tomar relevancia, cuando aparece la primera gr√°fica (no propiamente estad√≠stica), del **movimiento c√≠clico de los planetas** (siglos X y XI)

:::

::: {.column width="45%"}
![](img/dataviz_historico_1.png){width="370"}
:::
::::
 

[^1]: [¬´Gram√°tica de las gr√°ficas: pistas para mejorar las representaciones de datos¬ª de Joaqu√≠n Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)

[^2]: [¬´Presentation Graphics¬ª de Leland Wilkinson. International Encyclopedia of the Social & Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

[^3]: [¬´Quantitative Graphics in Statistics: A Brief History¬ª de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)]


---

## Navegaci√≥n y astronom√≠a


Con una motivaci√≥n similar, en torno a 1360 el matem√°tico **Nicole Oresme** dise√±√≥ el [**primer gr√°fico de barras**]{.hl-yellow} (pero no estad√≠stico), con la idea de visualizar a la vez dos **magnitudes f√≠sicas te√≥ricas**. [^4]


![](img/dataviz_historico_2.jpeg){width="300"}


[^4]: [¬´The First (Known) Statistical Graph: Michael Florent van Langren and the 'Secret' of Longitude¬ª de M. Friendly y P. M. Valero-Mora. The American Statistician (2010)](https://www.researchgate.net/publication/227369016_The_First_Known_Statistical_Graph_Michael_Florent_van_Langren_and_the_Secret_of_Longitude)

 
---

## Primer gr√°fico estad√≠stico

La mayor√≠a de expertos, como Tufte [^5] [^6], consideran este gr√°fico casi longitudinal como la [**primera visualizaci√≥n de datos**]{.hl-yellow} de la historia, hecha por **Van Langren** en 1644, representando la [**distancia entre Toledo y Roma**]{.hl-yellow}.


```{r}
#| echo: false
knitr::include_graphics("./img/longitud_dataviz.jpg")
``` 

```{r}
#| echo: false
knitr::include_graphics("./img/dataviz_historico_3.jpeg")
``` 


[^5]: [¬´Visual explanations: images and quantities, evidence and narrative¬ª de E. Tufte](https://archive.org/details/visualexplanatio00tuft)

[^6]: [¬´PowerPoint is evil¬ª de E. Tufte](https://www.wired.com/2003/09/ppt2/)



---

## Vizfails

::: columns
::: {.column width="55%"}
![](img/persona_dataviz.jpg)
:::

::: {.column width="45%"}
* La figura elegida (persona caminando) sin relaci√≥n con lo visualizado: [**mala met√°fora**]{.hl-red}.

* Los [**sectores se√±alados sin relaci√≥n con el √≠tem**]{.hl-red} a representar, lo que dificulta su interpretaci√≥n.

* Los [**colores sin codificar**]{.hl-red}: no dan informaci√≥n de ning√∫n tipo.

* Las [**formas irregulares impiden la comparaci√≥n**]{.hl-red} de las √°reas (am√©n de que la suma total supera el 100%).

* **Sin fuente**

:::
::::


---

## Vizfails

![](img/viz_fail_covid.jpg)

---

## Vizfails

![](img/viz_fail_uk.jpg)

---

## La importancia del CONTEXTO

Una **buena idea** puede estar mal ejecutada: la forma de llevarla a cabo es importante

![](img/semaforos.jpg)

---

## Dataviz: historia

En el siglo XVII hubo un boom de la estad√≠stica al empezar a aplicarse en [**demograf√≠a**]{.hl-yellow}. Uno de los autores m√°s importantes fue [**J. Graunt**]{.hl-purple}, autor de ¬´Natural and Political Observations Made upon the Bills of Mortality¬ª (1662), estimando la poblaci√≥n de Londres con las [**primeras tablas de natalidad y mortalidad**]{.hl-yellow}.

. . .

::: columns
::: {.column width="50%"}

Son precisamente las tablas de Graunt las que us√≥ [**Christiaan Huygens**]{.hl-yellow} para generar la [**primera gr√°fica de densidad**]{.hl-yellow} de una distribuci√≥n continua (esperanza de vida vs edad).

:::

::: {.column width="50%"}

```{r echo = FALSE,  out.width = "100%", fig.align = "center", fig.cap = "Primera funci√≥n de densidad, extra√≠da de https://omeka.lehigh.edu/exhibits/show/data_visualization/vital_statistics/huygen"}
knitr::include_graphics("./img/primera_densidad.jpg")
``` 

:::
::::

---

## Gr√°ficos de Playfair

La figura que cambi√≥ el dataviz fue, sin lugar a dudas, el economista y pol√≠tico [**William Playfair (1759-1823)**]{.hl-yellow}, publicando en 1786 el **¬´Atlas pol√≠tico y comercial¬ª** [^11] [^12] con 44 gr√°ficas (43 series temporales y el diagrama de barras m√°s famoso de la historia).

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "70%", fig.align = "center", fig.cap = "Extra√≠das de Funkhouser y Walker (1935)"}
knitr::include_graphics("./img/playfair_1.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "25%", fig.align = "center", fig.cap = "Extra√≠das de Funkhouser y Walker (1935)"}
knitr::include_graphics("./img/playfair_2.jpg")
``` 

:::
::::

[^10]: [¬´Atlas pol√≠tico y comercial¬ª de William Playfair (1786)](https://www.amazon.es/Playfairs-Commercial-Political-Statistical-Breviary/dp/0521855543)

[^11]: [¬´Playfair and his charts¬ª de H. Gray Funkhouser and  Helen M. Walker (1935)](https://www.jstor.org/stable/45366440)

---



## Gr√°ficos de Playfair

Playfair es adem√°s el autor del [**gr√°fico de barras m√°s famoso**]{.hl-yellow} (no fue el primero pero s√≠ quien lo hizo _mainstream_).

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "Gr√°ficas de Playfair de importaciones (barras grises) y exportaciones (negras) de Escocia en 1781, extra√≠das de la wikipedia."}
knitr::include_graphics("./img/playfair_5.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "Primer diagrama de barras (P. Buache y G. de L‚ÄôIsle), visualizando los niveles del Sena (1732 - 1766), extra√≠da de https://friendly.github.io/HistDataVis"}
knitr::include_graphics("./img/playfair_6.jpg")
``` 
:::
::::

---

## Gr√°ficos de Playfair


Playfair adem√°s fue el primero en [**combinar gr√°ficos en la misma visualizaci√≥n**]{.hl-yellow} [^12] [^13]

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "85%", fig.align = "center", fig.cap = "Visualiza 3 series temporales: precios (barras) del trigo, salarios (l√≠nea) y time-line con reinados, extra√≠da de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/playfair_7.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "85%", fig.align = "center", fig.cap = "Time-line hist√≥rico, extra√≠da de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/playfair_8.png")
``` 

:::
::::

[^12]: [¬´A Letter on Our Agricultural Distresses, Their Causes and Remedies¬ª de W. Playfair (1821)](http://onlinebooks.library.upenn.edu/webbin/book/lookupid?key=ha009726110)

[^13]: [¬´An Inquiry Into the Permanent Causes of the Decline and Fall of Powerful and Wealthy Nations¬ª de William Playfair (1821)](https://www.amazon.com/Permanent-Powerful-Nations-Prosperity-Prolonged/dp/140691830X)

---

## Primer scatter plot

Seg√∫n J. Sevilla, se considera al astr√≥nomo brit√°nico **John Frederick William Herschel** el autor del [**primer diagrama de dispersi√≥n o scatterplot**]{.hl-yellow} en 1833, visualizando el movimiento de la estrella doble Virginis (tiempo en el eje horizontal, posici√≥n angular en el eje vertical)


```{r echo = FALSE, out.width = "35%", fig.align = "center", fig.cap = "Extra√≠do de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/herschel.jpg")
``` 

---

## Florence Nigthingale

::: columns
::: {.column width="65%"}


* El 21 de octubre de 1854 [**Florence Nigthingale**]{.hl-yellow} fue enviada para mejorar las **condiciones sanitarias** de los soldados brit√°nicos en la guerra de Crimea. 

* A su regreso demostr√≥ que los [**soldados fallec√≠an por las condiciones sanitarias**]{.hl-yellow}. Nigthingale es la creadora del famoso [**diagrama de rosa**]{.hl-yellow}, visualizando tres variables a la vez y su estacionalidad.

* El 8 de febrero de 1955, The Times la describi√≥ como la **¬´√°ngel guardi√°n¬ª de los hospitales**, y acab√≥ siendo conocida como [**¬´The Lady with the Lamp¬ª**]{.hl-yellow} tras un poema de H. W. Longfellow (1857).

* A√±os despu√©s se convirti√≥ en la [**primera mujer en la Royal Statistical Society**]{.hl-yellow}.

:::

::: {.column width="35%"}

```{r echo = FALSE, out.width = "95%", fig.align = "center"}
knitr::include_graphics("./img/the_lady_with_the_lamp.png")
``` 

:::
::::

---

## Diagrama de rosa

Florence Nigthingale es la creadora del famoso [**diagrama de rosa**]{.hl-yellow}, permitiendo pintar [**tres variables a la vez y su estacionalidad**]{.hl-yellow}: **tiempo** (cada **gajo** es un mes), **n¬∫ de muertes** (**√°rea** del gajo) y **causa** de la muerte (**color** del gajo: azules enfermedades infecciosas, rojas por heridas, negras otras causas).


```{r echo = FALSE, out.width = "75%", fig.align = "center"}
knitr::include_graphics("./img/rosa_nightingale.jpg")
``` 

---


## Recursos de dataviz


üìö [¬´The Functional Art: an introduction to information graphics and visualization¬ª de Alberto Cairo](https://www.amazon.es/Functional-Art-Voices-That-Matter/dp/0321834739)


üìö [¬´Gram√°tica de las gr√°ficas: pistas para mejorar las representaciones de datos¬ª de Joaqu√≠n Sevilla](https://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)


üìö [¬´A Brief History of Visualization¬ª de Friendly et al. (2008)](https://www.researchgate.net/publication/226400313_A_Brief_History_of_Data_Visualization)

üìö [¬´Quantitative Graphics in Statistics: A Brief History¬ª de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)]

üìö [¬´Presentation Graphics¬ª de Leland Wilkinson. International Encyclopedia of the Social & Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

üìö [¬´The Grammar of Graphics¬ª de Leland Wilkinson](https://www.amazon.es/Grammar-Graphics-Statistics-Computing/dp/0387245448)


üìö [¬´The Minard System: The Graphical Works of Charles-Joseph Minard¬ª de Sandra Rendgen](https://www.amazon.es/gp/product/1616896337/ref=sw_img_1?smid=A1AT7YVPFBWXBL&psc=1)

üìö [¬´The Visual Display of Quantitative Information¬ª de E. W. Tufte](https://www.amazon.es/Visual-Display-Quantitative-Information/dp/0961392142)

---

## Dataviz en R: ggplot2

:::: columns
::: {.column width="50%"}

El paquete `{ggplot2}` se basa en la idea de Wilkinson en [**¬´Grammar of graphics¬ª**]{.hl-yellow}: dotar a los gr√°ficos de una gram√°tica propia. Una de las principales fortalezas de `R` es la [**visualizaci√≥n**]{.hl-yellow} con `{ggplot2}`.

```{r}
library(ggplot2)
```

La [**visualizaci√≥n de datos**]{.hl-yellow} deber√≠a ser una parte fundamental de todo an√°lisis de datos. No es solo una cuesti√≥n est√©tica.
:::

::: {.column width="50%"}
![](img/telling_dataviz.jpg){width="400"}
:::
::::

---

## Dataviz en R: ggplot2

La filosof√≠a detr√°s de `{ggplot2}` es entender los [**gr√°ficos como parte del flujo**]{.hl-yellow} de trabajo, dot√°ndoles de una [**gram√°tica**]{.hl-yellow}. El objetivo es empezar con un lienzo en blanco e ir [**a√±adiendo capas a tu gr√°fico**]{.hl-yellow}. La ventaja de `{ggplot2}` es poder [**mapear atributos est√©ticos**]{.hl-purple} (color, forma, tama√±o) de objetos geom√©tricos (puntos, barras, l√≠neas) en funci√≥n de los datos.

&nbsp;


La **documentaci√≥n** del paquete puedes consultarla en <https://ggplot2-book.org/introduction.html> 

![](img/grammar_ggplot2.jpg)


---

## Dataviz en R: ggplot2

![](img/tarta_ggplot2.png)

---

## Dataviz en R: ggplot2

:::: columns
::: {.column width="40%"}
![](img/tarta_recortada_ggplot2.jpg)
:::

::: {.column width="60%"}
Un gr√°fico se podr√° componer de [**capas**]{.hl-yellow}

* [**Datos (data)**]{.hl-purple}
* [**Mapeado (aesthetics)**]{.hl-purple} de elementos est√©ticos: ejes, color, forma, etc (en funci√≥n de los datos)
* [**Geometr√≠a (geom)**]{.hl-purple}: puntos, l√≠neas, barras, pol√≠gonos, etc.
* [**Componer gr√°ficas (facet)**]{.hl-purple}
* [**Transformaciones (stat)**]{.hl-purple}: ordenar, resumir, etc.
* [**Coordenadas (coord)**]{.hl-purple}: coordenadas cartesianas, polares, grids, etc.
* [**Temas (theme)**]{.hl-purple}: fuente, tama√±o de letra, subt√≠tulos, captions, leyenda, ejes, etc.

:::
::::

---

## Primer intento: scatter plot

Veamos un **primer intento** para entender la filosof√≠a ggplot. Imagina que queremos dibujar un [**scatter plot**]{.hl-yellow} (diagrama de dispersi√≥n de puntos). Para ello vamos a usar el conjunto de datos `gapminder`, del paquete hom√≥nimo: un fichero con **datos de esperanzas de vida, poblaciones y renta per c√°pita** de distintos pa√≠ses en distintos momentos temporales.

```{r}
library(gapminder)
gapminder
```


---

## Primer intento: scatter plot

El fichero consta de 1704 registros y 6 variables: `country`, `continent`, `year`, `lifeExp` (esperanza de vida), `pop` (poblaci√≥n)  y `gdpPercap` (renta per c√°pita).

```{r}
glimpse(gapminder)
```

Para empezar con algo sencillo [**filtraremos solo los datos de 1997**]{.hl-yellow}

```{r}
gapminder_1997 <-
  gapminder |>
  dplyr::filter(year == 1997) |> 
  tidyr::drop_na(gdpPercap, lifeExp, pop)
```

---

## Ingredientes: (x, y)


¬øQu√© [**elementos necesitamos**]{.hl-yellow} para realizar un diagrama de puntos? Para [**iniciar el lienzo**]{.hl-p√πrple} necesitamos una base de datos y dos variables a representar.

. . .

:::: columns
::: {.column width="45%"}

* [**Datos (data)**]{.hl-yellow}: conjunto `gapminder_1997`.

* [**Mapeado**]{.hl-yellow}: indicar dentro de `aes()` (aesthetics) las variables en cada coordenada. Todo [**dentro de aes() ser√° mapeado de los datos**]{.hl-purple}

```{r}
#| eval: false
ggplot(data = gapminder_1997,
       aes(x = gdpPercap, y = pop))
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop))
```

:::
::::

---


## Primera geometr√≠a: geom_point()

:::: columns
::: {.column width="45%"}

* [**Geometr√≠a (geom)**]{.hl-yellow}: optaremos por **puntos** usando `geom_point()`.

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop)) +
  geom_point()
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(x = gdpPercap, y = pop)) +
  geom_point()
```

:::
::::

---

## Rol de los ejes: (x, y)


:::: columns
::: {.column width="45%"}

Vamos a profundizar en ese mapeado: ¬øc√≥mo [**cambiar el rol**]{.hl-yellow} de los ejes (poblaci√≥n en el eje X y renta per c√°pita en el eje Y)? 

* **Eje X**: poblaci√≥n (variable `pop`)
* **Eje Y**: renta per c√°pita (variable `gdpPercap`)


```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = pop)) +
  geom_point() 
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop)) +
  geom_point() 
```
:::
::::



