---
title: "BioestadÃ­stica en R"
subtitle: "IntroducciÃ³n a la estadÃ­stica en R"
title-slide-attributes:
  data-background-image: img/data-science-2.jpeg
  data-background-size: cover
  data-background-opacity: "0.2"
author: "MÃ¡ster de BioinformÃ¡tica â€¢ Material elaborado en colaboraciÃ³n con Almudena Moreno Ribera y Silvia Pineda"
affiliation: Instituto de Salud Carlos III (ISCIII)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier Ãlvarez LiÃ©bana</strong>](...) â€¢ MÃ¡ster de BioinformÃ¡tica (ISCIII)"
    slide-number: c/t
execute:
  echo: true
---

::: r-fit-text
[Â¡Bienvenidos a R!]{.flow}
:::

[**Dejad vuestras hojas de cÃ¡lculo y SPSS a un lado**]{style="color:#444442;"}

---

## Â¡Buenas!

[**Correo**]{.hl-green}: [**javalv09\@ucm.es**](mailto:javalv09@ucm.es){.email}. [**Despacho**]{.hl-green}: 722 (3Âª planta de la Facultad de Estudios EstadÃ­sticos de la UCM).

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
-   [**Javier Ãlvarez LiÃ©bana**]{.hl-yellow}, de Carabanchel (Bajo).

-   Licenciado en MatemÃ¡ticas (UCM). [**Doctorado en estadÃ­stica**]{.hl-yellow} (UGR).

-   Encargado de la [**visualizaciÃ³n y anÃ¡lisis de datos covid**]{.hl-yellow} del Principado de Asturias (2021-2022).

-   Miembro de la [**Sociedad EspaÃ±ola de EstadÃ­stica e IO**]{.hl-yellow} y la [**Real Sociedad MatemÃ¡tica EspaÃ±ola**]{.hl-yellow}.
:::
:::
:::

Actualmente, [**investigador y docente en la Facultad de EstadÃ­stica de la UCM**]{.hl-yellow}. Divulgando por [**Twitter**](https://twitter.com/dadosdelaplace) e [**Instagram**](https://instagram.com/javieralvarezliebana)

---

## Objetivos

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
-   Quitarnos el [**miedo a los errores en programaciÃ³n**]{.hl-yellow} â†’ a programar se aprende programando

-   Entender los [**conceptos bÃ¡sicos de R**]{.hl-yellow} desde cero â†’ aprender a abstraer ideas y algoritmos

-   Utilidad de programar â†’ flujos de trabajo [**reproducibles**, **transparentes**]{.hl-yellow} y mantenibles

-   IntroducciÃ³n al [**anÃ¡lisis y preprocesamiento**]{.hl-yellow} de datos 

-   Adquirir habilidades en el [**anÃ¡lisis descriptivo de los datos**]{.hl-yellow}

-   Adquirir habilidades en la [**modelizaciÃ³n lineal**]{.hl-yellow}
:::
:::
:::

---

## PlanificaciÃ³n {#planificacion}

::: column-screen-inset-right
::: {style="font-size:20px"}
| CLASE | SEMANA | FECHAS | TOPIC |  EJ. | CASO PRÃCTICO  | ENTREGA |     |     |     |
|:-------------:|:------:|:------:|:-----------------------------------------:|:--------------------------------------------------:|:------------------------------------:|:-------:|:---:|:---:|:---:|
| [1](#clase-1) |   S1   | 17 oct | Primeros pasos. Tipos de datos y vectores |   [ğŸ’»](#tu-turno-1-1) [ğŸ’»](#tu-turno-1-2) [ğŸ’»](#tu-turno-1-3) |   [ğŸ£](#caso-practico-1-1)   |    |     |     |     |
| [2](#clase-2) |   S2   | 22 oct |  Primeras bases de datos  |    [ğŸ’»](#tu-turno-2-1) [ğŸ’»](#tu-turno-2-2)  |   [ğŸ£](#caso-practico-2-1) [ğŸ£](#caso-practico-2-2) [ğŸ£](#caso-practico-2-3)                                                   |         |     |     |     |
| [3](#clase-3) |   S2   | 24 oct |      Estructuras de control y Quarto      |                                         [ğŸ’»](#tu-turno-3-1) [ğŸ’»](#tu-turno-3-2)                                         |                                                                            [ğŸ£](#caso-practico-3-1)                                                                            |         |     |     |     |
| [4](#clase-4) |   S3   | 29 oct |        Import, ggplot y tidyverse         | [ğŸ’»](#tu-turno-4-1) [ğŸ’»](#tu-turno-4-2) [ğŸ’»](#tu-turno-4-3) [ğŸ’»](#tu-turno-4-4) [ğŸ’»](#tu-turno-4-5) [ğŸ’»](#tu-turno-4-6) | [ğŸ£](#caso-practico-4-1) [ğŸ£](#caso-practico-4-2) [ğŸ£](#caso-practico-4-3) [ğŸ£](#caso-practico-4-4) [ğŸ£](#caso-practico-4-5) [ğŸ£](#caso-practico-4-6) [ğŸ£](#caso-practico-4-7) |         |     |     |     |
:::
:::

---

## Casos prÃ¡cticos: R base {#casos-practicos}

Practicar tambiÃ©n con los ğŸ’» **ejercicios resueltos** de las diapositivas. Los ğŸ£ indican el nivel de dificultad

::: column-screen-inset-right
::: {style="font-size:25px"}
| TEMA | DATASET | LINK | DIFICULTAD |
|:----------|:---------|:---------:|:-----------:|
| R base y vectores | airquality  | [Link](https://javieralvarezliebana.quarto.pub/intro-r-vectores-isciii/#caso-pr%C3%A1ctico-i-airquality-vectores) | ğŸ£ |
| Tibbles | pinniped  | [Link](https://javieralvarezliebana.quarto.pub/matrices-tibble-isciii/#caso-pr%C3%A1ctico-i-pinniped-dataset) | ğŸ£ |
| Tibbles | Taylor Swift  | [Link](https://javieralvarezliebana.quarto.pub/matrices-tibble-isciii/#caso-pr%C3%A1ctico-ii-an%C3%A1lisis-de-taylor-swift) | ğŸ£ğŸ£ |
| Tibbles y textos | Discursos de Navidad | [Link](https://javieralvarezliebana.quarto.pub/matrices-tibble-isciii/#caso-pr%C3%A1ctico-iii-salto-de-longitud-practicando-textos) | ğŸ£ğŸ£ğŸ£ |
| Bucles y estructuras if-else | Simulados | [Link](https://javieralvarezliebana.quarto.pub/if-else-bucles-funciones-isciii/#caso-pr%C3%A1ctico-i-bucles-y-estructuras-condicionales) | ğŸ£ğŸ£ğŸ£ğŸ£ |
| Funciones | Simulados | [Link](https://javieralvarezliebana.quarto.pub/if-else-bucles-funciones-isciii/#caso-pr%C3%A1ctico-ii-conversor-de-temperaturas) | ğŸ£ğŸ£ğŸ£ |
:::
:::

- [ğŸ‘¾ Materiales extras R base](#extra-Rbase)

---

## Casos prÃ¡cticos: tidyverse 

Practicar tambiÃ©n con los ğŸ’» **ejercicios resueltos** de las diapositivas. Los ğŸ£ indican el nivel de dificultad

::: column-screen-inset-right
::: {style="font-size:25px"}
| TEMA | DATASET | LINK | DIFICULTAD |
|:---------------|:----------------|:--------:|:-----------:|
| Â¿QuÃ© es el tidydata? | Datos de la OMS  | [Link](https://javieralvarezliebana.quarto.pub/tidydata-isciii/#caso-pr%C3%A1ctico-an%C3%A1lisis-de-datos-de-la-oms) | ğŸ£ğŸ£ |
| Operaciones con filas | airquality  | [Link](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-ii-airquality-tidyverse) | ğŸ£ |
| Operaciones con columnas | Taylor Swift  | [Link](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-iii-taylor-swift) | ğŸ£ğŸ£ |
| Operaciones con columnas | El seÃ±or de los anillos  | [Link](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-iii-extra-el-se%C3%B1or-de-los-anillos) | ğŸ£ğŸ£ğŸ£ |
| ResÃºmenes | Billboard | [Link](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-iv-billboard) | ğŸ£ğŸ£ |
| ResÃºmenes | Datos de fÃºtbol: Messi vs Cristiano Ronaldo | [Link](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-v-messi-vs-ronaldo) | ğŸ£ğŸ£ |
| ResÃºmenes e importar/exportar | Encuesta del CIS sobre feminismo | [Link](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-vi-tabla-en-spss) | ğŸ£ğŸ£ğŸ£ğŸ£ |
:::
:::

- [ğŸ‘¾ Materiales extras tidyverse](#extra-tidyverse)

---

## Casos prÃ¡cticos: estadÃ­stica descriptiva en R

::: column-screen-inset-right
::: {style="font-size:25px"}
| TEMA | DATASET | LINK | DIFICULTAD |
|:---------------|:----------------|:--------:|:-----------:|
| Intro a la visualizaciÃ³n de datos en R | Datos de covid del ISCIII  | [Link](https://javieralvarezliebana.quarto.pub/intro-dataviz-isciii/#caso-pr%C3%A1ctico-visualizaci%C3%B3n-covid) | ğŸ£ |
| Intro a la estadÃ­stica descriptiva univariante | Encuesta de satisfacciÃ³n  | [Link](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-encuesta-de-satisfacci%C3%B3n) | ğŸ£ğŸ£ |
| Intro a la estadÃ­stica bivariante: cuali vs cuali | Placebo vs medicamento | [Link](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-i-placebo-vs-f%C3%A1rmaco) | ğŸ£ğŸ£ |
| Intro a la estadÃ­stica bivariante: cuali vs cuali | tabaco vs bronquitis | [Link](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-ii-bronquitis-y-tabaco) | ğŸ£ |
| Intro a la estadÃ­stica bivariante: cuali vs cuali | encuesta salud mental | [Link](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-iii-salud-mental) | ğŸ£ğŸ£ |
:::
:::

- [ğŸ‘¾ Recursos extras visualizaciÃ³n](#recursos-dataviz)
- [ğŸ‘¾ Materiales extras visualizaciÃ³n](#extra-dataviz)

---

## Material extras

-   [ğŸ’» R base](#extra-Rbase)
-   [ğŸ’» Tidyverse](#extra-tidyverse)
-   [ğŸ’» Dataviz en R](#extra-dataviz)
-   [ğŸ’» Github](#github)

---

## Materiales

-   [**Diapositivas**]{.hl-yellow}: diapositivas en `Quarto` disponibles y actualizadas en [**https://javieralvarezliebana.es/docencia/biostats-ISCII**](https://javieralvarezliebana.es/docencia/biostats-ISCII){.uri}. En el menÃº de las diapositivas (abajo a la izquierda) tienes una [**opciÃ³n para descargarlas en pdf**]{.hl-yellow} en `Tools`

- [ğŸ—ƒ **Datos**]{.hl-yellow}: datasets que usaremos a lo largo de la asignatura, disponibles en [**https://drive.google.com/drive/folders/1zDc_XqXnTxx8auEYW7aFfIsnzDXOcAiZ?usp=sharing**](https://drive.google.com/drive/folders/1zDc_XqXnTxx8auEYW7aFfIsnzDXOcAiZ?usp=sharing){.uri}

-   [ğŸ“š **Recursos de apoyo**]{.hl-yellow}: en inglÃ©s <https://r4ds.had.co.nz/> y en castellano <https://cdr-book.github.io/>, y <https://ivelasq.quarto.pub/intro-to-quarto/> para Quarto.

# Clase 1: [primeros pasos]{.flow} {#clase-1}

[**Instalando R y RStudio. Primeros pasos: Â¿quÃ© tipos de celdas (datos) existen?**]{style="color:#444442;"}

-   [ğŸ’» Ejercicios resueltos: R y RStudio](#tu-turno-1-1)
-   [ğŸ’» Ejercicios resueltos: tipos de datos](#tu-turno-1-2)
-   [ğŸ’» Ejercicios resueltos: vectores](#tu-turno-1-3)
-   [ğŸ£ Workbook/caso prÃ¡ctico I](#caso-practico-1-1)
-   [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## Requisitos

Para el curso los Ãºnicos requisitos serÃ¡n:

1.  [**ConexiÃ³n a internet**]{.hl-yellow} (para la descarga de algunos datos y paquetes).

. . .

2.  [**Instalar R**]{.hl-yellow}: serÃ¡ nuestro lenguaje. La descarga la haremos (gratuitamente) desde <https://cran.r-project.org/>

. . .

3.  [**Instalar RStudio**]{.hl-yellow} desde <https://posit.co/download/rstudio-desktop/>

::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="420"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="420"}
:::
:::

---

## R vs RStudio

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="360"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="430"}
:::
:::

::: {.fragment .fade-in-then-out}
Programaremos como escribimos (castellano, por ejemplo) â†’ `R` es [**lenguaje**]{.hl-yellow}
:::

::: {.fragment .fade-up}
-   Necesitaremos una [**gramÃ¡tica, un lenguaje**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}
-   Y un entorno, por ejemplo un [**Word**]{.hl-yellow} (`RStudio`), para escribirlo
:::
:::

---

## InstalaciÃ³n de R

El lenguaje `R` serÃ¡ nuestra [**gramÃ¡tica y ortografÃ­a**]{.hl-yellow} (nuestras reglas de juego)

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra en <https://cran.r-project.org/> y selecciona tu sistema operativo.

-   [**Paso 2**]{.hl-yellow}: para Mac basta con que hacer click en el **archivo .pkg**, y abrirlo una vez descargado. Para sistemas Windows, debemos clickar en **install R for the first time** y despuÃ©s en **Download R for Windows**. Una vez descargado, abrirlo como cualquier archivo de instalaciÃ³n.

-   [**Paso 3**]{.hl-yellow}: abrir el ejecutable de instalaciÃ³n.
:::

. . .

::: callout-warning
Siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), [**asegÃºrate de tener conexiÃ³n a internet**]{.hl-orange}.
:::

---

## Primera operaciÃ³n {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalaciÃ³n, tras abrir `R`, deberÃ­as ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**Primer cÃ³digo**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el cÃ³digo en la consola y daremos Â«enterÂ»). Tras ello haremos la suma `a + b`.

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## Primera operaciÃ³n {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalaciÃ³n, tras abrir `R`, deberÃ­as ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Primer cÃ³digo**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el cÃ³digo en la consola y daremos Â«enterÂ»). Tras ello haremos la suma `a + b`.

```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

---

## Primera operaciÃ³n {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalaciÃ³n, tras abrir `R`, deberÃ­as ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Primer cÃ³digo**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el cÃ³digo en la consola y daremos Â«enterÂ»). Tras ello haremos la suma `a + b`.

```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

. . .

::: callout-note
## FÃ­jate que...

En la consola aparece un nÃºmero `[1]`: simplemente es un contador de elementos (como contar filas en un Word)
:::

---

## InstalaciÃ³n de R Studio

`RStudio` serÃ¡ el [**Word**]{.hl-yellow} que usaremos para escribir (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra la [web oficial de RStudio](https://posit.co/download/rstudio-desktop/) (ahora llamado Posit) y selecciona la descarga gratuita.

-   [**Paso 2**]{.hl-yellow}: selecciona el ejecutable que te aparezca acorde a tu sistema operativo.

-   [**Paso 3**]{.hl-yellow}: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro y dejar que termine la instalaciÃ³n.
:::

---

## OrganizaciÃ³n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo cÃ³digo que antes (la suma de las variables) en ella. La consola serÃ¡ donde **ejecutaremos Ã³rdenes y mostraremos resultados**.

![](img/consola_rstudio.jpg){width="420"}

---

## OrganizaciÃ³n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Environment**]{.hl-yellow}: la pantalla pequeÃ±a (puedes ajustar los mÃ¡rgenes con el ratÃ³n a tu gusto) que tenemos en la parte superior derecha. Nos mostrarÃ¡ las **variables que tenemos definidas**.

![](img/environment.jpg){width="420"}

---

## OrganizaciÃ³n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha no servirÃ¡ para buscar **ayuda de funciones**, ademÃ¡s de para **visualizar grÃ¡ficos**.

![](img/multiusos.jpg){width="420"}

---

## Â¿QuÃ© es R? Â¿Por quÃ© R?

![](img/meme_barco.jpg)

---

## Â¿QuÃ© es R? Â¿Por quÃ© R?

![](img/incel_excel.png)

`R` es la evoluciÃ³n del trabajo de los laboratorios Bell con el lenguaje `S`, que fue llevado al mundo del software libre por Ross Ihaka y Robert Gentleman en los aÃ±os 90. La version `R 1.0.0` se publicÃ³ el 29 de febrero de 2000.

---

## Â¿QuÃ© es R? Â¿Por quÃ© R?

`R` es el [**lenguaje estadÃ­stico por excelencia**]{.hl-yellow}, creado por y para estadÃ­sticos/as, con 6 ventajas fundamentales [**frente a Excel, SAS, Stata o SPSS**]{.hl-red}:

. . .

-   [**Lenguaje de programaciÃ³n**]{.hl-yellow}: la obviedad â†’ anÃ¡lisis [**replicables**]{.hl-purple}

. . .

-   [**Gratuito**]{.hl-yellow}: la filosofÃ­a de la comunidad de `R` es el compartir cÃ³digo bajo **copyleft** â†’ **uso Ã©tico de dinero y algoritmos**

. . .

-   [**Software libre**]{.hl-yellow}: no solo es gratis sino que permite acceder libremente a cÃ³digo ajeno, incluso al **propio cÃ³digo fuente** â†’ [**flexibilidad y transparencia**]{.hl-purple} (Free and Open Source Software FOSS)

---

## Â¿QuÃ© es R? Â¿Por quÃ© R?

`R` es el [**lenguaje estadÃ­stico por excelencia**]{.hl-yellow}, creado por y para estadÃ­sticos/as, con 6 ventajas fundamentales [**frente a Excel, SAS, Stata o SPSS**]{.hl-red}:

-   [**Lenguaje modular**]{.hl-yellow}: hemos instalado lo mÃ­nimo, pero existen cÃ³digos de otras personas que podemos reusar (casi 20 000 [**paquetes**]{.hl-yellow}) â†’ [**ahorro de tiempo**]{.hl-purple} e [**innovaciÃ³n inmediata**]{.hl-purple}

. . .

-   [**Lenguaje de alto nivel**]{.hl-yellow}: facilita la programaciÃ³n (como Python) â†’ [**menor curva de aprendizaje**]{.hl-purple}

. . .

-   [**Comunidad y empleabilidad**]{.hl-yellow}: junto con Python es el lenguaje mÃ¡s utilizado en el campo de la estadÃ­stica y la ciencia de datos en investigaciÃ³n, docencia, empresas (LÃ­nea Directa, Mapfre, TelefÃ³nica, Orange, Apple, Spotify, Netflix, El PaÃ­s, Civio, HP, etc) y organismos pÃºblicos (ISCIII, CNIC, CNIO, INE, IGN, CIS, CEO, DGT, AEMET, RTVE, etc)

---

## Â¿Por quÃ© programar?

-   [**Automatizar**]{.hl-yellow} â†’ te permitirÃ¡ automatizar tareas recurrentes.

-   [**Replicabilidad**]{.hl-yellow} â†’ podrÃ¡s replicar tu anÃ¡lisis siempre de la misma manera.

-   [**Flexibilidad**]{.hl-yellow} â†’ podrÃ¡s adaptar el software a tus necesidades.

-   [**Transparencia**]{.hl-yellow} â†’ ser auditado por la comunidad.

![](img/the_general_problem.png)

---

## Idea fundamental: paquetes

Una de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: cÃ³digos que otras personas han implementado para **resolver un problema**

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}
-   [**InstalaciÃ³n**]{.hl-yellow}: descargamos los cÃ³digos de la web (necesitamos internet) â†’ [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)

```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}
-   [**Carga**]{.hl-yellow}: con el paquete descargado, indicamos quÃ© paquetes queremos usar cada vez que abramos `RStudio` â†’ [**traer el libro de la estanterÃ­a**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::
:::
:::

---

## Idea fundamental: paquetes

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
Una vez instalado, hay **dos manera de usar un paquete** (traerlo de la estanterÃ­a)

::: {.fragment fragment-index="1"}
-   [**Paquete entero**]{.hl-yellow}: con `library()`, usando el nombre del paquete sin comillas, cargamos en la sesiÃ³n [**todo el libro**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}
-   [**Funciones concretas**]{.hl-yellow} usando `paquete::funcion` le Ã­ndicamos que solo queremos una [**pÃ¡gina concreta de ese libro**]{.hl-purple}

```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## Te vas equivocar

Durante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera â†’ [**te vas equivocar**]{.hl-yellow}. No solo serÃ¡ importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.

. . .

-   [**Mensajes de error**]{.hl-red}: precedidos de **Â«Error in...Â»** y serÃ¡n aquellos fallos que [**impidan la ejecuciÃ³n**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Mensajes de warning**]{.hl-orange}: precedidos de **Â«Warning in...Â»** son los (posibles) fallos mÃ¡s delicados ya que son incoherencias que [**no impiden la ejecuciÃ³n**]{.hl-orange}

```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```

---

## Scripts (documentos .R)

::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}
Un [**script**]{.hl-yellow} serÃ¡ el documento en el que programamos, nuestro archivo `.doc` (aquÃ­ con extensiÃ³n `.R`) donde escribiremos las Ã³rdenes. Para **abrir nuestro primero script**, haz click en el menÃº en `File < New File < R Script`.

::: callout-warning
## Cuidado

Es importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habrÃ¡s perdido**]{.hl-orange}.
:::
:::
:::

::: callout-warning
## Cuidado

`R` es [**case-sensitive**]{.hl-orange}: es sensible a mayÃºsculas y minÃºsculas por lo que `x` y `X` representa variables distintas.
:::

---

## Ejecutando el primer script

Ahora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros cÃ³digos**]{.hl-yellow}. Â¿CÃ³mo ejecutarlo?

. . .

1.  **Escribimos** el cÃ³digo a ejecutar.

. . .

2.  **Guardamos** el archivo .R haciendo click en `Save current document`.

. . .

3.  El cÃ³digo no se ejecuta salvo que se lo indiquemos. Tenemos **tres opciones de ejecutar un script**:

-   [**Copiar y pegar**]{.hl-yellow} en consola.
-   [**Seleccionar lÃ­neas**]{.hl-yellow} y `Ctrl+Enter`
-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el cÃ³digo **completo**.

---

## SÃ© organizado: proyectos

De la misma manera que en el ordenador solemos trabajar de manera [**ordenada por carpetas**]{.hl-yellow}, en `RStudio` podemos hacer lo mismo para trabajar de [**manera eficaz creando proyectos**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
Un [**proyecto serÃ¡ una Â«carpetaÂ»**]{.hl-yellow} dentro de `RStudio`, de manera que nuestro directorio raÃ­z automÃ¡ticamente serÃ¡ la propia carpeta de proyecto (pudiendo pasar de un proyecto a otro con el menu superior derecho).

Podemos crear uno en una carpeta nueva o en una carpeta ya existente.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::

---

## ğŸ’» Tu turno {#tu-turno-1-1}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Crea en tu ordenador una carpeta de la asignatura y crea dentro de ella el proyecto de `RStudio`: es ahÃ­ donde vas a guardar todo lo que hagamos a lo largo de este curso.Tras crear el proyecto tendrÃ¡s un archivo `R Project`. A continuaciÃ³n crea en dicha carpeta dos subcarpetas: `datos` (es ahÃ­ donde irÃ¡s guardando los distintos datasets que usaremos) y `scripts` (es ahÃ­ donde irÃ¡s guardando los archivos `.R` de cada clase)

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Dentro del proyecto crea un script `ejercicios-clase1.R` (dentro de la carpeta `scripts`). Una vez creado define en Ã©l una variable de nombre `a` y cuyo valor sea -1. Ejecuta el cÃ³digo de las 3 maneras explicadas.

```{r}
#| code-fold: true
a <- -1
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ AÃ±ade debajo otra lÃ­nea para definir una variable `b` con el valor 5. Tras ello guarda la multiplicaciÃ³n de ambas variables. Ejecuta el cÃ³digo como consideres.

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # sin guardar
multiplicacion <- a * b # guardado
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables y guarda el resultado.

```{r}
#| eval: false
c <- # deberÃ­as asignarle el valor 3
d <- # deberÃ­as asignarle el valor -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d # sin guardar
division <- c / d # guardado
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Asigna un valor positivo a `x` y calcula su raÃ­z cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la funciÃ³n `abs()`.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

::: callout-note
## Toma nota

Comandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: lÃ­neas de cÃ³digo que hemos Â«encapsuladoÂ» bajo un nombre, y dado unos argumentos de entrada, ejecuta las Ã³rdenes (una especie de atajo). En las funciones los [**argumentos irÃ¡n SIEMPRE entre parÃ©ntesis**]{.hl-yellow}
:::

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Usando la variable `x` ya definida, completa/modifica el cÃ³digo inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.

```{r}
#| eval: false
z <- ? - ? # completa el cÃ³digo
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Define una variable `x` y asÃ­gnale el valor `-1`. Define otra `y` y asÃ­gnale el valor `0`. Tras ello realiza las operaciones a) `x` entre `y`; b) raÃ­z cuadrada de `x`. Â¿QuÃ© obtienes?

```{r}
#| code-fold: true
#| eval: false
x <- -1
y <- 0

x / y
sqrt(x)
```

### [**Ejercicio 8**]{.hl-yellow}

ğŸ“ Escribe el cÃ³digo inferior en tu script. Â¿Por quÃ© crees que no funciona?

```{r}
#| error: true
x <- -1
y <- 0

X + y
```
:::

---

## De la CELDA a la TABLA

Â¿QuÃ© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg)

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenaciÃ³n** de valores del mismo tipo ([**vectores en R**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenaciÃ³n de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenaciÃ³n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenaciÃ³n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

---

## Pero antes...buenas prÃ¡cticas

Antes de seguir, es importante que sepas algo cuÃ¡nto antes: [**empezar en la programaciÃ³n puede ser frustrante**]{.hl-yellow}

. . .

Al igual que cuando aprendes un idioma nuevo, el primer obstÃ¡culo a solventar no es tanto quÃ© decir sino cÃ³mo decirlo de manera correcta. Y en `R` pasa lo mismo, asÃ­ que vamos a [**normalizar nuestra forma de programar**]{.hl-yellow} lo mÃ¡ximo posible para evitar errores futuros.

. . .

-   [**Tip 1**]{.hl-green}: [**asignar, evaluar y comparar no es lo mismo**]{.hl-yellow}. Si te has fijado en `R` estamos usando `<-` para asignar valores a variables. Usaremos `=` para evaluar argumentos en funciones y `==` para saber si dos elementos son iguales.

```{r}
#| eval: false
x <- 1 # asignar
x = 1 # evaluar
x == 1 # comparar
```

---

## Pero antes...buenas prÃ¡cticas

-   [**Tip 2**]{.hl-green}: programa como escribes. Al igual que cuando redactas en castellano, acostÃºmbrate a incorporar [**espacios y saltos de lÃ­nea**]{.hl-yellow} paranoquedarteciego (es una buena prÃ¡ctica y no un requisito porque `R` no procesa los espacios)

```{r}
#| eval: false
x <- 1 # Ã³ptimo
x<-1 # regu
x<- 1 # peor (decÃ­dete)
```

. . .

-   [**Tip 3**]{.hl-green}: no seas caÃ³tico/a, [**estandariza nombres**]{.hl-yellow}. AcostÃºmbrate siempre a nombrar las variables de la misma manera. El Ãºnico requisito es que **debe empezar siempre por una letra** (y sin tildes). La forma mÃ¡s recomendable es la conocida como `snake_case`

```{r}
#| eval: false
variable_en_modo_snake_case
otraFormaMasDificilDeLeer
hay.gente.que.usa.esto
Incluso_Haygente.Caotica_que.NoMereceNuestraATENCION
```

---

## Pero antes...buenas prÃ¡cticas

-   [**Tip 4**]{.hl-green}: facilita la lectura y escritura, [**pon lÃ­mites**]{.hl-yellow}. En `Tools < Global Options` puedes personalizar algunas opciones de `RStudio`. En `Code < Display` podemos indicarle en `Show margin` que los scripts nos muestren un margen "imaginario" (no interacciona con el cÃ³digo) para "forzarnos" a realizar un salto de lÃ­nea.

![](img/show_margin.jpg)

---

## Pero antes...buenas prÃ¡cticas

-   [**Tip 5**]{.hl-green}: el [**tabulador es tu mejor amigo**]{.hl-yellow}. En `RStudio` tenemos una herramienta maravillosa: si escribes parte del nombre de una variable o funciÃ³n y tabulas, `RStudio` te autocompleta

![](img/tab-autocompletar.png)

---

## Pero antes...buenas prÃ¡cticas

-   [**Tip 6**]{.hl-green}: ni un parÃ©ntesis soltero. Siempre que abras un parÃ©ntesis deberÃ¡s cerrarlo. Para facilitar esta tarea entra en `Tools < Global Options < Code < Display` y activa la opciÃ³n `Rainbow parentheses`

![](img/rainbow-parentheses.jpg)

---

## Pero antes...buenas prÃ¡cticas

-   [**Tip 7**]{.hl-green}: fÃ­jate en el lateral izquierdo. No solo podrÃ¡s ver la lÃ­nea de cÃ³digo por la que vas sino que, en caso de estar cometiendo un [**error de sintaxis**]{.hl-red}, el propio `RStudio` te avisarÃ¡.

![](img/rstudio-error-sintaxis.png)

-   [**Tip 8**]{.hl-green}: intenta [**trabajar siempre por proyectos**]{.hl-yellow} (para esta clase, crea un script `clase2.R` en el proyecto que creamos en la anterior clase)

Â 

Ver mÃ¡s tips en <https://r4ds.had.co.nz/workflow-basics.html#whats-in-a-name>

---

## Celdas: tipos de datos

Â¿Existen [**variables mÃ¡s allÃ¡ de los nÃºmeros en la ciencia de datos**]{.hl-yellow}? Piensa por ejemplo en los datos que podrÃ­as guardar de una persona:

::: {.fragment .fade-up}
-   La edad o el peso serÃ¡ un [**nÃºmero**]{.hl-yellow}.

```{r}
edad <- 33
```
:::

::: {.fragment .fade-up}
-   Su nombre serÃ¡ una cadena de [**texto (conocida como string o char)**]{.hl-yellow}.

```{r}
nombre <- "javi"
```
:::

::: {.fragment .fade-up}
-   A la pregunta Â«Â¿estÃ¡s matriculado en la Facultad?Â» la respuesta serÃ¡ lo que llamamos una [**variable lÃ³gica**]{.hl-yellow} (`TRUE` si estÃ¡ matriculado o `FALSE` en otro caso).

```{r}
matriculado <- TRUE
```
:::

::: {.fragment .fade-up}
-   Su fecha de nacimiento serÃ¡ precisamente eso, una [**fecha**]{.hl-yellow}.
:::

---

## Variables numÃ©ricas {auto-animate="true"}

El dato mÃ¡s sencillo (ya lo hemos usado) serÃ¡n las [**variables numÃ©ricas**]{.hl-yellow}. Para saber la [**clase de dato en R**]{.hl-yellow} de una variable tenemos la funciÃ³n `class()`

```{r}
#| eval: false
#| code-line-numbers: "1"
a <- 5
```

---

## Variables numÃ©ricas {auto-animate="true"}

El dato mÃ¡s sencillo (ya lo hemos usado) serÃ¡n las [**variables numÃ©ricas**]{.hl-yellow}. Para saber la [**clase de dato en R**]{.hl-yellow} de una variable tenemos la funciÃ³n `class()`

```{r}
#| eval: false
#| code-line-numbers: "2"
a <- 5
class(a)
```

. . .

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

Para saber su [**tipologÃ­a (naturaleza o formato)**]{.hl-yellow} variable tenemos `typeof()`

```{r}
typeof(1) # 1 pero almacenado como un valor real (double, con decimales)
typeof(as.integer(1)) # 1 pero almacenado como un entero.
```

::: callout-note
## FÃ­jate que...

En `R` tenemos una colecciÃ³n de funciones que empiezan por `as.x()` y que sirven como [**funciones de conversiÃ³n**]{.hl-yellow}: un dato que era de un tipo, lo convertimos a tipo `x`.
:::

---

## Variables numÃ©ricas

AdemÃ¡s de los nÃºmeros Â«normalesÂ» tendremos el [**valor mÃ¡s/menos infinito**]{.hl-yellow} codificado como `Inf` o `-Inf`

```{r}
1/0
```

```{r}
-1/0
```

. . .

Y valores que [**no son nÃºmeros reales**]{.hl-yellow} *not a number* (indeterminaciones, complejos, etc) codificado como `NaN`

```{r}
0/0
```

```{r}
sqrt(-2)
```

---

## Variables numÃ©ricas

Con las variables numÃ©ricas podemos realizar las [**operaciones aritmÃ©ticas**]{.hl-yellow} de una calculadora: sumar (`+`)...

```{r}
a + b
```

. . .

...raÃ­z cuadrada (`sqrt()`)...

```{r}
sqrt(a)
```

. . .

... potencias (`^2`, `^3`)...

```{r}
a^2
```

. . .

...valor absoluto (`abs()`), etc.

```{r}
abs(a)
```

---

## Variables de texto

Imagina que ademÃ¡s de la edad de una persona queremos guardar su nombre: ahora la variable serÃ¡ de tipo `character`

```{r}
nombre <- "Javier"
class(nombre)
```

. . .

Las [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones aritmÃ©ticas**]{.hl-red} (sÃ­ otras operaciones como pegar o localizar patrones).

```{r}
#| error: true
nombre + 1 # error al sumar nÃºmero a texto
```

. . .

::: callout-warning
## Recuerda que...

Las variables de tipo texto (character o string) van [**SIEMPRE entre comillas**]{.hl-orange}: no es lo mismo `TRUE` (valor lÃ³gico, binario) que `"TRUE"` (texto).
:::

---

## Primera funciÃ³n: paste

Como hemos comentado `R` llamaremos [**funciÃ³n**]{.hl-yellow} a un trozo de [**cÃ³digo encapsulado**]{.hl-yellow} bajo un nombre, y que depende de unos [**argumentos**]{.hl-yellow} de entrada. Nuestra primera funciÃ³n serÃ¡ `paste()`: dadas dos cadenas de texto nos permite pegarlas.

```{r}
paste("Javier", "Ãlvarez")
```

. . .

FÃ­jate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos aÃ±adir un [**argumento opcional**]{.hl-yellow} para indicarle el separador (en `sep = ...`).

```{r}
paste("Javier", "Ãlvarez", sep = "*")
```

---

## Primera funciÃ³n: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}
Â¿CÃ³mo saber [**quÃ© argumentos necesita una funciÃ³n**]{.hl-yellow}? Escribiendo en consola `? paste` te aparecerÃ¡ una [**ayuda**]{.hl-yellow} en el panel multiusos.

En dicha ayuda podrÃ¡s ver en su cabecera que argumentos ya tiene [**asignados por defecto**]{.hl-yellow} la funciÃ³n
:::
:::

. . .

Existe una funciÃ³n similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).

```{r}
paste0("Javier", "Ãlvarez")
```

---

## Primera funciÃ³n: paste

Los argumentos (y su detalle) tambiÃ©n pueden ser consultado **tabulando (detras una coma)**.

![](img/tab-functions.png)

---

## Funciones: argumentos por defecto

Es muy importante entender el concepto de [**argumento por defecto de una funciÃ³n**]{.hl-yellow} en `R`: es un valor que la funciÃ³n usa pero a veces podemos no ver porque [**ya tiene un valor asignado**]{.hl-yellow}.

```{r}
# Hacen lo mismo
paste("Javier", "Ãlvarez")
paste("Javier", "Ãlvarez", sep = " ")
```

. . .

::: callout-note
## Toma nota

El operador `=` lo [**reservaremos para asignar argumentos**]{.hl-yellow} dentro de funciones. Para todas las demÃ¡s asignaciones usaremos `<-`
:::

---

## Primer paquete: glue

Una forma mÃ¡s intuitiva de trabajar con textos es usar el paquete `{glue}`: lo primero que haremos serÃ¡ Â«comprar el libroÂ» (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue") # solo la primra vez
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

Con la funciÃ³n `glue()` de dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, Â«la edad es de ... aÃ±osÂ», donde la edad estÃ¡ guardada en una variable.

```{r}
edad <- 33
glue("La edad es de {edad} aÃ±os")
```

. . .

Dentro de las llaves tambiÃ©n podemos [**ejecutar operaciones**]{.hl-yellow}

```{r}
unidades <- "dÃ­as"
glue("La edad es de {edad * 365} {unidades}")
```

---

## Variables lÃ³gicas

Otro tipo fundamental serÃ¡n las [**variables lÃ³gicas o binarias**]{.hl-yellow} (**dos valores**):

-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.
-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.

```{r}
soltero <- TRUE # Â¿Es soltero? --> SÃ
class(soltero)
```

. . .

Dado que internamente estÃ¡n guardados como variables binarias, podemos [**realizar operaciones aritmÃ©ticas**]{.hl-yellow} con ellas

```{r}
2 * TRUE
FALSE - 1
```

---

## Variables lÃ³gicas

Como veremos en breve, las variables lÃ³gicas en realidad puede tomar un tercer valor: `NA` o [**dato ausente**]{.hl-yellow}, representando las siglas de *not available*, y serÃ¡ muy habitual encontrarlo dentro de una base de datos.

```{r}
ausente <- NA
ausente + 1
```

. . .

::: callout-important
## Importante

Las variables lÃ³gicas [**NO son variables de texto**]{.hl-red}: `"TRUE"` es un texto, `TRUE` es un valor lÃ³gico.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Condiciones lÃ³gicas

Los valores lÃ³gicos suelen ser resultado de [**evaluar condiciones lÃ³gicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos [**comprobar**]{.hl-yellow} si una persona se llama Javi.

```{r}
nombre <- "MarÃ­a"
```

. . .

Con el [**operador lÃ³gico**]{.hl-yellow} `==` preguntamos sÃ­ lo que tenemos guardado a la izquierda es [**igual que**]{.hl-purple} lo que tenemos a la derecha: es una [**pregunta**]{.hl-yellow}

```{r}
nombre == "Javi"
```

. . .

Con su opuesto `!=` preguntamos [**si es distinto**]{.hl-purple}.

```{r}
nombre != "Javi"
```

. . .

::: callout-note
## FÃ­jate que...

No es lo mismo `<-` ([**asignaciÃ³n**]{.hl-yellow}) que `==` (estamos [**preguntando**]{.hl-yellow}, es una comparaciÃ³n lÃ³gica).
:::

---

## Condiciones lÃ³gicas

AdemÃ¡s de las comparaciones Â«igual aÂ» frente Â«distintoÂ», tambiÃ©n comparaciones de orden como [**menor que**]{.hl-purple} `<`, [**mayor que**]{.hl-purple} `>`, `<=` o `>=`.

**Â¿Tiene la persona menos de 32 aÃ±os?**

```{r}
edad <- 34
edad < 32 # Â¿Es la edad menor de 32 aÃ±os?
```

. . .

**Â¿La edad es mayor o igual que 38 aÃ±os?**

```{r}
edad >= 38
```

. . .

**Â¿El nombre guardado es Javi?**

```{r}
nombre <- "Javi"
nombre == "Javi"
```

---

## Variables de fecha

Un tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.

```{r}
fecha_char <- "2021-04-21"
```

Parece una simple cadena de texto pero [**deberÃ­a representar un instante en el tiempo**]{.hl-yellow}. Â¿QuÃ© deberÃ­a suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?

. . .

```{r}
#| error: true
fecha_char + 1
```

Las fechas [**NO pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha.

. . .

Â 

Para trabajar con fechas usaremos el paquete `{lubridate}`, que deberemos instalar antes de poder usarlo.

```{r}
#| eval: false
install.packages("lubridate")
```

---

## Variables de fecha

Una vez instalado, de todos los paquetes (libros) que tenemos, le indicaremos que nos cargue ese concretamente.

```{r}
library(lubridate) # instala si no lo has hecho

```

. . .

Para [**convertir a tipo fecha**]{.hl-yellow} usaremos la funciÃ³n `as_date()` del paquete `{lubridate}` (por defecto en formato `yyyy-mm-dd`)

Â 

::: columns
::: {.column width="50%"}
```{r}
#| error: true
# Â¡no es una fecha, es un texto!
fecha_char + 1
class(fecha_char)
```
:::

::: {.column width="50%"}
```{r}
fecha <- as_date("2023-03-28")
fecha + 1
class(fecha)
```
:::
:::

---

## Variables de fecha

En `as_date()` el formato de fecha por defecto es `yyyy-mm-dd` asÃ­ si la cadena de texto no se introduce de manera adecuada...

```{r}
as_date("28-03-2023")
```

. . .

Para [**cualquier otro formato debemos especificarlo**]{.hl-yellow} en el argumento opcional `format = ...` tal que `%d` representa dÃ­as, `%m` meses, `%Y` en formato de 4 aÃ±os y `%y` en formato de 2 aÃ±os.

```{r}
as_date("28-03-2023", format = "%d-%m-%Y")
as_date("28-03-23", format = "%d-%m-%y")
as_date("03-28-2023", format = "%m-%d-%Y")
as_date("28/03/2023", format = "%d/%m/%Y")
```

---

## Variables de fecha

En dicho paquete tenemos funciones muy Ãºtiles para [**manejar fechas**]{.hl-yellow}:

-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.

```{r}
today()
```

. . .

-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}

```{r}
now()
```

. . .

-   Con `year()`, `month()` o `day()` podemos [**extraer el aÃ±o, mes y dÃ­a**]{.hl-purple}

```{r}
fecha <- today()
year(fecha)
month(fecha)
```

---

## ResÃºmenes de paquetes

![](img/lubridate.png)

::: callout-note
## Amplia contenido

Tienes un resumen en pdf de los paquetes mÃ¡s importantes en la [**carpeta correspondiente en el campus**]{.hl-green}
:::

---

## ğŸ’» Tu turno {#tu-turno-1-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Define una variable que guarde tu edad (llamada `edad`) y otra con tu nombre (llamada `nombre`)

```{r}
#| code-fold: true
edad <- 33
nombre <- "Javi"
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Comprueba con dicha variable `edad` si NO tiene 60 aÃ±os o si se llama `"Ornitorrinco"` (debes obtener variables lÃ³gicas como resultado)

```{r}
#| code-fold: true
#| eval: false
edad != 60 # distinto de
nombre == "Ornitorrinco" # igual a
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Â¿Por quÃ© el cÃ³digo inferior da error?

```{r}
#| error: true
edad + nombre
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Define otra variable llamada `hermanos` que responda la pregunta Â«Â¿tienes hermanos?Â» y otra variable que almacene tu fecha de nacimiento (llamada `fecha_nacimiento`).

```{r}
#| code-fold: true
hermanos <- TRUE

library(lubridate) # sino lo tenÃ­as ya cargado
fecha_nacimiento <- as_date("1989-09-10")
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Define otra variable con tus apellidos (llamada `apellidos`) y usa `glue()` para tener, en una sola variable llamada `nombre_completo`, tu nombre y apellidos separando nombre y apellido por una coma

```{r}
#| code-fold: true
#| eval: false
apellidos <- "Ãlvarez LiÃ©bana"
glue("{nombre}, {apellidos}")
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ De `fecha_nacimiento` extrae el mes.

```{r}
#| code-fold: true
#| eval: false
month(fecha_nacimiento)
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Calcula los dÃ­as que han pasado desde la fecha de tu nacimiento hasta hoy (con la fecha de nacimiento definida en el ejercicio 4).

```{r}
#| code-fold: true
#| eval: false
today() - fecha_nacimiento
```
:::

---

## Vectores: concatenar

Cuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenaciÃ³n**]{.hl-purple} de celdas (valores) del [**mismo tipo**]{.hl-purple} (lo que serÃ­a una columna de una tabla).

. . .

La forma mÃ¡s sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus **elementos entre parÃ©ntesis y separados por comas**

```{r}
edades <- c(32, 27, 60, 61)
edades
```

. . .

::: callout-tip
Un nÃºmero individual `x <- 1` (o bien `x <- c(1)`) es en realidad un **vector de longitud uno** --\> todo lo que sepamos [**hacer con un nÃºmero podemos hacerlo con un vector de ellos**]{.hl-green}.
:::

---

## Vectores: concatenar

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}
Como ves ahora en el `environment` tenemos una **colecciÃ³n de elementos** guardada

```{r}
edades
```
:::
:::

. . .

La [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`

```{r}
length(edades)
```

. . .

TambiÃ©n podemos [**concatenar vectores**]{.hl-yellow} entre sÃ­ (los repite uno tras otro)

```{r}
c(edades, edades, 8)
```

---

## Secuencias numÃ©ricas

El vector mÃ¡s famoso serÃ¡ el de tipo numÃ©rico, y en concreto, las conocidas como [**secuencias numÃ©ricas**]{.hl-yellow} (por ejemplo, los dÃ­as del mes), usadas para, entre otras cosas, indexar bucles.

. . .

El comando `seq(inicio, fin)` nos permite crear una [**secuencia numÃ©rica**]{.hl-yellow} desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.

```{r}
seq(1, 31)
```

. . .

FÃ­jate que si hacemos eso con [**caracteres no podremos hacerlo**]{.hl-red} ya que no hay un orden a priori entre textos.

```{r}
#| error: true
"a":"z"
```

---

## Secuencias numÃ©ricas

Un atajo es el comando `1:n`, que nos devuelve lo mismo que `seq(1, n)`

```{r}
1:7
```

Si el elemento inicial es mayor que el final, entenderÃ¡ que la secuencia es [**en orden decreciente**]{.hl-purple}.

```{r}
7:-3
```

. . .

TambiÃ©n podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos con el argumento `by = ...`

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

---

## Secuencias numÃ©ricas

Otras veces nos interesarÃ¡ definir una [**secuencia con una longitud concreta**]{.hl-yellow}

```{r}
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```

. . .

Incluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}

```{r}
rep(0, 7) # vector de 7 ceros
```

. . .

Dado que internamente son guardados como nÃºmeros tambiÃ©n podremos hacer esto con [**fechas**]{.hl-yellow}.

```{r}
seq(as_date("2023-09-01"), as_date("2023-09-10"), by = 1)
```

---

## Vectores de caracteres

Un vector es una **concatenaciÃ³n** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente nÃºmeros. Vamos a crear una frase de ejemplo.

```{r}
frase <- "Me llamo Javi"
frase
length(frase)
```

. . .

En el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas

```{r}
vector <- c("Me", "llamo", "Javi")
vector
length(vector)
```

---

## Vectores de caracteres

Â¿QuÃ© sucederÃ¡ si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

FÃ­jate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}

. . .

```{r}
c(3, 4, TRUE, FALSE)
```

Es importante entender que los valores lÃ³gicos en realidad estÃ¡n [**almacenados internamente como 0/1**]{.hl-yellow}

---

## Operaciones con vectores

Con los vectores numÃ©ricos podemos hacer las mismas [**operaciones aritmÃ©ticas**]{.hl-yellow} que con los nÃºmeros â†’ un [**nÃºmero es un vector**]{.hl-purple} (de longitud uno)

. . .

Â¿QuÃ© sucederÃ¡ si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Cuidado

Salvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}
:::

---

## Suma de vectores

Los vectores tambiÃ©n pueden interactuar entre ellos, asÃ­ que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)

```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Dado que la operaciÃ³n (por ejemplo, una suma) se realiza elemento a elemento, Â¿quÃ© sucederÃ¡ si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?

. . .

```{r}
z <- c(1, 3, 5, 7)
x + z
```

Lo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que harÃ¡ serÃ¡ reciclar del vector con menor longitud.

---

## Comparar vectores

Una operaciÃ³n muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones lÃ³gicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...

[**Â¿QuÃ© dÃ­as hizo menos de 22 grados?**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

Nos devolverÃ¡ un [**vector lÃ³gico**]{.hl-yellow}, en funciÃ³n de si **cada elemento** cumple o no la condiciÃ³n pedida (de **igual longitud** que el vector preguntado)

. . .

Si tuviÃ©ramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese dÃ­a), la condiciÃ³n evaluada tambiÃ©n serÃ­a `NA`

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Comparar vectores

Las [**condiciones lÃ³gicas pueden ser combinadas**]{.hl-yellow} de dos maneras:

-   [**IntersecciÃ³n**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunciÃ³n y**]{.hl-purple} con `&`) para devolver un `TRUE`

```{r}
x < 30 & x > 15
```

-   [**UniÃ³n**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunciÃ³n o**]{.hl-purple} con `|`)

```{r}
x < 30 | x > 15
```

. . .

Con `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen

```{r}
any(x < 30)
all(x < 30)
```

---

## Acceder a elementos

Otra operaciÃ³n muy habitual es la de [**acceder a elementos**]{.hl-yellow}. La forma mÃ¡s sencilla es usar el operador `[i]` (acceder al elemento i-Ã©simo)

```{r}
edades <- c(20, 30, 33, NA, 61) 
edades[3] # accedemos a la edad de la tercera persona 
```

. . .

Dado que un nÃºmero no es mÃ¡s que un vector de longitud uno, esta operaciÃ³n tambiÃ©n la podemos aplicar usando un [**vector de Ã­ndices a seleccionar**]{.hl-yellow}

```{r}
y <- c("hola", "quÃ©", "tal", "estÃ¡s", "?")
y[c(1:2, 4)] # primer, segundo y cuarto elemento
```

. . .

::: callout-tip
Para acceder al Ãºltimo, sin preocuparnos de cuÃ¡l es, podemos pasarle como Ã­ndice la propia longitud `x[length(x)]`
:::

---

## Eliminar elementos

Otras veces no querremos seleccionar sino [**eliminar algunos elementos**]{.hl-yellow}. Deberemos repetir la misma operaciÃ³n pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-Ã©simo del vector sino que lo Â«des-seleccionaÂ»

```{r}
y
y[-2]
```

. . .

En muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones lÃ³gicas**]{.hl-yellow}, en funciÃ³n de los valores, asÃ­ que pasaremos como Ã­ndice la propia condiciÃ³n (recuerda, `x < 2` nos devuelve un vector lÃ³gico)

```{r}
edades <- c(15, 21, 30, 17, 45)
nombres <- c("javi", "marÃ­a", "laura", "carla", "luis")
nombres[edades < 18] # nombres de los menores de edad
```

---

## Sumar vectores

TambiÃ©n podemos hacer uso de [**operaciones estadÃ­sticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**Â¿QuÃ© sucede cuando falta un dato (ausente)?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

Por defecto, si tenemos un dato ausente, la [**operaciÃ³n tambiÃ©n serÃ¡ ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`

```{r}
sum(x, na.rm = TRUE)
```

---

## Sumar vectores

Como hemos comentado que los valores lÃ³gicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritmÃ©ticas.

Por ejemplo, si queremos [**averiguar el nÃºmero de elementos que cumplen una condiciÃ³n**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendrÃ¡n asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar dicho vector lÃ³gico para obtener el nÃºmero de elementos que cumplen

```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Suma acumulada

Otra operaciÃ³n habitual que puede sernos Ãºtil es la [**suma acumulada**]{.hl-yellow} con `cumsum()` que, dado un vector, nos devuelve un vector a su vez con el primero, el primero mÃ¡s el segundo, el primero mÃ¡s el segundo mÃ¡s el tercero...y asÃ­ sucesivamente.

```{r}
x <- c(1, 5, 2, -1, 8)
cumsum(x)
```

[**Â¿QuÃ© sucede cuando falta un dato (ausente)?**]{.hl-yellow}

```{r}
x <- c(1, -2, 3, NA, -1)
cumsum(x)
```

En el caso de la suma acumulada lo que sucede es que [**a partir de ese valor, todo lo acumulado posterior serÃ¡ ausente**]{.hl-yellow}.

---

## Diferencia

Otra operaciÃ³n habitual que puede sernos Ãºtil es la [**diferencia (con retardo)**]{.hl-yellow} con `diff()` que, dado un vector, nos devuelve un vector con el segundo menos el primero, el tercero menos el segundo, el cuarto menos el tercero...y asÃ­ sucesivamente.

```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x)
```

. . .

Con el argumento `lag =` podemos indicar el [**retardo**]{.hl-yellow} de dicha diferencia (por ejemplo, `lag = 3` implica que se resta el cuarto menos el primero, el quinto menos el segundo, etc)

```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x, lag = 3)
```

---

## Media

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La mÃ¡s conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores atÃ­picos o outliers (valores muy grandes o muy pequeÃ±os), la media se perturba con mucha facilidad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Percentiles

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Percentiles**]{.hl-yellow}: medidas de posiciÃ³n (nos dividen en partes iguales los datos).

```{r}
quantile(x) # por defecto percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

---

## Ordenar vectores

Por Ãºltimo, una acciÃ³n habitual es saber [**ordenar valores**]{.hl-yellow}:

-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(edades)
sort(edades, decreasing = TRUE)
```

. . .

-   `order()`: devuelve el [**vector de Ã­ndices**]{.hl-yellow} que tendrÃ­amos que usar para tener el vector ordenado

```{r}
order(x)
x[order(x)]
```

---

## ğŸ’» Tu turno {#tu-turno-1-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Define el vector `x` como la concatenaciÃ³n de los 5 primeros nÃºmeros impares. Calcula la longitud del vector

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Accede al tercer elemento de `x`. Accede al Ãºltimo elemento (sin importar la longitud, un cÃ³digo que pueda ejecutarse siempre). Elimina el primer elemento.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ ObtÃ©n los elementos de `x` mayores que 4. Calcula el vector `1/x` y guÃ¡rdalo en una variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Crea un vector que represente los nombres de 5 personas, de los cuales uno es desconocido.

```{r}
#| code-fold: true
#| eval: false
nombres <- c("Javi", "Sandra", NA, "Laura", "Carlos")
nombres
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Encuentra del vector `x` de ejercicios anteriores los elementos mayores (estrictos) que 1 Y ADEMÃS menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, Â¿por quÃ© su media no devuelve un nÃºmero sino lo que se muestra en el cÃ³digo inferior?

```{r}
x <- c(1, -5, 8, NA, 10, -3, 9)
mean(x)
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6.

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
x[-2]
```

### [**Ejercicio 8**]{.hl-yellow}

ğŸ“ Dado el vector `x` del ejercicio anterior, Â¿cuales tienen un dato ausente? Pista: las funciones `is.algo()` comprueban si el elemento es tipo `algo` (tabula)

```{r}
#| code-fold: true
#| eval: false
is.na(x)
```

### [**Ejercicio 9**]{.hl-yellow}

ğŸ“ Define el vector `x` como la concatenaciÃ³n de los 4 primeros nÃºmeros pares. Calcula el nÃºmero de elementos de `x` menores estrictamente que 5.

```{r}
#| code-fold: true
#| eval: false
x[x < 5] 
sum(x < 5)
```

### [**Ejercicio 10**]{.hl-yellow}

ğŸ“ Calcula el vector `1/x` y obtÃ©n la versiÃ³n ordenada (de menor a mayor) de las dos formas posibles

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Ejercicio 11**]{.hl-yellow}

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Ejercicio 12**]{.hl-yellow}

ğŸ“ Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 6. Encuentra una forma de averiguar si todos los elementos son o no negativos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```
:::

## ğŸ£ Caso prÃ¡ctico I: vectores {#caso-practico-1-1}

En el paquete `{datasets}` (ya instalado por defecto) tenemos diversos conjuntos de datos y uno de ellos es `airquality`. Debajo te he extraÃ­do 3 variables de dicho dataset (fÃ­jate que se hace con `datos$variable`, ese dolar serÃ¡ importante en el futuro).

Los datos capturan [**medidas diarias (n = 153 observaciones) de la calidad del aire**]{.hl-yellow} en Nueva York, de mayo a septiembre de 1973. Se midieron **6 variables**: niveles de ozono, radiaciÃ³n solar, viento, temperatura, mes y dÃ­a.

```{r}
library(datasets)
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/intro-r-vectores-isciii/)

# Clase 2: [primeras bases de datos]{.flow} {#clase-2}

[**Primera base de datos: matrices, data.frame y tibble**]{style="color:#444442;"}

-   [ğŸ’» Ejercicios resueltos: matrices](#tu-turno-2-1)
-   [ğŸ’» Ejercicios resueltos: data.frame y tibble](#tu-turno-2-2)
-   [ğŸ£ Workbook/caso prÃ¡ctico: tibble](#caso-practico-2-1)
-   [ğŸ£ Workbook/caso prÃ¡ctico: Quarto](#caso-practico-2-2)
-   [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## Primera base de datos

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una Â«tablaÂ» que las recopile. La opciÃ³n mÃ¡s inmediata son las [**matrices**]{.hl-yellow}: concatenaciÃ³n de variables del [**mismo tipo e igual longitud**]{.hl-purple}.

Imagina que tenemos estaturas y pesos de 4 personas. Â¿CÃ³mo [**crear un dataset con las dos variables**]{.hl-yellow}?

. . .

La opciÃ³n mÃ¡s habitual es usando `cbind()`: [**concatenamos (bind) vectores en forma de columnas (c)**]{.hl-yellow}

```{r}
#| code-line-numbers: "3"
estaturas <- c(150, 160, 170, 180)
pesos <- c(63, 70, 85, 95)
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

---

## Primer intento: matrices

TambiÃ©n podemos [**construir la matriz por filas**]{.hl-yellow} con la funciÃ³n `rbind()` (concatenar - bind - por filas - rows), aunque lo [**recomendable es tener cada variable en columna**]{.hl-green} e individuo en fila como luego veremos.

```{r}
rbind(estaturas, pesos) # Construimos la matriz por filas
```

. . .

-   Podemos [**Â«visualizarÂ» la matriz**]{.hl-yellow} con `View(matriz)`.

. . .

-   Podemos [**comprobar las dimensiones**]{.hl-yellow} con `dim()`, `nrow()` y `ncol()`: las matrices son un tipo de **datos tabulados** (organizados en filas y columnas)

```{r}
dim(datos_matriz)
nrow(datos_matriz)
ncol(datos_matriz)
```

---

## Primer intento: matrices

TambiÃ©n podemos [**Â«darle vueltaÂ» (matriz transpuesta)**]{.hl-yellow} con `t()`.

```{r}
t(datos_matriz)
```

. . .

Dado que ahora tenemos dos dimensiones en nuestros datos, para [**acceder a elementos con `[]`**]{.hl-yellow} deberemos proporcionar **dos Ã­ndices separados por comas**: Ã­ndice de la fila y de la columna

```{r}
datos_matriz[2, 1] # segunda fila, primera columna
datos_matriz[1, 2] # primera fila, segunda columna 
```

---

## Primer intento: matrices

En algunas casos querremos obtener los [**datos totales de un individuo**]{.hl-yellow} (una fila concreta pero todas las columnas) o los valores de [**toda una variable**]{.hl-yellow} para todos los individuos (una columna concreta pero todas las filas). Para ello dejaremos [**sin rellenar uno de los Ã­ndices**]{.hl-yellow}

```{r}
datos_matriz[2, ] # segundo individuo
datos_matriz[, 1] # primera variable
```

. . .

Mucho de lo aprendido con vectores podemos hacerlo con matrices, asÃ­ podemos por ejemplo acceder a varias filas y/o columnas haciendo uso de las [**secuencias de enteros 1:n**]{.hl-yellow}

```{r}
datos_matriz[c(1, 3), 1] # primera variable para el primer y tercer individuo
```

---

## Primer intento: matrices

TambiÃ©n podemos definir una [**matriz a partir de un vector numÃ©rico**]{.hl-yellow}, reorganizando los valores en forma de matriz (sabiendo que los elementos se van [**colocando por columnas**]{.hl-purple}).

```{r}
z <- matrix(1:9, ncol = 3) 
z
```

. . .

Incluso podemos [**definir una matriz de valores constantes**]{.hl-yellow}, por ejemplo de ceros (para luego rellenar)

```{r}
matrix(0, nrow = 2, ncol = 3)
```

---

## Operaciones con matrices

Con las matrices sucede como con los vectores: cuando aplicamos una [**operaciÃ³n aritmÃ©tica lo hacemos elemento a elemento**]{.hl-yellow}

```{r}
z/5
```

. . .

Para realizar [**operaciones en un sentido matricial**]{.hl-yellow} deberemos aÃ±adir `%%`, por ejemplo, para multiplicar matrices serÃ¡ `%*%`

```{r}
z * t(z)
z %*% t(z)
```

---

## Operaciones con matrices

TambiÃ©n podemos [**realizar operaciones por columnas/filas**]{.hl-yellow} sin recurrir a bucles con la funciÃ³n `apply()`, y le indicaremos como **argumentos**

-   la matriz
-   el sentido de la operaciÃ³n (`MARGIN = 1` por filas, `MARGIN = 2` por columnas)
-   la funciÃ³n a aplicar
-   argumentos extra que necesite la funciÃ³n

. . .

Por ejemplo, para aplicar una media a cada variable, serÃ¡ `mean` aplicada con `MARGIN = 2` (misma funciÃ³n para cada columna)

```{r}
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")
```

---

## ğŸ’» Tu turno (matrices) {#tu-turno-2-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para definir una matriz `x` de unos, de 3 filas y 7 columnas.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ A la matriz anterior, suma un 1 a cada nÃºmero de la matriz y divide el resultado entre 5. Tras ello calcula su transpuesta

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Â¿Por quÃ© el cÃ³digo inferior nos devuelve dicho mensaje de aviso?

```{r}
#| warning: TRUE
matrix(1:15, nrow = 4)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Define la matriz `x <- matrix(1:12, nrow = 4)`. Tras ello obtÃ©n los datos del primer individuo, los datos de la tercera variable, y el elemento `(4, 1)`.

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # primera fila
x[, 3] # tercera columna
x[4, 1] # elemento (4, 1)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Define una matriz de 2 variables y 3 individuos tal que cada variable capture la estatura y la edad 3 personas, de manera que la edad de la segunda persona sea desconocida (ausente). Tras ello calcula la media de cada variable (Â¡nos debe de volver un nÃºmero!)

```{r}
#| code-fold: true
#| eval: false
datos <- cbind("edad" = c(20, NA, 25), "estatura" = c(160, 165, 170))
apply(datos, MARGIN = 2, FUN = "mean", na.rm = TRUE) # media por columnas

```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Â¿Por quÃ© devuelve error el cÃ³digo inferior? Â¿QuÃ© estÃ¡ mal?

```{r}
#| error: true
matriz <- cbind("edad" = c(15, 20, 25), "nombres" = c("javi", "sandra", "carlos"))
matriz
matriz + 1
```
:::

---

## Segundo intento: data.frame

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte (fÃ­jate en el cÃ³digo inferior: las edades y los `TRUE/FALSE` los ha convertido a texto)

```{r}
#| code-line-numbers: "4-5"
edades <- c(14, 24, NA)
soltero <- c(TRUE, NA, FALSE)
nombres <- c("javi", "laura", "lucÃ­a")
matriz <- cbind(edades, soltero, nombres)
matriz
```

. . .

De hecho al no ser nÃºmeros ya no podemos realizar operaciones aritmÃ©ticas

```{r}
#| error: true
matriz + 1
```

---

## Segundo intento: data.frame

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos en `R` lo que se conoce como [**data.frame**]{.hl-yellow}: concatenaciÃ³n de variables de igual longitud pero que pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
tabla <- data.frame(edades, soltero, nombres)
class(tabla)
tabla
```

---

## Segundo intento: data.frame

Dado que un `data.frame` es ya un intento de Â«base de datosÂ» las variables no son meros vectores matemÃ¡ticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple} que describan su significado

```{r}
library(lubridate)
tabla <-
  data.frame("edad" = edades, "estado" = soltero, "nombre" = nombres,
             "f_nacimiento" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
tabla
```

---

## Segundo intento: data.frame

[**Â¡TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} (estrictamente no podemos hablar de base de datos pero de momento como lo si fuesen). Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

![](img/view_tabla.jpg)

---

## Acceso a variables

Si queremos acceder a sus elementos, al ser de nuevo **datos tabulados**, podemos acceder como en las matrices ([**no recomendable**]{.hl-red}): de nuevo [**tenemos dos Ã­ndices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera caracterÃ­stica de la segunda persona
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
Pero tambiÃ©n tiene las ventajas de una [**Â«baseÂ» de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} ([**lo recomendable**]{.hl-green} ya que las variables pueden cambiar de posiciÃ³n y ahora sÃ­ tienen un significado), poniendo el nombre de la tabla seguido del sÃ­mbolo `$` (con el **tabulador**, nos aparecerÃ¡ un menÃº de columnas a elegir)
:::
:::

---

## Funciones de consulta

-   `names()`: nos muestra los nombres de las variables

```{r}
names(tabla)
```

. . .

-   `dim()`: nos muestra las dimensiones (tambiÃ©n `nrow()` y `ncol()`)

```{r}
dim(tabla)
```

. . .

-   Podemos acceder a las variables por su nombre

```{r}
tabla[c(1, 3), "nombre"]
tabla$nombre[c(1, 3)]
```

---

## AÃ±adir variable

Si tenemos uno ya creado y queremos [**aÃ±adir una columna**]{.hl-yellow} es tan simple como usar la funciÃ³n `data.frame()` que ya hemos visto para concatenar la columna. Vamos aÃ±adir por ejemplo una nueva variable, el nÃºmero de hermanos de cada individuo.

```{r}
# AÃ±adimos una nueva columna con nÂº de hermanos/as
hermanos <- c(0, 2, 3)
tabla <- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

---

## Intento final: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}. La principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```

. . .

En adelante usaremos el formato `tibble` ([**data.frame mejorado**]{.hl-yellow}) del paquete `{tibble}`

```{r}
library(tibble)
datos_tb <- 
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
class(datos_tb)
datos_tb
```

---

## Intento final: tibble

```{r}
datos_tb <-
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
datos_tb
```

Las tablas en formato `tibble` nos permitirÃ¡ una [**gestiÃ³n mÃ¡s Ã¡gil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

-   [**MetainformaciÃ³n**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya automÃ¡ticamente el nÃºmero de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

---

## Intento final: tibble

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
datos_tb$invent
```

. . .

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de pÃ¡ginas web y documentos sencillos
:::

---

## Recapitulando

-   Cada [**celda puede ser de un tipo diverso**]{.hl-yellow}: nÃºmeros, texto, fechas, valores lÃ³gicos, etc

. . .

-   Un [**vector es una concatenaciÃ³n de celdas**]{.hl-yellow} (las futuras columnas de nuestras tablas) --\> En `R` por defecto las operaciones se hacen [**elemento a elemento**]{.hl-yellow}

. . .

-   Una [**matriz**]{.hl-yellow} nos permite concatenar [**variables del MISMO tipo y MISMA longitud**]{.hl-yellow} --\> datos tabulados

. . .

-   Un [**data.frame**]{.hl-yellow} nos permite concatenar [**variables de DISTINTO tipo y MISMA longitud**]{.hl-yellow} --\> usaremos [**tibble**]{.hl-yellow} como una opciÃ³n mejorada de base de datos

---

## ğŸ’» Tu turno (tb/df) {#tu-turno-2-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Carga del paquete `{datasets}` el conjunto de datos `airquality` (variables de la calidad del aire de Nueva York desde mayo hasta septiembre de 1973). Â¿Es el conjunto de datos airquality de tipo tibble? En caso negativo, conviÃ©rtelo a tibble (busca en la documentaciÃ³n del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Una vez convertido a `tibble` obtÃ©n el nombre de las variables y las dimensiones del conjunto de datos. Â¿CuÃ¡ntas variables hay? Â¿CuÃ¡ntos dÃ­as se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Filtra solo los datos de la quinta observaciÃ³n

```{r}
#| code-fold: true
#| eval: false
airquality_tb[5, ]
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para filtrar solo los datos del mes de agosto. Â¿CÃ³mo indicarle que queremos solo las filas que cumplan una condiciÃ³n concreta? (pista: en realidad todo son vectores "formateados")

```{r}
#| eval: false
airquality_tb[Month == 8, ]
```

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, ]
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Selecciona aquellos datos que no sean ni de julio ni de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month != 7 & airquality_tb$Month != 8, ]

# otra forma
airquality_tb[!(airquality_tb$Month %in% c(7, 8)), ]
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Modifica el siguiente cÃ³digo para quedarte solo con las variable de ozono y temperatura (sin importar quÃ© posiciÃ³n ocupen)

```{r}
#| eval: false
airquality_tb[, 3]
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Selecciona los datos de temperatura y viento de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, c("Temp", "Wind")]
```

### [**Ejercicio 8**]{.hl-yellow}

ğŸ“ Traduce a castellano el nombre de las variables.

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```
:::

---

## ğŸ£ Caso prÃ¡ctico I: tibble {#caso-practico-2-1}

Del paquete `{Biostatistics}` usaremos el conjunto de datos `pinniped`, que guarda los **datos de peso de cuerpo y cerebro** (desagregado por sexo y mono/poligamia) de 33 especies de mamÃ­feros marinos.

```{r}
#| eval: false
Biostatistics::pinniped
```

```{r}
#| echo: false
#| warning: false
#| message: false
library(dplyr)
Biostatistics::pinniped |> slice(1:5)
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/matrices-tibble-isciii)

---

## ğŸ£ Caso prÃ¡ctico II: Taylor Swift {#caso-practico-2-2}

Del paquete `{taylor}` vamos a usar el conjunto de datos `taylor_album_songs` para poner en prÃ¡ctico lo aprendido sobre bases de datos y manejo de variables. Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/matrices-tibble-isciii)

```{r}
library(taylor)
taylor_album_songs
```

# Clase 3: [if-elses, bucles y Quarto]{.flow} {#clase-3}

[**Estructuras condicionales, bucles y Quarto**]{style="color:#444442;"}

-   [ğŸ’» Ejercicios resueltos: estructuras condicionales](#tu-turno-3-1)
-   [ğŸ’» Ejercicios resueltos: bucles](#tu-turno-3-2)
-   [ğŸ£ Workbook/caso prÃ¡ctico: bucles y condicionales](#caso-practico-3-1)
-   [ğŸ‘¾ Materiales extras R base](#extra-Rbase)
-   [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## Estructuras de control

Una [**estructura de control**]{.hl-yellow} se compone de una serie de comandos orientados a [**decidir el camino**]{.hl-yellow} que tu cÃ³digo debe recorrer

-   Si se cumple la condiciÃ³n A, Â¿quÃ© sucede?

-   Â¿Y si sucede B?

-   Â¿CÃ³mo puedo repetir una misma expresiÃ³n (dependiendo de una variable)?

. . .

Si has programado antes, quizÃ¡s te sea familiar las conocidas como [**estructuras condicionales**]{.hl-yellow} tales como `if (blabla) {...} else {...}` o [**bucles**]{.hl-yellow} `for/while` (a evitar siempre que podamos).

---

## Estructura If

Una de las estructuras de control mÃ¡s famosas son las conocidas como [**estructuras condicionales**]{.hl-yellow} `if`.

> SI (IF) un conjunto de condiciones se cumple (TRUE), entonces ejecuta lo que haya dentro de las llaves

Por ejemplo, la estructura `if (x == 1) { cÃ³digo A }` lo que harÃ¡ serÃ¡ [**ejecutar el cÃ³digo A entre llaves**]{.hl-yellow} pero [**SOLO SI**]{.hl-purple} la [**condiciÃ³n entre parÃ©ntesis es cierta**]{.hl-purple} (solo si `x` es 1). En cualquier otro caso, no harÃ¡ nada.

. . .

Por ejemplo, definamos un vector de edades de 8 personas

```{r}
edad <- c(14, 17, 24, 56, 31, 20, 87, 73)
edad < 18
```

---

## Estructura If

Nuestra estructura condicional harÃ¡ lo siguiente: [**si existe algÃºn menor de edad, imprimirÃ¡**]{.hl-yellow} por pantalla un mensaje.

```{r}
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```

---

## Estructura If

```{r}
#| eval: false
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```

En caso de que las [**condiciones no sean ciertas**]{.hl-yellow} dentro de `if()` (`FALSE`), no sucede nada

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
}
```

**No obtenemos ningÃºn mensaje** porque la condiciÃ³n `all(edad >= 18)` no es `TRUE`, asÃ­ que no ejecuta nada.

---

## Estructura If-else

La estructura `if (condicion) { cÃ³digo A }` puede combinarse con un `else { cÃ³digo B }`: cuando la [**condiciÃ³n no estÃ¡ verificada**]{.hl-yellow}, se [**ejecutarÃ¡ el cÃ³digo alternativo B**]{.hl-yellow} dentro de `else { }`, permitiÃ©ndonos decidir que sucede cuando se cumple y cuando no.

. . .

Por ejemplo, `if (x == 1) { cÃ³digo A } else { cÃ³digo B }` ejecutarÃ¡ A si `x` es igual a 1 y B en cualquier otro caso.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else {
  
  print("Existe alguna persona menor de edad")
}
```

---

## Estructura If-else

Esta estructura `if - else` puede ser [**anidada**]{.hl-yellow}: imagina que queremos ejecutar un cÃ³digo si todos son menores; si no sucede, pero todos son mayores de 16, hacer otra cosa; en cualquier otra cosa, otra acciÃ³n.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else if (all(edad >= 16)) {
  
  print("Hay algÃºn menor de edad pero todos con 16 aÃ±os o mÃ¡s")
  
} else { print("Hay alguna persona con menos de 16 aÃ±os") }
```

::: callout-note
## Truco

Puedes **colapsar las estructuras** haciendo click en la flecha a la izquierda que aparece en tu script.
:::

---

## If-else vectorizado

Esta estructura condicional se puede [**vectorizar**]{.hl-yellow} (en una sola lÃ­nea) con `if_else()` (del paquete `{dplyr}`), cuyos argumentos son

-   la condiciÃ³n a evaluar
-   lo que sucede cuando se cumple y cuando no
-   un argumento opcional para cuando la condiciÃ³n a evaluar es `NA`

Vamos a etiquetar sin son mayores/menores y un "desconocido" cuando no conocemos

```{r}
library(dplyr)
edad <- c(NA, edad)
if_else(edad >= 18, "mayor", "menor", missing = "desconocido")
```

En `R` base existe `ifelse()`: no deja especificar que hacer con los ausentes pero permite especificar distintos tipos de datos en `TRUE` y en `FALSE`.

---

## ğŸ’» Tu turno {#tu-turno-3-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Â¿CuÃ¡l es la salida del siguiente cÃ³digo?

```{r}
#| eval: false
if_else(sqrt(9) < 2, sqrt(9), 0)
```

```{r}
#| eval: false
#| code-fold: true

La salida es 0 ya que sqrt(9) es igual 3, y dado que no es menor que 2, devuelve el segundo argumento que es 0
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Â¿CuÃ¡l es la salida del siguiente cÃ³digo?

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true

La salida es el vector c(0, NA, NA, 1) ya que sqrt(1) sÃ­ es menor que 2, sqrt(9) no lo es, y tanto en el caso de sqrt(NA) (raÃ­z de ausente) como sqrt(-1) (devuelve NaN, not a number), su raÃ­z cuadrada no puede verificarse si es menor que 2 o no, asÃ­ que la salida es NA.
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para que, cuando no se pueda verificar si la raÃ­z cuadrada de un nÃºmero es menor que 2, devuelva -1

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1, missing = -1)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Â¿CuÃ¡l es son los valores de `x` e `y` del cÃ³digo inferior para `z <- 1`, `z <- -1` y `z <- -5`?

```{r}
#| eval: false
z <- -1
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
En primero caso x = 1 e y = -1. En el segundo caso x = 1 e y = 1. En el tercer caso -2.5 y 5
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Â¿QuÃ© pasarÃ­a si ejecutamos el siguiente cÃ³digo? Spoiler: da error. Â¿Por quÃ©? Â¿CÃ³mo solucionarlo?

```{r}
#| eval: false
z <- c(-1, 1, 5)
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
Da error ya que en los `if (condiciÃ³n) { } else { }` "clÃ¡sicos" necesitamos que
la condiciÃ³n tenga longitud uno (un solo valor TRU/FALSE)
```

```{r}
#| eval: false
#| code-fold: true
# para arreglarlo podemos hacer un if_else vectorial
z <- c(-1, 1, -5)
library(dplyr)
x <- if_else(z > 0, z^3, if_else(abs(z) < 2, z^4, z/2))
y <- if_else(z > 0, -sqrt(z), if_else(abs(z) < 2, sqrt(-z), abs(z)))
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Â¿QuÃ© sucederÃ¡ si ejecutamos el cÃ³digo inferior?

```{r}
#| eval: false
z <- "a"
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| code-fold: true
#| eval: false

# darÃ¡ error ya que no es un argumento numÃ©rico
Error in z^3 : non-numeric argument to binary operator
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Del paquete `{lubridate}`, la funciÃ³n `hour()` nos devuelve la hora de una fecha dada, y la funciÃ³n `now()` nos devuelve fecha y hora del momento actual. Con ambas funciones haz que se imprima por pantalla (`cat()`) "buenas noches" solo a partir de las 21 horas.

```{r}
#| code-fold: true
#| eval: false

# Cargamos librerÃ­a
library(lubridate)

# Fecha-hora actual
fecha_actual <- now()

# Estructura if
if (hour(fecha_actual) > 21) {
  
  cat("Buenas noches") # print/cat dos formas de imprimir por pantalla
}
```
:::

---

## Bucles {#bucles}

Aunque en la mayorÃ­a de ocasiones se pueden reemplazar por otras estructuras mÃ¡s eficientes y legibles, es importante conocer una de las expresiones de control mÃ¡s famosas: los [**bucles**]{.hl-yellow}.

-   `for { }`: permite [**repetir el mismo cÃ³digo**]{.hl-yellow} en un [**nÃºmero prefijado y conocido**]{.hl-purple} de veces.

-   `while { }`: permite [**repetir el mismo cÃ³digo**]{.hl-yellow} pero en un [**nÃºmero indeterminado de veces**]{.hl-purple} (hasta que una **condiciÃ³n** deje de cumplirse).

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de Ã³rdenes un nÃºmero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de Ã­ndices.

Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacÃ­a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los parÃ©ntesis indicaremos un Ã­ndice y unos valores a recorrer, dentro de las llaves el cÃ³digo a ejecutar en cada iteraciÃ³n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()
```

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de Ã³rdenes un nÃºmero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de Ã­ndices.

Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacÃ­a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los parÃ©ntesis indicaremos un Ã­ndice y unos valores a recorrer, dentro de las llaves el cÃ³digo a ejecutar en cada iteraciÃ³n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  
}
```

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de Ã³rdenes un nÃºmero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de Ã­ndices.

Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacÃ­a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los parÃ©ntesis indicaremos un Ã­ndice y unos valores a recorrer, dentro de las llaves el cÃ³digo a ejecutar en cada iteraciÃ³n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
```

---

## Bucles for

FÃ­jate que debido a que `R` funciona de manera [**vectorial por defecto**]{.hl-yellow}, el bucle es lo mismo que hacer `x + 1` directamente.

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
y

y2 <- x + 1
y2
```

---

## Bucles for

Otra opciÃ³n habitual es indicar los Ã­ndices de manera Â«automÃ¡ticaÂ»: desde el primero `1` hasta el Ãºltimo (que corresponde con la longitud de x `length(x)`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:length(x)) {
  y[i] <- x[i] + 1
}
y

```

---

## Bucles for

AsÃ­ la [**estructura general de un bucle for**]{.hl-yellow} serÃ¡ siempre la siguiente

```{r}
#| eval: false
for (Ã­ndice in conjunto) { 
  cÃ³digo (dependiente de i)
}
```

[**SIEMPRE**]{.hl-green} sabemos cuÃ¡ntas iteraciones tenemos (tantas como elementos haya en el conjunto a indexar)

---

## Evitando bucles

Como ya hemos aprendido con el paquete`{microbenchmark}` podemos chequear como [**los bucles suelen ser muy ineficientes**]{.hl-yellow} (de ahÃ­ que debamos evitarlos en la mayorÃ­a de ocasiones

```{r}
library(microbenchmark)
x <- 1:1000
microbenchmark(y <- x^2, 
               for (i in 1:100) { y[i] <- x[i]^2 },
               times = 500)
```

---

## Bucles for

Podemos ver otro ejemplo de bucle [**combinando nÃºmeros y textos**]{.hl-yellow}: definimos un vector de edades y de nombres, e imprimimos el nombre y edad i-Ã©sima.

```{r}
nombres <- c("Javi", "Sandra", "Carlos", "Marcos", "Marta")
edades <- c(33, 27, 18, 43, 29)

for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} aÃ±os")) 
  
}
```

---

## Bucles for

Aunque normalmente se suelen indexar con vectors numÃ©ricos, los bucles pueden ser [**indexados sobre cualquier estructura vectorial**]{.hl-yellow}, da igual de que tipo sea el conjunto

```{r}
library(stringr)
week_days <- c("monday", "tuesday", "wednesday", "thursday",
               "friday", "saturday", "sunday")

for (days in week_days) {
  
  print(str_to_upper(days))
}
```

---

## Bucles y condicionales

Vamos a **combinar las estructuras condicionales y los bucles**: usando el conjunto `swiss` del paquete `{datasets}`, vamos a asignar `NA` si los valores de fertilidad son mayores de 80.

```{r}
for (i in 1:nrow(swiss)) {
  
  if (swiss$Fertility[i] > 80) { 
    
    swiss$Fertility[i] <- NA
    
  }
}
```

. . .

Esto es exactamente igual a un `if_else()` vectorizado

```{r}
data("swiss")
swiss$Fertility <- if_else(swiss$Fertility > 80, NA, swiss$Fertility)
```

---

## Bucles while

Otra forma de crear un bucle es con la estructura `while { }`, que nos ejecutarÃ¡ un bucle [**un nÃºmero desconocido de veces**]{.hl-yellow}, hasta que una condiciÃ³n [**deje de cumplirse**]{.hl-yellow} (de hecho puede que nunca termine). Por ejemplo, vamos a inializar una variable `ciclos <- 1`, que incrementaremos en cada paso, y no saldremos del bucle hasta que `ciclos > 4`.

```{r}
ciclos <- 1
while(ciclos <= 4) {
  
  print(glue("No todavÃ­a, vamos por el ciclo {ciclos}")) 
  ciclos <- ciclos + 1
  
}
```

---

## Bucles while

Un bucle `while` serÃ¡ siempre como sigue

```{r}
#| eval: false
while(condiciÃ³n) {
  
  cÃ³digo a hacer mientras la condiciÃ³n sea TRUE
  # normalmente aquÃ­ se actualiza alguna variable
  
}
```

---

## Bucles while

Â¿QuÃ© sucede cuando la [**condiciÃ³n nunca es FALSE**]{.hl-yellow}? PruÃ©balo tu mismo

```{r}
#| eval: false
while (1 > 0) {
  
  print("Presiona ESC para salir del bucle")
  
}
```

Â 

::: callout-warning
## Cuidado

Un bucle `while { }` puede ser bastante Â«peligrosoÂ» sino controlamos bien cÃ³mo pararlo.
:::

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

-   `break`: permite [**abortar un bucle**]{.hl-yellow} incluso si no se ha llegado a su final

```{r}
for(i in 1:10) {
  if (i == 3) {
    
    break # si i = 3, abortamos bucle
    
  }
  print(i)
}
```

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

-   `next`: [**fuerza un bucle a avanzar a la siguiente iteraciÃ³n**]{.hl-yellow}

```{r}
for(i in 1:5) {
  if (i == 3) {
    
    next # si i = 3, la obvia y continua al siguiente
    
  }
  print(i)
}
```

---

## Bucles repeat

Aunque no es tan usado como las opciones anteriores, tambiÃ©n contamos con `repeat { }` que ejecuta un [**bucle de manera infinita hasta que se indique abortar**]{.hl-yellow} con un break

```{r}
count <- 0
repeat { 
  
  count <- count + 1
  if (count >= 100) { break }
  
}
count
```

---

## Replicate

Aunque no es formalmente un bucle, otra forma de [**repetir cÃ³digo un nÃºmero de veces**]{.hl-yellow} es hacer uso de `replicate()`: simplemente permite repetir lo mismo [**n veces**]{.hl-yellow}

```{r}
x <- 1:3
replicate(n = 3, x^2)
```

---

## Replicate

La funciÃ³n `replicate()` se suele usar para [**generar distintas repeticiones de elementos aleatorios**]{.hl-yellow}. Por ejemplo, imaginemos que queremos generar 3 muestras de distribuciones normales, en la que cada muestra tendrÃ¡ 7 elementos. Para generar una se usa `rnorm(n = 7)` (r de resample, norm de normal, y si no se dice nada es media 0 y desv 1).

```{r}
replicate(n = 3, rnorm(n = 7))
```

---

## ğŸ’» Tu turno {#tu-turno-3-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para que se imprima un mensaje por pantalla si y solo si todos los datos de `airquality` son con mes distinto a enero

```{r}
#| eval: false
library(datasets)
months <- airquality$Month

if (months == 2) {
  print("No hay datos de enero")
}
```

```{r}
#| code-fold: true
#| eval: false
library(datasets)
months <- airquality$Month

if (all(months != 1)) {
  print("No hay datos de enero")
}
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para guardar en una variable llamada `temp_alta` un `TRUE` si alguno de los registros tiene una temperatura superior a 90 grados Farenheit y `FALSE` en cualquier otro caso

```{r}
#| eval: false
temp <- airquality$Temp

if (temp == 100) {
  print("Algunos de los registros tienen temperaturas superiores a 90 grados Farenheit")
}
```

```{r}
#| eval: false
#| code-fold: true
# Option 1
temp <- airquality$Temp
temp_alta <- FALSE
if (any(temp > 90)) {
   temp_alta <- TRUE
}

# Option 2
temp_alta <- any(airquality$Temp > 90)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para diseÃ±ar un bucle `for` de 5 iteraciones que solo recorra los primeros 5 impares (y en cada paso del bucle los imprima)

```{r}
#| eval: false
for (i in 1:5) {
  
  print(i)
}
```

```{r}
#| eval: false
#| code-fold: true
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i)
}
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para diseÃ±ar un bucle `while` que empiece con un contador `count <- 1` y pare cuando llegue a 6

```{r}
#| eval: false
count <- 1
while (count == 2) {
  
  print(count)
}
```

```{r}
#| eval: false
#| code-fold: true
count <- 1
while (count < 6) {
  
  print(count)
  count <- count + 1
  
}
```
:::

---

## ğŸ£ Caso prÃ¡ctico I {#caso-practico-3-1}

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/if-else-bucles-funciones-isciii/) donde tendrÃ¡s que diseÃ±ar algunos estudios de simulaciÃ³n haciendo uso de **bucles y estructuras condicionales**

---

## Comunicar: rmd y Quarto

Una de las [**principales fortalezas**]{.hl-yellow} de `R` es la [**facilidad para generar informes, libros, webs, apuntes y hasta diapositivas**]{.hl-yellow} (este mismo material por ejemplo). Para ello [**instalaremos**]{.hl-purple} antes

::: columns
::: {.column width="40%"}
-   el paquete `{rmarkdown}` (para generar archivos `.rmd`)

```{r}
#| eval: false
install.packages("rmarkdown")
```

-   instalar [**Quarto**](https://quarto.org/docs/get-started/) (si ya conocÃ­as `R`, el Â«nuevoÂ» `.rmd` ahora como `.qmd`)
:::

::: {.column width="60%"}
![](img/quarto.png)
:::
:::

---

## Comunicar: rmd y Quarto

Hasta ahora solo hemos programado en scripts (archivos `.R`) dentro de proyectos, pero en muchas ocasiones [**no trabajaremos solos**]{.hl-yellow} y necesitaremos [**comunicar los resultados**]{.hl-yellow} en diferentes formatos:

-   apuntes (para nosotros mismos)
-   diapositivas
-   web
-   informes

Para todo ello usaremos [**Quarto**]{.hl-yellow} (ver mÃ¡s en <https://ivelasq.quarto.pub/intro-to-quarto/>)

---

## Comunicar: rmd y Quarto

Los archivos de extensiÃ³n `.qmd` (o `.rmd` antes) nos permitirÃ¡n fÃ¡cilmente combinar:

-   [**Markdown**]{.hl-yellow}: [**lenguaje tipado**]{.hl-purple} que nos permite crear contenido simple (tipo wordpress, con texto, **negritas**, *cursivas*, etc) con un diseÃ±o legible.

. . .

-   [**MatemÃ¡ticas (latex)**]{.hl-yellow}: lenguaje para escribir notaciÃ³n matemÃ¡tica como $x^2$ o $\sqrt{y}$ o $\int_{a}^{b} f(x) dx$

. . .

-   [**CÃ³digo y salidas**]{.hl-yellow}: podremos no solo mostrar el paso final sino el cÃ³digo que has ido realizando (en `R`, `Python`, `C++`, `Julia`, ...), con [**cajitas de cÃ³digo llamadas CHUNKS**]{.hl-purple}.

. . .

-   ImÃ¡genes, [**grÃ¡ficas**]{.hl-yellow}, tablas, estilos (css, js), etc.

---

## Comunicar: rmd y Quarto

La principal ventaja de realizar este tipo de material en Quarto/Rmarkdown es que, al hacerlo desde `RStudio`, puedes generar un [**informe o una presentaciÃ³n sin salirte del entorno de programaciÃ³n**]{.hl-yellow} en el que estÃ¡s trabajando

De esta forma podrÃ¡s analizar los datos, resumirlos y a la vez comunicarlos con la misma herramienta.

. . .

Recientemente el equipo de `RStudio` desarrollÃ³ [**Quarto**]{.hl-yellow}, una versiÃ³n mejorada de Rmarkdown (archivos `.qmd`), con un formato un poco mÃ¡s estÃ©tico y simple. Tienes toda la documentaciÃ³n y ejemplos en [**https://quarto.org/**](https://quarto.org/)

---

## Usos de Quarto

::: panel-tabset
### Webs

![](./img/website.png){height="350"}

### Libros

![](./img/book.png){height="350"}

### Blogs

![](./img/blog.png){height="350"}

### Presentaciones

![](./img/presentation.png){height="350"}

### Revistas

![](https://user-images.githubusercontent.com/163582/42351114-e5deaa1c-8078-11e8-90de-2aff57bba255.png){height="350"}
:::

ImÃ¡genes obtenidas de <https://ivelasq.quarto.pub/intro-to-quarto/#/working-with-the-rstudio-visual-editor>

---

## Nuestro primer informe

::: columns
::: {.column width="55%"}
![](img/quarto-create.png)
:::

::: {.column width="45%"}
Vamos a crear el [**primer fichero rmarkdown con Quarto**]{.hl-yellow} con extensiÃ³n `.qmd`. Para ello solo necesitaremos hacer click en

`File << New File << Quarto Document`
:::
:::

---

## Nuestro primer informe

::: columns
::: {.column width="45%"}
![](img/quarto-format.png)
:::

::: {.column width="55%"}
Tras hacerlo nos aparecerÃ¡n varias [**opciones de formatos de salida**]{.hl-yellow}:

-   archivo `.pdf`
-   archivo `.html` ([**recomendable**]{.hl-yellow}): documento dinÃ¡mico, permite la interacciÃ³n con el usuario, como una Â«pÃ¡gina webÂ».
-   archivo `.doc` (nada recomendable)
:::
:::

. . .

De momento dejaremos marcado el [**formato HTML que viene por defecto**]{.hl-yellow}, y escribiremos el [**tÃ­tulo**]{.hl-yellow} de nuestro documento. Tras ello tendremos nuestro [**archivo .qmd**]{.hl-yellow} (ya no es un script .R como los que hemos abierto hasta ahora).

---

## Nuestro primer informe

::: columns
::: {.column width="60%"}
![](img/quarto-example.png)
:::

::: {.column width="40%"}
DeberÃ­as tener algo similar a la captura de la imagen con [**dos modos de ediciÃ³n**]{.hl-yellow}: `Source` (con cÃ³digo, la opciÃ³n recomendada hasta que lo domines) y `Visual` (mÃ¡s parecido a un blog)
:::
:::

Para [**ejecutar TODO el documento**]{.hl-yellow} debes clickar `Render on Save` y darle a guardar.

---

## Salida de Quarto

![](img/quarto-prueba-html.png)

DeberÃ­as haber obtenido una [**salida en html similar a esta**]{.hl-yellow} (y se te ha generado en tu ordenador un [**archivo html**]{.hl-yellow})

---

## Editor: source vs visual

Como se indicaba, tienes dos formas de trabajar: con cÃ³digo puro y algo parecido a un Notion (blog)

![](./img/rstudio-source-visual.png)

Imagen obtenida de <https://ivelasq.quarto.pub/intro-to-quarto/#/working-with-the-rstudio-visual-editor>

---

## Nuestro primer informe

::: columns
::: {.column width="50%"}
![](img/quarto-example.png)
:::

::: {.column width="50%"}
Un fichero `.qmd` se [**divide bÃ¡sicamente en tres partes**]{.hl-yellow}:

-   [**Cabecera**]{.hl-yellow}: la parte que tienes al inicio entre `---`.

-   [**Texto**]{.hl-yellow}: que podremos formatear y mejorar con negritas (escrito como **negritas**, con doble astÃ©risco al inicio y final), cursivas (*cursivas*, con barra baja al inicio y final) o destacar nombres de funciones o variables de R. Puedes aÃ±adir ecuaciones como $x^2$ (he escrito `$x^2$`, entre dÃ³lares).

-   [**CÃ³digo R**]{.hl-yellow}
:::
:::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera estÃ¡n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

::: columns
::: {.column width="60%"}
-   `title` y `subtitle`: el tÃ­tulo/subtÃ­tulo del documento
-   `author`: autor del mismo
-   `format`: formato de salida (podremos personalizar)
    -   `theme`: si tienes algÃºn archivo de estilos
    -   `toc`: si quieres Ã­ndice o no
    -   `toc-location`: posiciÃ³n del Ã­ndice
    -   `toc-title`: tÃ­tulo del Ã­ndice
-   `editor`: si estÃ¡s en modo visual o source.
:::

::: {.column width="40%"}
``` yaml
---
title: "prueba"
format:
  html:
editor: visual
---
```
:::
:::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera estÃ¡n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

::: columns
::: {.column width="60%"}
-   `title` y `subtitle`: el tÃ­tulo/subtÃ­tulo del documento
-   `author`: autor del mismo
-   `format`: formato de salida (podremos personalizar)
    -   `theme`: si tienes algÃºn archivo de estilos
    -   `toc`: si quieres Ã­ndice o no
    -   `toc-location`: posiciÃ³n del Ã­ndice
    -   `toc-title`: tÃ­tulo del Ã­ndice
-   `editor`: si estÃ¡s en modo visual o source.
:::

::: {.column width="40%"}
``` yaml
---
title: "prueba"
author: "javier Ã¡lvarez liÃ©bana"
format:
  html:
editor: visual
---
```
:::
:::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera estÃ¡n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

::: columns
::: {.column width="60%"}
-   `title` y `subtitle`: el tÃ­tulo/subtÃ­tulo del documento
-   `author`: autor del mismo
-   `format`: formato de salida (podremos personalizar)
    -   `theme`: si tienes algÃºn archivo de estilos
    -   `toc`: si quieres Ã­ndice o no
    -   `toc-location`: posiciÃ³n del Ã­ndice
    -   `toc-title`: tÃ­tulo del Ã­ndice
-   `editor`: si estÃ¡s en modo visual o source.
:::

::: {.column width="40%"}
``` yaml
---
title: "prueba"
author: "javier Ã¡lvarez liÃ©bana"
format:
  html:
    style: style.css
    toc: true
editor: visual
---
```
:::
:::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera estÃ¡n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

::: columns
::: {.column width="60%"}
-   `title` y `subtitle`: el tÃ­tulo/subtÃ­tulo del documento
-   `author`: autor del mismo
-   `format`: formato de salida (podremos personalizar)
    -   `theme`: si tienes algÃºn archivo de estilos
    -   `toc`: si quieres Ã­ndice o no
    -   `toc-location`: posiciÃ³n del Ã­ndice
    -   `toc-title`: tÃ­tulo del Ã­ndice
-   `editor`: si estÃ¡s en modo visual o source.
:::

::: {.column width="40%"}
``` yaml
---
title: "prueba"
author: "javier Ã¡lvarez liÃ©bana"
format:
  html:
    style: style.css
    toc: true
    toc-location: left
editor: visual
---
```
:::
:::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera estÃ¡n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

::: columns
::: {.column width="60%"}
-   `title` y `subtitle`: el tÃ­tulo/subtÃ­tulo del documento
-   `author`: autor del mismo
-   `format`: formato de salida (podremos personalizar)
    -   `theme`: si tienes algÃºn archivo de estilos
    -   `toc`: si quieres Ã­ndice o no
    -   `toc-location`: posiciÃ³n del Ã­ndice
    -   `toc-title`: tÃ­tulo del Ã­ndice
-   `editor`: si estÃ¡s en modo visual o source.
:::

::: {.column width="40%"}
``` yaml
---
title: "prueba"
author: "javier Ã¡lvarez liÃ©bana"
format:
  html:
    style: style.css
    toc: true
    toc-location: left
    toc-title: Ãndice
editor: visual
---
```
:::
:::

---

## Texto de un qmd

Respecto a la escritura solo hay una [**cosa importante**]{.hl-yellow}: salvo que indiquemos lo contrario, [**TODO lo que vamos a escribir es texto (normal)**]{.hl-yellow}. No cÃ³digo R.

::: columns
::: {.column width="35%"}
![](img/quarto-prueba-qmd2.png){width="350"} ![](img/quarto-prueba-html2.png){width="320"}
:::

::: {.column width="65%"}
Vamos a empezar escribiendo una secciÃ³n al inicio (`# Intro` y detrÃ¡s por ej. la frase

> Este material ha sido diseÃ±ado por el profesor Javier Ãlvarez LiÃ©bana, docente en la Universidad Complutense de Madrid

AdemÃ¡s al `Running Code` le aÃ±adiremos una almohadilla `#`: las [**almohadillas FUERA DE CHUNKS**]{.hl-yellow} nos servirÃ¡n para crear [**epÃ­grafes (secciones)**]{.hl-yellow} en el documento
:::
:::

---

## Ãndice de un qmd

::: columns
::: {.column width="40%"}
![](img/quarto-indice-qmd-2.png){width="370"} ![](img/quarto-indice-html2.png){width="370"}
:::

::: {.column width="60%"}
Para que el [**Ã­ndice capture dichas secciones**]{.hl-yellow} modificaremos la cabecera del archivo como se observa en la imagen (puedes cambiar la localizaciÃ³n del Ã­ndice y el tÃ­tulo si quieres para probar).
:::
:::

---

## Texto en un qmd

Vamos a [**personalizar un poco el texto**]{.hl-yellow} haciendo lo siguiente:

::: columns
::: {.column width="50%"}
![](img/quarto-texto-mejorado-qmd.png){width="370"} ![](img/quarto-texto-mejorado-html.png){width="370"}
:::

::: {.column width="50%"}
-   Vamos a aÃ±adir [**negrita al nombre**]{.hl-yellow} (poniendo \*\* al inicio y al final).

-   Vamos aÃ±adir [**cursiva**]{.hl-yellow} a la palabra material (poniendo \_ al inicio y al final).

-   Vamos aÃ±adir un [**enlace**]{.hl-yellow} <https://www.ucm.es>, asociÃ¡ndolo al nombre de la Universidad. Para ello el tÃ­tulo lo ponemos entre corchetes y justo detrÃ¡s el enlace entre parÃ©ntesis `[Â«Universidad Complutense de MadridÂ»](https://www.ucm.es)`
:::
:::

---

## CÃ³digo en un qmd

Para [**aÃ±adir cÃ³digo R**]{.hl-yellow} debemos crear nuestras [**cajas de cÃ³digo llamadas chunks**]{.hl-yellow}: altos en el camino en nuestro texto markdown donde podremos incluir cÃ³digo de casi cualquier lenguaje (y sus salidas).

Â 

::: columns
::: {.column width="50%"}
![](img/quarto-chunk-qmd.png){width="470"}
:::

::: {.column width="50%"}
Para incluir uno deberÃ¡ de ir [**encabezado**]{.hl-yellow} de la siguiente forma tienes un atajo `Command + Option + I` (Mac) o `Ctrl + Shift + I` (Windows)
:::
:::

---

## CÃ³digo en un qmd

Dentro de dicha cajita (que tiene ahora otro color en el documento) [**escribiremos cÃ³digo R**]{.hl-yellow} como lo venÃ­amos haciendo hasta ahora en los scripts.

::: columns
::: {.column width="50%"}
![](img/quarto-chunk-1-qmd.png){width="410"} ![](img/quarto-chunk-1-html.png){width="410"}
:::

::: {.column width="50%"}
Vamos por ejemplo a definir dos variables y su suma de la siguiente manera, escribiendo dicho cÃ³digo en nuestro `.qmd` (dentro de ese chunk)

```{r}
# CÃ³digo R
x <- 1
y <- 2
x + y
```
:::
:::

---

## Etiquetando chunks

::: columns
::: {.column width="50%"}
![](img/quarto-tag-chunks-qmd.png){width="400"} ![](img/quarto-tag-chunks-html.png){width="400"}
:::

::: {.column width="50%"}
Los chunks pueden tener un [**nombre o etiqueta**]{.hl-yellow}, de forma que podamos referenciarlos de nuevo para no repetir cÃ³digo.
:::
:::

---

## Ejecutando chunks

::: columns
::: {.column width="40%"}
![](img/quarto-inline-qmd.png){width="400"} ![](img/quarto-inline-html.png){width="380"}
:::

::: {.column width="60%"}
En cada chunk aparecen [**dos botones**]{.hl-yellow}:

-   botÃ³n de [**play**]{.hl-yellow}: activa la [**ejecuciÃ³n y salida de ese chunk particular**]{.hl-yellow} (lo puedes visualizar dentro de tu propio `RStudio`)

-   botÃ³n de [**rebobinar**]{.hl-yellow}: activa la [**ejecuciÃ³n y salida de todos los chunk hasta ese**]{.hl-yellow} (sin llegar a Ã©l)

Â 

AdemÃ¡s podemos [**incluir cÃ³digo R dentro de la lÃ­nea de texto**]{.hl-yellow} (en lugar de mostrar el texto x ejecuta el cÃ³digo R mostrando la variable).
:::
:::

---

## PersonalizaciÃ³n de chunks

Los [**chunks podemos personalizarlos**]{.hl-yellow} con opciones al inicio del chunk precedido de `#|`:

-   `#| echo: false`: [**ejecuta cÃ³digo**]{.hl-green} y se [**muestra resultado**]{.hl-green} pero [**no visualiza cÃ³digo**]{.hl-red} en la salida.

-   `#| include: false`: [**ejecuta cÃ³digo**]{.hl-green} pero [**no muestra resultado**]{.hl-red} y [**no visualiza cÃ³digo**]{.hl-red} en la salida.

-   `#| eval: false`: [**no ejecuta cÃ³digo**]{.hl-red}, [**no muestra resultado**]{.hl-red} pero [**sÃ­ visualiza cÃ³digo**]{.hl-green} en la salida.

-   `#| message: false`: [**ejecuta cÃ³digo**]{.hl-green} pero [**no muestra mensajes de salida**]{.hl-red}.

-   `#| warning: false`: [**ejecuta cÃ³digo**]{.hl-green} pero [**no muestra mensajes de warning**]{.hl-red}.

-   `#| error: true`: [**ejecuta cÃ³digo**]{.hl-green} y [**permite que haya errores**]{.hl-green} mostrando el mensaje de error en la salida.

![](img/quarto-options-chunk.png){width="380"}

Estas opciones podemos aplicarlas chunk a chunk o fijar los parÃ¡metros de forma global con `knitr::opts_chunk$set()` al inicio del documento (dentro de un chunk).

---

## Personalizando chunks

Si queremos que aplique la **opciÃ³n a todos los chunks por defecto** debemos incluirlo al final de la cabecera, como [**opciones de ejecuciÃ³n**]{.hl-yellow}

``` yaml
---
title: "Â¡Hola!"
format: html
editor: visual
execute:
  echo: false
---
```

---

## Organizando qmd

AdemÃ¡s de texto y cÃ³digo podemos introducir lo siguiente:

-   [**Ecuaciones**]{.hl-yellow}: puedes aÃ±adir ademÃ¡s ecuaciones como $x^2$ (he escrito `$x^2$`, la ecuaciÃ³n entre dÃ³lares).

-   [**Listas**]{.hl-yellow}: puedes itemizar elementos poniendo `*`

`* Paso 1: ...`

`* Paso 2: ...`

-   [**Cross-references**]{.hl-yellow}: puedes etiquetar partes del documento (la etiqueta se construye con `{#nombre-seccion}`) y llamarlas luego con `[SecciÃ³n](@nombre-seccion)`

---

## GrÃ¡ficas/imÃ¡genes en qmd

::: columns
::: {.column width="50%"}
![](img/quarto-fig-qmd.png){width="340"} ![](img/quarto-fig-html.png){width="390"}
:::

::: {.column width="50%"}
Por Ãºltimo, tambiÃ©n podemos [**aÃ±adir pies de grÃ¡ficas o imÃ¡genes**]{.hl-yellow} aÃ±adiendo `#| fig-cap: "..."`
:::
:::

. . .

::: columns
::: {.column width="65%"}
FÃ­jate que el [**caption estÃ¡ en el margen**]{.hl-yellow} (por ejemplo). Puedes cambiarlo introduciendo [**ajustes en la cabecera**]{.hl-yellow} (todo lo relativo a figuras empieza por `fig-`, y puedes ver las opciones tabulando). Tienes mÃ¡s informaciÃ³n en [**https://quarto.org/**](https://quarto.org/){.uri}
:::

::: {.column width="35%"}
![](img/quarto-cabecera-desplegable.png){width="400"}
:::
:::

---

## AÃ±adir estilos

::: columns
::: {.column width="50%"}
![](img/quarto-estilos-qmd.png){width="400"} ![](img/quarto-estilos-html.png){width="400"}
:::

::: {.column width="50%"}
Por Ãºltimo puedes aÃ±adir un [**tema personalizado**]{.hl-yellow} incluyendo un [**archivo de estilos**]{.hl-yellow} (archivo en formato `.scss` o `.css`). Te he dejado uno en <https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material>.

::: callout-important
## Importante

El archivo de estilos debe estar en la misma carpeta que el archivo `.qmd`
:::
:::
:::

---

## AÃ±adir estilos

TambiÃ©n puedes hacerlo de manera sencilla [**aÃ±adiendo a los textos un poco de HTML**]{.hl-yellow}. Por ejemplo, para personalizar el color de un texto va entre corchetes y justo tras el texto, entre llaves, las opciones de estilo

``` html
Esta palabra es [roja]{style="color:red;"} ...
```

``` html
... y esta [verde y en negrita]{style="color:green; font-weight: bold;"}
```

. . .

Esta palabra es [roja]{style="color:red;"} ...

... y esta [verde y en negrita]{style="color:green; font-weight: bold;"}

---

## Revealjs

Puedes aÃ±adir algunas Â«animacionesÂ» usando lo que se conoce como Revealjs (javascript), especifcÃ¡ndolo en la cabecera y usando [**bloques**]{.hl-yellow} de dicho lenguaje delimitados por `:::` al inicio y final, y la palabra de la Â«herramientaÂ» a usar. Por ejemplo `{.incremental}` hace una transiciÃ³n de los elementos.

``` yaml
format:
  revealjs
```

Â 

``` revealjs
::: {.incremental}
- Me
- llamo
- Javi
:::
```

::: incremental
-   Me
-   llamo
-   Javi
:::

---

## Bloques de llamada

TambiÃ©n puedes usar los [**bloques de llamada**]{.hl-yellow} que por defecto son `note`, `tip`, `warning`, `caution` e `important` (aunque los puedes crear y personalizar). Para ello basta con usar `:::{.callout-tipo}` y el tipo que quieras

``` html
:::{.callout-tip}

Note that there are five types of callouts, including: 
`note`, `tip`, `warning`, `caution`, and `important`.

:::
```

. . .

::: callout-tip
Recuerda que los 5 tipos son `note`, `tip`, `warning`, `caution` e `important`.
:::

. . .

::: callout-caution
Ãšsalos con cabeza, a veces mucho recursos estÃ©tico puede marear.
:::

---

## MÃºltiples columnas

Con `:::: columns` podemos definir una disposiciÃ³n de [**mÃºltiples columnas**]{.hl-yellow} donde cada una viene definida por `::: {.column width="65%"} cosa :::`, indicando al lado del porcentaje cuanto quieres que ocupe cada columna (Â¡cuidado, no dejar espacios!)

``` html
:::: columns
::: {.column width="65%"}
AsÃ­ se define un vector
:::
::: {.column width="35%"}
x <- c(1, 2, 3)
x
:::
::::
```

Â 

. . .

::: columns
::: {.column width="65%"}
AsÃ­ se define un vector
:::

::: {.column width="35%"}
```{r}
x <- c(1, 2, 3)
x
```
:::
:::

# Clase 4: [intro a tidyverse]{.flow} {#clase-4}

[**Dataviz, importar/exportar e intro a tidyverse**]{style="color:#444442;"}

-   [Intro a tidydata](#tidydata)
-   [Intro a preprocesamiento con dplyr](#dplyr)
-   [Intro a resÃºmenes](#summarise)
-   [Intro a dataviz en R](#ggplot)

---

## Clase 4: [tidydata]{.flow} {#tidydata}

[**Dataviz, importar/exportar ggplot e intro a tidyverse**]{style="color:#444442;"}

-   [ğŸ’» Ejercicios resueltos: tidydata](#tu-turno-4-1)
-   [ğŸ£ Workbook/caso prÃ¡ctico: tidy data](#caso-practico-4-1)
-   [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## R base vs Tidyverse 

Hasta ahora todo lo que hemos hecho en `R` lo hemos realizado en el paradigma de programaciÃ³n conocido como [**R base**]{.hl-yellow}. Y es que cuando `R` naciÃ³ como lenguaje, muchos de los que programaban en Ã©l imitaron formas y metodologÃ­as heredadas de otros lenguajes, basado en el uso de

-   Bucles [**for**]{.hl-yellow} y [**while**]{.hl-yellow}

-   Estructuras [**if-else**]{.hl-yellow}

-   Estructuras [**\$ y \[\]**]{.hl-yellow}

Y aunque es necesario conocer dichas estructuras, en la [**mayorÃ­a de ocasiones hay opciones mÃ¡s modernas y vamos a poder evitarlas**]{.hl-red} en especial los bucles: es necesario conocer la gramÃ¡tica de un idioma para habler uno de sus dialectos.

---

## Â¿QuÃ© es tidyverse?

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

En ese contexto de programaciÃ³n funcional, hace una dÃ©cada nacÃ­a `{tidyverse}`, un [**Â«universoÂ» de paquetes**]{.hl-yellow} para garantizar un flujo de trabajo eficiente, coherente y lexicogrÃ¡ficamente sencillo de entender, basado en la idea de que [**nuestros datos estÃ¡n limpios y ordenados (tidy)**]{.hl-purple}

---

## Â¿QuÃ© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)

-   `{lubridate}` manejo de fechas
-   `{rvest}`: web scraping
-   `{tidymodels}`: modelizaciÃ³n/predicciÃ³n
:::

::: {.column width="55%"}
-   `{tibble}`: optimizando data.frame
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv), `{readxl}` para importar archivos .xls y .xlsx
-   `{dplyr}`: gramÃ¡tica para depurar
-   `{stringr}`: manejo de textos
-   `{purrr}`: manejo de listas
-   `{forcats}`: manejo de cualitativas
-   `{ggplot2}`: visualizaciÃ³n de datos
:::
:::

---

## FilosofÃ­a base: tidy data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

El [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducida por **Hadley Wickham** (el Dios al que rezamos) de [**estandarizar**]{.hl-yellow} el formato de los datos para

::: incremental
-   [**sistematizar**]{.hl-green} la depuraciÃ³n
-   hacer mÃ¡s [**sencillo**]{.hl-green} su manipulaciÃ³n.
-   cÃ³digo [**legible**]{.hl-green}
:::

---

## Reglas del tidy data

Lo primero por tanto serÃ¡ entender quÃ© son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos estÃ¡n estandarizados.

::: columns
::: {.column width="50%"}
::: {.fragment .fade-in}
1.  Cada [**variable**]{.hl-yellow} en una [**Ãºnica columna**]{.hl-purple}
:::

::: {.fragment .fade-in}
2.  Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}
:::

::: {.fragment .fade-in}
3.  Cada [**celda**]{.hl-yellow} con un [**Ãºnico valor**]{.hl-purple}
:::

::: {.fragment .fade-in}
4.  Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5.  Si queremos cruzar [**mÃºltiples tablas**]{.hl-yellow} debemos tener una [**columna comÃºn**]{.hl-purple}
:::
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
:::

---

## TuberÃ­a (pipe)

En `{tidyverse}` serÃ¡ clave el [**operador pipe (tuberÃ­a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): serÃ¡ una [**tuberÃ­a que recorre los datos**]{.hl-yellow} y los transforma.

. . .

::: columns
::: {.column width="50%"}
En R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, serÃ­a

```{r}
#| eval: false
third(second(first(datos)))
```
:::

::: {.column width="50%"}
En `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones

```{r}
#| eval: false
datos |> first() |> second() |> third()
```
:::
:::

. . .

::: callout-caution
## Apunte importante

Desde la versiÃ³n 4.1.0 de `R` disponemos de `|>`, un pipe **nativo** disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que dependÃ­a del paquete `{magrittr}` (bastante problemÃ¡tico).
:::

---

## TuberÃ­a (pipe)

La principal ventaja es que el [**cÃ³digo sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas cÃ³digo.

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::

::: {.column width="50%"}
<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
:::

---

## Datos SUCIOS: messy data

Â¿Pero quÃ© aspecto tienen los [**datos no tidy**]{.hl-yellow}? Vamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).

```{r}
library(tidyr)
table4a
```

[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="40%"}
```{r}
table4a
```
:::

::: {.column width="60%"}
â Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) â†’ las columnas `1999` y `2000` en realidad deberÃ­an ser en sÃ­ [**valores de una variable**]{.hl-yellow} y no nombres de columnas.
:::
:::

. . .

Incluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el aÃ±o y otra que guarde el valor de la variable de interÃ©s en cada uno de esos aÃ±os. Y lo haremos con la funciÃ³n `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="50%"}
```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
               values_to = "cases")
```
:::

::: {.column width="50%"}
![](img/table4a.jpg)
:::
:::

-   `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}
-   `names_to`: nombre de la nueva variable a la quemandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).
-   `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table2`

```{r}
table2
```

[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_wider()

::: columns
::: {.column width="60%"}
```{r}
#| echo: false
table2
```
:::

::: {.column width="40%"}
â Cada [**observaciÃ³n estÃ¡ dividido en dos filas**]{.hl-red} â†’ los [**registros con el mismo aÃ±o deberÃ­an ser el mismo**]{.hl-yellow}
:::
:::

. . .

Lo que haremos serÃ¡ lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table3`

```{r}
table3
```

[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Separar: separate()

::: columns
::: {.column width="60%"}
```{r}
table3
```
:::

::: {.column width="40%"}
â Cada [**celda contiene varios valores**]{.hl-red}
:::
:::

. . .

Lo que haremos serÃ¡ hacer uso de la funciÃ³n `separate()` para mandar [**separar cada valor**]{.hl-yellow} a una columna diferente.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

---

## Separar: separate()

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

FÃ­jate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deberÃ­an ser variables numÃ©ricas. Para ello podemos aÃ±adir el argumento opcional `convert = TRUE`

. . .

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

---

## Datos SUCIOS: messy data

Veamos el Ãºltimo ejemplo con la tabla `table5`

```{r}
table5
```

[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Unir unite()

::: columns
::: {.column width="50%"}
```{r}
table5
```
:::

::: {.column width="50%"}
â Tenemos [**mismos valores divididos en dos columnas**]{.hl-red}
:::
:::

. . .

Usaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y aÃ±o en una misma columna

```{r}
table5 |> unite(col = year_completo, century, year, sep = "")
```

---

## ğŸ’» Tu turno {#tu-turno-4-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Usa el dataset original `relig_income` en `{tidyr}` y trata de responder a la Ãºltima pregunta: Â¿cuÃ¡ntas personas agnÃ³sticas con ingresos superiores (o iguales) a 30 tenemos?

```{r}
#| code-fold: true
#| eval: false

sum(relig_income[relig_income$religion == "Agnostic",
             c("$30-40k", "$40-50k", "$50-75k", "$75-100k", "$100-150k", ">150k")])
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Convierte a tidy data

```{r}
#| code-fold: true
#| eval: false

relig_tidy <-
  relig_income |> 
  pivot_longer(cols = -religion, names_to = "ingresos", values_to = "personas")
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. Â¿Es tidydata? En caso negativo, Â¿quÃ© falla? Â¿CÃ³mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. Â¿Es tidydata? En caso negativo, Â¿quÃ© falla? Â¿CÃ³mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```
:::

---

## ğŸ£ Caso prÃ¡ctico I: tidy data {#caso-practico-4-1}

En el paquete `{tidyr}` contamos con el dataset `who2` (dataset de la OrganizaciÃ³n Mundial de la Salud). Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/tidydata-isciii/#caso-pr%C3%A1ctico-an%C3%A1lisis-de-datos-de-la-oms).

```{r}
who2
```

---

## Clase 4: [preprocesamiento con dplyr]{.flow} {#dplyr}

[**Intro a tidyverse**]{style="color:#444442;"}

-   [ğŸ’» Ejercicios resueltos: operaciones por filas](#tu-turno-4-2)
-   [ğŸ£ Workbook/caso prÃ¡ctico: airquality](#caso-practico-4-2)
-   [ğŸ’» Ejercicios resueltos: operaciones por columnas](#tu-turno-4-3)
-   [ğŸ£ Workbook/caso prÃ¡ctico: Taylor Swift](#caso-practico-4-3)
-   [ğŸ‘¾ Materiales extras tidyverse](#extra-tidyverse)
-   [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## Preprocesamiento: dplyr

Dentro de `{tidyverse}` usaremos el paquete `{dplyr}` para el [**preprocesamiento y depuraciÃ³n**]{.hl-yellow} de los datos. La idea es que el [**cÃ³digo sea legible**]{.hl-yellow}, como si fuese una **lista de instrucciones** que al leerla nos diga de manera muy evidente lo que estÃ¡ haciendo.

Vamos a practicar con el dataset `starwars` del paquete cargado `{dplyr}`

```{r}
#| eval: false
library(tidyverse)
starwars
```

---

## Muestreo

::: columns
::: {.column width="60%"}
Una de las operaciones mÃ¡s comunes es lo que se conoce en estadÃ­stica como [**muestreo**]{.hl-yellow}: una [**selecciÃ³n o filtrado de registros**]{.hl-yellow} (una submuestra)
:::

::: {.column width="40%"}
![](img/muestreo.jpeg){width="500"}
:::
:::

. . .

-   [**No aleatorio (por cuotas)**]{.hl-purple}: en base a condiciones lÃ³gicas sobre los registros (`filter()`)

. . .

-   [**No aleatorio (intencional/discreccional)**]{.hl-purple}: en base a posiciÃ³n (`slice()`)

. . .

-   [**Aleatorio simple**]{.hl-purple} (`slice_sample()`)

. . .

-   [**Aleatorio estratificado**]{.hl-purple} (`group_by()` + `slice_sample()`)

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

El mÃ¡s simple es cuando [**filtramos registros**]{.hl-yellow} en base a alguna condiciÃ³n lÃ³gica: con `filter()` se seleccionarÃ¡n solo individuos que cumplan ciertas condiciones (muestreo no aleatorio por condiciones)

::: incremental
-   `==`, `!=`: [**igual**]{.hl-purple} o [**distinto**]{.hl-yellow} que (`|> filter(variable == "a")`)
-   `>`, `<`: [**mayor**]{.hl-purple} o [**menor**]{.hl-yellow} que (`|> filter(variable < 3)`)
-   `>=`, `<=`: [**mayor o igual**]{.hl-yellow} o [**menor o igual**]{.hl-purple} que (`|> filter(variable >= 5)`)
-   `%in%`: valores [**pertenencen**]{.hl-yellow} a un listado de opciones (`|> filter(variable %in% c("azul", "verde"))`)
-   `between(variable, val1, val2)`: si los valores (continuos) [**caen dentro de un rango**]{.hl-yellow} de valores (`|> filter(between(variable, 160, 180))`)
:::

---

## Filtrar filas: filter()

Dichas [**condiciones lÃ³gicas**]{.hl-yellow} las podemos [**combinar**]{.hl-yellow} de diferentes maneras (y, o, o excluyente)

![](img/tablas_verdad.png)

. . .

::: callout-tip
## Importante

Recuerda que dentro de `filter()` debe ir siempre algo que devuelva un [**vector de valores lÃ³gicos**]{.hl-green}.
:::

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para... [**filtrar**]{.hl-yellow} los personajes de [**ojos marrones**]{.hl-purple}?

. . .

[**Â¿QuÃ© tipo de variable es?**]{.hl-yellow} --\> La variable `eye_color` es cualitativa asÃ­ que estÃ¡ representada por textos

. . .

```{r}
#| echo: false
#| include: false
library(tidyverse)
```

```{r}
starwars |>
  filter(eye_color == "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para... [**filtrar**]{.hl-yellow} los personajes que [**no tienen ojos marrones**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color != "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para ... [**filtrar**]{.hl-yellow} los personajes que [**tengan los ojos marrones o azules**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color %in% c("blue", "brown"))
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

FÃ­jate que `%in%` es equivalente a concatenar varios `==` con una conjunciÃ³n o (`|`)

```{r}
starwars |>
  filter(eye_color == "blue" | eye_color == "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para ... [**filtrar**]{.hl-yellow} los personajes que [**midan entre 120 y 160 cm**]{.hl-purple}?

. . .

[**Â¿QuÃ© tipo de variable es?**]{.hl-yellow} --\> La variable `height` es cuantitativa continua asÃ­ que deberemos filtrar por rangos de valores (intervalos) --\> usaremos `between()`

. . .

```{r}
starwars |>
  filter(between(height, 120, 160))
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color == "brown" & species != "Human")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos, o que tengan mÃ¡s de 60 aÃ±os**]{.hl-purple}? PiÃ©nsalo bien: los [**parÃ©ntesis son importantes**]{.hl-yellow}: no es lo mismo $(a+b)*c$ que $a+(b*c)$

. . .

```{r}
starwars |>
  filter((eye_color == "brown" & species != "Human") | birth_year > 60)
```

---

## Eliminar ausentes: drop_na()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  retirar_ausentes(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(var1, var2, ...)
```
:::
:::

Hay un **filtro especial** para una de las operaciones mÃ¡s habituales en depuraciÃ³n: [**retirar los ausentes**]{.hl-yellow}. Para ello podemos usar dentro de un filtro `is.na()`, que nos devuelve `TRUE/FALSE` en funciÃ³n de si es ausente, o bien ...

. . .

Usar `drop_na()`: si no indicamos variable, elimina registros con ausente en cualquier variable. MÃ¡s adelante veremos como [**imputar esos ausentes**]{.hl-yellow}

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(mass, height)
```

```{r}
#| echo: false
starwars |>
  drop_na(mass, height, sex) |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na()
```

```{r}
#| echo: false
starwars |>
  drop_na() |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::
:::

---

## Reordenar filas: arrange()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> ordenar(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(var1, var2, ...)
```
:::
:::

TambiÃ©n podemos [**ordenar filas**]{.hl-yellow} en funciÃ³n de alguna variable con `arrange()`

```{r}
#| eval: false
starwars |> arrange(mass)
```

```{r}
#| echo: false
starwars |> arrange(mass) |> select(name:eye_color) |> slice(1:5) 
```

. . .

Por [**defecto de menor a mayor**]{.hl-yellow} pero podemos [**invertir el orden**]{.hl-purple} con `desc()`

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(desc(height))
```

```{r}
#| echo: false
starwars |> arrange(desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(mass, desc(height))
```

```{r}
#| echo: false
starwars |> arrange(mass, desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::
:::

---

## Eliminar duplicados: distinct()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> sin_duplicados(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> distinct(var1, var2, ...)
```
:::
:::

Muchas veces necesitaremos asegurarnos que no hay duplicados en alguna variable (DNI) y podemos [**eliminar filas duplicadas**]{.hl-yellow} con `distinct()`.

```{r}
starwars |> distinct(sex)
```

. . .

Para mantener todas las columnas de la tabla usaremos `.keep_all = TRUE`.

```{r}
#| eval: false
starwars |> distinct(sex, .keep_all = TRUE)
```

```{r}
#| echo: false
starwars |> distinct(sex, .keep_all = TRUE) |> slice(1:3)
```

---

## AÃ±adir filas: bind_rows()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> encuadernar_filas(tibble2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> bind_rows(tibble2)
```
:::
:::

Por Ãºltimo, podemos [**concatenar nuevas filas**]{.hl-yellow} con `bind_rows()` con [**las nuevas observaciones en tabla**]{.hl-red} (si no cuadran columnas rellena con ausentes)

```{r}
datos <-
  tibble("nombre" = c("javi", "laura"), "edad" = c(33, 50))
datos
```

. . .

```{r}
datos |> bind_rows(tibble("nombre" = c("carlos", NA), "cp" = c(28045, 28019)))
```

---

## ğŸ’» Tu turno {#tu-turno-4-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Selecciona del conjunto de starwars solo los personajes que sean androides o cuyo valor en `species` sea desconocido

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Droid" | is.na(species))
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Selecciona del conjunto de starwars solo los personajes cuyo peso estÃ© entre 65 y 90 kg.

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(between(mass, 65, 90))
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Tras limpiar de ausentes en todas las variables, selecciona del conjunto de starwars solo los personajes que sean humanos y que vengan de Tatooine

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na() |> 
  filter(species == "Human" & homeworld == "Tatooine")
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Selecciona del conjunto original de starwars los personajes no humanos, `male` en el sexo y que midan entre 120 y 170 cm, o los personajes con ojos marrones o rojos.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter((species != "Human" & sex == "male" &
            between(height, 120, 170)) |
           eye_color %in% c("brown", "red"))
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Selecciona solo los personajes que sean humanos y de ojos marrones, para despuÃ©s ordernarlos en altura descendente y peso ascendente.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(eye_color == "brown" & species == "Human") |> 
  arrange(height, desc(mass))
```
:::

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Hasta ahora todas las operaciones realizadas (aunque usÃ¡semos info de columnas) eran por filas. En elc aso de columnas, la acciÃ³n mÃ¡s sencilla es [**seleccionar variables por nombre**]{.hl-yellow} con `select()`, dando como argumentos los nombres de columnas [**sin comillas**]{.hl-purple}.

```{r}
starwars |> select(name, hair_color)
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

La funciÃ³n `select()` nos permite seleccionar varias variables a la vez, incluso [**concatenando sus nombres como si fuesen Ã­ndices numÃ©ricos**]{.hl-yellow}

```{r}
#| eval: false
starwars |> select(name:eye_color) 
```

```{r}
#| echo: false
starwars |> select(name:eye_color) |> slice(1:4)
```

. . .

Y podemos [**deseleccionar columnas**]{.hl-yellow} con `-` delante

```{r}
#| eval: false
starwars |>  select(-mass, -(eye_color:starships))
```

```{r}
#| echo: false
starwars |> select(-mass, -(eye_color:starships)) |> slice(1:4)
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Tenemos ademÃ¡s [**palabras reservadas**]{.hl-yellow}: `everything()` [**todas las variables**]{.hl-purple}...

```{r}
#| eval: false
starwars |> select(mass, homeworld, everything())
```

```{r}
#| echo: false
starwars |> select(mass, homeworld, everything()) |> slice(1:4)
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

TambiÃ©n podemos jugar con [**patrones**]{.hl-yellow} en el nombre, aquellas que [**comiencen por un prefijo**]{.hl-purple} (`starts_with()`), [**terminen con un sufijo**]{.hl-purple} (`ends_with()`), [**contengan un texto**]{.hl-purple} (`contains()`) o cumplan una [**expresiÃ³n regular**]{.hl-purple} (`matches()`).

```{r}
# variables cuyo nombre acaba en "color" y contengan sexo o gÃ©nero
starwars |> select(ends_with("color"), matches("sex|gender"))
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Por Ãºltimo, podemos seleccionar columnas por [**tipo de dato**]{.hl-yellow} haciendo uso de `where()` y dentro una funciÃ³n que devuelva un valor lÃ³gico de tipo de dato.

```{r}
# Solo columnas numÃ©ricas o de texto
starwars |> select(where(is.numeric) | where(is.character))
```

---

## Renombrar: rename()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> renombrar(nuevo = antiguo)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> rename(nuevo = antiguo)
```
:::
:::

A veces tambiÃ©n podemos querer [**modificar la Â«metainformaciÃ³nÂ»**]{.hl-yellow} de los datos, [**renombrando columnas**]{.hl-yellow}. Para ello usaremos de `rename()` poniendo [**primero el nombre nuevo**]{.hl-purple} y luego el [**antiguo**]{.hl-purple}.

```{r}
starwars |> rename(nombre = name, altura = height, peso = mass)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

En muchas ocasiones querremos [**modificar o crear variables**]{.hl-yellow} con `mutate()`.

. . .

Vamos a crear por ejemplo una nueva variable `height_m` con la altura en metros.

```{r}
starwars |> mutate(height_m = height / 100)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

AdemÃ¡s con los argumentos opcionales podemos [**recolocar la columna modificada**]{.hl-yellow}

```{r}
starwars |> 
  mutate(height_m = height / 100,
         IMC = mass / (height_m^2), .before = name)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

::: callout-important
## Importante...

Cuando aplicamos `mutate()`, debemos de acordarnos que las [**operaciones se realizan de manera vectorial**]{.hl-yellow}, elemento a elemento, por lo que la funciÃ³n que usemos dentro debe devolver un vector de igual longitud. En caso contrario, [**devolverÃ¡ una constante**]{.hl-red}
:::

. . .

```{r}
starwars |> 
  mutate(constante = mean(mass, na.rm = TRUE), .before = name)
```

---

## Recategorizar: if_else()

TambiÃ©n podemos combinar `mutate()` con la expresiÃ³n de control `if_else()` para [**recategorizar la variable**]{.hl-yellow}: si [**se cumple una condiciÃ³n**]{.hl-purple}, hace una cosa, en caso contrario otra.

```{r}
starwars |> 
  mutate(human = if_else(species == "Human", "Human", "Not Human"),
         .after = name) |> 
  select(name:mass)
```

---

## ğŸ’» Tu turno {#tu-turno-4-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Filtra el conjunto de personajes y quÃ©date solo con aquellos que en la variable `height` no tengan un dato ausente. Con los datos obtenidos del filtro anterior, selecciona solo las variables name, height, asÃ­ como todas aquellas variables que CONTENGAN la palabra color en su nombre.

```{r}
#| code-fold: true
#| eval: false

starwars_2 <-
  starwars |> 
  drop_na(height) |> 
  select(name, height, contains("color"))
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Con los datos originales, comprueba cuÃ¡ntas modalidades Ãºnicas hay en la variable de color de pelo.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  distinct(hair_color) |> 
  nrow()
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Del dataset original, selecciona solo las variables numÃ©ricas y de tipo texto. Tras ello define una nueva variable llamada `under_18` que nos recategorice la variable de edad: `TRUE` si es menor de edad y `FALSE` en caso contrario

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(where(is.numeric) | where(is.character)) |> 
  mutate(under_18 = birth_year < 18)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Del dataset original, crea una nueva columna llamada `auburn` (cobrizo/caoba) que nos diga TRUE si el color de pelo contiene dicha palabra y FALSE en caso contrario (reminder `str_detect()`).

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(auburn = str_detect(hair_color, "auburn"))
```
:::

---

## Clase 4: [construyendo resÃºmenes]{.flow} {#summarise}

[**Intro a tidyverse**]{style="color:#444442;"}

-   [ğŸ’» Ejercicios resueltos: resÃºmenes](#tu-turno-4-4)
-   [ğŸ£ Workbook/caso prÃ¡ctico: billboard](#caso-practico-4-4)
-   [ğŸ£ Workbook/caso prÃ¡ctico: fÃºtbol](#caso-practico-4-5)
-   [ğŸ‘¾ Materiales extras tidyverse](#extra-tidyverse)
-   [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## Contar: count()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
:::

Hasta ahora solo hemos transformado o consultado los datos pero no hemos generado estadÃ­sticas. Empecemos por lo sencillo: [**Â¿cÃ³mo contar (frecuencias)?**]{.hl-yellow}

. . .

Cuando lo usamos en solitario `count()` nos devolverÃ¡ simplemente el nÃºmero de registros , pero cuando lo usamos con variables `count()` calcula lo que se conoce como [**frecuencias**]{.hl-yellow}: [**nÃºmero de elementos de cada modalidad**]{.hl-purple}.

```{r}
starwars |> count(sex)
```

---

## Contar: count()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
:::

AdemÃ¡s si pasamos varias variables nos calcula lo que se conoce como una [**tabla de contigencia**]{.hl-yellow}. Con `sort = TRUE` nos devolverÃ¡ el [**conteo ordenado**]{.hl-purple} (mÃ¡s frecuentes primero).

```{r}
starwars |> count(sex, gender, sort = TRUE)
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Una de las [**funciones mÃ¡s potentes**]{.hl-yellow} a combinar con las acciones vistas es `group_by()`, que nos permitirÃ¡ [**agrupar nuestros registros**]{.hl-yellow} previamente

```{r}
starwars |> 
  group_by(sex) |>
  count() |>
  ungroup()
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Cuando apliquemos `group_by()` es importante entender que [**NO MODIFICA los datos**]{.hl-yellow}, sino que nos crea una [**variable de grupo**]{.hl-yellow} (subtablas por cada grupo) que modificarÃ¡ las acciones futuras: las [**operaciones se aplicarÃ¡n a cada subtabla por separado**]{.hl-purple}

. . .

Por ejemplo, imaginemos que queremos extraer el personaje mÃ¡s alto con `slice_max()`.

```{r}
starwars |> slice_max(height)
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Â¿Y si queremos [**extraer el personaje mÃ¡s alto pero...de cada uno de los sexos**]{.hl-yellow}?

. . .

```{r}
starwars |>
  group_by(sex) |> 
  slice_max(height) |> 
  ungroup()
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

::: columns
::: {.column width="50%"}
![](img/tidydatatutor_1.jpg)
:::

::: {.column width="50%"}
![](img/tidydatatutor_2.jpg)
:::
:::

La web <https://tidydatatutor.com/> permite visualizar las operaciones de `{tidyverse}` (con el pipe antiguo)

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |>
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |>
  ungroup()
```
:::
:::

::: callout-important
## Importante

Recuerda siempre [**hacer ungroup**]{.hl-red} para eliminar la variable de grupo creada
:::

. . .

En la nueva versiÃ³n de `{dplyr}` ahora se [**permite incluir la variable de grupo**]{.hl-yellow} en la llamada a muchas funciones con el argumento `by = ...` o `.by = ...`

```{r}
#| eval: false
starwars |> slice_max(height, by = sex)
```

```{r}
#| echo: false
starwars |> slice_max(height, by = sex) |> select(name:eye_color)
```

---

## Resumir: summarise()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
:::

Por Ãºltimo tenemos `summarise()`, que nos permitirÃ¡ sacar resÃºmenes estadÃ­sticos. Por ejemplo, vamos a [**calcular la media de las alturas**]{.hl-yellow}.

```{r}
starwars |> 
  drop_na(height) |> 
  summarise(media_altura = mean(height))
```

. . .

::: callout-warning
## Cuidado

FÃ­jate que `mutate()` devuelve [**tantas filas como registros originales**]{.hl-yellow}, mientras que con `summarise()` calcula un [**nuevo dataset de resumen**]{.hl-purple}, solo incluyendo aquello que estÃ© indicado.
:::

---

## Resumir: summarise()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
:::

Si ademÃ¡s esto lo [**combinamos con la agrupaciÃ³n**]{.hl-yellow} de `group_by()` o `.by = ...`, en pocas lÃ­neas de cÃ³digo puedes obtener [**estadÃ­sticas desagreagadas**]{.hl-purple}

```{r}
starwars |> 
  drop_na(sex, height, mass) |> 
  summarise(media_altura = mean(height),
            media_peso = mean(mass),
            .by = sex)
```

---

## Resumir: reframe()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> reframe()
```
:::
:::

En el nuevo `{dplyr}` han incluido `reframe()` para evitar problemas de `summarise()` cuando [**devolvemos mÃ¡s de un valor por variable**]{.hl-yellow}.

::: columns
::: {.column width="50%"}
```{r}
#| warning: true
starwars |>
  drop_na(mass) |>
  summarise(quantile(mass))
```
:::

::: {.column width="50%"}
```{r}
starwars |>
  drop_na(mass) |>
  reframe(quantile(mass))
```
:::
:::

---

## ğŸ’» Tu turno {#tu-turno-4-4}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Calcula cuÃ¡ntos personajes hay de cada especie, ordenados de mÃ¡s a menor frecuencia.

```{r}
#| code-fold: true
#| eval: false
starwars |> count(species, sort = TRUE)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Tras eliminar ausentes en las variables de peso y estatura, aÃ±ade una nueva variable que nos calcule el IMC de cada personaje, y determina el IMC medio de nuestros personajes desagregada por sexo

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass, height) |> 
  mutate(IMC = mass / ((height/100)^2)) |> 
  summarise(IMC_medio = mean(IMC), .by = sex)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ ObtÃ©n el personaje mÃ¡s joven por cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  slice_min(birth_year, by = sex)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ ObtÃ©n la edad del personaje mÃ¡s joven y mÃ¡s viejo de cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(birth_year) |>
  summarise(min(birth_year), max(birth_year), .by = sex)
```
:::

---

## Clase 4: [dataviz en R]{.flow} {#ggplot}

[**Intro a ggplot. Exportar/importar**]{style="color:#444442;"}

-   [ğŸ’» Ejercicios resueltos: importar/exportar](#tu-turno-4-5)
-   [ğŸ£ Workbook/caso prÃ¡ctico: encuesta CIS](#caso-practico-4-6)
-   [ğŸ’» Ejercicios resueltos: ggplot](#tu-turno-4-6)
-   [ğŸ‘¾ Materiales extras visualizaciÃ³n](#extra-dataviz)
-   [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## Dataviz en R: ggplot2

::: columns
::: {.column width="50%"}
El paquete `{ggplot2}` se basa en la idea de Wilkinson en [**Â«Grammar of graphicsÂ»**]{.hl-yellow}: dotar a los grÃ¡ficos de una gramÃ¡tica propia. Una de las principales fortalezas de `R` es la [**visualizaciÃ³n**]{.hl-yellow} con `{ggplot2}`.

```{r}
library(ggplot2)
```

La [**visualizaciÃ³n de datos**]{.hl-yellow} deberÃ­a ser una parte fundamental de todo anÃ¡lisis de datos. No es solo una cuestiÃ³n estÃ©tica.
:::

::: {.column width="50%"}
![](img/telling_dataviz.jpg){width="400"}
:::
:::

---

## Dataviz en R: ggplot2

La filosofÃ­a detrÃ¡s de `{ggplot2}` es entender los [**grÃ¡ficos como parte del flujo**]{.hl-yellow} de trabajo, dotÃ¡ndoles de una [**gramÃ¡tica**]{.hl-yellow}. El objetivo es empezar con un lienzo en blanco e ir [**aÃ±adiendo capas a tu grÃ¡fico**]{.hl-yellow}. La ventaja de `{ggplot2}` es poder [**mapear atributos estÃ©ticos**]{.hl-purple} (color, forma, tamaÃ±o) de objetos geomÃ©tricos (puntos, barras, lÃ­neas) en funciÃ³n de los datos.

Â 

La **documentaciÃ³n** del paquete puedes consultarla en <https://ggplot2-book.org/introduction.html>

![](img/grammar_ggplot2.jpg)

---

## Dataviz en R: ggplot2

![](img/tarta_ggplot2.png)

---

## Dataviz en R: ggplot2

::: columns
::: {.column width="40%"}
![](img/tarta_recortada_ggplot2.jpg)
:::

::: {.column width="60%"}
Un grÃ¡fico se podrÃ¡ componer de [**capas**]{.hl-yellow}

-   [**Datos (data)**]{.hl-purple}
-   [**Mapeado (aesthetics)**]{.hl-purple} de elementos estÃ©ticos: ejes, color, forma, etc (en funciÃ³n de los datos)
-   [**GeometrÃ­a (geom)**]{.hl-purple}: puntos, lÃ­neas, barras, polÃ­gonos, etc.
-   [**Componer grÃ¡ficas (facet)**]{.hl-purple}
-   [**Transformaciones (stat)**]{.hl-purple}: ordenar, resumir, etc.
-   [**Coordenadas (coord)**]{.hl-purple}: coordenadas cartesianas, polares, grids, etc.
-   [**Temas (theme)**]{.hl-purple}: fuente, tamaÃ±o de letra, subtÃ­tulos, captions, leyenda, ejes, etc.
:::
:::

---

## Importar/exportar

Veamos un **primer intento** para entender la filosofÃ­a ggplot pero para ello muchas veces [**necesitaremos importar datos externamente**]{.hl-yellow}. Una de las principales [**fortalezas**]{.hl-yellow} de `R` es que podemos importar datos muy fÃ¡cilmente en diferentes formatos:

-   [**Formatos nativos de R**]{.hl-yellow}: archivos `.rda` y `.RData`.

-   [**Rectangular data**]{.hl-yellow}: archivos `.csv` y `.tsv`, archivos `.txt`, etc.

-   [**Datos en excel**]{.hl-yellow}: archivos `.xls` y`.xlsx`.

-   [**Datos desde SAS/Stata/SPSS**]{.hl-yellow}: archivos `.sas7bdat`, `.sav` y `.dat`.

-   [**Datos desde Google Drive**]{.hl-yellow}

-   [**Datos desde API's**]{.hl-yellow}: aemet, catastro, censo, spotify, etc.

---

## Formatos nativos

Los ficheros [**mÃ¡s sencillos**]{.hl-yellow} para importar a `R` (y que suelen ocupar menos espacio en disco) son sus propias [**extensiones nativas**]{.hl-yellow}: ficheros en formatos `.RData` y `.rda`. Para cargarlos basta con [**utilizar la funciÃ³n**]{.hl-yellow} `load()` proporcionÃ¡ndole la ruta del fichero.

-   Archivos `RData`: vamos a importar el archivo `world_bank_pop.RData` que incluye la tabla `world_bank_pop`

```{r}
load("./datos/world_bank_pop.RData")
world_bank_pop
```

---

## Formatos nativos

-   Archivos `.rda`: vamos a importar el dataset airquality desde `airquality.rda`

```{r}
load("./datos/airquality.rda")
as_tibble(airquality)
```

---

## Formatos nativos

Tenga en cuenta que los archivos cargados con `load()` se cargan [**automÃ¡ticamente en el entorno**]{.hl-yellow} (con el nombre guardado originalmente), y no sÃ³lo se pueden cargar conjuntos de datos: `load()` nos permite cargar mÃºltiples objetos (no sÃ³lo datos tabulares).

Los archivos nativos `.rda` y `.RData` son una forma adecuada de guardar el entorno de variables.

```{r}
load(file = "./datos/multiple_objects.rda")
```

::: callout-important
## Importante

Las [**rutas**]{.hl-yellow} deben ser siempre [**sin espacios, Ã±, ni acentos**]{.hl-yellow}.
:::

---

## Datos tabulados: readr

El paquete `{readr}` dentro del entorno `{tidyverse}` contiene varias funciones Ãºtiles para [**cargar datos rectangulares (sin formatear pero tabulados)**]{.hl-yellow}.

::: columns
::: {.column width="50%"}
-   `read_csv()`: archivos `.csv` [**variables separadas por comas**]{.hl-purple}
-   `read_csv2()`: variables separadas por [**punto y coma**]{.hl-purple}
-   `read_tsv()`: variables separadas por [**tabuladores**]{.hl-purple}.
-   `read_table()`: variables separadas por [**espacios**]{.hl-purple}.
-   `read_delim()`: funciÃ³n generar con opciÃ³n de [**especificar el delimitador**]{.hl-purple}.
:::

::: {.column width="50%"}
![](img/data-import-readr.png)
:::
:::

Todos ellos necesitan como **argumento la ruta del fichero** mÃ¡s **otros opcionales** (saltar cabecera o no, decimales, etc). Ver mÃ¡s en <https://readr.tidyverse.org/>

---

## Datos tabulados (.csv, .tsv)

La principal ventaja de `{readr}` es que [**automatiza el formato**]{.hl-yellow} para pasar de un fichero plano (sin formato) a un tibble (en filas y columnas, con formato).

. . .

-   Archivo `.csv`: con `read_csv()` cargaremos archivos [**separados por comas**]{.hl-purple}, pasando como [**argumento la ruta**]{.hl-yellow} en `file = ...`. Vamos a importar el conjunto de datos `chickens.csv` (sobre pollos de dibujos animados, por quÃ© no). Si nos fijamos en la salida nos da el tipo de variables.

```{r}
library(readr)
chickens <- read_csv(file = "./datos/chickens.csv")
chickens
```

---

## Datos tabulados (.csv, .tsv)

El [**formato de la variable**]{.hl-yellow} se harÃ¡ normalmente [**automÃ¡ticamente**]{.hl-yellow} por `read_csv()`, y podemos consultarlo con `spec()`.

```{r}
spec(chickens)
```

---

## Datos tabulados (.csv, .tsv)

Aunque normalmente lo hace bien automÃ¡ticamente podemos [**especificar el formato explÃ­citamente**]{.hl-yellow} en `col_types = lista()` (en formato lista, con `col_xxx()` para cada tipo de variable, por ejemplo `eggs_laid` se importarÃ¡ como carÃ¡cter).

```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_types = list(col_character(), col_character(),
                            col_character(), col_character()))
chickens
```

---

## Datos tabulados (.csv, .tsv)

Incluso podemos indicar que [**variables queremos seleccionar**]{.hl-yellow} (sin ocupar memoria), indicÃ¡ndolo en `col_select = ...` (en formato lista, con `col_select = ...`).

```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_select = c(chicken, sex, eggs_laid))
chickens
```

---

## Datos tabulados (.txt)

Â¿QuÃ© ocurre cuando el [**separador no es correcto**]{.hl-red}?

. . .

Si usamos `read_csv()` espera que el separador entre columnas sea una coma pero, como puedes ver con el siguiente `.txt`, lo interpreta todo como una sola columna: [**no tiene coma y no sabe dÃ³nde separar**]{.hl-yellow}

```{r}
datos_txt <- read_csv(file = "./datos/massey-rating.txt")
dim(datos_txt)
as_tibble(datos_txt)
```

---

## Datos tabulados (.txt)

Para ello tenemos.

-   `read_csv2()` cuando el [**separador es punto y coma**]{.hl-yellow}, `read_tsv()` cuando es un [**tabulador**]{.hl-yellow} y `read_table()` cuando es un [**espacio**]{.hl-yellow}.

-   `read_delim()` en general.

```{r}
datos_txt <- read_table(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```

---

## Datos Excel (.xls, .xlsx)

Otro paquete de importaciÃ³n clave serÃ¡ el paquete `{readxl}` para [**importar datos desde Excel**]{.hl-yellow}. Tres funciones serÃ¡n clave:

-   `read_xls()` especÃ­fica para `.xls`, `read_xlsx()` especÃ­fica para `.xlsx`.
-   `read_excel()`: tanto para `.xls` como para `.xlsx`.

. . .

Vamos a importar `deaths.xlsx` con los registros de defunciones de famosos.

```{r}
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths
```

---

## Datos Excel (.xls, .xlsx)

```{r}
deaths |> slice(1:6)
```

[**Una desgracia muy comÃºn**]{.hl-red} es que haya algÃºn tipo de comentario o texto al principio del fichero, teniendo que [**saltar esas filas**]{.hl-yellow}.

---

## Datos Excel (.xls, .xlsx)

Podemos [**saltar estas filas**]{.hl-yellow} directamente en la carga con `skip = ...` (indicando el nÃºmero de filas a saltar).

```{r}
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths
```

---

## Datos Excel (.xls, .xlsx)

AdemÃ¡s con `col_names = ...` ya podemos renombrar las columnas en la importaciÃ³n ([**proporcionar nombres supone 1Âª lÃ­nea ya como dato**]{.hl-yellow})

```{r}
#| code-line-numbers: "2-3"
deaths <-
  read_xlsx(path = "./datos/deaths.xlsx", skip = 5,
            col_names = c("nombre", "profesion", "edad", "hijos", "nacimiento", "muerte"))
deaths
```

---

## Datos Excel (.xls, .xlsx)

TambiÃ©n podemos [**cargar un Excel con varias hojas**]{.hl-yellow}: para [**indicar la hoja**]{.hl-yellow} (ya sea por su nombre o por su nÃºmero) utilizaremos el argumento `sheet = ...`.

```{r}
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars
```

---

## Datos Excel (.xls, .xlsx)

Incluso podemos indicar el [**rango de celdas**]{.hl-yellow} a cargar con `range = ...`.

```{r}
iris <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "iris", range = "C1:E4")
iris
```

---

## Importar desde SAS/STATA/SPSS

El paquete `{haven}` dentro del universo tidyverse nos permitirÃ¡ [**importar ficheros de los 3 software de pago mÃ¡s importantes**]{.hl-yellow}: SAS, SPSS y Stata.

```{r}
library(haven)

# SAS
iris_sas <- read_sas(data_file = "./datos/iris.sas7bdat")

# SPSS
iris_spss <- read_sav(file = "./datos/iris.sav")

# Stata
iris_stata <- read_dta(file = "./datos/iris.dta")
```

---

## Exportar

De la misma forma que podemos importar tambiÃ©n podemos [**exportar**]{.hl-yellow}

-   exportar en `.RData` (opciÃ³n recomendada para variables almacenadas en `R`). Recuerda que esta extensiÃ³n [**sÃ³lo se puede utilizar en `R`**]{.hl-yellow}. Para ello, basta con utilizar `save(object, file = path)`.

```{r}
table <- tibble("a" = 1:4, "b" = 1:4)
save(table, file = "./datos/table.RData")
rm(table) # eliminar
load("./datos/table.RData")
table
```

---

## Exportar

La ventaja de `.RData` es que podemos [**exportar mÃºltiples variables de nuestro environment**]{.hl-yellow}, no solo un Ãºnico dataset.

```{r}
table <- tibble("a" = 1:4, "b" = 1:4)
a <- 1
b <- c("javi", "sandra")
save(table, a, b, file = "./datos/mult_obj.RData")
rm(list = c("a", "b", "table"))
load("./datos/mult_obj.RData")
table
```

---

## Exportar

-   [**exportado en `.csv`**]{.hl-yellow}. Para ello simplemente utilizamos `write_csv(object, file = path)`, y es el mÃ¡s recomendable para exportar bases de datos de tamaÃ±o pequeÃ±o o mediano. Ver <https://arrow.apache.org/docs/r/> para bases de datos masivas.

```{r}
write_csv(table, file = "./datos/table.csv")
read_csv(file = "./datos/table.csv")
```

---

## ğŸ’» Tu turno {#tu-turno-4-5}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ El conjunto de datos `who2` del paquete `{tidyr}` que hemos utilizado en ejercicios anteriores, expÃ³rtalo a un formato nativo `R` en la carpeta `datos` de tu proyecto de RStudio

```{r}
#| code-fold: true
#| eval: false
library(tidyr)
save(who2, file = "./datos/who2.RData")
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Carga el conjunto de datos `who2` pero desde la carpeta data (importa el fichero creado en el ejercicio anterior)

```{r}
#| code-fold: true
#| eval: false
load("./datos/who2.RData")
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Repite lo mismo (exportar e importar) en 4 formatos: `.csv`, `.xlsx`, `.sav` (spss) y `.dta` (stata)

```{r}
#| code-fold: true
#| eval: false

# csv
library(readr)
write_csv(who2, file = "./datos/who2.csv")
who2_data <- read_csv(file = "./datos/who2.csv")

# excel
library(openxlsx)
write.xlsx(who2, file = "./datos/who2.xlsx")
who2_data <- read_xlsx(path = "./datos/who2.xlsx")

# sas y stata
library(haven)
write_sav(who2, path = "./datos/who2.sav")
who2_data <- read_spss(path = "./datos/who2.sav")

write_dta(who2, path = "./datos/who2.dta")
who2_data <- read_dta(path = "./datos/who2.dta")
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Repita la carga de `who2.csv` pero seleccione sÃ³lo las 4 primeras columnas ya cargadas.

```{r}
#| code-fold: true
#| eval: false
who_select <-
  read_csv(file = "./datos/who2.csv",
           col_select = c("country", "iso2", "iso3", "year"))
who_select
```
:::

---

## Primer intento: scatter plot

Ahora que sabemos importar archivos, vamos a importar el conjunto de datos `gapminder`: un fichero con **datos de esperanzas de vida, poblaciones y renta per cÃ¡pita** de distintos paÃ­ses en distintos momentos temporales.

```{r}
library(readr)
gapminder <- read_csv(file = "./datos/gapminder.csv")
gapminder
```

---

## Primer intento: scatter plot

El fichero consta de 1704 registros y 6 variables: `country`, `continent`, `year`, `lifeExp` (esperanza de vida), `pop` (poblaciÃ³n) y `gdpPercap` (renta per cÃ¡pita).

```{r}
glimpse(gapminder)
```

Para empezar con algo sencillo [**filtraremos solo los datos de 1997**]{.hl-yellow}

```{r}
gapminder_1997 <- gapminder[gapminder$year == 1997, ]
```

---

## Primer intento: scatter plot

Imagina que queremos dibujar un [**scatter plot**]{.hl-yellow} (diagrama de dispersiÃ³n de puntos, que enfrenta a una variable `x` con una variable `y`).

Â 

Si tuviÃ©ses que [**construir capa a capa el grÃ¡fico**]{.hl-yellow}: Â¿quÃ© necesitarÃ­as?

---

## Ingredientes: datos

Â¿QuÃ© [**elementos necesitamos**]{.hl-yellow} para realizar un diagrama de puntos? Para [**iniciar el lienzo VACÃO (de momento)**]{.hl-purple} necesitamos llamar una base de datos con `ggplot(datos)`

::: columns
::: {.column width="45%"}
-   [**Datos (data)**]{.hl-yellow}: conjunto `gapminder_1997`.

```{r}
#| eval: false
ggplot(gapminder_1997)
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997)
```
:::
:::

---

## Ingredientes: (x, y)

Ya tenemos linkada la base de datos pero necesitamos [**indicarle que variables de la tabla**]{.hl-yellow} queremos que relacione con el grÃ¡fico (en este caso necesita mÃ­nimo una `x` y otra `y`).

::: columns
::: {.column width="45%"}
-   [**Datos (data)**]{.hl-yellow}: conjunto `gapminder_1997`.

-   [**Mapeado**]{.hl-yellow}: indicar dentro de `aes()` (aesthetics) las variables en cada coordenada. Todo [**dentro de aes() serÃ¡ mapeado de la base de datos**]{.hl-purple}

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop))
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop))
```
:::
:::

---

## GeometrÃ­a: geom_point()

De momento sigue vacÃ­o ya que aÃºn no le hemos indicado lo mÃ¡s importante: [**Â¿quÃ© tipo de grÃ¡fica queremos hacer?**]{.hl-yellow}. Para eso usaremos las [**capas geomÃ©tricas**]{.hl-yellow} que empiezan por `geom_xxx()`.

::: columns
::: {.column width="45%"}
-   [**GeometrÃ­a (geom)**]{.hl-yellow}: optaremos por **puntos** usando `geom_point()`.

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop)) +
  geom_point()
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(x = gdpPercap, y = pop)) +
  geom_point()
```
:::
:::

---

## Rol de los ejes: (x, y)

::: columns
::: {.column width="45%"}
Vamos a profundizar en ese mapeado: Â¿cÃ³mo [**cambiar el rol**]{.hl-yellow} de los ejes (poblaciÃ³n en el eje X y renta per cÃ¡pita en el eje Y)?

-   **Eje X**: poblaciÃ³n (variable `pop`)
-   **Eje Y**: renta per cÃ¡pita (variable `gdpPercap`)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(x = pop, y = gdpPercap)) +
  geom_point() 
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop)) +
  geom_point() 
```
:::
:::

---

## Rol de los ejes: (x, y)

::: columns
::: {.column width="45%"}
Â¿Y un scatter plot con **esperanza de vida** en eje X frente a **renta per cÃ¡pita**?

-   **Eje X**: esperanza de vida (variable `lifeExp`)
-   **Eje Y**: renta per cÃ¡pita (variable `gdpPercap`)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point()
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point()
```
:::
:::

---

## Color, size, shape: fijos

Dentro de `geom_point()` tenemos varios **parÃ¡metros estÃ©ticos a configurar**:

-   `na.rm = ...`: si queremos que nos quite ausentes.

-   `color = ...`: color (si tiene dimensiÃ³n, color del contorno)

-   `fill = ...`: color del relleno (si tiene dimensiÃ³n)

. . .

::: columns
::: {.column width="45%"}
Empezaremos por un [**color fijo**]{.hl-yellow}, por ejemplo `"red"` (existen otros como `"blue"`, `"black"`, `"yellow"`, etc)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red")
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red")
```
:::
:::

---

## Color, size, shape: fijos

::: columns
::: {.column width="45%"}
-   `size = ...`: tamaÃ±o de la geometrÃ­a (en este caso el [**tamaÃ±o de los puntos**]{.hl-yellow}), cuanto mayor sea el nÃºmero, mayor serÃ¡ el tamaÃ±o de la geometrÃ­a.

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7) 
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7)
```
:::
:::

---

## Color, size, shape: fijos

::: columns
::: {.column width="45%"}
-   `alpha = ...`: grado de opacidad del color (1 totalmente opaco, 0 totalmente transparente)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7,
             alpha = 0.4)
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7, alpha = 0.4)
```
:::
:::

---

## Color, size, shape: fijos

::: columns
::: {.column width="45%"}
-   `shape = ...`: forma de la geometrÃ­a, en este caso del Â«puntoÂ» (ver todas las opciones en `vignette("ggplot2-specs")`)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red",
             fill = "black",
             size = 7,
             alpha = 0.4,
             shape = 23)
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", fill = "black",
             size = 7, alpha = 0.4, shape = 23)
```
:::
:::

---

## Color, size, shape: fijos

::: columns
::: {.column width="45%"}
-   `stroke = ...`: tamaÃ±o del contorno

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7,
             alpha = 0.4, stroke = 3)
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", alpha = 0.4,
             size = 7, stroke = 3)
```
:::
:::

---

## Color, size, shape: fijos

::: columns
::: {.column width="45%"}
Los colores tambiÃ©n podemos asignÃ¡rselos por su **cÃ³digo hexadecimal**, consultando en <https://htmlcolorcodes.com/es/>, eligiendo el color que queramos. El cÃ³digo hexadecimal siempre comenzarÃ¡ con `#`

```{r}
#| eval: false
# Color en hexadecimal
# https://htmlcolorcodes.com/es/
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "#A02B85",
             alpha = 0.4, size = 7) 
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "#A02B85", alpha = 0.4, size = 7)
```
:::
:::

---

## Mapeado estÃ©tico: aes()

Hasta ahora los **atributos estÃ©ticos** se los hemos pasado fijos y [**constantes**]{.hl-yellow}. Pero la verdadera potencia y versatilidad de `ggplot` es que podemos [**mapear los atributos estÃ©ticos en funciÃ³n de los datos**]{.hl-yellow} en `aes()` para que **dependan de variables de los datos**.

. . .

::: columns
::: {.column width="45%"}
Por ejemplo, vamos a asignar un [**color a cada dato en funciÃ³n de su continente**]{.hl-yellow} con `aes(color = continent)`

```{r}
#| eval: false
# TamaÃ±o fijo
# Color por continentes
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent)) +
  geom_point(size = 7)
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(size = 5)
```
:::
:::

---

## Mapeado estÃ©tico: aes()

::: columns
::: {.column width="50%"}
Podemos combinarlo con lo que hemos hecho anteriormente:

-   [**color**]{.hl-yellow} en funciÃ³n del [**continente**]{.hl-purple}.

-   [**tamaÃ±o**]{.hl-yellow} en funciÃ³n de la [**poblaciÃ³n**]{.hl-purple}.

-   [**transparencia**]{.hl-yellow} la fijamos [**constante**]{.hl-purple} del 50%.

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7)
```

A este scatter plot particular se le conoce **BUBBLE CHART**
:::

::: {.column width="50%"}
```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7)
```
:::
:::

---

## VisualizaciÃ³n multivariante

Reflexionemos sobre el grÃ¡fico anterior:

-   **color** en funciÃ³n del **continente**.
-   **tamaÃ±o** en funciÃ³n de la **poblaciÃ³n**
-   **transparencia** fija del 50%


Usando los datos hemos conseguido dibujar en un [**grÃ¡fico bidimensional 4 variables**]{.hl-yellow}: `lifeExp` y `gdpPercap` en los ejes , `continent` como color y `pop` como tamaÃ±o de la geometrÃ­a, con muy pocas lÃ­neas de cÃ³digo.

---

## Escalas (scale): ejes

Es importante entender que [**hasta ahora solo hemos indicado que un atribut estÃ©tico A dependa de una variable B de los datos**]{.hl-yellow}.



Por ejemplo, si `aes(color = variable)` le estoy diciendo que cada modalidad distinta de la variable adopte un color distinto pero...[**Â¿quÃ© color?**]{.hl-yellow}

. . .

Para ello usaremos una de las capas mÃ¡s importantes, las [**capas de escalas**]{.hl-yellow} `scale_xxx()`.

---

## Escalas (scale): ejes

Hasta ahora dentro de `aes()` solo le indicÃ¡bamos que variable mapeamos pero no sus ajustes.

::: columns
::: {.column width="47%"}
Por ejemplo, vamos a **configurar el eje x para tener marcas personalizadas** cada 10 unidades (`scale_x_continuous(breaks = ...)`)
:::

::: {.column width="53%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```
:::
:::

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita",
       title = "Primer ggplot", caption = "J. Ãlvarez LiÃ©bana",
       color = "continente")
```

---

## Escalas (scale): colores

La misma idea la podemos aplicar a otro atrÃ­buto como los [**colores**]{.hl-yellow} con `scale_color_...()` y `scale_fill_...()`: hemos indicado que mapeÃ© dicho atributo por continente pero...Â¿quÃ© colores usar?

. . .

::: columns
::: {.column width="50%"}
Con `scale_color_manual()` podemos indicar manualmente una [**paleta**]{.hl-yellow} (puedes buscar en <https://htmlcolorcodes.com/>)
:::

::: {.column width="50%"}
```{r}
#| echo: false
pal <- c("#A02B85", "#2DE86B", "#4FB2CA", "#E8DA2D", "#E84C2D")
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = pal) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita",
       title = "Primer ggplot", caption = "J. Ãlvarez LiÃ©bana",
       color = "continente")
```
:::
:::

```{r}
#| eval: false
pal <- c("#A02B85", "#2DE86B", "#4FB2CA", "#E8DA2D", "#E84C2D")
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = pal) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

---

## Escalas (scale): colores

Otra opciÃ³n es elegir alguna de las [**paletas de colores diseÃ±adas**]{.hl-yellow} en el paquete `{ggthemes}`:

::: columns
::: {.column width="40%"}
-   `scale_color_colorblind()`: paleta de colores basada en los colores de [**daltÃ³nicos/as**]{.hl-yellow}.
:::

::: {.column width="60%"}
```{r}
#| echo: false
library(ggthemes)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```
:::
:::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

---

## Escalas (scale): colores

Incluso cargar [**paletas de colores diseÃ±adas en base a pelÃ­culas o arte**]{.hl-yellow}

::: columns
::: {.column width="44%"}
-   [**pelÃ­culas**]{.hl-yellow}: paquete `{harrypotter}` (repositorio de Github `aljrico/harrypotter`) usando `scale_color_hp_d()`.

```{r echo = FALSE,  out.width = "20%", fig.align = "center", fig.cap = "Paleta basada en la casa Ravenclaw"}
knitr::include_graphics("https://raw.githubusercontent.com/aljrico/harrypotter/master/readme_raw_files/palettes/ravenclaw.png")
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
library(harrypotter)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_hp_d(option = "ravenclaw")+
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```
:::
:::

```{r}
#| eval: false
devtools::install_github(repo = "aljrico/harrypotter") 
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  harrypotter::scale_color_hp_d(option = "ravenclaw")+
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

---

## Escalas (scale): colores

Incluso cargar [**paletas de colores diseÃ±adas en base a pelÃ­culas o arte**]{.hl-yellow}

::: columns
::: {.column width="45%"}
-   [**cuadros**]{.hl-yellow}: paquete `{MetBrewer}` (repositorio de Github `BlakeRMills/MetBrewer`) usando `scale_colour_manual(values = met.brewer(...))`.
:::

::: {.column width="55%"}
```{r}
#| echo: false
library(MetBrewer)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = met.brewer("Monet")) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```
:::
:::

```{r}
#| eval: false
devtools::install_github(repo = "BlakeRMills/MetBrewer") 
library(MetBrewer)

ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = met.brewer("Monet")) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

---

## Escalas (scale): colores

Incluso cargar [**paletas de colores diseÃ±adas en base a pelÃ­culas o arte**]{.hl-yellow}

::: columns
::: {.column width="45%"}
-   [**discos**]{.hl-yellow}: paquete `{peRReo}` (repositorio de Github `jbgb13/peRReo`) usando `scale_colour_manual(values = latin_palette())`.
:::

::: {.column width="55%"}
```{r}
#| echo: false
library(peRReo)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = latin_palette("rosalia")) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```
:::
:::

```{r}
#| eval: false
devtools::install_github(repo = "jbgb13/peRReo") 
library(peRReo)

ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = latin_palette("rosalia")) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

---

## Escalas: otros atributos

Lo mismo que hemos hecho para los ejes o colores podemos hacer para el [**resto de atrÃ­butos estÃ©ticos**]{.hl-yellow}

::: columns
::: {.column width="40%"}
Por ejemplo, vamos a indicarle que mapeÃ© el tamaÃ±o en funciÃ³n de poblaciÃ³n pero indicÃ¡ndole el [**rango de valores**]{.hl-yellow} (continuo en este caso) entre los que moverse con `scale_size_continuous()`
:::

::: {.column width="60%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  scale_size_continuous(range = c(3, 17)) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```
:::
:::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  scale_size_continuous(range = c(3, 15)) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

::: ::::

---

## Etiquetas sencillas: labs()

Podemos tambiÃ©n [**personalizar de manera sencilla**]{.hl-yellow} haciendo uso de la capa `labs()`:

::: columns
::: {.column width="45%"}
-   `title,subtitle`: tÃ­tulo/subtÃ­tulo
-   `caption`: pie de grÃ¡fica
-   `x, y`: nombres de los ejes
-   `size, color, fill, ...`: nombre en leyenda de las variables que codifiquen los atributos
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esp. de vida",
       y = "Renta per cÃ¡pita",
       title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana",
       color = "continente",
       size = "poblaciÃ³n")
```
:::
:::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita",
       title = "Primer ggplot", subtitle = "Datos de gapminder",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente", size = "poblaciÃ³n")
```

---

## Eliminar de la leyenda

Podemos eliminar variables de la leyenda con `guides(atributo = "none")`

::: columns
::: {.column width="45%"}
```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, 
           x = lifeExp,
           color = continent, 
           size = pop)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida",
       y = "Renta per cÃ¡pita",
       title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana",
       color = "continente")
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida",
       y = "Renta per cÃ¡pita",
       title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana",
       color = "continente")
```
:::
:::

---

## Tema (bÃ¡sico)

Por Ãºltimo en este primer grÃ¡fico, vamos personalizar el tema con alguna de las capas `theme_...()`

::: columns
::: {.column width="45%"}
Por ejemplo, vamos a usar `theme_minimal()` para tener un tema "austero" y minimalista (aprenderemos a definir cada detalle de nuestro tema).
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```
:::
:::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```


---

## GrÃ¡ficos de una variable

El anterior ejemplo era un **diagrama de dispersiÃ³n** (bivariante) que nos permite jugar mucho con los parÃ¡metros pero empezaremos [**aprendiendo a analizar una sola variable**]{.hl-yellow} (estadÃ­stica univariante).

. . .

::: columns
::: {.column width="40%"}
Para ello algo fundamental serÃ¡ conocer la naturaleza de la variable ya que [**habrÃ¡ cosas que podamos hacer con un tipo de variables y no con otras**]{.hl-yellow}. Por ejemplo, vamos a tomar el fichero de datos `starwars` del paquete `{dplyr}` y vamos a **empezar un ggplot**

```{r}
#| eval: false
library(dplyr)
ggplot(starwars)
```
:::

::: {.column width="60%"}
```{r}
#| echo: false
library(dplyr)
ggplot(starwars)
```
:::
:::

---

## GrÃ¡ficos de una variable

::: columns
::: {.column width="45%"}
Si quiÃ©semos hacer un diagrama de dispersiÃ³n sencillo como antes entre peso y estatura serÃ­a asÃ­

```{r}
#| eval: false
ggplot(starwars) +
  geom_point(aes(x = mass, y = height)) +
  theme_minimal()
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(starwars) +
  geom_point(aes(x = mass, y = height)) +
  theme_minimal()
```
:::
:::

Â¿QuÃ© lÃ­nea habrÃ¡ cambiar si en lugar de hacer un diagrama de dispersiÃ³n queremos hacer un [**histograma de la estatura**]{.hl-yellow}

. . .

Lo que [**diferencia a un grÃ¡fico de otro es la capa geomÃ©trica**]{.hl-yellow}, asÃ­ que deberemos buscar un `geom_xxx()` distinto (en este caso `geom_histogram()`)

---

## Histogramas

Un [**histograma es una representaciÃ³n grÃ¡fica de la distribuciÃ³n de frecuencia**]{.hl-yellow} de un conjunto de datos **numÃ©ricos continuos**. Consiste en un grÃ¡fico de barras [**PERO donde ahora la base de cada barra representa un intervalo de valores**]{.hl-yellow}, y la altura de la barra indica la frecuencia o la densidad de datos dentro de ese intervalo: ahora la [**anchura de las barras sÃ­ es relevante**]{.hl-yellow} (cuantifica la anchura del intervalo en el que estamos agrupando los datos).

. . .

Los histogramas son especialmente Ãºtiles para visualizar la forma y la dispersiÃ³n de los datos aunque [**dependen de un parÃ¡metro crÃ­tico**]{.hl-red} como es la cantidad de barras (o anchura de cada barra) de las que queramos disponer.

![](img//clipboard-984736011.png){fig-align="center" width="414"}

---

## Histogramas

FÃ­jate que si lo [**cambiamos tal cual produce error**]{.hl-red}. Â¿Por quÃ©?

```{r}
#| error: true
ggplot(starwars) + geom_histogram(aes(x = mass, y = height))
```

. . .

::: columns
::: {.column width="42%"}
La capa usada (histograma) solo admite una `x` o un `y` --\> habrÃ¡s grÃ¡ficos bivariantes y [**grÃ¡ficos univariantes**]{.hl-yellow}

```{r}
#| eval: false
ggplot(starwars) +
  geom_histogram(aes(x = height)) +
  theme_minimal()
```
:::

::: {.column width="58%"}
```{r}
#| echo: false
ggplot(starwars) +
  geom_histogram(aes(x = height)) +
  theme_minimal()
```
:::
:::

---

## Histogramas

Los histogramas dependen de una [**decisiÃ³n crÃ­tica**]{.hl-red} que cambiarÃ¡ por completo el grÃ¡fico: el nÃºmero de barras (`bins = ...`).

```{r}
#| code-fold: true
ggplot(starwars) +
  geom_histogram(aes(x = height), bins = 8) +
  theme_minimal()
```

---


## GrÃ¡fico de densidad

Como hemos comentado una de las decisiones a tomar en un histograma es la anchura de las barras ya que dicho valor va a cambiar nuestra percepciÃ³n de la distribuciÃ³n de los datos.

. . .

Una de las alternativas mÃ¡s conocidas son los conocidos como [**grÃ¡ficos de densidad**]{.hl-yellow}, una especie de aproximaciÃ³n continua de dichas barras, proporcionando la curva que se intuye que define la forma de un histograma si hacemos las barras cada vez mÃ¡s finas.

![](img//clipboard-2738368484.png){fig-align="center" width="300"}

---

## GrÃ¡fico de densidad

Para realizar un grÃ¡fico de densidad debemos de usar simplemente `geom_density()` como capa geomÃ©trica

```{r}
#| code-fold: true
ggplot(starwars) +
  geom_density(aes(x = height)) +
  theme_minimal()
```

---

## GrÃ¡fico de densidad

Lo que hemo aprendido sobre los [**atributos estÃ©ticos de un grÃ¡fico**]{.hl-yellow} podemos aplicarlo a cualquier capa. Por ejemplo, vamos a decirle que el [**color y relleno de la densidad dependa del `sex`**]{.hl-yellow} (es decir, una densidad para cada uno).

```{r}
#| code-fold: true
#| warning: false
ggplot(starwars |> drop_na(sex)) +
  geom_density(aes(x = height, fill = sex, color = sex),
               alpha = 0.3) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

---

## GrÃ¡fico de densidad

El paquete `{ggridges}` y su funciÃ³n `geom_density_ridges()` nos permite [**visualizar densidades de distintos grupos en distintos niveles de altura**]{.hl-yellow}: en lugar de tener todas una encima de otra, podremos indicarle una variable `y`

```{r}
#| code-fold: true
#| warning: false
library(ggridges)
ggplot(starwars |> drop_na(sex)) +
  geom_density_ridges(aes(x = height, y = sex,
                          fill = sex, color = sex),
               alpha = 0.3) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

---


## Diagrama de sectores

Un [**grÃ¡fico de sectores**]{.hl-red}, tambiÃ©n conocido como grÃ¡fico circular o pie chart en inglÃ©s, es una representaciÃ³n visual de datos que muestra la proporciÃ³n de cada categorÃ­a dentro de un conjunto de datos en forma de un cÃ­rculo dividido en sectores. Cada sector representa una categorÃ­a y su tamaÃ±o angular es proporcional a la frecuencia o proporciÃ³n de esa categorÃ­a en relaciÃ³n con el total.

![](img/clipboard-2656977358.png){fig-align="center" width="590"}

---

## Diagrama de sectores

![](img/clipboard-2247838254.png){fig-align="center" width="590"}

---

## Diagrama de sectores

![](img/clipboard-2247838254.png){fig-align="center" width="550"}

![](img/clipboard-1745598244.png){fig-align="center" width="550"}

---

## Diagrama de barras

Utiliza [**barras rectangulares para mostrar la frecuencia, la magnitud o la proporciÃ³n de diferentes categorÃ­as**]{.hl-yellow}. Cada barra representa una categorÃ­a especÃ­fica y su longitud es proporcional a la cantidad o frecuencia que representa. Es importante [**no confundir con un histograma**]{.hl-red}: en un diagrama de barras la anchura de cada barra es una decisiÃ³n meramente estÃ©tica (incluso si dejas o no un hueco entre cada barra).

TambiÃ©n pueden ser Ãºtiles para representar variables cuantitativas discretas (e.g., nÃºmero de hijos).

![](img//clipboard-3388298140.png){fig-align="center" width="400"}


---

## Diagrama de cajas

Un [**diagrama de cajas (boxplots)**]{.hl-yellow} es una representaciÃ³n grÃ¡fica que proporciona un resumen de varias caracterÃ­sticas importantes de un conjunto de datos numÃ©ricos basado en **medidas de posiciÃ³n**.

. . .

El diagrama de cajas muestra la distribuciÃ³n de los datos a lo largo de un eje vertical, dividiendo el conjunto de datos en cuartiles y proporcionando informaciÃ³n sobre la dispersiÃ³n y la simetrÃ­a de la distribuciÃ³n. Es importante tener en cuenta que en este grÃ¡fico, tanto la centralidad representada (mediana) como las medidas de posiciÃ³n (cuartiles) como los valores atÃ­picos, se hace [**en relaciÃ³n a la mediana y no a la media**]{.hl-yellow}.

![](img/clipboard-2370668930.png){fig-align="center" width="477"}

---

## Diagrama de cajas

Para realizarlos basta con usar `geom_boxplot()` como capa geomÃ©trica. Por ejemplo, vamos a realizar uno con la variable `height`

```{r}
#| code-fold: true
ggplot(starwars |> drop_na(height)) +
  geom_boxplot(aes(x = height)) +
  theme_minimal()
```

---

## Diagrama de cajas

Podemos **invertir la posiciÃ³n de los boxplots** indicÃ¡ndole la variable `y` en lugar de `x`.

```{r}
#| code-fold: true
ggplot(starwars |> drop_na(height)) +
  geom_boxplot(aes(x = height)) +
  theme_minimal()
```

---

## Diagrama de cajas

Podemos de nuevo incluir lo aprendido sobre atributos estÃ©ticos en estos grÃ¡ficos. Por ejemplo, vamos a pintar un boxplot vertical (es decir `y = height`) por cada sexo (`x = sex`) distinguiendo los colores de cada uno.

```{r}
#| code-fold: true
ggplot(starwars |> drop_na(height, sex)) +
  geom_boxplot(aes(x = sex, y = height, fill = sex,
                   color = sex), alpha = 0.5) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

---

## Diagrama de cajas

La funciÃ³n `geom_boxplot()` nos permite incluso [**distinguir outliers**]{.hl-yellow} en color, forma y tamaÃ±o (empiezan todos los parÃ¡metros por `outlier...`)

```{r}
#| code-fold: true
ggplot(starwars |> drop_na(height, sex)) +
  geom_boxplot(aes(x = sex, y = height, fill = sex,
                   color = sex), alpha = 0.5,
               outlier.alpha = 0.8, outlier.shape = 23,
               outlier.size = 2, outlier.color = "#d72020",
               outlier.fill = "#d72020") +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

---

## Diagrama de cajas

Dichos grÃ¡ficos podemos combinarlos con un [**gotelÃ© de las observaciones**]{.hl-yellow} haciendo uso de `geom_jitter()`, indicÃ¡ndole con `width = ...` la anchura del gotelÃ© (a mÃ¡s valor, mÃ¡s disperso y confuso).

```{r}
#| code-fold: true
ggplot(starwars |> drop_na(height, sex),
       aes(x = sex, y = height, fill = sex, color = sex)) +
  geom_boxplot(alpha = 0.5, outlier.alpha = 0) +
  geom_jitter(width = 0.3) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

---

## GrÃ¡ficos de violÃ­n

Los grÃ¡ficos de cajas y bigotes o boxplot son una alternativa que mejora los clÃ¡sicos grÃ¡ficos dinÃ¡mita o error bar plots (ver [**incovenientes de boxplots**](https://hausetutorials.netlify.app/posts/2019-02-22-why-we-should-never-use-barplots-use-geomquasirandom-instead/)), uno de los grÃ¡ficos mÃ¡s habituales en artÃ­culos cientÃ­ficos en el Ã¡mbito de la bioinformÃ¡tica y bioestadÃ­stica.

A pesar de que son una mejor alternativa que los error bar plots, en muchas ocasiones puede ser interesante acompaÃ±ar a nuestros boxplot con lo que se conoce como [**grÃ¡ficos de violÃ­n**]{.hl-yellow} (algo parecido a dos grÃ¡ficos de densidad, uno pegado al otro de manera simÃ©trica)

![](img/clipboard-943497861.png){fig-align="center" width="477"}

---

## GrÃ¡ficos de violÃ­n

Para el grÃ¡fico de violÃ­n basta con `geom_violin()` 

```{r}
#| code-fold: true
ggplot(starwars |> drop_na(height, sex),
       aes(x = sex, y = height,
           fill = sex, color = sex)) +
  geom_violin(alpha = 0.5) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

---

## Violin + boxplot 

Incluso puedes **combinarlo con un boxplot**

```{r}
#| code-fold: true
ggplot(starwars |> drop_na(height, sex),
       aes(x = sex, y = height,
           fill = sex, color = sex)) +
  geom_violin(alpha = 0.5) +
  geom_boxplot(alpha = 0.2, width = 0.2,
               outlier.alpha = 0.8) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

---

## Recursos para visualizaciÃ³n {#recursos-dataviz}

- [**Tipos de grÃ¡ficos**]: <https://data-to-viz.com/>
- [**GrÃ¡ficos en ggplot**]: <https://r-graph-gallery.com/>
- [**Hay vida mÃ¡s allÃ¡ de los boxplots**]: <https://z3tt.github.io/beyond-bar-and-box-plots/>


- [**Selector de colores**]: <https://htmlcolorcodes.com/>
- [**Selector de colores desde captura**]: <https://imagecolorpicker.com/>



---

## ğŸ’» Tu turno {#tu-turno-4-6}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Toma el conjunto ya conocido de `starwars` del paquete `{dplyr}`. Realiza un diagrama de barras para contar las modalidades de la variable `sex` (solo eso, sin mÃ¡s opciones) eliminando antes los ausentes.

```{r}
#| code-fold: true
starwars |> 
  drop_na(sex) |> 
  ggplot() +
  geom_bar(aes(x = sex))
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ AÃ±ade lo que consideres del grÃ¡fico anterior para hacer que el relleno dependa de cada valor de `sex`. Personaliza tÃº los colores.

```{r}
#| code-fold: true
starwars |> 
  drop_na(sex) |> 
  ggplot() +
  geom_bar(aes(x = sex, fill = sex), alpha = 0.7) +
  scale_fill_manual(values = c("#3b9559", "#e29c4d", "#4265b0", "#b0428b"))
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ AÃ±ade lo que consideres del grÃ¡fico anterior para personalizar los tÃ­tulos de los ejes, de la leyenda, poner un tÃ­tulo al grÃ¡fico.

```{r}
#| code-fold: true
starwars |> 
  drop_na(sex) |> 
  ggplot() +
  geom_bar(aes(x = sex, fill = sex), alpha = 0.7) +
  scale_fill_manual(values = c("#3b9559", "#e29c4d", "#4265b0", "#b0428b")) +
  labs(x = "Sexo", y = "Frec. absoluta",
       title = "DistribuciÃ³n de sexo en personajes\nde Starwars",
       fill = "Sexo")
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ AÃ±ade lo que consideres del grÃ¡fico anterior para hacer que el eje y tenga una marca de 10 en 10 valores. Incluye un tema diferente al de por defecto

```{r}
#| code-fold: true
starwars |> 
  drop_na(sex) |> 
  ggplot() +
  geom_bar(aes(x = sex, fill = sex), alpha = 0.7) +
  scale_fill_manual(values = c("#3b9559", "#e29c4d", "#4265b0", "#b0428b")) +
  scale_y_continuous(breaks = seq(0, 60, by = 10)) +
  labs(x = "Sexo", y = "Frec. absoluta",
       title = "DistribuciÃ³n de sexo en personajes\nde Starwars",
       fill = "Sexo") +
  theme_minimal()
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Â¿CÃ³mo podrÃ­as modificar el cÃ³digo anterior para que cada barra se divida en funciÃ³n de la variable gÃ©nero? Cada barra (para cada sexo) se dividirÃ¡ en dos gÃ©neros: masculino y femenino.

```{r}
#| code-fold: true
#| code-line-numbers: "4-5"
starwars |> 
  drop_na(sex) |> 
  ggplot() +
  geom_bar(aes(x = sex, fill = gender), alpha = 0.7) +
  scale_fill_manual(values = c("#e29c4d", "#4265b0")) +
  scale_y_continuous(breaks = seq(0, 60, by = 10)) +
  labs(x = "Sexo", y = "Frec. absoluta",
       title = "DistribuciÃ³n de sexo y gÃ©nero\nen personajes de Starwars",
       fill = "GÃ©nero") +
  theme_minimal()
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Replica el grÃ¡fico del ejercicio 4 pero haciendo uso de las frecuencias relativas (cÃ¡lculas antes para poder visualizarla)

```{r}
#| code-fold: true
starwars |> 
  drop_na(sex) |> 
  count(sex) |> 
  mutate("frec_rel" = n/sum(n)) |> 
  ggplot() +
  geom_col(aes(x = sex, y = frec_rel, fill = sex), alpha = 0.7) +
  scale_fill_manual(values = c("#3b9559", "#e29c4d", "#4265b0", "#b0428b")) +
  scale_y_continuous(breaks = seq(0, 0.9, by = 0.1)) +
  labs(x = "Sexo", y = "Frec. absoluta",
       title = "DistribuciÃ³n de sexo en\n personajes de Starwars",
       fill = "Sexo") +
  theme_minimal()
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Visualiza un boxplot de la variable estatura distinguiendo por sexos

```{r}
#| code-fold: true
starwars |> 
  drop_na(height, sex) |> 
  ggplot() + # le decimos que los outlier
  geom_boxplot(aes(x = sex, y = height, color = sex, fill = sex), alpha = 0.5) +
  scale_color_manual(values = c("#3b9559", "#e29c4d", "#4265b0", "#b0428b")) +
  scale_fill_manual(values = c("#3b9559", "#e29c4d", "#4265b0", "#b0428b")) +
  guides(color = "none") + # para eliminar color de leyenda
  labs(x = "Sexo", y = "Estatura",
       title = "DistribuciÃ³n de la estatura vs sexo en\n personajes de Starwars",
       fill = "Sexo") +
  theme_minimal()
```



:::

---

## ğŸ£ Caso prÃ¡ctico: visualizaciÃ³n covid

Vamos a practicar la visualizaciÃ³n con la [**base de datos completa de covid del ISCIII**]{.hl-yellow} que vamos a cargar directamente desde la web: en lugar de poner la ruta del `.csv` de nuestro ordenador vamos a poder usar el link directamente (clickando con botÃ³n derecho del ratÃ³n en los archivos de <https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>)

```{r}
library(readr)
datos <- read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/intro-dataviz-isciii/#caso-pr%C3%A1ctico-visualizaci%C3%B3n-covid).

# Clases 5 y 6: [intro a descriptiva]{.flow} {#descriptiva}

[**EstadÃ­stica univariante**]{style="color:#444442;"}

-   [ğŸ’» Tu turno: descriptiva univariante](#tu-turno-5-1)
-   [ğŸ£ Caso prÃ¡ctico: encuestas de satisfacciÃ³n](#caso-practico-5-1)
-   [ğŸ‘¾ Materiales extras visualizaciÃ³n](#extra-dataviz)
-   [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## IntroducciÃ³n

La estadÃ­stica descriptiva es una rama de la estadÃ­stica que se dedica a [**recolectar, organizar, presentar y analizar un conjunto de datos**]{.hl-yellow} para describir las caracterÃ­sticas y comportamientos de dicho conjunto.


AdemÃ¡s de para conocer y entender los datos es la fase en la que [**detectaremos errores e incongruencias**]{.hl-yellow}, teniendo muchas veces que hacer una [**depuraciÃ³n de datos**]{.hl-yellow} para dejar la base de datos preparada para su anÃ¡lisis.

---

## Resumen de etapas

1.  RecolecciÃ³n de datos.

2.  OrganizaciÃ³n y presentaciÃ³n de los datos (estudio de una variable).

3.  RelaciÃ³n entre variables (estudio bivariado).

---

## Fase 1: recolecciÃ³n

La podemos hacer a travÃ©s de **encuestas, experimentos, observaciones, registros**, etc. Lo mÃ¡s importante en esta etapa es que los datos sean representativos del fenÃ³meno o poblaciÃ³n que se estudia.


[**Ejemplo**]{.hl-green}: queremos llevar a cabo una [**investigaciÃ³n para analizar la satisfacciÃ³n de los pacientes**]{.hl-yellow} con los servicios de urgencias de la red de hospitales pÃºblicos madrileÃ±os. Â¿QuÃ© muestra serÃ¡ mÃ¡s representativa?

a)  100 primeros pacientes que lleguen a urgencias del 12 de Octubre.

b)  Los 10 primeros pacientes que lleguen a las urgencias de todos los hospitales de la red de hospitales madrileÃ±os.

c)  Seleccionamos al azar 3 hospitales del grupo 3 (hospitales de gran complejidad), grupo 2 (complejidad intermedia) y grupo 3 (baja complejidad) y de cada uno de ellos seleccionamos un nÃºmero proporcional de pacientes segÃºn el total de pacientes que llegan a cada hospital.

---

## Fase 1: recolecciÃ³n

[**SoluciÃ³n**]{.hl-yellow}:

c)  **Seleccionamos al azar 3 hospitales del grupo 3 (hospitales de gran complejidad), grupo 2 (hospitales de complejidad intermedia) y grupo 3 (hospitales de baja complejidad) y de cada uno de ellos seleccionamos un nÃºmero proporcional de pacientes segÃºn el nÃºmero total de pacientes que llegan a cada hospital**.

Â 

Con a) todas las conclusiones que saquemos del estudio serÃ¡n aplicadas al Hospital 12 de Octubre. Con b) es una forma semi representativa pero vÃ¡lida de conseguir una muestra de forma fÃ¡cil.

. . .

La rama de la estadÃ­stica que se dedica a estudiar esta parte del anÃ¡lisis se conoce como [**muestreo**]{.hl-yellow}

---

## Fase 2: organizaciÃ³n y presentaciÃ³n

Una vez recopilados los datos deben organizarse de manera que sean comprensibles y manejables. Para ello necesitaremos clasificar los datos en [**cuantitativos y cualitativos**]{.hl-yellow} y estudiar sus caracterÃ­sticas segÃºn su tipo.

-   [**Messy data**]{.hl-red}: datos mal organizados o desordenados (mÃºltiples individuos en cada fila, misma variable pero separada en varias columnas, etc).

-   [**Tidy data**]{.hl-green}: datos organizados y estandarizados (una variable en cada columna, un registro/individuo en cada fila y un solo valor en cada celda).

---

## Fase 2: organizaciÃ³n y presentaciÃ³n

La informaciÃ³n la poder **resumir o presentar** de distintas maneras.

-   [**EstadÃ­sticos o medidas**]{.hl-yellow}:

    -   Medidas cualitativas: tablas de frecuencias.

    -   Medidas cuantitativas: medidas numÃ©ricas de centralizaciÃ³n y dispersiÃ³n.

-   [**GrÃ¡ficamente**]{.hl-yellow}:

    -   Medidas cualitativas: grÃ¡ficos de barras, gofres, etc.

    -   Medidas cuantitativas: histogramas, densidades, boxplots, etc

---

## Fase 3: relaciÃ³n entre variables

Una vez hecho el estudio de cada variable por separado buscaremos [**relacionar dos variables de forma simultÃ¡nea para buscar la asociaciÃ³n**]{.hl-yellow} entre ellas:

-   [**Cuali vs cuali**]{.hl-yellow}: tablas de frecuencias --\> pruebas de Fisher y chi-cuadrado --\> interpretaciÃ³n de OR y RR.

-   [**Cuanti vs cuanti**]{.hl-yellow}: correlaciÃ³n --\> test de correlaciones (o test de igualdad de distribuciones) --\> diagrmas de dispersiÃ³n.

-   [**Cuanti vs cuali**]{.hl-yellow}: ANOVA.

---

## Conceptos bÃ¡sicos

En estadÃ­stica es fundamental entender los conceptos de [**poblaciÃ³n, muestra y variable**]{.hl-yellow}, ya que son la base para cualquier anÃ¡lisis estadÃ­stico.

. . .

-   [**PoblaciÃ³n**]{.hl-yellow}

La poblaciÃ³n es el **conjunto completo de elementos o individuos** que tienen una caracterÃ­stica comÃºn y sobre los cuales se desea obtener informaciÃ³n. En la mayorÃ­a de casos el acceso a la **totalidad de la poblaciÃ³n es inviable** por motivos econÃ³micos, legales o Ã©ticos, asÃ­ que en la mayorÃ­a de situaciones las conclusiones deberemos sacarlas haciendo uso de lo que se conoce como **muestra**.

. . .

**Ejemplo**: la diferencia entre censo y encuesta es que el primero recopila datos de todos los individuos de una poblaciÃ³n, mientras que el segundo trata de estimarlos o inferirlos a partir de una muestra representativa de la misma.

---

## Conceptos bÃ¡sicos

-   [**Muestra**]{.hl-yellow}: subconjunto de la poblaciÃ³n que se selecciona para su anÃ¡lisis con el fin de hacer inferencias o generalizaciones sobre la poblaciÃ³n completa. La muestra debe ser **representativa de la poblaciÃ³n** para que las conclusiones sean vÃ¡lidas.

-   **Muestreo aleatorio simple**: cada miembro de la poblaciÃ³n tiene la misma probabilidad de ser seleccionado.

-   **Muestreo estratificado**: la poblaciÃ³n se divide en subgrupos (estratos) y se toma una muestra de cada uno.

-   **Muestreo (no aleatorio) sistemÃ¡tico**: se selecciona cada n-Ã©simo miembro de la poblaciÃ³n.

-   **Muestreo (no aleatorio) por cuotas**: se seleccionan aquellos individuos que cumplan ciertas condiciones.

-   **Muestreo por conveniencia**: se elige a los miembros que son mÃ¡s fÃ¡ciles de acceder, aunque este mÃ©todo puede introducir sesgos.

---

## Tipos de muestreo

[**Ejemplo 1**]{.hl-yellow}

-   **PoblaciÃ³n**: todos los pacientes que han sido atendidos en un hospital especÃ­fico durante el Ãºltimo aÃ±o.

-   **Muestra (aleatoria simple)**: Seleccionamosseleccionamos 200 pacientes de manera aleatoria del registro de pacientes del Ãºltimo aÃ±o. Para asegurarnos de que la muestra sea representativa, podemos usar muestreo aleatorio simple, donde cada paciente tiene la misma probabilidad de ser seleccionado.

---

## Tipos de muestreo

[**Ejemplo 2**]{.hl-yellow}

-   **PoblaciÃ³n**: todos los estudiantes matriculados en una universidad durante el semestre actual.

-   **Muestra (aleatoria estratificada)**: seleccionamos 500 estudiantes utilizando muestreo estratificado para asegurar que diferentes subgrupos (estratos) de la poblaciÃ³n estÃ©n representados. Los estratos pueden ser facultades (mismo % de facultades representadas que en la poblaciÃ³n universitaria), gÃ©nero, clase social, etc.

---

## Tipos de muestreo

[**Ejemplo 3**]{.hl-yellow}

-   **PoblaciÃ³n**: todas las especies de Ã¡rboles en un bosque determinado.

-   **Muestra (sistemÃ¡tica no aleatoria)**: Sseleccionamos parcelas de muestreo de 10m x 10m dentro del bosque y contabilizamos todas las especies de Ã¡rboles presentes en esas parcelas. Esto se puede hacer utilizando muestreo sistemÃ¡tico.

---

## Tipos de muestreo

[**Ejemplo 4**]{.hl-yellow}

-   **PoblaciÃ³n**: todos los pacientes de covid de un hospital.

-   **Muestra (por cuotas no aleatoria)**: seleccionamos solo a las personas mayores de 65 aÃ±os para realizar un estudio clÃ­nico inicial sobre los efectos secundarios de una posible vacuna de la covid-19.

Estos mÃ©todos aseguran, de una manera u otra, que las muestras sean representativas de sus respectivas poblaciones, lo que permite realizar anÃ¡lisis precisos y confiables.

---

## Conceptos bÃ¡sicos

-   [**Variable**]{.hl-yellow}

Una variable es **cualquier caracterÃ­stica o atributo** que puede tomar diferentes valores entre los individuos de la poblaciÃ³n o muestra. Las variables pueden ser de varios tipos segÃºn su naturaleza:

-   [**Cualitativas (o categÃ³ricas)**]{.hl-purple}: describen cualidades o categorÃ­as. Ejemplos:

    -   Nominales: no tienen un orden intrÃ­nseco (e.g., gÃ©nero, estado civil).
    -   Ordinales: tienen un orden intrÃ­nseco (e.g., niveles de satisfacciÃ³n, grado acadÃ©mico, sano-leve-grave).

---

## Conceptos bÃ¡sicos

-   [**Variable**]{.hl-yellow}

-   [**Cuantitativas**]{.hl-purple}: describen cantidades y pueden ser medidas numÃ©ricamente. Ejemplos:

    -   Discretas finitas: toman valores finitos (e.g., nÃºmero de hijos, nÃºmero de visitas al mÃ©dico, escala de dolor).
    -   Discretas infinitas: toman valores infinitos (o que se podrÃ­an considerar como tal) pero podemos enumerarlas y sabemos siempre el siguiente elemento (e.g., nÃºmero de pelos de nuestra cabellera, nÃºmero de personas que pueden entrar en una tienda en un periodo dado).
    -   Continuas: pueden tomar cualquier valor dentro de un rango (e.g., altura, peso, tiempo de espera).

---

## Conceptos bÃ¡sicos

-   [**Modalidades**]{.hl-yellow}

Una modalidad es uno de los **valores** que toma una **variable dentro de una muestra**.

El **conjunto de modalidades posibles** que podrÃ­a haber tomado (en tu poblaciÃ³n) se suele conocer tambiÃ©n como soporte. Algunos ejemplos en funciÃ³n del tipo de variables son:

-   Color de ojos (cualitativa nominal): negro, azul y marrÃ³n (3 modalidades en esa muestra de un espectro de colores mÃ¡s amplio que podrÃ­amos tener como soporte).
-   Estado del paciente (cualitativa ordinal): sano, leve y grave (3 modalidades en esa muestra de un conjunto de opciones - por ejemplo, sano, leve, grave, UCI, fallecido - que podrÃ­amos tener).

---

## Conceptos bÃ¡sicos

-   [**Modalidades**]{.hl-yellow}

Una modalidad es uno de los valores que toma una variable dentro de una muestra. El **conjunto de modalidades** posibles que podrÃ­a haber tomado (en tu **poblaciÃ³n**) se suele conocer tambiÃ©n como **soporte**. Algunos ejemplos en funciÃ³n del tipo de variables son:

-   NÃºmero de hijos (cuantitativa discreta finita): 0, 1, 2 y 3 (4 modalidades en esa muestra de un conjunto de valores posibles - de 0 a...20 hijos - que podrÃ­amos tener en la poblaciÃ³n general).

-   Temperatura anual de Madrid (cuantitativa continua): un rango de -5ÂºC a 45ÂºC (un rango continuo de valores en los que se mueve nuestra variable en la muestra (de un rango mÃ¡s amplio, por ejemplo desde -20ÂºC a 50ÂºC que podrÃ­a moverse de manera global si tuviÃ©semos otra muestra).

---

## Ejercicio: tipo de variables

Piensa en tipos de variables que se pueden medir en cada uno de los ejemplos de poblaciÃ³n y muestra que hemos estudiado.

[**Ejemplo 1**]{.hl-yellow}

| PoblaciÃ³n                                                                                                              | Muestra                                                                                   | Variables                            |
|:--------------------------------------------------|:---------------------|:-------------------------------------|
| Todos los pacientes de un hospital de los queremos estudiar su grado de satisfcacciÃ³n con la atenciÃ³n que han recibido | 200 pacientes seleccionados de forma aleatoria del registro de pacientes en el Ãºltimo aÃ±o | **Cuantitativas**: **Cualitativas**: |

---

## Ejercicio: tipo de variables

[**Ejemplo 1: soluciÃ³n**]{.hl-yellow}

| PoblaciÃ³n                                                                                                              | Muestra                                                                                   | Variables                                                                                                                                                                                                                                                                                                                           |     |
|:--------------------------------------------------|:---------------------|:------------------------------------------------|-----|
| Todos los pacientes de un hospital de los queremos estudiar su grado de satisfcacciÃ³n con la atenciÃ³n que han recibido | 200 pacientes seleccionados de forma aleatoria del registro de pacientes en el Ãºltimo aÃ±o | **Cuantitativas**: edad (discreta), tiempo de espera (continua), grado de satisfacciÃ³n en una escala del 0 al 10 (discreta), nÃºmero de visitas en el Ãºltimo aÃ±o (discreta). \| **Cualitativas**: gÃ©nero (nominal), estado civil (nominal), si viene acompaÃ±ado (nominal), grado de satisfacciÃ³n como bueno, regular malo (ordinal). |     |

---

## Ejercicio: tipo de variables

Piensa en tipos de variables que se pueden medir en cada uno de los ejemplos de poblaciÃ³n y muestra que hemos estudiado.

-   [**Ejemplo 2**]{.hl-yellow}

+--------------------------------------------+----------------------------------------------+--------------------+
| PoblaciÃ³n                                                                                                       | Muestra                                      | Variables          |
+:================================================================================================================+:=============================================+:===================+
| Todos los estudiantes matriculados en una universidad de los que queremos estudiar las calificaciones obtenidas | 500 estudiantes de las diferentes facultades | **Cuantitativas**: |
|                                                                                                                 |                                              |                    |
|                                                                                                                 |                                              | **Cualitativas**:  |
+--------------------------------------------+----------------------------------------------+--------------------+

---

## Ejercicio: tipo de variables

-   [**Ejemplo 2: soluciÃ³n**]{.hl-yellow}

| PoblaciÃ³n                                                                                                       | Muestra                                      | Variables                                                                                                                                                                   |
|:-------------------------------------------|:---------------------------------------------|:----------------------------------|
| Todos los estudiantes matriculados en una universidad de los que queremos estudiar las calificaciones obtenidas | 500 estudiantes de las diferentes facultades | **Cuantitativas**: calificaciones, edad (discreta), nÃºmero de veces que se ha presentado al examen (discreta). **Cualitativas**: asignaturas (nominal), facultad (nominal). |

---

## Ejercicio: tipo de variables

Piensa en tipos de variables que se pueden medir en cada uno de los ejemplos de poblaciÃ³n y muestra que hemos estudiado.

-   [**Ejemplo 3**]{.hl-yellow}

+-------------+------------------------------------------------------------------+--------------------+
| PoblaciÃ³n                                                                        | Muestra                                                          | Variables          |
+:=================================================================================+:=================================================================+:===================+
| Especies de Ã¡rboles en un bosque de los que queremos estudiar su estado de salud | selecciÃ³n sistemÃ¡tica de parcelas de 10m x 10m dentro del bosque | **Cuantitativas**: |
|                                                                                  |                                                                  |                    |
|                                                                                  |                                                                  | **Cualitativas**:  |
+-------------+------------------------------------------------------------------+--------------------+

---

## Ejercicio: tipo de variables

-   [**Ejemplo 3: soluciÃ³n**]{.hl-yellow}

| PoblaciÃ³n                                                                        | Muestra                                                          | Variables                                                                                                                                                                                                    |
|:------------|:-----------------------------------------------------------------|:-------------------------------------------------------------------|
| Especies de Ã¡rboles en un bosque de los que queremos estudiar su estado de salud | SelecciÃ³n sistemÃ¡tica de parcelas de 10m x 10m dentro del bosque | **Cuantitativas**: altura del Ã¡rbol (continua), diÃ¡metro del Ã¡rbol (continua), edad del Ã¡rbol (discreta). **Cualitativas**: especie del Ã¡rbol (nominal), estado de salud (ordinal), tipo de suelo (nominal). |

---

## CaracterÃ­sticas numÃ©ricas

Nos referimos a las medidas con las que se pretende resumir y condensar la informaciÃ³n contenida en un conjunto de datos. Las mayorÃ­a de caracterÃ­sticas numÃ©ricas las mediremos en variables cuantitativas.

-   [**Medidas de centralizaciÃ³n y posiciÃ³n**]{.hl-yellow}

Son los valores que resumen el conjunto de los datos de forma que reflejan el **centro de la distribuciÃ³n** de la tabla de frecuencias

---

## Media

Es el [**valor medio o centro de gravedad**]{.hl-yellow} (el valor mÃ¡s cercano a todos los puntos a la vez). Es la suma de todos los valores dividida por el nÃºmero total de valores.

$$\bar x= \frac{\sum^n_{i=1} x_i}{n}$$

---

## Ejemplos

-   [**Ejemplo 1**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nÂº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3. Â¿CuÃ¡l es su media?

$n=11$

$\sum^n_{i=1} x_i = 0+1+2+0+1+1+0+0+2+2+3 = 12$

$\bar x= \frac{\sum^n_{i=1} x_i}{n} = \frac{12}{11} = 1.09$ hijos

```{r}
x <- c(0, 1, 2, 0, 1, 1, 0, 0, 2, 2, 3)
mean(x)
```

---

## Ejemplos

-   [**Ejemplo 2**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nÂº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3,10. Â¿CuÃ¡l es su media?

$\bar x= \frac{\sum^n_{i=1} x_i}{n} = \frac{22}{12} = 1.83$ hijos

```{r}
x <- c(0, 1, 2, 0, 1, 1, 0, 0, 2, 2, 3, 10)
mean(x)
```

::: callout-warning
## Cuidado...

La media es una medida Ãºtil y ampliamente aplicada de la tendencia central, pero debe ser utilizada con precauciÃ³n en conjuntos de datos que contienen valores atÃ­picos o estÃ¡n distribuidos de manera asimÃ©trica.
:::

---

## Mediana

Es el [**valor del medio SIEMPRE Y CUANDO ordenemos**]{.hl-yellow} los datos. Divide la distribuciÃ³n de frecuencias en dos partes.

Para calcularla debemos realizar los siguientes pasos:

1.  Ordenar los datos en orden creciente

2.  SegÃºn el nÃºmero de observaciones (n):

    -   Si n es impar: La mediana es el valor que ocupa la posiciÃ³n central

    -   Si n es par: La mediana es el promedio de los dos valores central

---

## Ejemplos

-   [**Variables cuantitativas**]{.hl-yellow}

-   Conjunto de datos con un nÃºmero impar de observaciones:

-   Datos: 3, 1, 4, 2, 5 (n=5)

-   Ordenados: 1, 2, 3, 4, 5

-   Mediana: 3 (el tercer valor)

-   Conjunto de datos con un nÃºmero par de observaciones:

-   Datos: 7, 2, 4, 6 (n=4)

-   Ordenados: 2, 4, 6, 7

-   Mediana: (4 + 6) / 2 = 5

---

## Ejemplos

-   [**Variables cualitativas**]{.hl-yellow}

Conjunto de datos cualitativos ordinales (aunque sean cualitativas admite una jerarquÃ­a):

-   Datos: "notable", "suspenso", "sobresaliente", "suspenso", "notable", "aprobado", "notable" (n=7).

-   Ordenados: "suspenso", "suspenso", "aprobado", "notable", "notable", "notable", "sobresaliente".

-   Mediana: "notable".

::: callout-tip
## Consejo

La mediana es especialmente Ãºtil en **distribuciones asimÃ©tricas** o cuando se quiere una medida de tendencia central que no sea afectada por valores extremadamente altos o bajos.
:::

---

## Ejemplos

-   [**Ejemplo 1**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nÂº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3. Â¿CuÃ¡l es su mediana?

$n=11$

Ordenados: 0,0,0,0,1,1,1,2,2,2,3

Mediana: PosiciÃ³n 6 = 1 hijo

```{r}
#| code-fold: true
#| eval: false
x <- c(0,1,2,0,1,1,0,0,2,2,3)

median(x)
# 1
```

---

## Ejemplos

-   [**Ejemplo 2**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nÂº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3,10. Â¿CuÃ¡l es su mediana?

$n=12$

Ordenados: 0,0,0,0,1,1,1,2,2,2,3,10

Mediana: PosiciÃ³n 6 y 7 = 1 +1 /2 = 1 hijo

```{r}
#| code-fold: true
#| eval: false
x <- c(0,1,2,0,1,1,0,0,2,2,3, 10)

median(x)
# 1.833333
```

---

## Moda

Es el valor que [**presenta la mÃ¡xima frecuencia**]{.hl-yellow} y se puede calcular para **todas las variables (tambiÃ©n) cualitativas**.

1.  Unimodal:

    -   Datos: "negro", "negro", "amarillo", "verde", "amarillo", "negro". Moda: "negro".

2.  Bimodal:

    -   Datos: 1, 2, 3, 3, 4, 4, 5. Modas: 3 y 4 (ambos aparecen dos veces)

3.  Multimodal:

    -   Datos: 2, 2, 3, 3, 4, 4, 5, 5. Modas: 2, 3, 4, y 5 (todos aparecen dos veces)

4.  Sin moda (amodal):

    -   Datos: 1, 2, 3, 4, 5
    -   Moda: no hay moda (todos los valores aparecen solo una vez)

---

## Ejemplos

-   [**Ejemplo 1**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nÂº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3. Â¿CuÃ¡l es su moda?

```{r}
#| code-fold: true
library(tidyverse)
datos <- tibble("x" = c(0,1,2,0,1,1,0,0,2,2,3))

datos |>
  count(x)
```

La modalidad mÃ¡s frecuente es 0 por lo que la moda es 0.

---

## Cuantiles

Los [**cuantiles son valores que dividen un conjunto de datos en partes iguales**]{.hl-yellow} segÃºn la distribuciÃ³n de los datos (de nuevo asumiento que tenemos los datos ordenados de menor a mayor). Los cuantiles son Ãºtiles para comprender la distribuciÃ³n y la dispersiÃ³n de los datos. Existen diferentes tipos de cuantiles, cada uno con un nÃºmero especÃ­fico de divisiones:

1.  Cuartiles: dividen el conjunto de datos en cuatro partes iguales.

2.  Deciles: dividen el conjunto de datos en diez partes iguales.

3.  Percentiles: dividen el conjunto de datos en cien partes iguales.

---

## Cuantiles

1.  [**Cuartiles**]{.hl-yellow}: dividen el conjunto de datos en cuatro partes iguales.

    -   Primer cuartil (Q1): divide el 25% inferior de los datos del 75% superior.

    -   Mediana (Q2): divide el 50% inferior del 50% superior. Es el segundo cuartil.

    -   Tercer cuartil (Q3): divide el 75% inferior del 25% superior.

---

## Cuantiles

2.  [**Deciles**]{.hl-yellow}: dividen el conjunto de datos en diez partes iguales.

    -   Primer decil (D1): divide el 10% inferior del 90% superior.

    -   Segundo decil (D2): divide el 20% inferior del 80% superior.

    -   Y asÃ­ sucesivamente hasta el noveno decil (D9), que divide el 90% inferior del 10% superior.

---

## Cuantiles

3.  [**Percentiles**]{.hl-yellow}: dividen el conjunto de datos en cien partes iguales.

    -   Percentil 1 (P1): divide el 1% inferior del 99% superior.

    -   Percentil 2 (P2): divide el 2% inferior del 98% superior.

    -   Y asÃ­ sucesivamente hasta el percentil 99 (P99), que divide el 99% inferior del 1% superior.

---

## Ejemplos

Supongamos que tenemos el siguiente conjunto de datos (que podemos ordenar): 10, 25, 4, 2, 14, 6, 18, 16, 8, 12, 20. Â¿CuÃ¡les son sus cuartiles?

```{r}
#| code-fold: true
datos <- tibble("x" = c(10, 25, 4, 2, 14, 6, 18, 16, 8, 12, 20))

datos |> 
  reframe("cuartiles" = quantile(x))
```

---

## Medidas de dispersiÃ³n

Medidas (solo disponibles para cuantitativas) que nos indican [**cÃ³mo de lejos o cerca estÃ¡n las observaciones del valor central**]{.hl-yellow} que hemos calculado, es decir cuÃ¡nto se alejan de la media o mediana.

Â 

Nos indican el grado de dispersiÃ³n de la distribuciÃ³n de frecuencias.

---

## Recorrido o rango

Indica la diferencia entre el valor mÃ¡ximo y el valor mÃ­nimo en un conjunto de datos.

---

## Ejemplos

-   [**Ejemplo 1**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nÂº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3. Â¿CuÃ¡l es su recorrido?

-   Valor mÃ¡ximo = 3

-   Valor mÃ­nimo = 0

-   Recorrido= 3-0 = 3

```{r}
#| code-fold: true
#| eval: false
x <- c(0,1,2,0,1,1,0,0,2,2,3)

max(x)- min(x)
```

---

## Ejemplos

-   [**Ejemplo 2**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nÂº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3,10. Â¿CuÃ¡l es su recorrido?

-   Valor mÃ¡ximo = 10

-   Valor mÃ­nimo = 0

-   Recorrido= 10-0 = 10

```{r}
#| code-fold: true
#| eval: false
x <- c(0,1,2,0,1,1,0,0,2,2,3, 10)

max(x)- min(x)
```

::: callout-warning
## Cuidado...

El recorrido es Ãºtil cuando se necesita una medida rÃ¡pida y simple de la dispersiÃ³n, pero para anÃ¡lisis mÃ¡s detallados y robustos, se utilizan otras medidas de dispersiÃ³n como la desviaciÃ³n estÃ¡ndar, la varianza o el rango intercuartÃ­lico.
:::

---

## Rango IntercuatÃ­lico (IQR)

Mide la [**amplitud del 50% central de un conjunto de datos**]{.hl-yellow}. Se calcula como la diferencia entre el tercer cuartil (Q3) y el primer cuartil (Q1), proporcionando una medida robusta de la variabilidad de los datos al no ser afectada por valores atÃ­picos o extremos.

$$IQR = Q_3 - Q_1$$

---

## Varianza

Cuantifica [**cuÃ¡nto varÃ­an los datos respecto a la media**]{.hl-yellow} del conjunto. Una varianza alta indica que los datos estÃ¡n mÃ¡s dispersos alrededor de la media, mientras que una varianza baja indica que los datos estÃ¡n mÃ¡s agrupados cerca de la media. [**Importante**]{.hl-green}: medimos las desviaciones al cuadrado para que no se cancelen signos.

$$s^2 = \frac{\sum_{i=1}^n (x_i - \bar x)^2}{n-1}$$

-   $x_i$ representa cada valor individual en el conjunto de datos.

-   $\bar x$ es la media de la muestra.

-   $n$ es el tamaÃ±o de la muestra.

---

## DesviaciÃ³n tÃ­pica

Es la raÃ­z cuadrada de la varianza y se calcula de la siguiente manera:

$$s = \sqrt {s^2} = \sqrt {\frac{\sum_{i=1}^n (x_i - \bar x)^2}{n-1}}$$

La [**desviaciÃ³n estÃ¡ndar**]{.hl-yellow} se interpreta en las mismas unidades que los datos originales, lo que la hace mÃ¡s intuitiva que la varianza. Indica la dispersiÃ³n promedio de los datos respecto a la media.

---

## EstimaciÃ³n insesgada

FÃ­jate que en las **medidas de dispersiÃ³n el promedio lo estamos realizando diviendo entre n-1 y no entre n**. Esto es debido a que los parÃ¡metros que hemos visto hasta ahora se conocen con un apellido: [**parÃ¡metros muestrales**]{.hl-yellow} (calculados con los datos disponibles en una muestra).

. . .

El objetivo con ellos es aproximar los [**verdaderos parÃ¡metros poblacionales**]{.hl-yellow} (la media real de la poblaciÃ³n, no la que calculas con tu tabla), y el mejor estimador posible de la varianza poblaciÃ³n (se conoce como estimador insesgado, sin sesgo) es la que hemos definido dividiendo entre n-1, de ahÃ­ que todos los softwares estadÃ­sticos nos calculen dicho valor (se la conoce tambiÃ©n como cuasivarianza).

---

## Ejemplos

-   [**Ejemplo 1**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nÂº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3. Â¿CuÃ¡l es su varianza y desviaciÃ³n tÃ­pica?

```{r}
x <- c(0,1,2,0,1,1,0,0,2,2,3)

var(x)
sd(x)
```

---

## Ejemplos

-   [**Ejemplo 2**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nÂº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3,10. Â¿CuÃ¡l es su varianza y desviaciÃ³n tÃ­pica?

```{r}
x <- c(0,1,2,0,1,1,0,0,2,2,3, 10)

var(x)
sd(x)
```

---

## Coeficiente de variaciÃ³n

Uno de los problemas al [**comparar dispersiones**]{.hl-yellow} de dos variables diferentes es que tanto la varianza como la desviaciÃ³n tÃ­pica [**dependen de la escala de los datos**]{.hl-red}.

Esto implica que una desviaciÃ³n de, por ejemplo, 0.5, puede representar una dispersiÃ³n pequeÃ±a (si el rango de mis datos estÃ¡ entre 100 y 200, por ejemplo) pero puede representar una dispersiÃ³n enorme si el rango de mis datos es tambiÃ©n pequeÃ±o (por ejemplo, datos entre 0 y 1).

Para poder comparar dispersiones de variables de diferentes rangos (o incluso unidades) existe el conocido como coeficiente de variaciÃ³n (CV):

$$CV = \frac s {|\bar x|}$$

El **coeficiente de variaciÃ³n es siempre adimensional y positivo**.

---

## Tablas de frecuencias

Las variables cualitativas o cuantis discretas las vamos a [**resumir en tablas de frecuencias**]{.hl-yellow} donde se ordenan y estructuran los valores de una variable x de forma resumida de la siguiente manera:

-   **Frecuencia absoluta de x**: nÂº de veces que se repite cada modalidad de x.

-   **Frecuencia relativa de x**: proporciÃ³n de veces que se repite cada modalidad de x.

-   **Frecuencia absoluta acumulada de x**: nÂº de observaciones menores o iguales que cada modalidad de x (solo apto para cuantitativas o cualitativas ordinales ya que necesitamos una estructura de orden).

-   **Frecuencia relativa acumulada de x**: proporciÃ³n de valores menores o iguales que cada modalidad de x (solo apto para cuantitativas o cualitativas ordinales ya que necesitamos una estructura de orden).

---

## Tablas de frecuencias

| Valores | Frec abs | Frec rel | Frec abs acum | Frec rel acum |
|:-----------------------|:---------------------|:----------------------|:---------------------------------|:---------------------------------|
| $x_i$                  | $f_i$                | $p_i$                 | $F_i$                            | $P_i$                            |

---

## Ejemplo

En un estudio sobre el [**grupo sanguÃ­neo realizado con** $n = 6313$ individuos]{.hl-yellow} se obtuvo la siguiente tabla de frecuencias La variable tiene $k = 4$ modalidades (O, A, B, AB).

| Valores | Frec abs | Frec rel | Frec abs acum | Frec rel acum |

|:-----------------------|:---------------------|:----------------------|:---------------------------------|:---------------------------------|
| $x_i$                  | $f_i$                | $p_i$                 | $F_i$                            | $P_i$                            |
| O                      | 2892                 | 2892/6313 = 0.458     | 2892                             | 0.458                            |
| A                      | 2625                 | 1625/6313 = 0.416     | 5517                             | 0.874                            |
| B                      | 570                  | 570/6313 = 0.09       | 6087                             | 0.964                            |
| AB                     | 226                  | 226/6313 = 0.036      | 6313                             | 1                                |
| TOTAL                  | 6313                 | 1                     | 6313                             | 1                                |

$$\sum^k_{i=1} f_i=n$$ $$\sum^k_{i=1} p_i = 1$$

---

## Ejemplo

Â¿QuÃ© **conclusiones** sacarÃ­as al ver esta tabla?

. . .

La gran mayorÃ­a de esta muestra tiene grupo sanguÃ­neo O Ã³ A con un 46% y 42% respectivamente y que los grupos B y AB son minoritarios, siendo el AB la modalidad minoritaria.

---

## Ejemplo

Otro ejemplo:las edades en un grupo de $n = 25$ estudiantes universitarios

| Valores | Frec abs | Frec rel | Frec abs acum | Frec rel acum |

|:-----------------------|:---------------------|:----------------------|:---------------------------------|:---------------------------------|
| $x_i$                  | $f_i$                | $p_i$                 | $F_i$                            | $P_i$                            |
| 18                     | 6                    | 0.24                  | 6                                | 0.24                             |
| 19                     | 5                    | 0.20                  | 11                               | 0.44                             |
| 20                     | 3                    | 0.12                  | 14                               | 0.56                             |
| 21                     | 3                    | 0.12                  | 17                               | 0.68                             |
| 22                     | 3                    | 0.12                  | 20                               | 0.80                             |
| 23                     | 3                    | 0.12                  | 23                               | 0.92                             |
| 24                     | 2                    | 0.08                  | 25                               | 1                                |
| Total                  | 25                   | 1                     | 25                               | 1                                |

---

## Ejemplo

Contesta a las siguientes preguntas sobre la tabla anterior:

-   Â¿CuÃ¡ntos individuos tienen 21 aÃ±os?

-   Â¿QuÃ© porcentaje de individuos tiene mÃ¡s de 19 aÃ±os?

---

## Tablas de frecuencias

Â¿QuÃ© pasa cuando tenemos una [**variable cuantitativa continua**]{.hl-red}?

Imagina que anotamos las puntuaciones obtenidas por 100 pacientes en un test psicolÃ³gico en una escala continua del 0 al 100.

$x_i$: 11,42,58,25,48,18,45,35,59,29,35,2,37,68,70,31,44,84,64,82,26,42,51,29, 59,92,56,5,52,8,1,12,21,6,32,15,67,47,61,47,43,33,48,47,43,69,49,21,9,15,11,22, 29,14,31,46,19,49,51,71,52,32,51,44,58,60,43,65,73,62,3,17,39,22,40,65,30,31,16, 80,41,59,60,41,51,10,63,41,74,81,20,36,59,38,40,43,18,60,71,44.

Â¿Tiene sentido hacer una tabla de frecuencias? Â¿Nos resume la informaciÃ³n? Â¿QuÃ© podemos hacer?

---

### Ejemplo

| $x_i$     | $f_i$ | $p_i$ | $F_i$ | $P_i$ |
|:----------|:------|:------|:------|:------|
| \[0,10\]  | 8     | 0.08  | 8     | 0.08  |
| (10,20\]  | 12    | 0.12  | 20    | 0.20  |
| (20,30\]  | 10    | 0.1   | 30    | 0.30  |
| (30,40\]  | 14    | 0.14  | 44    | 0.44  |
| (40,50\]  | 21    | 0.21  | 65    | 0.65  |
| (50,60\]  | 16    | 0.16  | 81    | 0.81  |
| (60,70\]  | 10    | 0.10  | 91    | 0.91  |
| (70,80\]  | 5     | 0.05  | 96    | 0.96  |
| (80,90\]  | 3     | 0.03  | 99    | 0.99  |
| (90,100\] | 1     | 0.01  | 100   | 1     |
| Total     | 100   | 1     |       |       |

---

## Tablas de frecuencias

Los **resÃºmenes numÃ©ricos** deberÃ­amos saber hacerlos en  `R` con `datos |> summarise()` pero... [**Â¿y las tablas de frecuencia o contigencia (unidimensionales de momento)?**]{.hl-yellow}

. . .

Por ejemplo, vamos a realizar un [**conteo de frecuencias de la variable `hair_color`**]{.hl-yellow} de starwars. Para ello en tidyverse basta usar `count()`

```{r}
starwars |>
  drop_na(hair_color) |> 
  count(hair_color)
```

---

## Tablas de frecuencias

```{r}
tabla_freq <-
  starwars |>
  drop_na(hair_color) |> 
  count(hair_color)
```

Si te fijas la [**frecuencia absoluta viene siempre como $n$**]{.hl-yellow} pero podemos **renombrarla**

```{r}
tabla_freq <-
  tabla_freq |> 
  rename(frec_abs = n)
tabla_freq
```

---

## Tablas de frecuencias

A esa tabla de frecuencias podemos aÃ±adirle la [**frecuencia relativa**]{.hl-yellow} calculada como cada frecuencia absoluta dividida por el total (la suma de todos)

```{r}
tabla_freq <-
  tabla_freq |> 
  mutate("frec_rel" = frec_abs / sum(frec_abs))
tabla_freq
```

---

## Tablas de frecuencias

Este proceso podemos obtenerlo de forma [**mÃ¡s sencilla con `R base`**]{.hl-yellow} (recuerda: funciones aplican a vectores aislados, que debes sacar de la tabla con `$` y sin tuberÃ­as) con la funciÃ³n `table()`

```{r}
tabla_freq <-
 table(starwars$hair_color)
tabla_freq
```

---

## Tablas de frecuencias

TambiÃ©n podemos obtener en `R base` las [**frecuencias realtivas**]{.hl-yellow} aplicando `prop.table()` a la tabla de frecuencias anterior.

```{r}
prop.table(tabla_freq)
```

. . .

[**Moraleja**]{.hl-green}: no te cases de manera acÃ©rrima con una forma de hacer las cosas, ambos mundos van a ser necesarios.

---

## ParÃ©ntesis: sample

Imagina que queremos aÃ±adir una columna nueva llamada `rol` tal que a cada persona le asignamos de manera aleatoria `"bueno"` (con probabilidad 0.45), `"malo"` (con probabilidad 0.35), `"villano"` (con probabilidad 0.2)

. . .

Para [**generar experimentos aleatorios de una variable cualitativa**]{.hl-yellow} contamos con `sample(x = ..., size = ..., replace = ..., probs = ...)`:

* `x = c("cruz", "cara")`: las opciones que permitimos que salgan.
* `size = 20`: las veces que Â«tiramos la monedaÂ».
* `replace = TRUE`: si permitimos reemplazamiento (pueden salir elementos repetidos) o no (en este caso solo podrÃ­amos tirar 2 veces).
* `prob = c(0.3, 0.7)`: las probabilidades de los posibles eventos

---

## ParÃ©ntesis: sample


* `x = c("cruz", "cara")`: las opciones que permitimos que salgan.
* `size = 20`: las veces que Â«tiramos la monedaÂ».
* `replace = TRUE`: si permitimos reemplazamiento (pueden salir elementos repetidos) o no (en este caso solo podrÃ­amos tirar 2 veces).
* `prob = c(0.3, 0.7)`: las probabilidades de los posibles eventos

En nuestro caso de ejemplo estamos tirando una **moneda trucada (mÃ¡s caras que cruces) 20 veces**.

```{r}
sample(x = c("cruz", "cara"), size = 20, replace = TRUE, prob = c(0.3, 0.7))
```

---

## Tablas de frecuencias

Imagina que queremos aÃ±adir una columna nueva llamada `rol` tal que a cada persona le asignamos de manera aleatoria `"bueno"` (con probabilidad 0.45), `"malo"` (con probabilidad 0.35), `"villano"` (con probabilidad 0.2)

Tendremos que hacer un `sample()` con las 3 opciones (y sus probabilidades) de tamaÃ±o 87 (tenemos 87 personajes).

```{r}
starwars <- 
  starwars |> 
  mutate("rol" = sample(x = c("bueno", "malo", "villano"), size = 87,
                        replace = TRUE, prob = c(0.45, 0.35, 0.2)),
         .after = name)
starwars
```

---

## Tablas de frecuencias

Si te fijas esa variable no solo es cualitativa sino ordinal. Entre las variables cualitativas tenemos [**nominales**]{.hl-yellow} (gÃ©nero, sexo, estado civil, etc) y [**ordinales**]{.hl-yellow} (estado de salud, rol, etc). Â¿CÃ³mo distinguirlas?

. . .

La forma que tenemos en `R` de indicarle que una variable de tipo texto (universo informÃ¡tico) es una cualitativa y de quÃ© tipo (universo estadÃ­stica) es haciendo uso de lo que se conoce como [**factores**]{.hl-yellow}

---

## ParÃ©ntesis: factores

En `R` las [**variables cualitativas pueden ser tratadas como tales**]{.hl-yellow} convirtiendo una cadena de texto a lo que se conoce como [**factor**]{.hl-yellow}. Por ejemplo, supongamos que tenemos un vector de notas

```{r}
notas <- c("suspenso", "notable", "suspenso", "aprobado", "notable", "suspenso")
notas
```

. . .

Para [**convertir a factor nos basta con `factor()`**]{.hl-yellow}. Â¿QuÃ© notas diferente?

```{r}
notas_fct <- factor(notas)
notas_fct
```

---


## ParÃ©ntesis: factores

```{r}
notas_fct
```

Si te fijas ahora [**tenemos disponibles unos niveles (levels)**]{.hl-yellow}: son las posibles modalidades de nuestra variable cualitativa, el soporte, de manera que aunque borremos uno de ellos (vamos a borrar todos los aprobados), la opciÃ³n sigue disponible si entrase un dato nuevo (algo asÃ­ como un menÃº de opciones permitidas)

```{r}
notas_fct[notas_fct != "aprobado"]
```

---

## ParÃ©ntesis: factores

En el caso de las [**cualitativas ordinales podemos incluso establecer una jerarquÃ­a**]{.hl-yellow}, indicando explÃ­citamente los niveles y `ordered = TRUE`

```{r}
notas_fct_ord <- factor(notas, levels = c("aprobado", "notable", "suspenso"),
                        ordered = TRUE)
notas_fct_ord
```

FÃ­jate que ahora tenemos una [**jerarquÃ­a**]{.hl-yellow} y aunque sea cualitativa podemos buscar [**elementos \<= o \>= que otros**]{.hl-yellow}

```{r}
notas_fct_ord[notas_fct_ord <= "notable"]
```

---

## Tablas de frecuencias

Volvamos a nuestro ejemplo: Â¿cÃ³mo convertir nuestra nueva variable rol en una variable cualitativa ordinal (en orden de maldad)?

. . .

Debemos usar el concepto de factor pero para no aislar la variable de su tabla, lo introduciremos en un `mutate()`

```{r}
starwars <-
  starwars |> 
  mutate("rol" = factor(rol, levels = c("bueno", "malo", "villano"),
                        ordered = TRUE))
```

---

## Tablas de frecuencias

Cuando tenemos una variable ordinal no solo vamos a poder calcular la tabla de frecuencias absoluta y relativa...

```{r}
tabla_freq <-
  starwars |> 
  count(rol) |> 
  mutate("frec_rel" = n/sum(n))
tabla_freq

# o bien
table(starwars$rol)
```

---

## Tablas de frecuencias

...sino que al tener una [**jerarquÃ­a de orden**]{.hl-yellow} (fÃ­jate que salen automÃ¡ticamente ordenados) vamos a poder calcular las [**frecuencias acumuladas**]{.hl-yellow} con `cumsum()`

```{r}
tabla_freq <-
  tabla_freq |>
  mutate("frec_abs_acum" = cumsum(n),
         "frec_rel_acum" = cumsum(frec_rel))
tabla_freq

# o bien
cumsum(table(starwars$rol))
cumsum(prop.table(table(starwars$rol)))
```

---

## ğŸ’» Tu turno {#tu-turno-5-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Para repasar lo aprendido vamos a poner todo en prÃ¡ctica con el dataset `SatisfaccionPacientes.csv` que tenÃ©is subido al campus. [**Â¿CÃ³mo importarlo?**]{.hl-yellow}.

```{r}
#| code-fold: true
library(readr) # dentro de tidyverse
# en mi caso tengo el .csv en una carpeta datos dentro del proyecto
datos <-
  read_csv(file = "./datos/SatisfaccionPacientes.csv") |> 
  # la funciÃ³n clean_names del paquete janitor 
  # nos normaliza nombres de variables
  janitor::clean_names()
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Aplica el cÃ³digo que sea necesario para responder a estas preguntas. Â¿CuÃ¡l es el tamaÃ±o muestral? Â¿CuÃ¡ntas variables tenemos? Â¿CuÃ¡ntas modalidades tenemos en la variable `estado_civil` (y cuantas observaciones en cada una)?

```{r}
#| code-fold: true
#| eval: false
# TamaÃ±o muestral / nÃºmero de observaciones
n <- nrow(datos)

# NÃºmero de variables
p <- ncol(datos)

# Â¿QuÃ© modalidades tenemos?
datos |>  count(estado_civil)
```


### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Determina el tipo de variable (cuantitativa vs. cualitativa).

```{r}
#| code-fold: true
#| eval: false
# Variables cuantitativas: tiempo, grado satisfacciÃ³n, nÃºmero de visitas
# Variables cualitativas: gÃ©nero, estado civil, estado salud
glimpse(datos)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“  Obten tablas de frecuencias (absoluta y relativa) en el caso de las cualitativas NOMINALES. Con ella intenta responder a las preguntas: a) Â¿cuÃ¡ntas mujeres hay? b) Â¿quÃ© % de individuos estÃ¡n casados?

```{r}
#| code-fold: true
#| eval: false
# no podemos calcular acumulados ya que genero es nominal
datos |>  count(genero) |> 
  rename(frecuencia_abs = n) |> 
  mutate(frecuencia_rel = frecuencia_abs/sum(frecuencia_abs))
# Hay 53 mujeres

datos |> count(estado_civil) |> 
  rename(frecuencia_abs = n) |> 
  mutate(frecuencia_rel = frecuencia_abs/sum(frecuencia_abs))
# Hay 26% personas casadas
```


### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Convierte de manera adecuada la variable `genero` y `estado_civil` a cualitativa nominal

```{r}
#| code-fold: true
datos <-
  datos |>
  mutate(estado_civil = factor(estado_civil),
         genero = factor(genero))
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Calcula la media, mediana, rango intercuartÃ­lico y desviaciÃ³n tÃ­pica de edad y tiempo de espera.

```{r}
#| code-fold: true
resumen <-
  datos |>
  summarise(media_edad = mean(edad), sd_edad = sd(edad), mediana_edad = median(edad),
           IQR_edad = quantile(edad, probs = 0.75) - quantile(edad, probs = 0.25),
           # tiempo espera
           media_tiempo_espera = mean(tiempo_espera), sd_tiempo_espera = sd(tiempo_espera),
           mediana_tiempo_espera = median(tiempo_espera),
           IQR_tiempo_espera = quantile(tiempo_espera, probs = 0.75) - quantile(tiempo_espera, probs = 0.25))
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Repite el anterior ejercicio pero obteniendo las mÃ©tricas desagregadas por sexo.

```{r}
#| code-fold: true
resumen <-
  datos |>
  summarise(media_edad = mean(edad), sd_edad = sd(edad), mediana_edad = median(edad),
           IQR_edad = quantile(edad, probs = 0.75) - quantile(edad, probs = 0.25),
           # tiempo espera
           media_tiempo_espera = mean(tiempo_espera), sd_tiempo_espera = sd(tiempo_espera),
           mediana_tiempo_espera = median(tiempo_espera),
           IQR_tiempo_espera = quantile(tiempo_espera, probs = 0.75) - quantile(tiempo_espera, probs = 0.25),
          .by = genero)
```

### [**Ejercicio 8**]{.hl-yellow}

ğŸ“ Realiza un grÃ¡fico de violÃ­n para la variable `tiempo_espera` para cada gÃ©nero

```{r}
#| code-fold: true
#| eval: false
ggplot(datos) +
  geom_violin(aes(x = genero, y = tiempo_espera, fill = genero, color = genero),
              alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

:::

---

## ğŸ£ Caso prÃ¡ctico: encuesta de satisfacciÃ³n {#caso-practico-5-1}

Vamos a seguir poniendo en prÃ¡ctica lo aprendido el dataset `SatisfaccionPacientes.csv` que tenÃ©is subido al campus. 

&nbsp;

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-encuesta-de-satisfacci%C3%B3n)


# Clase 7: [bivariante cualitativa]{.flow} {#descriptiva-bivariante}

[**Inferencia y anÃ¡lisis de variables cualitativas**]{style="color:#444442;"}

-   [ğŸ£ Caso prÃ¡ctico: placebo vs medicamento](#caso-practico-7-1)
-   [ğŸ£ Caso prÃ¡ctico: tabaco vs bronquitis](#caso-practico-7-2)
-   [ğŸ£ Caso prÃ¡ctico: encuesta salud mental](#caso-practico-7-3)
-   [ğŸ‘¾ Materiales extras visualizaciÃ³n](#extra-dataviz)
-   [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## EstadÃ­stica bivariante

Todo lo que hemos hecho con una variable podemos hacerlo tambiÃ©n de manera [**bivariante**]{.hl-yellow} considerando dos variables.

. . .

Uno de los principales objetivos de la estadÃ­stica bivariante es [**determinar si existe relaciÃ³n o dependencia entre dos variables**]{.hl-yellow}, es decir, cuando un cambio en el valor de una de ellas se asocia a un cambio en el de la otra (una [**dependencia estadÃ­stica no implica un efecto causal**]{.hl-red}).

. . .

La situaciÃ³n contraria, es decir, la ausencia de relaciÃ³n, se denomina [**independencia**]{.hl-yellow}.


---

## Tipos de anÃ¡lisis posibles

Una primera aproximaciÃ³n al estudio de dos variables serÃ¡ [**clasificar el tipo de anÃ¡lisis**]{.hl-yellow}

- [**Cuali vs cuali**]{.hl-yellow}:
  - **Resumen**: tablas de contigencia (frecuencia cruzada).
  - **Inferencia**: prueba $\chi^2$ de independencia o test de Fisher.
  - **GrÃ¡ficos**: barras apiladas, gofres, grÃ¡ficos de Â«flujoÂ».

---

## Tipos de anÃ¡lisis posibles

Una primera aproximaciÃ³n al estudio de dos variables serÃ¡ [**clasificar el tipo de anÃ¡lisis**]{.hl-yellow}


- [**Cuani vs cuanti**]{.hl-yellow}:
  - **Resumen**: covarianza y correlaciÃ³n.
  - **Inferencia**: test de correlaciÃ³n (relaciÃ³n lineal) y test de Kolmogorov-Smirnov (Â¿ambas distribuciones son iguales?). Test de igualdad de medias o igualdad de varianzas
  - **GrÃ¡ficos**: diagrama de dispersiÃ³n, correlogramas, heatmaps.

---

## Tipos de anÃ¡lisis posibles

Una primera aproximaciÃ³n al estudio de dos variables serÃ¡ [**clasificar el tipo de anÃ¡lisis**]{.hl-yellow}


- [**Cuanti vs cuali**]{.hl-yellow}:
  - **Resumen**: medidas de centralizaciÃ³n/dispersiÃ³n/posiciÃ³n de la cuanti desagregado por los grupos de la cuali.
  - **Inferencia**: ANOVA (una vÃ­a, dos vÃ­as, ...). Test de igualdad de medias o igualdad de varianzas (desagregada por grupos)
  - **GrÃ¡ficos**: boxplots, grÃ¡ficos de violÃ­n (desagregados por grupos)


---

## IntroducciÃ³n a inferencia

Â¿Pero que es eso de la [**inferencia estadÃ­stica**]{.hl-yellow}? Es un conjunto de mÃ©todos y tÃ©cnicas que permite [**inferir conclusiones sobre una poblaciÃ³n a partir de una muestra**]{.hl-yellow} de datos.

. . .

Su propÃ³sito es utilizar la informaciÃ³n muestral para estimar caracterÃ­sticas de la poblaciÃ³n, probar hipÃ³tesis y realizar predicciones, basado en el cÃ¡lculo de [**estadÃ­sticos**]{.hl-yellow}

-   [**ParÃ¡metro**]{.hl-yellow}: medida que describe una caracterÃ­stica de la **poblaciÃ³n** (ejemplo: la media poblacional $\mu$ de la estatura de las mujeres en EspaÃ±a).

-   [**EstadÃ­stico**]{.hl-yellow}: medida que describe una caracterÃ­stica de la **muestra** (ejemplo: la media muestral $\overline{x}$ de un conjunto de 100 mujeres).

---

## IntroducciÃ³n a inferencia

Haciendo uso de **estadÃ­sticos que aproximen una correcta estimaciÃ³n de los parÃ¡metros**, los [**contraste de hipÃ³tesis**]{.hl-yellow} son procedimientos estadÃ­sticos para [**tomar decisiones sobre la validez de una afirmaciÃ³n acerca de una poblaciÃ³n**]{.hl-yellow} en funciÃ³n de los datos muestrales.

. . .

La idea es muy parecido a un **juicio**: con las pruebas (muestra) el jurado (estadÃ­stico) deben decidir sobre tu culpabilidad real (poblaciÃ³n), pudiendo ser declarado **culpable** o **no culpable**.

. . .

Este proceso implica formula

-   [**HipÃ³tesis nula** $H_0$]{.hl-yellow}: es una afirmaciÃ³n generalmente representa una **posiciÃ³n de no efecto o no diferencia** (ejemplo: entras siendo no culpable a un juicio)

-   [**HipÃ³tesis alternativa** $H_0$]{.hl-yellow}: es una afirmaciÃ³n que [**se acepta si se rechaza la hipÃ³tesis nula**]{.hl-yellow}. Representa un efecto o diferencia (ejemplo: culpable)

---

## IntroducciÃ³n a inferencia

-   [**HipÃ³tesis nula** $H_0$]{.hl-yellow}: es una afirmaciÃ³n generalmente representa una **posiciÃ³n de no efecto o no diferencia** (ejemplo: entras siendo no culpable a un juicio)

-   [**HipÃ³tesis alternativa** $H_1$]{.hl-yellow}: es una afirmaciÃ³n que [**se acepta si se rechaza la hipÃ³tesis nula**]{.hl-yellow}. Representa un efecto o diferencia (ejemplo: culpable)

La idea es similar a la del juicio: solo vamos a [**rechazar** $H_0$ (es decir, aceptar $H_1$) si hay MUCHAS EVIDENCIAS en la muestra]{.hl-yellow} (solo se condena culpable a una persona si hay muchas evidencias que demuestran su culpabilidad, pero el acusado no tiene que demostrar su inocencia).

. . .

Llamaremos [**nivel de significancia** $\alpha$]{.hl-yellow} a la probabilidad de [**rechazar la hipÃ³tesis nula cuando es verdadera**]{.hl-red} (condenar a un inocente, conocido como **error tipo I**. Normalmente $\alpha = 0.05$ aunque se pueden usar otros valores como 0.01 o 0.10 (a decidir ANTES de realizar el contraste.)

---

## IntroducciÃ³n a inferencia

[**Ejemplo**]{.hl-yellow}: supongamos que estamos probando si un nuevo medicamento tiene un efecto en la presiÃ³n arterial $\mu$

$$H_0:~\mu = \mu_0~\text{(medicamento no tiene efecto sobre la presiÃ³n arterial)}$$ $$H_1:~\mu \neq \mu_0~\text{(medicamento SI tiene efecto sobre la presiÃ³n arterial)}$$

donde $\mu_0$ es la media de la presiÃ³n arterial antes del tratamiento.


| DecisiÃ³n  | $H_0$ es cierta | $H_1$ es cierta |
|:---------:|:---------------:|:---------------:|
| Se decide rechazar $H_0$ | Error de tipo I   |  Acierto   |
| Se decide no rechazar $H_0$ | Acierto   |  Error de tipo II  |

---

## p valor

El conocido como [**p-valor**]{.hl-yellow} es uno de los conceptos mÃ¡s importantes en estadÃ­stica pero tambiÃ©n peor usados. Puedes ver toda una revisiÃ³n de quÃ© significa y quÃ© no en <https://pmc.ncbi.nlm.nih.gov/articles/PMC4877414/>

. . .

Podemos definir el [**p-valor**]{.hl-yellow} como un valor continuo que nos mide la [**compatibilidad de los datos observados con el modelo e hipÃ³tesis asumidas**]{.hl-yellow}: 1 indica compatibilidad perfecta y 0 incompatibilidad completa.

* [**No repesenta la probabilidad de que la hipÃ³tesis nula sea cierta**]{.hl-red}: el propio p-valor se calcula ASUMIENDO que lo es.

* [**No repesenta la probabilidad de que, por azar, se produzca nada**]{.hl-red}

---

## Bivariante cuali vs cuali

Una vez visto conceptos bÃ¡sicos de inferencia vamos a empezar por un [**anÃ¡lisis bivariante de dos variables cualitativas**]{.hl-yellow}

. . .

El primer paso siempre serÃ¡ intentar resumir la informaciÃ³n mediante el uso de [**tablas de contigencia**]{.hl-yellow}, en este caso bidimensionales.

. . .

Â¿CÃ³mo lo harÃ­as con **tidyverse**? Â¿Y con **R base**?

---

## Tablas de contigencia

Vamos a tomar de nuevo nuestros datos de satisfacciÃ³n de pacientes

```{r}
library(readr)
datos <-
  read_csv(file = "./datos/SatisfaccionPacientes.csv") |> 
  janitor::clean_names()
```

. . .

Para calcular una tabla bidimensional de frecuencias en tidyverse basta con **indicar dos variables en `count()`**

```{r}
datos |>
  count(genero, estado_civil)
```

---

## Tablas de contigencia

Lo habitual es mostrar esta tabla como una [**tabla con m filas y n columnas**]{.hl-yellow}, siendo $m$ el nÃºmero de modalidades distintas de la primera variable (en este caso $m=2$, femenino y masculino) y $n$ el nÃºmero de modalidades distintas de la segunda variable (en este caso $n = 4$). 

Â¿CÃ³mo hacer que la variable `estado_civil` pivote para pasar de estar en vertical a estar Â«en horizontalÂ»? (echa un repaso a la parte de tidy data)

. . .

```{r}
datos |>
  count(genero, estado_civil) |> 
  pivot_wider(names_from = estado_civil, values_from = n)
```

---

## Tablas de contigencia


Esto se puede hacer **mucho mÃ¡s sencillo de nuevo en `R base`** con `table()`


```{r}
table(datos$genero, datos$estado_civil)
```

---

## Tablas de contigencia


FÃ­jate que ahora podemos [**normalizar las frecuencias de 3 formas**]{.hl-yellow}: respecto al total de los datos, por filas (`margin = 1`) o por columnas (`margin = 2`).

```{r}
prop.table(table(datos$genero, datos$estado_civil))
prop.table(table(datos$genero, datos$estado_civil), margin = 1)
prop.table(table(datos$genero, datos$estado_civil), margin = 2)

```

---

## Tablas de contigencia

Haciendo uso de las tablas anteriores intenta responder a las siguientes preguntas:

a) Â¿QuÃ© cantidad de pacientes mujeres estÃ¡n solteras?

b) Â¿QuÃ© porcentaje, de entre los pacientes hombres, estÃ¡n viudos?

c) Â¿QuÃ© porcentaje, de entre los que estÃ¡n divorciados, son mujeres?

d) Â¿QuÃ© porcentaje (del total de pacientes) son hombres solteros?


```{r}
#| code-fold: true
# a) 22 mujeres
# b) 8.51%
# c) 57.89%
# d) 20%
```


---

## Tablas de contigencia

Puedes incluso visualizar dichas cantidades con `geom_tile()` indicÃ¡ndole que el relleno dependa del conteo `n`

```{r}
datos |>
  count(genero, estado_civil) |>
  ggplot() +
  geom_tile(aes(x = genero, y = estado_civil, fill = n)) +
  theme_minimal()
```

---

## Inferencia cuali vs cuali

Esas tablas de frecuencia serÃ¡n las que usen los [**diferentes contrastes**]{.hl-yellow} para decidir si hay o no dependencia entre ellas.

&nbsp;

El contraste mÃ¡s conocido es la conocida como [**prueba de $\chi^2$ (chi-cuadrado)**]{.hl-yellow}: dada una tabla de contigencia entre dos cualitativas, el contraste [**compara dicha tabla con la que deberÃ­amos obtener bajo la hipÃ³tesis nula de independencia**]{.hl-yellow}

Vamos a hacerlo con nuestras variables `genero` y `estado_civil`

---

## Prueba chi-cuadrado

$$H_0:~\text{genero y estado civil son independientes}$$

$$H_1:~\text{genero y estado civil son dependientes}$$

```{r}
table(datos$genero, datos$estado_civil)
```

. . .

[**Si la hipÃ³tesis nula fuese cierta**]{.hl-yellow}, Â¿quÃ© esperarÃ­amos?

---

## Prueba chi-cuadrado

1. Elegimos uno de los factores y calculamos su **proporciÃ³n en la tabla general** (53% vs 47% en este caso)

```{r}
prop.table(table(datos$genero))
```

. . .

2. Calculamos la **tabla de contigencia**  de ambas variables obteniendo lo que denotaremos como [**frecuencias observadas $O_{ij}$**]{.hl-yellow}

```{r}
table(datos$genero, datos$estado_civil)
```

---

## Prueba chi-cuadrado


3. **Si ambas variables fuesen independientes**, en cada columna tendrÃ­amos que tener **porcentajes parecidos a cuando lo hacemos sin desagregar** (53% mujeres y 47% hombres). Es decir, del total de casados (26) deberÃ­amos tener $8.48$ mujeres y $7.52$ hombres; del total de divorciados (19) deberÃ­amos tener $10.07$ mujeres y $8.93$ hombres; y asÃ­ sucesivamente. Estas frecuencias las denotaremos como [**frecuencias esperadas $E_{ij}$**]{.hl-yellow}

$$E_{ij} = \frac{\text{suma fila i * suma fila j}}{\text{total}}$$


---

## Prueba chi-cuadrado


4. [**Resumimos lo que se desvÃ­a una de otra**]{.hl-yellow} mediante el [**estadÃ­stico chi-cuadrado**]{.hl-yellow}:

$$\begin{eqnarray}\chi^2 &=& \sum_{i,j} \frac{\left(O_{ij} - E_{ij} \right)^2}{E_{ij}} = \frac{(13.78 - 11)^2}{13.78} + \frac{(12.22 - 15)^2}{12.22} \nonumber \\
&+& \frac{(10.07 - 11)^2}{10.07} + \ldots + \frac{(6.11 - 4)^2}{6.11} = 2.75731\end{eqnarray}$$

. . .


5. Calculamos [**cÃ³mo de extremo es el valor del estadÃ­stico si la hipÃ³tesis nula fuese cierta**]{.hl-yellow}, proporcionÃ¡ndonos un **p-valor**.

---

## Prueba chi-cuadrado

Este proceso podemos hacerlo directamente aplicando `chisq.test()`, indicÃ¡ndole las variables (o su tabla de frecuencias)

```{r}
contraste <- chisq.test(datos$genero, datos$estado_civil)
```

* `...$statistic`: tenemos guardado el valor del estadÃ­stico

```{r}
contraste$statistic
```

* `...$observed`: tenemos guardada la tabla de frecuencias observada

```{r}
contraste$observed
```

---

## Prueba chi-cuadrado


* `...$expected`: tenemos guardada la tabla de frecuencias esperada

```{r}
contraste$expected
```

* `...$p.value`: tenemos guardado el p-valor.

```{r}
contraste$p.value
```

---

## Prueba chi-cuadrado


Â¿CÃ³mo [**interpretar el contraste**]{.hl-yellow}?

```{r}
contraste
```

Como $p.value = 0.4306 > \alpha = 0.05$, no podemos rechazar la hipÃ³tesis nula: [**no hay evidencias suficientes en la muestra para concluir que haya dependencia**]{.hl-yellow}.

---

## Prueba de Fisher

Otra alternativa es el [**test exacto de Fisher**]{.hl-yellow}, una prueba estadÃ­stica utilizada para [**determinar si hay una asociaciÃ³n significativa entre dos variables cualitativas**]{.hl-yellow} especialmente Ãºtil cuando las frecuencias esperadas son bajas y tenemos dos grupos en cada cualitativa (la tabla de frecuencias es $2 \times 2$). No entraremos en mucho detalle matemÃ¡tico pero usa la distribuciÃ³n real de una variable aleatoria que sigue lo que se conoce como distribuciÃ³n hipergeomÃ©trica.

&nbsp;

Como **curiosidad** dicha prueba naciÃ³ cuando Fisher trataba de comprobar si una compaÃ±era, Muriel Birstol, era capaz de detectar en un tÃ© con leche si se habÃ­a aÃ±adido primero el tÃ© o la leche en su taza (y del experiemnto del que naciÃ³ la regla del $\alpha = 5%$).

---

## Prueba de Fisher

Para aplicarlo nos basta con usar `fisher.test()`.

```{r}
fisher.test(datos$genero, datos$estado_civil)
```

---

## Prueba de Fisher

Como hemos dicho es especialmente Ãºtil cuando tenemos solo 2 modalidades en cada cualitativa ya nos proporciona [**mÃ©tricas de asociaciÃ³n**]{.hl-yellow}

Veamos un ejemplo con la tabla `placebo_medicamento.csv`

```{r}
datos_placebo <- read_csv(file = "./datos/placebo_medicamento.csv")
datos_placebo
```

---

## Prueba de Fisher


```{r}
fisher.test(datos_placebo$observado, datos_placebo$grupo_tratamiento)
```

Si te fijas ahora nos devuelve ademÃ¡s un [**contraste de lo que se conoce como odds ratio (OR: razÃ³n de probabilidades)**]{.hl-yellow}

`alternative hypothesis: true odds ratio is not equal to 1`


---

## MÃ©tricas de asociaciÃ³n

```{r}
table(datos_placebo$observado, datos_placebo$grupo_tratamiento)
```

La interpretaciÃ³n de [**Odds ratio (OR)**]{.hl-yellow} es cuantificar la [**asociaciÃ³n entre dos variables respecto a una asociaciÃ³n espÃºrea**]{.hl-yellow} Â¿CuÃ¡nto [**mejoran los que tomaron medicamento respecto a una posible mejora basal**]{.hl-yellow} (aleatoria) del placebo?

* [**Ratio de mejora en tratados**]{.hl-purple}: $13/3 = 4.33333$
* [**Ratio de mejora en placebo**]{.hl-purple}: $6/11 = 0.54545$

$$OR = \frac{13/3}{6/11} = \frac{13*11}{6*3} = 7.94$$

Los pacientes sometidos a tratamiento mejoran 7.9 veces mÃ¡s si el placebo mejorase por azar.

---

## MÃ©tricas de asociaciÃ³n

```{r}
table(datos_placebo$observado, datos_placebo$grupo_tratamiento)
```

Otra de las mÃ©tricas habituales es la conocida como [**razÃ³n de prevalencias (Risk Ratio, RR)**]{.hl-yellow} que nos proporciona un [**ratio entre la probabilidad de prevalencia**]{.hl-yellow} de un evento en dos grupos.


* [**Prevalencia de mejora en tratados**]{.hl-purple}: $13/(3+13) = 0.8125$
* [**Prevalencia de mejora en placebo**]{.hl-purple}: $6/(11+6) = 0.35294$

$$RR = \frac{13/(3+13)}{6/(11+6)} = \frac{13*11}{6*3} = 2.30208$$
Los pacientes sometidos a tratamiento tienen mÃ¡s del doble de Â«riesgoÂ» de mejorar que los pacientes con placebo.

---

## MÃ©tricas de asociaciÃ³n

Ambas mÃ©tricas podemos estimarlas tambiÃ©n con el paquete `{epitools}`

```{r}
library(epitools)
OR <- oddsratio(datos_placebo$observado, datos_placebo$grupo_tratamiento)
OR$measure
```

* Si $OR = 1$ no hay asociaciÃ³n entre las variables.
* Si $OR > 1$ hay una asociaciÃ³n positiva, es decir, la exposiciÃ³n estÃ¡ asociada con un mayor riesgo.
* Si $OR < 1$ hay una asociaciÃ³n negativa, es decir, la exposiciÃ³n estÃ¡ asociada con un menor riesgo.


---

## MÃ©tricas de asociaciÃ³n


```{r}
RR <- riskratio(datos_placebo$observado, datos_placebo$grupo_tratamiento)
RR$measure
```


* Si $RR = 1$ no hay diferencias en el riesgo entre los grupos.
* Si $RR > 1$ el grupo expuesto (en este caso medicado) tiene mayor riesgo (en este caso de mejorar)
* Si $RR < 1$ el grupo expuesto tiene menor riesgo.

---

## GrÃ¡ficos de barras

Volvamos al ejemplo de encuesta de satisfacciÃ³n: vamos a intentar relacionar las dos variables cualitativas `genero` y `estado_civil` para **complementar el anÃ¡lisis numÃ©rico realizado** (amÃ©n del `geom_tile()` que hemos hecho para visualizar la tabla de frecuencias)

. . .

Sabemos realizar un diagrama de barras de cada una por separado, [**Â¿cÃ³mo incluir la informaciÃ³n de ambas con `geom_bar()`**]{.hl-yellow}

. . .

Piensa cÃ³mo hacerlo recordando que `geom_bar()` solo admite una coordenada `x = ...` o `y = ...`. Â¿CÃ³mo incluir la info de otra variable que no sea en `x` o `y`?

---

## GrÃ¡ficos de barras

```{r}
#| code-fold: true
ggplot(datos) +
  geom_bar(aes(x = estado_civil, fill = genero), alpha = 0.6) +
  ggthemes::scale_fill_colorblind() +
  labs(x = "Estado civil", y = "Frec. absolutas",
       fill = "GÃ©nero") +
  theme_minimal()
```

---

## GrÃ¡ficos de barras

La funciÃ³n `geom_bar()` nos permite jugar un poco con el tipo de barras, que por defecto las muestra `stacked` (apiladas). Dicho ajuste podemos **cambiarlo con el argumento `position`**: si `position = "dodge"` las muestra de [**manera agrupada una detrÃ¡s de otra**]{.hl-yellow}.

```{r}
#| code-fold: true
ggplot(datos) +
  geom_bar(aes(x = estado_civil, fill = genero),
           position = "dodge", alpha = 0.6) +
  ggthemes::scale_fill_colorblind() +
  labs(x = "Estado civil", y = "Frec. absolutas",
       fill = "GÃ©nero") +
  theme_minimal()
```

---

## GrÃ¡ficos de barras

La mejor opciÃ³n para visualizar si hay asociaciÃ³n es que **cada barra de estado civil representa el total y nos muestre el % de cada sexo** en cada una: si fuesen independientes, el reparto por sexo en cada barra deberÃ­a ser similar. Lo haremos con `position = "fill"`

```{r}
#| code-fold: true
ggplot(datos) +
  geom_bar(aes(x = estado_civil, fill = genero),
           position = "fill", alpha = 0.6) +
  ggthemes::scale_fill_colorblind() +
  labs(x = "Estado civil", y = "Frec. relativas",
       fill = "GÃ©nero") +
  theme_minimal()
```


---

## GrÃ¡ficos de barras

```{r}
#| code-fold: true
ggplot(datos) +
  geom_bar(aes(y = estado_civil, fill = genero),
           position = "fill", alpha = 0.6) +
  ggthemes::scale_fill_colorblind() +
  labs(x = "Estado civil", y = "Frec. relativas",
       fill = "GÃ©nero") +
  theme_minimal()
```

---

## ğŸ’» Tu turno {#tu-turno-6-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Calcula las tablas de frecuencias absoluta y relativa con las variables `genero` y `estado_salud`

```{r}
#| code-fold: true
#| eval: false
tabla_freq <- table(datos$genero, datos$estado_salud)
prop.table(tabla_freq)
prop.table(tabla_freq, margin = 1)
prop.table(tabla_freq, margin = 2)
```


### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Usando la tabla anterior:

* Â¿QuÃ© porcentaje, de entre las mujeres, tiene un buen estado de salud?

* Â¿QuÃ© porcentaje, de entre los hombres, tiene un estado de salud regular?

* Â¿QuÃ© porcentaje de los que tienen estado de salud malo, son mujeres?

```{r}
#| code-fold: true
# De entre las mujeres un 45.28% tiene un buen estado de salud
# De entre los hombres un 34.04% tiene un estado de salud regular
# Un 33.33% de los que tienen un estado de salud malo, son mujeres
```


### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Realiza ambos contrastes e intenta razonar la respuesta a la pregunta: Â¿estÃ¡n estas dos variables asociadas? Â¿Existe algÃºn tipo de dependencia entre ellas? Hazlo considerando $\alpha = 0.05$.

```{r}
#| code-fold: true
#| eval: false
chisq.test(tabla_freq)$p.value
fisher.test(tabla_freq)$p.value

# En ambos casos p-value > alpha: no podemos rechazar la  hipÃ³tesis nula de independencia: no hay evidencias suficientes CON LA MUESTRA QUE TENEMOS para concluir que haya alguna asociaciÃ³n
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Las funciones `chisq.test()` y `fisher.test()` proporcionan un objeto htest que dentro contiene el p-valor (accediendo con `$p.value` dentr de Ã©l). Â¿CÃ³mo guardar ambos p-valores en una tabla resumen en tidyverse? Exporta los resultados a un `.csv`



```{r}
#| code-fold: true
resumen_dependencia <-
  datos |> 
  summarise("sig_chisq" = chisq.test(genero, estado_civil)$p.value,
            "sig_fisher" = fisher.test(genero, estado_civil)$p.value)
write_csv(resumen_dependencia, file = "./datos/resumen_dependencia.csv")
```

:::

---

## ğŸ£ Caso prÃ¡ctico I: placebo vs fÃ¡rmaco {#caso-practico-7-1}

En el fichero `placebo_medicamento_completo.csv` tenemos guardado los niveles de colesterol antes y despuÃ©s de un tratamiento: a 76 personas se les dio un medicamento para bajarlo y a 24 personas placebo.

```{r}
datos <- read_csv(file = "./datos/placebo_medicamento_completo.csv")
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-i-placebo-vs-f%C3%A1rmaco)

---

## ğŸ£ Caso prÃ¡ctico II: bronquitis y tabaco {#caso-practico-7-2}

En el fichero `fumadores.csv` tenemos datos de 96 pacientes sobre sÃ­ o fuman y quienes han desarrollado o no bronquitis.

```{r}
datos <- read_csv(file = "./datos/fumadores.csv")
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-ii-bronquitis-y-tabaco)

---

## ğŸ£ Caso prÃ¡ctico III: salud mental {#caso-practico-7-3}

En el fichero `datos_salud_mental.csv` tenemos informaciÃ³n recopilada de 100 pacientes que acuden a un centro de salud mental. Se quiere realizar un estudio para ver el impacto que tienen distintas caracterÃ­sticas sobre la ansiedad y depresiÃ³n en estos 100 pacientes. Los datos incluyen una variedad de variables relacionadas con la salud mental, asÃ­ como caracterÃ­sticas demogrÃ¡ficas y de estilo de vida.

```{r}
datos <- read_csv(file = "./datos/datos_salud_mental.csv")
```


Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-iii-salud-mental)

# Clase 8: [inferencia cuanti]{.flow} {#descriptiva-bi-cuanti}

[**EstadÃ­stica bivariante: anÃ¡lisis de variables cuantitativas. CorrelaciÃ³n**]{style="color:#444442;"}

---

## CorrelaciÃ³n

---

## Biserial...

---

## Intro regresiÃ³n lineal

# Clase 9: [regresiÃ³n lineal]{.flow} {#reg-lineal}

[**Primer modelo: regresiÃ³n lineal**]{style="color:#444442;"}

---

## pendiente...


---

# Materiales extras {#materiales-extra}

-   [ğŸ’» R base](#extra-Rbase)
-   [ğŸ’» Tidyverse](#extra-tidyverse)
-   [ğŸ’» Dataviz en R](#extra-dataviz)
-   [ğŸ’» Github](#github)

# Materiales extras: R base {#extra-Rbase}

-   [ğŸ’» Bucles en R](#bucles)
-   [ğŸ£ Casos prÃ¡cticos bucles + if-else](https://javieralvarezliebana.quarto.pub/if-else-bucles-funciones-isciii/)
-   [ğŸ’» Funciones en R](#funciones)
-   [ğŸ£ Casos prÃ¡cticos funciones](#caso-practico-funciones-1)

---

## Creando funciones {#funciones} {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, ademÃ¡s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. Â¿CÃ³mo [**crear nuestra propia funciÃ³n**]{.hl-purple}? Veamos su **esquema bÃ¡sico**:

-   [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraÃ±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

-   Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

-   [**Cuerpo**]{.hl-yellow} de la funciÃ³n dentro de `{ }`.

-   Finalizamos la funciÃ³n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function() {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, ademÃ¡s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. Â¿CÃ³mo [**crear nuestra propia funciÃ³n**]{.hl-purple}? Veamos su **esquema bÃ¡sico**:

-   [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraÃ±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

-   Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

-   [**Cuerpo**]{.hl-yellow} de la funciÃ³n dentro de `{ }`.

-   Finalizamos la funciÃ³n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, ademÃ¡s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. Â¿CÃ³mo [**crear nuestra propia funciÃ³n**]{.hl-purple}? Veamos su **esquema bÃ¡sico**:

-   [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraÃ±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

-   Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

-   [**Cuerpo**]{.hl-yellow} de la funciÃ³n dentro de `{ }`.

-   Finalizamos la funciÃ³n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  cÃ³digo a ejecutar
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, ademÃ¡s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. Â¿CÃ³mo [**crear nuestra propia funciÃ³n**]{.hl-purple}? Veamos su **esquema bÃ¡sico**:

-   [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraÃ±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

-   Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

-   [**Cuerpo**]{.hl-yellow} de la funciÃ³n dentro de `{ }`.

-   Finalizamos la funciÃ³n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  cÃ³digo a ejecutar
  
  return(var_salida)
  
}
```

---

## Creando funciones

-   `arg1, arg2, ...`: serÃ¡n los [**argumentos de entrada**]{.hl-yellow}, los argumentos que toma la funciÃ³n para ejecutar el cÃ³digo que tiene dentro

-   `cÃ³digo`: lÃ­neas de cÃ³digo que queramos que [**ejecute la funciÃ³n**]{.hl-yellow}.

-   `return(var_salida)`: se introducirÃ¡n los [**argumentos de salida**]{.hl-yellow}.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # CÃ³digo que queramos ejecutar
  cÃ³digo
  
  # Salida
  return(var_salida)
  
}
```

::: callout-important
## Importante

Todas las variables que definamos dentro de la funciÃ³n son [**variables LOCALES: solo existirÃ¡n dentro de la funciÃ³n**]{.hl-yellow} salvo que especifiquemos lo contrario.
:::

---

## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funciÃ³n para [**calcular el Ã¡rea de un rectÃ¡ngulo**]{.hl-yellow}.

Dado que el Ã¡rea de un rectÃ¡ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serÃ¡n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} serÃ¡ justo su **Ã¡rea** ($lado_1 * lado_2$).

```{r}
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
}
```

---

## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funciÃ³n para [**calcular el Ã¡rea de un rectÃ¡ngulo**]{.hl-yellow}.

Dado que el Ã¡rea de un rectÃ¡ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serÃ¡n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} serÃ¡ justo su **Ã¡rea** ($lado_1 * lado_2$).

```{r}
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  
}
```

---

## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funciÃ³n para [**calcular el Ã¡rea de un rectÃ¡ngulo**]{.hl-yellow}.

Dado que el Ã¡rea de un rectÃ¡ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serÃ¡n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} serÃ¡ justo su **Ã¡rea** ($lado_1 * lado_2$).

```{r}
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  return(area)
  
}
```

---

## Uso de funciones

TambiÃ©n podemos hacer una definiciÃ³n directa de las variables **sin almacenar por el camino**.

```{r}
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  return(lado_1 * lado_2)
  
}
```

. . .

[**Â¿CÃ³mo aplicar la funciÃ³n?**]{.hl-yellow}

```{r}
calcular_area(5, 3) # Ã¡rea de un rectÃ¡ngulo 5 x 3 
calcular_area(1, 5) # Ã¡rea de un rectÃ¡ngulo 1 x 5
```

---

## Uso de funciones

::: callout-tip
Aunque no sea necesario, es [**recomendable hacer explÃ­cita la llamada de los argumentos**]{.hl-green}, especificando en el cÃ³digo quÃ© valor es para cada argumento para que no dependa de su orden, haciendo el cÃ³digo mÃ¡s legible
:::

```{r}
calcular_area(lado_1 = 5, lado_2 = 3) # Ã¡rea de un rectÃ¡ngulo 5 x 3 
calcular_area(lado_2 = 3, lado_1 = 5) # Ã¡rea de un rectÃ¡ngulo 5 x 3 
```

---

## Argumentos por defecto

Imagina ahora que nos damos cuenta que el 90% de las veces usamos dicha funciÃ³n para [**calcular por defecto el Ã¡rea de un cuadrado**]{.hl-yellow} (es decir, solo necesitamos un lado). Para ello, podemos definir [**argumentos por defecto**]{.hl-yellow} en la funciÃ³n: tomarÃ¡n dicho valor salvo que le asignemos otro.

Â¿Por quÃ© no asignar `lado_2 = lado_1` **por defecto**, para ahorrar lÃ­neas de cÃ³digo y tiempo?

. . .

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

---

## Argumentos por defecto

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

Ahora [**por defecto**]{.hl-yellow} el segundo lado serÃ¡ igual al primero (si se lo aÃ±adimos usarÃ¡ ambos).

```{r}
calcular_area(lado_1 = 5) # cuadrado
calcular_area(lado_1 = 5, lado_2 = 7) # rectÃ¡ngulo
```

---

## Salida mÃºltiple

Compliquemos un poco la funciÃ³n y aÃ±adamos en la salida los valores de cada lado, etiquetados como `lado_1` y `lado_2`, [**empaquetando la salida en una vector**]{.hl-yellow}.

```{r}
#| code-line-numbers: "7-8"
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

---

## Salida mÃºltiple

Podemos complicar un poco mÃ¡s la salida aÃ±adiendo una cuarta variable que nos diga, en funciÃ³n de los argumentos, [**si rectÃ¡ngulo o cuadrado**]{.hl-yellow}, teniendo que aÃ±adir en la salida una variable que de tipo caracter (o lÃ³gica).

```{r}
#| code-line-numbers: "7-9"
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rectÃ¡ngulo")))
  
}
calcular_area(5, 3)
```

. . .

[**Problema**]{.hl-red}: al intentar juntar nÃºmeros y texto, lo convierte todo a nÃºmeros. PodrÃ­amos guardarlo todo en un `tibble()` como hemos aprendido o en un objeto conocido en `R` como [**listas**]{.hl-yellow}

---

## IntroducciÃ³n a listas

Veamos un pequeÃ±o resumen de los datos que ya conocemos:

-   [**vectores**]{.hl-yellow}: colecciÃ³n de elementos de igual tipo. Pueden ser nÃºmeros, caracteres o valores lÃ³gicos, entre otros.

-   [**matrices**]{.hl-yellow}: colecciÃ³n BIDIMENSIONAL de elementos de igual tipo e igual longitud.

-   [**data.frame / tibble**]{.hl-yellow}: colecciÃ³n BIDIMENSIONAL de elementos de igual longitud pero de cualquier tipo.

. . .

Las [**listas**]{.hl-yellow} serÃ¡n [**colecciones de variables de diferente tipo y diferente longitud**]{.hl-purple}, con estructuras totalmente heterÃ³geneas (incluso una lista puede tener dentro a su vez otra lista).

---

## IntroducciÃ³n a listas

Vamos a crear [**nuestra primera lista**]{.hl-yellow} con `list()` con tres elementos: el nombre de nuestros padres/madres, nuestro lugar de nacimiento y edades de nuestros hermanos.

```{r}
var_1 <- c("Paloma", "Gregorio")
var_2 <- "Madrid"
var_3 <- c(25, 30, 26)

lista <- list("progenitores" = var_1, "lugar_nac" = var_2, "edad_hermanos" = var_3)
lista
```

---

## IntroducciÃ³n a listas

```{r}
length(lista)
```

Si observas el objeto que hemos definido como lista, su [**longitud**]{.hl-yellow} del es de 3 ya que tenemos **guardados tres elementos**: un vector de caracteres (de longitud 2), un caracter (vector de longitud 1), y un vector de nÃºmeros (de longitud 3)

. . .

Tenemos guardados elementos de [**distinto tipo**]{.hl-yellow} (algo que ya podÃ­amos hacer) pero, ademÃ¡s, de **longitudes dispares**.

```{r}
dim(lista) # devolverÃ¡ NULL al no tener dos dimensiones
class(lista) # de tipo lista
```

---

## IntroducciÃ³n a listas

Si los juntÃ¡semos con un `tibble()`, al tener distinta longitud, obtendrÃ­amos un [**error**]{.hl-red}.

```{r}
#| error: true
library(tibble)
tibble("progenitores" = var_1, "lugar_nac" = va_2, "edad_hermanos" = var_3)
```

---

## IntroducciÃ³n a listas

-   [**Acceder por Ã­ndice**]{.hl-yellow}: con el operador `[[i]]` accedemos al **elemento i-Ã©simo** de la lista.

```{r}
lista[[1]]
```

. . .

-   [**Acceder por nombre**]{.hl-yellow}: con `$nombre_elemento` accedemos por su nombre.

```{r}
lista$progenitores
```

. . .

En contraposiciÃ³n, el [**corchete simple**]{.hl-yellow} nos permite acceder a [**varios elementos**]{.hl-yellow} a la vez

```{r}
# Varios elementos
lista[1:2]
```

---

## Salida mÃºltiple: listas

```{r}
#| code-line-numbers: "7-9"
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rectÃ¡ngulo")))
  
}
calcular_area(5, 3)
```

---

## Orden de los argumentos

Antes nos daba igual el orden de los argumentos pero ahora el [**orden de los argumentos de entrada importa**]{.hl-yellow}, ya que en la salida incluimos `lado_1` y `lado_2`.

. . .

::: callout-note
## RecomendaciÃ³n

Como se comentaba, altamente recomendable hacer la llamada a la funciÃ³n [**indicando explÃ­citamente los argumentos**]{.hl-yellow} para mejorar **legibilidad e interpretabilidad**.

```{r}
# Equivalente a calcular_area(5, 3)
calcular_area(lado_1 = 5, lado_2 = 3)
```
:::

---

## Funciones: generando conocimiento

Parece una tonterÃ­a lo que hemos hecho pero hemos cruzado una frontera importante: hemos pasado de [**consumir conocimiento**]{.hl-yellow} (cÃ³digo de otros paquetes, elaborado por otros/as), a [**generar conocimiento**]{.hl-purple}, creando nuestras propias funciones.

. . .

Las funciones van a ser claves en tu dÃ­a a dÃ­a ya que te permitirÃ¡ automatizar cÃ³digo que vas a repetir una y otra vez: empaquetando ese cÃ³digo bajo un alias (nombre de la funciÃ³n) vas a [**poder usarlo una y otra vez sin necesidad de programarlo (por lo que hacer el doble de trabajo no implicarÃ¡ trabajar el doble)**]{.hl-yellow}

---

## Variables locales vs globales

Un aspecto importante sobre el que reflexionar con las funciones: Â¿quÃ© sucede si [**nombramos a una variable dentro**]{.hl-yellow} de una funciÃ³n a la que se nos ha **olvidado asignar** un valor dentro de la misma?

. . .

Debemos ser cautos al usar funciones en `R`, ya que debido a la [**Â«regla lexicogrÃ¡ficaÂ»**]{.hl-yellow}, si una variable no se define dentro de la funciÃ³n, `R` [**buscarÃ¡ dicha variable en el entorno**]{.hl-purple} de variables.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  print(x) # No devuelve nada, solo realiza la acciÃ³n 
}
funcion_ejemplo()
```

---

## Variables locales vs globales

Si una variable [**ya estÃ¡ definida fuera de la funciÃ³n (entorno global)**]{.hl-yellow}, y ademÃ¡s es usada dentro de cambiando su valor, el valor [**solo cambia dentro**]{.hl-yellow} pero [**no en el entorno global**]{.hl-red}.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  x <- 2
  print(x) # lo que vale dentro
}
```

```{r}
# lo que vale dentro
funcion_ejemplo() #<<
# lo que vale fuera
print(x) #<<
```

---

## Variables locales vs globales

Si queremos que ademÃ¡s de cambiar localmente lo haga [**globalmente**]{.hl-yellow} deberemos usar la [**doble asignaciÃ³n**]{.hl-yellow} (`<<-`).

```{r}
x <- 1
y <- 2
funcion_ejemplo <- function() {
  
  # no cambia globalmente, solo localmente
  x <- 3 
  # cambia globalmente
  y <<- 0 #<<
  
  print(x)
  print(y)
}

funcion_ejemplo() # lo que vale dentro
x # lo que vale fuera
y # lo que vale fuera
```

---

## ğŸ’» Tu turno {#tu-turno-3-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ej 1**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para definir una funciÃ³n llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.

```{r}
#| eval: false
nombre <- function(x, y) {
  suma <- # cÃ³digo a ejecutar
  return()
}
# Aplicamos la funciÃ³n
suma(3, 7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_suma <- function(x, y) {
  suma <- x + y
  return(suma)
}
funcion_suma(3, 7)
```

### [**Ej 2**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para definir una funciÃ³n llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado

```{r}
#| eval: false
nombre <- function(x, y) {
  producto <- # cÃ³digo de la multiplicaciÃ³n
  return()
}
producto(3)
producto(3, -7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_producto <- function(x, y = x) {
  producto <- x * y
  return(producto)
}
funcion_producto(3)
funcion_producto(3, -7)
```

### [**Ej 3**]{.hl-yellow}

ğŸ“ Define una funciÃ³n llamada `igualdad_nombres` que, dados dos nombres, nos diga si son iguales o no. Hazlo considerando importantes las mayÃºsculas, y sin que importen las mayÃºsculas. Usa el paquete `{stringr}`.

```{r}
#| code-fold: true
#| eval: false
# Distinguiendo mayÃºsculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "LucÃ­a")

# Sin importar mayÃºsculas (ver tambiÃ©n str_equal)
igualdad_nombres <- function(persona_1, persona_2) {
  return(str_to_upper(persona_1) == str_to_upper(persona_2))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "LucÃ­a")
```

### [**Ej 4**]{.hl-yellow}

ğŸ“ Crea una funciÃ³n llamada `calculo_IMC` que, dados dos argumentos (peso y estatura en metros) y un nombre, devuelva una lista con el IMC ($peso/(estatura_m^2)$) y el nombre.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura) {
  
  return(list("nombre" = nombre, "IMC" = peso/(estatura^2)))
}
```

### [**Ej 5**]{.hl-yellow}

ğŸ“ Repite el ejercicio anterior pero con otro argumento opcional que se llame unidades (por defecto, `unidades = "metros"`). Desarrolla la funciÃ³n de forma que haga lo correcto si `unidades = "metros"` y si `unidades = "centÃ­metros"`.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  
  return(list("nombre" = nombre,
              "IMC" = peso/(if_else(unidades == "metros", estatura, estatura/100)^2)))
}
```

### [**Ej 6**]{.hl-yellow}

ğŸ“ Crea un tibble ficticio de 7 personas, con tres variables (inventa nombre, y simula peso, estatura en centÃ­metros), y adapta la funciÃ³n `calculo_IMC()` de forma que obtengamos una cuarta columna con su IMC.

```{r}
#| code-fold: true
#| eval: false
datos <- tibble("nombres" = c("javi", "sandra", "eva", "ana", "carlos", "leo", NA),
                "peso" = rnorm(n = 7, mean = 70, sd = 1),
                "estatura" = rnorm(n = 7, mean = 168, sd = 5))

# IMPORTANTE. if_else trabaja de manera vectorial, elemento a elemento: la longitud de la
# condiciÃ³n (unidades == "metros" es un vector lÃ³gico de longitud uno) debe ser igual que
# lo que le decimos que haga cuando es TRUE y FALSE (en este caso, condicion tiene longitud 1
# pero al aplicarla lo que devuelve es vector de tamaÃ±o 7, por eso hay que usar ifelse (sin _))
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  return(list("nombre" = nombre,
              "IMC" = peso/(ifelse(unidades == "metros", estatura, estatura/100)^2)))
}
datos |> mutate(IMC = calculo_IMC(nombres, peso, estatura, unidades = "centÃ­metros")$IMC)
```

### [**Ej 7**]{.hl-yellow}

ğŸ“ Crea una funciÃ³n llamada `atajo` que tenga dos argumentos numÃ©ricos `x` e `y`. Si ambos son iguales, debes devolver `"iguales"` y hacer que la funciÃ³n acaba automÃ¡ticamente (piensa cuÃ¡ndo una funciÃ³n sale). OJO: `x` e `y` podrÃ­an ser vectores. Si son distintos (de igual de longitud) calcula la proporciÃ³n de elementos diferentes. Si son distintos (por ser distinta longitud), devuelve los elementos que no sean comunes.

```{r}
#| code-fold: true
#| eval: false
atajo <- function(x, y) {
  
  if (all(x == y) & length(x) == length(y)) { return("iguales") }
  else {
   
    if (length(x) == length(y)) {
      
      n_diff <- sum(x != y) / length(x)
      return(n_diff)
      
    } else {
      
      diff_elem <- unique(c(setdiff(x, y), setdiff(y, x)))
      return(diff_elem)
    }
    
  }
}
```
:::

---

## ğŸ£ Caso prÃ¡ctico I: conversor {#caso-practico-funciones-1}

Para practicar con funciones vamos a crear un completo **conversor de temperaturas** que, dada una temperatura en Fahrenheit, Celsius o Kelvin, la convierta a cualquiera de las otras

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/if-else-bucles-funciones-isciii/) hasta construirlo.

# Materiales extras: tidyverse {#extra-tidyverse}

-   [ğŸ’» Operaciones por filas](#dplyr-filas)
-   [ğŸ’» Operaciones por columnas](#dplyr-columnas)
-   [ğŸ’» ResÃºmenes](#dplyr-resumenes)
-   [ğŸ’» Importar y exportar](#importar-exportar)
-   [ğŸ£ Casos prÃ¡cticos](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-vi-tabla-en-spss)

## Rebanadas de datos: slice() {#dplyr-filas}

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice(posiciones)
```
:::
:::

A veces nos puede interesar realizar un [**muestreo no aleatorio discreccional**]{.hl-yellow}, o lo que es lo mismo, [**filtrar por posiciÃ³n**]{.hl-yellow}: con `slice(posiciones)` podremos seleccionar filas concretas pasando como argumento un [**vector de Ã­ndices**]{.hl-yellow}

. . .

::: columns
::: {.column width="50%"}
```{r}
#| eval: false

# fila 1
starwars |>
  slice(1)
```

```{r}
#| echo: false
starwars |> slice(1) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false

# filas de la 7 a la 9
starwars |>
  slice(7:9)
```

```{r}
#| echo: false
starwars |> slice(7:9) |> select(name:hair_color)
```
:::
:::

. . .

```{r}
#| eval: false

# filas 2, 7, 10 y 31
starwars |>
  slice(c(2, 7, 10, 31))
```

```{r}
#| echo: false
starwars |>
  slice(c(2, 7, 10, 31)) |> select(name:sex)
```

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(posiciones)
```
:::
:::

Disponemos de opciones por defecto:

-   con `slice_head(n = ...)` y `slice_tail(n = ...)` podemos obtener la [**cabecera y cola**]{.hl-yellow} de la tabla

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_head(n = 2)
```

```{r}
#| echo: false
starwars |> slice_head(n = 2) |> select(name:hair_color)
```
:::

::: {.column width="\"50%"}
```{r}
#| eval: false
starwars |> slice_tail(n = 2)
```

```{r}
#| echo: false
starwars |> slice_tail(n = 2) |> select(name:hair_color)
```
:::
:::

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(posiciones)
```
:::
:::

Disponemos de opciones por defecto:

-   con `slice_max()` y `slice_min()` obtenemos la [**filas con menor/mayor valor de una variable**]{.hl-yellow} (si empate, todas salvo que `with_ties = FALSE`) que indicamos en `order_by = ...`

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_min(mass, n = 2)
```

```{r}
#| echo: false
starwars |> slice_min(n = 2, order_by = mass) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_max(height, n = 2)
```

```{r}
#| echo: false
starwars |> slice_max(n = 2, order_by = height) |> select(name:hair_color)
```
:::
:::

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

El conocido como [**muestreo aleatorio simple**]{.hl-yellow} se basa en [**seleccionar individuos aleatoriamente**]{.hl-yellow}, de forma que cada uno tenga ciertas [**probabilidades**]{.hl-yellow} de ser seleccionado. Con `slice_sample(n = ...)` podemos extraer n registros aleatoriamente (a priori equiprobables).

```{r}
starwars |> slice_sample(n = 2)
```

. . .

::: callout-important
## Importante...

[**Â«AleatorioÂ» no implica equiprobable**]{.hl-yellow}: es igual de aleatorio un dado normal que uno trucado. No hay cosas Â«mÃ¡s aleatoriasÂ» que otras, simplemente tienen subyacente distintas leyes de probabilidad.
:::

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

TambiÃ©n podremos indicarle la [**proporciÃ³n de datos a samplear**]{.hl-yellow} (en lugar del nÃºmero) y si queremos que sea [**con reemplazamiento (que se puedan repetir)**]{.hl-yellow}.

```{r}
# 5% de registros aleatorios con reemplazamiento
starwars |> 
  slice_sample(prop = 0.05, replace = TRUE)

```

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

Como decÃ­amos, Â«aleatorioÂ» no es igual que Â«equiprobableÂ», asÃ­ que podemos pasarle un [**vector de probabilidades**]{.hl-yellow}. Por ejemplo, vamos a forzar que sea muy improbable sacar una fila que no sean las dos primeras

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

. . .

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

---

## ğŸ’» Tu turno {#tu-turno-4-2-bis}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Extrae 3 registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(n = 3)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Extrae el 10% de los registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(prop = 0.1)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Extrae aleatoriamente 10 personajes pero de forma que la probabilidad de que salga cada uno sea proporcional a su peso (mÃ¡s pesados, mÃ¡s probable)

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass) |> 
  slice_sample(n = 10, weight_by = mass)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Selecciona los 3 personajes mÃ¡s mayores.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_max(birth_year, n = 3)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ De los personajes que son humanos y miden mÃ¡s de 160 cm, elimina duplicados en color de ojos, elimina ausentes en peso, selecciona los 3 mÃ¡s altos, y orden de mayor a menor peso. Devuelve la tabla.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Human" & height > 160) |> 
  distinct(eye_color, .keep_all = TRUE) |> 
  drop_na(mass) |> 
  slice_max(height, n = 3) |> 
  arrange(desc(mass))
```
:::

---

## ğŸ£ Caso prÃ¡ctico: airquality {#caso-practico-4-2}

Vamos a volver aun viejo conocido: en el paquete `{datasets}` (ya instalado por defecto) tenÃ­amos diversos conjuntos de datos y uno de ellos era `airquality` con el que ya trabajamos. Los datos capturan [**medidas diarias (n = 153 observaciones) de la calidad del aire**]{.hl-yellow} en Nueva York, de mayo a septiembre de 1973.

En ese momento lo trabajamos desde la perspectiva de R base y extrayendo algunas variables del mismo. El objetivo ahora serÃ¡ trabajarlo desde la perspectiva de `{tidyverse}` fijÃ¡ndonos en las diferencias de una y otra forma.

```{r}
#| eval: false
library(datasets)
airquality
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-ii-airquality-tidyverse).

---

## Recategorizar: case_when() {#dplyr-columnas}

Para [**recategorizaciones mÃ¡s complejas**]{.hl-yellow} tenemos `case_when()`, por ejemplo, para crear una categorÃ­a de los personajes en funciÃ³n de su altura.

```{r}
starwars |> 
  drop_na(height) |> 
  mutate(altura = case_when(height < 120 ~ "enanos",
                            height < 160 ~ "bajito",
                            height < 180 ~ "normal",
                            height < 200 ~ "alto",
                            TRUE ~ "gigante"), .before = name)
```

---

## Mover columnas: relocate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  recolocar(var1, despues_de = var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  relocate(var1, .after = var2)
```
:::
:::

Para facilitar la [**recolocaciÃ³n de variables**]{.hl-yellow} tenemos una funciÃ³n para ello, `relocate()`, indicÃ¡ndole en `.after` o `.before` [**detrÃ¡s**]{.hl-purple} o [**delante**]{.hl-purple} de quÃ© columnas queremos moverlas.

```{r}
starwars |> relocate(species, .before = name)
```

---

## ğŸ’» Tu turno {#tu-turno-4bis-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano.

```{r}
#| code-fold: true
#| eval: false

starwars_2 |> 
  rename(nombre = name, altura = height, color_pelo = hair_color,
         color_piel = skin_color, color_ojos = eye_color)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio 1, coloca la variable de color de pelo justo detrÃ¡s de la variable de nombres.

```{r}
#| code-fold: true
#| eval: false

starwars_2 |>
  relocate(hair_color, .after = name)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Del dataset original, incluye una columna que calcule el IMC. Tras ello, crea una nueva variable que valga `NA` si no es humano, `delgadez` por debajo de 18, `normal` entre 18 y 30, `sobrepeso` por encima de 30.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(IMC = mass / ((height/100)^2),
         IMC_recat = case_when(species != "Human" ~ NA,
                               IMC < 18 ~ "delgadez",
                               IMC < 30 ~ "normal",
                               TRUE ~ "sobrepeso"),
         .after = name)
```
:::

---

## ğŸ£ Caso prÃ¡ctico: Taylor Swift {#caso-practico-4-3}

Vamos a volver al [**anÃ¡lisis de Taylor Swift**]{.hl-yellow} pero esta vez desde una perspectiva [**tidyverse**]{.hl-yellow}

```{r}
#| eval: false
library(taylor)
taylor_album_songs
```

```{r}
#| echo: false
library(taylor)
taylor_album_songs |> slice(1:5)
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-iii-taylor-swift)

---

## ğŸ£ Caso prÃ¡ctico: el seÃ±or de los anillos

Para practicar algunas funciones de `{dplyr}` vamos a usar datos de las pelÃ­culas de la [**trilogÃ­a de El SeÃ±or de los Anillos**]{.hl-yellow}. Los datos los cargaremos directamente desde la web (Github en este caso), sin pasar por el ordenador antes, simplemente **indicando como ruta la web donde estÃ¡ el archivo**

-   La comunidad del anillo -\> <https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Fellowship_Of_The_Ring.csv>

-   Las 2 torres -\> <https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Two_Towers.csv>

-   El Retorno del Rey -\> <https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Return_Of_The_King.csv>

---

## ğŸ£ Caso prÃ¡ctico: el seÃ±or de los anillos

```{r}
library(readr)
lotr_1 <-
  read_csv(file = "https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Fellowship_Of_The_Ring.csv")
lotr_2 <-
  read_csv(file = "https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Two_Towers.csv")
lotr_3 <-
  read_csv(file = "https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Return_Of_The_King.csv")
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-iii-extra-el-se%C3%B1or-de-los-anillos)

---

## Selectores: across() {#dplyr-resumenes}

Un truco es [**hacer uso de selectores**]{.hl-yellow} `across()` y `where()`. El primero nos permite [**actuar sobre varias columnas por nombre**]{.hl-purple} (con `mutate()` o `summarise()`)

```{r}
starwars |> summarise(medias = across(height:mass, mean, na.rm = TRUE), .by = sex)
```

. . .

El segundo, `where()`, nos permite hacer lo mismo pero [**seleccionando por tipo**]{.hl-yellow}.

```{r}
starwars |> 
  summarise(across(where(is.numeric), mean, na.rm = TRUE), .by = c(sex, gender))
```

---

## ğŸ£ Caso prÃ¡ctico: billboard {#caso-practico-4-4}

Vamos a hacer un **repaso de lo aprendido** en `{tidyverse}` con la tabla billboard del paquete `{tidyr}`. El dataset representa algo parecido a Los 40 principales (pero versiÃ³n americana y un top 100 en lugar de 40): para cada artista y canciÃ³n se guarda la fecha en la que entrÃ³ en el ranking, y la posiciÃ³n que ocupaba en el ranking en cada una de las semanas (`wk1`, `wk2`, ...)

```{r}
#| eval: false
billboard
```

```{r}
#| echo: false
billboard[, 1:8]
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-iv-billboard)

---

## ğŸ£ Caso prÃ¡ctico: fÃºtbol {#caso-practico-4-5}

Vamos a seguir **practicando lo aprendido** en `{tidyverse}` con el fichero `futbol.csv`, donde tenemos **datos de los jugadores de las 5 principales ligas de futbol masculinas**, desde 2005 hasta 2019, recopilando diferentes estadÃ­sticas. Los datos se han extraÃ­do directamente haciendo uso del paquete `{worldfootballR}`, que nos permite extraer datos de <https://www.fbref.com>

```{r}
datos <- read_csv(file = "./datos/futbol.csv")
datos
```

---

## ğŸ£ Caso prÃ¡ctico: fÃºtbol

Las variables capturan la siguiente informaciÃ³n:

-   `season`, `team`, `league`: temporada, equipo y liga
-   `player`, `country`, `position`, `date_birth`: nombre del jugador, paÃ­s, posiciÃ³n y aÃ±o de nacimiento.
-   `minutes_playing`, `matches`: minutos totales jugados y partidos jugados en media (es decir, cuantos partidos de 90 minutos ha jugado con los minutos jugados).
-   `goals`, `assist`: goles y asistencias totales
-   `pk`, `pk_attemp`, `goals_minus_pk`: penalties marcados, penalties tirados y goles marcados sin contar los penalties.
-   `yellow_card`, `red_card`: tarjetas amarillas/rojas.

[**Importante**]{.hl-red}: la variable `matches` debes crearla tÃº haciendo uso de `minutes_playing` (por ejemplo, si ha jugado 315 minutos, cuentan como 3.5 partidos)

---

## ğŸ£ Caso prÃ¡ctico: fÃºtbol

```{r}
datos
```

Â 

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-v-messi-vs-ronaldo)

---

## Importar desde web {#importar-exportar}

Una de las principales ventajas de `R` es que podemos hacer uso de todas las funciones anteriores de [**importar pero directamente desde una web**]{.hl-yellow}, sin necesidad de realizar la descarga manual: en lugar de pasarle la ruta local le indicaremos el [**enlace**]{.hl-yellow}. Por ejemplo, vamos a descargar los datos covid del ISCIII (<https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>)

```{r}
#| eval: false
covid_data <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
covid_data
```

```{r}
#| echo: false
covid_data <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv", n_max = 500)
covid_data
```

---

## Importar desde wikipedia

El paquete `{rvest}`, uno de los mÃ¡s Ãºtiles de `{tidyverse}` nos permite [**importar (scrappear) directamente desde un `html`**]{.hl-yellow}. Por ejemplo, para exportar tablas de wikipedia basta con `read_html()` para importar el html, `html_element(Â«tableÂ»)` para extraer los objetos tabla, y `html_table()` para convertir la tabla html a `tibble`.

```{r}
library(rvest)
wiki_jump <- 'https://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression'
wiki_jump |> read_html() |> 
  html_element("table") |> 
  html_table()
```

---

## Importar desde google drive

Otra opciÃ³n disponible (especialmente si trabajamos con otras personas trabajando) es [**importar desde una hoja de cÃ¡lculo de Google Drive**]{.hl-yellow}, haciendo uso de `read_sheet()` del paquete `{googlesheets4}`.

La primera vez se te pedirÃ¡ un permiso tidyverse para interactuar con tu drive

```{r}
library(googlesheets4)
google_sheet <-
  read_sheet("https://docs.google.com/spreadsheets/d/1Uz38nHjl3bmftxDpcXj--DYyPo1I39NHVf-xjeg1_wI/edit?usp=sharing")
google_sheet
```

---

## Importar desde API (aemet)

En muchas ocasiones para conectarnos a la API primero tendremos que [**registrarnos y obtener una clave**]{.hl-yellow}, este es el caso del paquete `{climaemet}` para acceder a [**datos meteorolÃ³gicos de EspaÃ±a**]{.hl-yellow} (<https://opendata.aemet.es/centrodedescargas/inicio>).

Una vez tengamos la clave API la registramos en nuestro RStudio para poder utilizarla en el futuro.

```{r}
#| eval: false
library(climaemet)

# Api key
apikey <- "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqYXZhbHYwOUB1Y20uZXMiLCJqdGkiOiI4YTU1ODUxMS01MTE3LTQ4MTYtYmM4OS1hYmVkNDhiODBkYzkiLCJpc3MiOiJBRU1FVCIsImlhdCI6MTY2NjQ2OTcxNSwidXNlcklkIjoiOGE1NTg1MTEtNTExNy00ODE2LWJjODktYWJlZDQ4YjgwZGM5Iiwicm9sZSI6IiJ9.HEMR77lZy2ASjmOxJa8ppx2J8Za1IViurMX3p1reVBU"

aemet_api_key(apikey, install = TRUE)
```

```{r}
#| echo: false
library(climaemet)
```

---

## Importar desde API (aemet)

Con este paquete podemos hacer una [**bÃºsqueda de estaciones**]{.hl-yellow} para conocer tanto su cÃ³digo postal como su cÃ³digo identificador dentro de la red AEMET

```{r}
stations <- aemet_stations()
stations
```

---

## Importar desde API (aemet)

Por ejemplo, para obtener datos de la estaciÃ³n del aeropuerto de El Prat, Barcelona, el cÃ³digo a proporcionar es `Â«0076Â»`, obteniendo **datos horarios**.

```{r}
aemet_last_obs("0076")
```

---

## Importar desde API

Otras opciones

-   `{tidycensus}`: una herramienta para [**facilitar el proceso de descarga de datos censales**]{.hl-yellow} de Estados Unidos desde `R`

-   `{chessR}`: datos de partidas de ajedrez de las plataformas chess.com y lychess. Ver mÃ¡s en <https://github.com/JaseZiv/chessR>

-   `{spotifyr}`: datos de canciones de Spotify. Ver mÃ¡s en <https://www.rcharlie.com/spotifyr/>

-   `{gtrendsR}`: datos de Google Trends. Ver mÃ¡s en <https://github.com/PMassicotte/gtrendsR>

-   `{scholar}`: datos de Google Scholar. Ver mÃ¡s en <https://github.com/jkeirstead/scholar>

---

## ğŸ£ Caso prÃ¡ctico: encuesta CIS {#caso-practico-4-6}

[ğŸ“Š Datos](https://drive.google.com/drive/folders/1zDc_XqXnTxx8auEYW7aFfIsnzDXOcAiZ?usp=sharing)

Vamos a poner en prÃ¡ctica la carga y preprocesado de un fichero generado por uno de los programas informÃ¡ticos mÃ¡s utilizados (SPSS). El fichero contiene [**datos del barÃ³metro del CIS (Centro de Investigaciones SociolÃ³gicas) Â«Percepciones sobre igualdad entre hombres y mujeres y estereotipos de gÃ©neroÂ»**]{.hl-yellow} cuyo trabajo muestral se realizÃ³ del 6 al 14 de noviembre (4000 entrevistas a mayores de 16 aÃ±os de ambos sexos en 1174 municipios y 50 provincias).

Â 

Intenta responder a las preguntas planteadas en el [**workbook (pendiente)**](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-vi-tabla-en-spss)

# Materiales extra: intro a dataviz en R {#extra-dataviz}

-   [ğŸ’» Historia del dataviz](#historia)

---

## Dataviz: historia {#historia}

La apariciÃ³n de grÃ¡ficos estadÃ­sticos es [**relativamente reciente en la ciencia**]{.hl-yellow} ya que hasta la Edad Media la Ãºnica visualizaciÃ³n estaba en los [**mapas**]{.hl-yellow}. [^1] Las propias palabras *chart* y *cartography* derivan del mismo origen latino, *charta*, aunque el primer uso de coordenadas viene de los egipcios. [^2] [^3]

[^1]: [Â«GramÃ¡tica de las grÃ¡ficas: pistas para mejorar las representaciones de datosÂ» de JoaquÃ­n Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)

[^2]: [Â«Presentation GraphicsÂ» de Leland Wilkinson. International Encyclopedia of the Social & Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

[^3]: [Â«Quantitative Graphics in Statistics: A Brief HistoryÂ» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)\]

. . .

::: columns
::: {.column width="55%"}
No es hasta la Edad Media, cuando la [**navegaciÃ³n y la astronomÃ­a**]{.hl-yellow} empezaban a tomar relevancia, cuando aparece la primera grÃ¡fica (no propiamente estadÃ­stica), del **movimiento cÃ­clico de los planetas** (siglos X y XI)
:::

::: {.column width="45%"}
![](img/dataviz_historico_1.png){width="370"}
:::
:::

---

## Primer grÃ¡fico estadÃ­stico

La mayorÃ­a de expertos, como Tufte [^4] [^5], consideran este grÃ¡fico casi longitudinal como la [**primera visualizaciÃ³n de datos**]{.hl-yellow} de la historia, hecha por **Van Langren** en 1644, representando la [**distancia entre Toledo y Roma**]{.hl-yellow}.

[^4]: [Â«Visual explanations: images and quantities, evidence and narrativeÂ» de E. Tufte](https://archive.org/details/visualexplanatio00tuft)

[^5]: [Â«PowerPoint is evilÂ» de E. Tufte](https://www.wired.com/2003/09/ppt2/)

```{r}
#| echo: false
knitr::include_graphics("./img/longitud_dataviz.jpg")
```

```{r}
#| echo: false
knitr::include_graphics("./img/dataviz_historico_3.jpeg")
```

---

## Vizfails

::: columns
::: {.column width="55%"}
![](img/persona_dataviz.jpg)
:::

::: {.column width="45%"}
-   La figura elegida (persona caminando) sin relaciÃ³n con lo visualizado: [**mala metÃ¡fora**]{.hl-red}.

-   Los [**sectores seÃ±alados sin relaciÃ³n con el Ã­tem**]{.hl-red} a representar, lo que dificulta su interpretaciÃ³n.

-   Los [**colores sin codificar**]{.hl-red}: no dan informaciÃ³n de ningÃºn tipo.

-   Las [**formas irregulares impiden la comparaciÃ³n**]{.hl-red} de las Ã¡reas (amÃ©n de que la suma total supera el 100%).

-   **Sin fuente**
:::
:::

---

## Vizfails

![](img/viz_fail_covid.jpg)

---

## Vizfails

![](img/viz_fail_uk.jpg)

---

## La importancia del CONTEXTO

Una **buena idea** puede estar mal ejecutada: la forma de llevarla a cabo es importante

![](img/semaforos.jpg)

---

## Dataviz: historia

En el siglo XVII hubo un boom de la estadÃ­stica al empezar a aplicarse en [**demografÃ­a**]{.hl-yellow}. Uno de los autores mÃ¡s importantes fue [**J. Graunt**]{.hl-purple}, autor de Â«Natural and Political Observations Made upon the Bills of MortalityÂ» (1662), estimando la poblaciÃ³n de Londres con las [**primeras tablas de natalidad y mortalidad**]{.hl-yellow}.

. . .

::: columns
::: {.column width="50%"}
Son precisamente las tablas de Graunt las que usÃ³ [**Christiaan Huygens**]{.hl-yellow} para generar la [**primera grÃ¡fica de densidad**]{.hl-yellow} de una distribuciÃ³n continua (esperanza de vida vs edad).
:::

::: {.column width="50%"}
```{r echo = FALSE,  out.width = "100%", fig.align = "center", fig.cap = "Primera funciÃ³n de densidad, extraÃ­da de https://omeka.lehigh.edu/exhibits/show/data_visualization/vital_statistics/huygen"}
knitr::include_graphics("./img/primera_densidad.jpg")
```
:::
:::

---

## GrÃ¡ficos de Playfair

La figura que cambiÃ³ el dataviz fue, sin lugar a dudas, el economista y polÃ­tico [**William Playfair (1759-1823)**]{.hl-yellow}, publicando en 1786 el **Â«Atlas polÃ­tico y comercialÂ»** [^6] [^7] con 44 grÃ¡ficas (43 series temporales y el diagrama de barras mÃ¡s famoso de la historia).

[^6]: [Â«Playfair and his chartsÂ» de H. Gray Funkhouser and Helen M. Walker (1935)](https://www.jstor.org/stable/45366440)

[^7]: [Â«A Letter on Our Agricultural Distresses, Their Causes and RemediesÂ» de W. Playfair (1821)](http://onlinebooks.library.upenn.edu/webbin/book/lookupid?key=ha009726110)

::: columns
::: {.column width="50%"}
```{r echo = FALSE, out.width = "70%", fig.align = "center", fig.cap = "ExtraÃ­das de Funkhouser y Walker (1935)"}
knitr::include_graphics("./img/playfair_1.jpg")
```
:::

::: {.column width="50%"}
```{r echo = FALSE, out.width = "25%", fig.align = "center", fig.cap = "ExtraÃ­das de Funkhouser y Walker (1935)"}
knitr::include_graphics("./img/playfair_2.jpg")
```
:::
:::

---

## GrÃ¡ficos de Playfair

Playfair es ademÃ¡s el autor del [**grÃ¡fico de barras mÃ¡s famoso**]{.hl-yellow} (no fue el primero pero sÃ­ quien lo hizo *mainstream*).

::: columns
::: {.column width="50%"}
```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "GrÃ¡ficas de Playfair de importaciones (barras grises) y exportaciones (negras) de Escocia en 1781, extraÃ­das de la wikipedia."}
knitr::include_graphics("./img/playfair_5.jpg")
```
:::

::: {.column width="50%"}
```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "Primer diagrama de barras (P. Buache y G. de Lâ€™Isle), visualizando los niveles del Sena (1732 - 1766), extraÃ­da de https://friendly.github.io/HistDataVis"}
knitr::include_graphics("./img/playfair_6.jpg")
```
:::
:::

---

## GrÃ¡ficos de Playfair

Playfair ademÃ¡s fue el primero en [**combinar grÃ¡ficos en la misma visualizaciÃ³n**]{.hl-yellow} [^8] [^9]

[^8]: [Â«A Letter on Our Agricultural Distresses, Their Causes and RemediesÂ» de W. Playfair (1821)](http://onlinebooks.library.upenn.edu/webbin/book/lookupid?key=ha009726110)

[^9]: [Â«An Inquiry Into the Permanent Causes of the Decline and Fall of Powerful and Wealthy NationsÂ» de William Playfair (1821)](https://www.amazon.com/Permanent-Powerful-Nations-Prosperity-Prolonged/dp/140691830X)

::: columns
::: {.column width="50%"}
```{r echo = FALSE, out.width = "85%", fig.align = "center", fig.cap = "Visualiza 3 series temporales: precios (barras) del trigo, salarios (lÃ­nea) y time-line con reinados, extraÃ­da de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/playfair_7.jpg")
```
:::

::: {.column width="50%"}
```{r echo = FALSE, out.width = "85%", fig.align = "center", fig.cap = "Time-line histÃ³rico, extraÃ­da de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/playfair_8.png")
```
:::
:::

---

## Primer scatter plot

SegÃºn J. Sevilla, se considera al astrÃ³nomo britÃ¡nico **John Frederick William Herschel** el autor del [**primer diagrama de dispersiÃ³n o scatterplot**]{.hl-yellow} en 1833, visualizando el movimiento de la estrella doble Virginis (tiempo en el eje horizontal, posiciÃ³n angular en el eje vertical)

```{r echo = FALSE, out.width = "35%", fig.align = "center", fig.cap = "ExtraÃ­do de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/herschel.jpg")
```

---

## Florence Nigthingale

::: columns
::: {.column width="65%"}
-   El 21 de octubre de 1854 [**Florence Nigthingale**]{.hl-yellow} fue enviada para mejorar las **condiciones sanitarias** de los soldados britÃ¡nicos en la guerra de Crimea.

-   A su regreso demostrÃ³ que los [**soldados fallecÃ­an por las condiciones sanitarias**]{.hl-yellow}. Nigthingale es la creadora del famoso [**diagrama de rosa**]{.hl-yellow}, visualizando tres variables a la vez y su estacionalidad.

-   El 8 de febrero de 1955, The Times la describiÃ³ como la **Â«Ã¡ngel guardiÃ¡nÂ» de los hospitales**, y acabÃ³ siendo conocida como [**Â«The Lady with the LampÂ»**]{.hl-yellow} tras un poema de H. W. Longfellow (1857).

-   AÃ±os despuÃ©s se convirtiÃ³ en la [**primera mujer en la Royal Statistical Society**]{.hl-yellow}.
:::

::: {.column width="35%"}
```{r echo = FALSE, out.width = "95%", fig.align = "center"}
knitr::include_graphics("./img/the_lady_with_the_lamp.png")
```
:::
:::

---

## Diagrama de rosa

Florence Nigthingale es la creadora del famoso [**diagrama de rosa**]{.hl-yellow}, permitiendo pintar [**tres variables a la vez y su estacionalidad**]{.hl-yellow}: **tiempo** (cada **gajo** es un mes), **nÂº de muertes** (**Ã¡rea** del gajo) y **causa** de la muerte (**color** del gajo: azules enfermedades infecciosas, rojas por heridas, negras otras causas).

```{r echo = FALSE, out.width = "75%", fig.align = "center"}
knitr::include_graphics("./img/rosa_nightingale.jpg")
```

---

## Recursos de dataviz

ğŸ“š [Â«The Functional Art: an introduction to information graphics and visualizationÂ» de Alberto Cairo](https://www.amazon.es/Functional-Art-Voices-That-Matter/dp/0321834739)

ğŸ“š [Â«GramÃ¡tica de las grÃ¡ficas: pistas para mejorar las representaciones de datosÂ» de JoaquÃ­n Sevilla](https://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)

ğŸ“š [Â«A Brief History of VisualizationÂ» de Friendly et al. (2008)](https://www.researchgate.net/publication/226400313_A_Brief_History_of_Data_Visualization)

ğŸ“š [Â«Quantitative Graphics in Statistics: A Brief HistoryÂ» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)\]

ğŸ“š [Â«Presentation GraphicsÂ» de Leland Wilkinson. International Encyclopedia of the Social & Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

ğŸ“š [Â«The Grammar of GraphicsÂ» de Leland Wilkinson](https://www.amazon.es/Grammar-Graphics-Statistics-Computing/dp/0387245448)

ğŸ“š [Â«The Minard System: The Graphical Works of Charles-Joseph MinardÂ» de Sandra Rendgen](https://www.amazon.es/gp/product/1616896337/ref=sw_img_1?smid=A1AT7YVPFBWXBL&psc=1)

ğŸ“š [Â«The Visual Display of Quantitative InformationÂ» de E. W. Tufte](https://www.amazon.es/Visual-Display-Quantitative-Information/dp/0961392142)

---

# Github {#github}

---

## Â¿QuÃ© es Github?

[**GitHub**]{.hl-yellow} es la plataforma colaborativa mÃ¡s conocida basada en el [**sistema de control de versiones Git**]{.hl-yellow}

. . .

-   [**Â¿QuÃ© es Git?**]{.hl-purple} Git es un sistema de [**control de versiones**]{.hl-yellow}: una especie de [**Dropbox**]{.hl-yellow} para facilitar la [**programaciÃ³n colaborativa**]{.hl-yellow} entre un grupo de personas, permitiendo llevar la [**trazabilidad de los cambios**]{.hl-yellow} realizados.

. . .

-   [**Â¿QuÃ© es Github?**]{.hl-purple} Nuestra [**plataforma/interfaz**]{.hl-yellow} para ejecutar el control de versiones: nos servirÃ¡ no solo para trabajar colaborativamente sino para [**hacer transparente**]{.hl-yellow} el proceso de construcciÃ³n de nuestros proyectos de cÃ³digo.

. . .

::: callout-important
## Importante

Desde el 4 de junio de 2018 Github es de Microsoft (ergo el cÃ³digo que subas tambiÃ©n)
:::

---

## VisiÃ³n general

Tras hacernos una cuenta en Github, [**arriba a la derecha**]{.hl-purple} tendremos un cÃ­rculo, y haciendo click en [**Your Profile**]{.hl-purple}, veremos algo similar a esto

::: columns
::: {.column width="55%"}
![](img/github_1.png)
:::

::: {.column width="45%"}
-   [**Edit profile**]{.hl-purple}: nos permite aÃ±adir una [**descripciÃ³n y foto de perfil**]{.hl-yellow}.

-   [**Overview**]{.hl-purple}: en ese panel de cuadrados se [**visualizarÃ¡ nuestra actividad**]{.hl-yellow} a lo largo del tiempo.

-   [**Repositories**]{.hl-purple}: el cÃ³dugo serÃ¡ subido a [**repositorios**]{.hl-yellow}, el equivalente a nuestras carpetas compartidas en Dropbox.
:::
:::

---

## Primer uso: consumidor

Antes de aprender como crear repositorios, Github tambiÃ©n nos servirÃ¡ para

-   [**Acceder a cÃ³digo**]{.hl-purple} ajeno
-   [**Proponer mejoras**]{.hl-purple} a otros usuarios, e incluso proponer [**correcciones de error que detectemos**]{.hl-yellow} de software que usemos

. . .

-   [**Instalar paquetes de R**]{.hl-purple}. En muchas ocasiones los desarrolladores de paquetes suben las actualizaciones a CRAN cada cierto tiempo, y en otras el software no es suficientemente Â«amplioÂ» para poder ser subido como paquete.

El cÃ³digo de paquetes que no tengamos subido en CRAN podremos [**instalarlo como cÃ³digo desde Github**]{.hl-yellow}

---

## Instalar desde Github

Por ejemplo, vamos a instalar un paquete llamado [`{peRReo}`](https://github.com/jbgb13/peRReo), cuya Ãºnica funciÃ³n es darnos [**paletas de colores**]{.hl-yellow} basadas en portadas de [**Ã¡lbumes de mÃºsica urbana**]{.hl-yellow}

::: columns
::: {.column width="50%"}
![](img/perrreo.png)
:::

::: {.column width="50%"}
![](img/rosalia.png){width="360"}
:::
:::

. . .

Para ello antes tendremos que instalar un [**conjunto de paquetes para desarrolladores**]{.hl-yellow} llamado `{devtools}`, que nos permitirÃ¡ la instalaciÃ³n desde Github

```{r}
#| eval: false
install.packages("devtools")
```

---

## Instalar desde Github

Las [**instrucciones de instalaciÃ³n**]{.hl-yellow} suelen venir detalladas en la portada del repositorio

::: columns
::: {.column width="50%"}
![](img/install_perreo.png)
:::

::: {.column width="50%"}
![](img/rosalia.png){width="310"}
:::
:::

. . .

En la mayorÃ­a de casos bastarÃ¡ con la funciÃ³n `install_github()` (del paquete que acabamos de instalar), pasÃ¡ndole como argumento la [**ruta del repositorio**]{.hl-yellow} (sin "github.com/").

```{r}
#| eval: false
devtools::install_github("jbgb13/peRReo")
```

Ya puedes perrear con ggplot ;)

---

## Descargar desde Github

La mayorÃ­a de veces lo que subamos no serÃ¡ un paquete de R como tal sino que [**subiremos un cÃ³digo mÃ¡s o menos organizado**]{.hl-yellow} y comentado. En ese caso podremos [**descargar el repo entero**]{.hl-yellow} haciendo click [**Code**]{.hl-green} y luego Download ZIP.

Por ejemplo, vamos a descargarnos los scripts de dataviz que han subido desde el [Centre d'Estudis d'OpiniÃ³](https://github.com/ceopinio/bop-grafics)

![](img/ceo_github.png)

---

## Ideal

![](img/abogados_simpson.jpeg){width="600"}

[**Â¿Lo ideal en caso de RTVE?**]{.hl-purple} Tener dos tipos de repositorios

-   Una [**colecciÃ³n de repositorios pÃºblicos (producciÃ³n)**]{.hl-yellow} donde hacer transparente el cÃ³digo y los datos ([**ya validados**]{.hl-purple}), coordinado por un nÂº reducido de personas.

-   Una [**colecciÃ³n de repositorios privados (desarrollo)**]{.hl-yellow} donde estÃ© todo el equipo colaborando y donde se haga el [**trabajo del dÃ­a**]{.hl-purple}, con trazabilidad interna.

---

## Nuestro primer repositorio

Vamos a [**crear nuestro primero repositorio**]{.hl-yellow} que servirÃ¡ ademÃ¡s como [**carta de presentaciÃ³n**]{.hl-yellow} de nuestro perfil en Github.

1.  [**Repositories**]{.hl-purple}: hacemos click en las pestaÃ±a de Repositories.

2.  [**New**]{.hl-purple}: hacemos click en el [**botÃ³n verde New**]{.hl-green} para crear un nuevo repositorio

![](img/new_repo.png)

---

## Nuestro primer repositorio

-   [**Repository name**]{.hl-purple}: el [**nombre del repositorio**]{.hl-yellow}. En este caso vamos a crear un repositorio muy concreto: el nombre debe [**coincidir exactamente con tu nombre de usuario**]{.hl-yellow}

-   [**Description**]{.hl-purple}: descripciÃ³n de tu repositorio. En este caso serÃ¡ un repo de presentaciÃ³n.

![](img/repo_init_1.png)

---

## Nuestro primer repositorio

-   [**Public vs private**]{.hl-purple}: con cada repositorio tendremos la opciÃ³n de hacer el repositorio

    -   [**pÃºblico**]{.hl-purple}: todos los usuarios podrÃ¡n ver el cÃ³digo asÃ­ cÃ³mo la trazabilidad de su desarrollo (quÃ© se aÃ±ade y cuÃ¡ndo). Es para mÃ­ la opciÃ³n mÃ¡s recomendable cuando quieres darle [**visibilidad y transparencia**]{.hl-yellow} a tu trabajo
    -   [**privado**]{.hl-purple}: solo tendrÃ¡n acceso al repositorio aquellos usuarios a los que se lo permitas. No se podrÃ¡ visualizar ni instalar nada de Ã©l fuera de Github.

![](img/repo_init_2.png)

En este caso concreto, dado que serÃ¡ un repositorio de presentaciÃ³n, lo [**haremos pÃºblico**]{.hl-yellow}.

---

## Nuestro primer repositorio

-   [**Add a README file**]{.hl-purple}: un README file serÃ¡ el archivo donde incluiremos las [**instrucciones y detalles de uso**]{.hl-yellow} a los demÃ¡s (en el caso de `{peRReo}` era el archivo que contenÃ­a los detalles de instalaciÃ³n)

![](img/repo_init_3.png)

De momento [**ignoraremos los demÃ¡s campos**]{.hl-red} para este primer repositorio.

---

## Nuestro primer repositorio

![](img/repo_init_1.png)

Por defecto Github asume que este repositorio, con el [**mismo nombre que nuestro usuario**]{.hl-yellow} serÃ¡ el repositorio que querremos que se presente de inicio cuando alguien entra en nuestro perfil, y serÃ¡ el repositorio donde \[**incluir en el README.md**\] una presentaciÃ³n de nosotros y un Ã­ndice de tu trabajo (si quieres).

---

## Nuestro primer repositorio

![](img/profile_github_md.png)

FÃ­jate que ahora en nuestra [**portada tenemos dicho README.md**]{.hl-yellow} que podemos personalizar a nuestro gusto haciendo uso de [**html y markdown**]{.hl-yellow}.

AquÃ­ puedes ver [**algunos ejemplos de README.MD**](https://github.com/matiassingers/awesome-readme)

---

## Repo de cÃ³digo

Una vez que tenemos nuestro README de presentaciÃ³n (recuerda que puedes [**personalizar a tu gusto con html y markdown**]{.hl-yellow}) vamos a crear un [**repositorio de cÃ³digo**]{.hl-yellow}.

. . .

Si ya era importante [**trabajar con proyectos**]{.hl-yellow} en `RStudio`, cuando lo combinamos con Github es aÃºn mÃ¡s crucial que creemos un proyecto antes de subir el cÃ³digo, asÃ­ que vamos a crear uno de prueba que se llame `repo-github-1`.

. . .

En dicho proyecto vamos a [**crear un script**]{.hl-yellow} (en mi caso llamado **codigo.R**) en el que deberÃ¡s hacer los siguientes pasos:

---

## Repo de cÃ³digo

1.  [**Carga**]{.hl-yellow} directamente desde la pÃ¡gina del [ISCIII](https://cnecovid.isciii.es/covid19/resources) el archivo llamado `casos_hosp_uci_def_sexo_edad_provres.csv`

```{r}
#| eval: false
#| code-fold: true
# Carga de datos desde ISCIII
datos_covid <- read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
```

. . .

2.  [**Filtra**]{.hl-yellow} datos de Madrid (`"M"`), de 2020 y con sexo conocido (hombre/mujer). Tras ello quÃ©date con las columnas `fecha`, `sexo`, `grupo_edad`, `num_casos` (ese orden). Por Ãºltimo obtÃ©n la suma de casos diarios por fecha y sexo.

```{r}
#| eval: false
#| code-fold: true
# DepuraciÃ³n
datos_madrid <-
  datos_covid |>
  # Filtrado por Madrid y fecha
  filter(provincia_iso == "M" & fecha <= "2020-12-31" & sexo != "NC") |> 
  # SelecciÃ³n de columnas
  select(provincia_iso:fecha, num_casos) |> 
  # Resumen de casos diarios por fecha y sexo
  summarise(num_casos = sum(num_casos), .by = c(fecha, sexo))
  
```

---

## Repo de cÃ³digo

3.  [**Exporta el dataset a un csv**]{.hl-yellow} en una carpeta que se llame `exportado`

```{r}
#| eval: false
#| code-fold: true
# Exportamos datos
write_csv(datos_madrid, file = "./exportado/datos_madrid.csv")
```

. . .

::: columns
::: {.column width="40%"}
4.  Crea una [**grÃ¡fica de lÃ­neas**]{.hl-yellow} que tenga en el eje x fecha, en el eje y casos, con una curva por sexo (grÃ¡ficas separadas).

```{r}
#| eval: false
#| code-fold: true
# GrÃ¡fica
ggplot(datos_madrid) +
  geom_line(aes(x = fecha, y = num_casos, color = sexo),
            alpha = 0.6, linewidth = 0.7) +
  scale_color_manual(values = c("#85519D", "#278862")) +
  facet_wrap(~sexo) +
  theme_minimal() +
  theme(legend.position = "bottom")
```
:::

::: {.column width="60%"}
![](./img/ggplot.png){width="380"}
:::
:::

. . .

5.  Tras ello [**exportamos la grÃ¡fica**]{.hl-yellow}

```{r}
#| eval: false
ggsave(filename = "./exportado/ggplot.png", plot = last_plot(),
       bg = "white", width = 12, height = 8)
```

---

## Repo de cÃ³digo

Â¿CÃ³mo [**subimos el proyecto**]{.hl-yellow}? Vamos de nuevo a [**crear un proyecto de cero**]{.hl-yellow}. Antes no hemos hablado de dos campos importantes:

::: columns
::: {.column width="50%"}
![](./img/repo-1.png){width="460"}
:::

::: {.column width="50%"}
-   `Add .gitignore` nos permitirÃ¡ [**seleccionar el lenguaje**]{.hl-yellow} en el que estarÃ¡ nuestro proyecto para que Github lo entienda al sincronizar (y no actualice cosas que no deba).

-   `Choose a license` nos permitirÃ¡ [**seleccionar la licencia**]{.hl-yellow} que determinarÃ¡ las condiciones en las que otros podrÃ¡n reusar tu cÃ³digo.
:::
:::

---

## Repo de cÃ³digo

::: columns
::: {.column width="50%"}
![](./img/repo-1-1.png)
:::

::: {.column width="50%"}
Si te fijas traer crearlo tenemos solo 3 archivos: el de licencia, el .gitignore y el readme.md (donde deberÃ­amos escribir una guÃ­a de uso de lo que hayamos subido)
:::
:::

Para subir los archivos vamos a clickar en [**Add file \< Upload File**]{.hl-purple} y [**arrastraremos TODOS los archivos**]{.hl-yellow} de la carpeta de nuestro proyecto.

---

## Repo de cÃ³digo

Tras la subida de archivos tendremos un cuadro llamado [**Commit changes**]{.hl-purple}

![](./img/commit-1.png)

Un [**commit**]{.hl-purple} es una [**modificaciÃ³n del repositorio**]{.hl-yellow} con algo que se aÃ±ade/elimine/modifique, y dicho cuadro es recomendable usarlo para [**resumir en quÃ© consiste la modificaciÃ³n**]{.hl-yellow}, de manera que quede trazado el cambio.

---

## Repo de cÃ³digo

Haciendo click en el reloj donde indica el [**nÃºmero de commits**]{.hl-yellow} accedemos al [**histÃ³rico de commits (cambios)**]{.hl-yellow} con hora, dÃ­a, autor, comentarios, etc.

![](./img/commit-reloj.png)

---

## Repo de cÃ³digo

Vamos a realizar un [**cambio en nuestro cÃ³digo**]{.hl-yellow}: en tu cÃ³digo local (local --\> tu ordenador), en lugar de filtrar por Madrid haz el [**filtro por Barcelona**]{.hl-yellow}, guarda el cÃ³digo y sube en el repositorio el nuevo archivo (con el mismo nombre, Github harÃ¡ la sobrescritura)

```{r}
#| eval: false
#| code-line-numbers: "3"
datos_bcn <-
  datos_covid |>
  filter(provincia_iso == "B" & fecha <= "2020-12-31" & sexo != "NC") |> 
  select(fecha, sexo, grupo_edad, num_casos) |> 
  summarise(num_casos = sum(num_casos), .by = c(fecha, sexo))
```

---

## Consulta de commits

![](./img/barcelona_covid.png){width="550"}

::: columns
::: {.column width="40%"}
Si ahora [**consultamos el commit**]{.hl-yellow}, al lado hay un nÃºmero que lo identifica, y clickando en Ã©l nos resume los cambios: no solo [**almacena todas las versiones pasadas**]{.hl-yellow} sino que ademÃ¡s nos [**muestra las diferencias entre los archivos cambiados**]{.hl-yellow}
:::

::: {.column width="60%"}
![](./img/commit_cambio.png)
:::
:::

---

## Trazabilidad de cambios

::: columns
::: {.column width="72%"}
![](./img/commit_split.png) ![](./img/commit_unified.png)
:::

::: {.column width="28%"}
Tenemos [**dos modos de visualizaciÃ³n**]{.hl-yellow} de los cambios: el modo split nos muestra el antiguo y el nuevo, con las inclusiones en verde y lo que ya no estÃ¡ en rojo; y el modo unified nos muestra todo en un mismo documento.
:::
:::

---

## RecuperaciÃ³n de commits

![](./img/browse-repo.png)

Github nos permite incluso [**recuperar una versiÃ³n del pasado**]{.hl-yellow} de nuestro repositorio, haciendo click en el tercer icono del commit.

---

## RecuperaciÃ³n de commits

![](./img/branch-commit.png)

Si te fijas ahora al lado de `1 branch` tenemos un [**menÃº desplegable**]{.hl-yellow} en el que antes ponÃ­a `main` y ahora un nÃºmero identificador del commit. Ya hablaremos de la idea de [**rama (branch)**]{.hl-yellow}

---

## Repo con rmd/qmd

::: columns
::: {.column width="60%"}
Vamos a poner en prÃ¡ctica lo aprendido:

1.  Crea un nuevo repositorio en Github (llamado `repo-github-2`) donde habrÃ¡ alojado con proyecto de R.

2.  Crea un proyecto en `RStudio` que se llame (por ejemplo) `proyecto-qmd`

3.  Una vez dentro del proyecto en `RStudio` haz click en `File < New File < Quarto Document`
:::

::: {.column width="40%"}
![](./img/primer-qmd.png)
:::
:::

DeberÃ¡s tener un documento similar a este: un [**quarto markdown (.qmd)**]{.hl-yellow}, un documento que nos permitirÃ¡ incluir [**markdown + cÃ³digo**]{.hl-yellow} (puede ser `R` o puede ser `Observable`, `D3`, etc).

---

## Repo con rmd/qmd

Este formato es ideal para:

-   [**Trabajar en equipo**]{.hl-yellow} construyendo el borrador de una pieza.
-   Tomar [**apuntes o informes**]{.hl-yellow} para uno mismo.
-   [**Presentar**]{.hl-yellow} tu trabajo a tus compaÃ±eros.

::: columns
::: {.column width="50%"}
![](./img/prueba-qmd-html.png)
:::

::: {.column width="50%"}
Si te fijas ahora nuestro repositorio tiene un archivo con formato `.html`...es decir...

[**Â¡Es una web!**]{.hl-yellow}
:::
:::

---

## Github pages

Â¿CÃ³mo [**convertir nuestro repositorio en una web**]{.hl-yellow}?

![](./img/github-pages.png)

1.  Haz click en `Settings`
2.  Ve al apartado `Pages`
3.  En el subapartado `branch` selecciona la Ãºnica rama que tenemos ahora (`main`)
4.  Selecciona la carpeta donde tengas el `.html` (en web complejas estarÃ¡ como en cualquier web en `docs`, en algo simple estarÃ¡ en la ruta raiz del repositorio)
5.  Haz click en `Save`

---

## Github pages

Si te fijas en la [**parte superior del repositorio**]{.hl-yellow} ahora tenemos un icono naranja, que nos indica que la [**web estÃ¡ en proceso de ser desplegada (deploy)**]{.hl-orange}

![](./img/github-naranja.png)

---

## Github pages

Pasados unos segundos (dependiendo del tamaÃ±o de la web y tu conexiÃ³n a internet) ese [**icono pasarÃ¡ a ser un check verde**]{.hl-green}: habemus web

![](./img/github-verde.png)

El [**link de la web por defecto**]{.hl-yellow} serÃ¡ `{nombre_usuario}.github.io/{nombre_repo}`

---

## Github pages

![](./img/github-pages-deploy.png)

Â¡Un momento! Ahora mismo nuestra web [**no nos estÃ¡ mostrando nuestro .qmd**]{.hl-red}, sino por defecto el [**README.md**]{.hl-yellow}.

. . .

Para que Github entienda que queremos visualizar ese `.html` que hemos generado a partir del `.qmd` vamos en nuestro proyecto local a [**borrar**]{.hl-yellow} todo lo que no sea nuestro archivo `.Rproj` y nuestro archivo `.qmd`, y vamos a [**cambiar el nombre**]{.hl-yellow} a este Ãºltimo llamÃ¡ndolo `index.qmd`, y volvemos a compilarlo para [**generar un index.html**]{.hl-yellow}

---

## Github pages

Vamos a [**subir a Github ese nuevo proyecto**]{.hl-yellow} con el cambio de nombre (llamado `repo-github-3`) para ver luego las diferencias entre uno y otro

![](./img/repo-index-html.png)

---

## Github pages

Si [**repetimos el proceso para hacer una Page**]{.hl-yellow} y esperamos al tick verde...

::: columns
::: {.column width="50%"}
![](./img/index-html-qmd.png)
:::

::: {.column width="50%"}
Si a tu `.qmd` ya le llamas de inicio `index.qmd`, automÃ¡ticamente, al detectar Github un `index.html`, interpreta que ese [**archivo index.html**]{.hl-yellow} es el que define la web (y puedes personalizar aÃ±adiendo un archivo `css` de estilos)

[**Habemus web**]{.hl-green} simplemente clickando en Pages :)
:::
:::

---

## Repo con diapositivas

Vamos a crear el Ãºltimo repositorio que se llamarÃ¡ `repo-diapos`, y crear un proyecto en `RStudio` del mismo nombre (por ejemplo). Una vez creado le daremos a `File < New File < Quarto Presentation`.

::: columns
::: {.column width="45%"}
![](img/quarto-slides.png)
:::

::: {.column width="55%"}
La forma de escribir serÃ¡ igual que un `.qmd` normal solo que ahora [**cada diapositiva la separaremos**]{.hl-yellow} con un `---` (usando archivos de estilos podemos personalizar lo que queramos)

Llama al archivo directamente `index.qmd`, sÃºbelo a Github y con un click en Pages tienes una [**web con tus diapositivas**]{.hl-yellow}
:::
:::

---

## Uso de Gitkraken

La forma mÃ¡s [**sencilla para trabajar de manera colaborativa**]{.hl-yellow} en Github, y tenerlo sincronizado con nuestro local, es hacer uso de [Gitkraken](https://www.gitkraken.com/download)

::: columns
::: {.column width="50%"}
![](img/gitkraken-repo.png)
:::

::: {.column width="50%"}
Una vez dentro clickamos en el icono de la carpeta (`Repo Management`) y si ya tenemos el repositorio en Github seleccionamos `Clone`, indicando donde queremos clonar (en nuestro local) y que [**repositorio de Github queremos clonar**]{.hl-yellow}.
:::
:::

---

## Uso de Gitkraken

::: columns
::: {.column width="50%"}
![](img/view-change.png)
:::

::: {.column width="50%"}
Una vez clonado, la idea es que cada [**cambio que hagamos en local nos aparecerÃ¡ en Gitkraken**]{.hl-yellow} como `View changes`.
:::
:::

---

## Uso de Gitkraken

Cuando tengas suficientes cambios como para [**actualizar el repositorio**]{.hl-yellow} (tampoco tiene sentido actualizar con cada ediciÃ³n), verÃ¡s algo similar a esto con todos los [**commits realizados**]{.hl-yellow}

::: columns
::: {.column width="50%"}
![](img/stage-all-changes.png)
:::

::: {.column width="50%"}
PodrÃ¡s decidir cuÃ¡les de los [**commits locales quieres incluir en remoto**]{.hl-yellow}, bien uno a uno o en `Stage all changes` (para todos)
:::
:::

---

## Uso de Gitkraken

Tras incluir los commits deberÃ¡s incluir un [**tÃ­tulo y descripciÃ³n del commit**]{.hl-yellow}

![](img/titulo-commit.png)

---

## Uso de Gitkraken

Tras hacerlo verÃ¡s que ahora tenemos [**dos iconos separados en una especie de Ã¡rbol**]{.hl-yellow} (Â¿te acuerdas de la `branch` o rama?):

-   [**Ordenador**]{.hl-purple}: la versiÃ³n del repositorio que tienes en tu [**ordenador**]{.hl-yellow}.

-   [**Logo**]{.hl-purple}: la versiÃ³n del repositorio que tienes [**subida en remoto**]{.hl-yellow}

![](img/split-gitkraken.png)

---

## Uso de Gitkraken

Mientras eso suceda solo tendrÃ¡s sincronizado tu ordenador con Gitkraken, pero no con Github. Para ello haremos [**click en Push**]{.hl-yellow} (con `Pull` podrÃ¡s forzar a tener en local lo mismo que en remoto).

![](img/push-gitkraken.png)

---

## Branchs

Como hemos mencionado ya en varias ocasiones, hay un elefante en la habitaciÃ³n que aÃºn no hemos mentado: las [**ramas o branchs**]{.hl-yellow} de un repositorio.

. . .

Imagina que estÃ¡is trabajando varios en un proyecto y teneÃ­s una versiÃ³n que funciona pero que querÃ©is [**modificar en paralelo a partir del estado actual**]{.hl-yellow} del repositorio.

. . .

Las [**ramas**]{.hl-yellow} nos permiten partir de una versiÃ³n comÃºn del repositorio y hacer cambios que [**no afecten a los demÃ¡s**]{.hl-yellow}

---

## Branchs

Para [**crear una rama**]{.hl-yellow} a partir del estado actual de repositorio haremos click en `Branch` y le pondremos un nombre

![](img/branch-button.png)

Una vez creada verÃ¡s [**dos iconos**]{.hl-yellow} y un [**menÃº desplegable**]{.hl-yellow} con las distintas ramas en las que quieres hacer el commit. Imagina que realizas un cambio pero [**no quieres aÃ±adirlo a la rama principal**]{.hl-yellow}: puedes hacer el [**commit en tu rama propia en LOCAL**]{.hl-yellow} (lo harÃ¡s en la rama activa de tu menÃº de branchs).

---

## Branchs

La primera vez te pedirÃ¡ que escribas la [**rama en REMOTO**]{.hl-yellow} con la quieres sincronizar tu rama en local. [**Consejo**]{.hl-green}: ponle el mismo nombre en remoto que en local.

![](img/name-branch.png)

---

## Branchs

FÃ­jate que ahora tenemos el ordenador y el logo en el mismo sitio. Esto no significa que tengas ambas ramas en tu local, solo que [**Gitkraken tiene ambas sincronizadas**]{.hl-yellow}: clickando en cualquiera de ellas, tus archivos en tu ordenador cambiarÃ¡n.

![](img/both-branchs.png)

---

## Pull request

Lo mÃ¡s recomendable es que [**solo se incorpore de una rama secundaria**]{.hl-yellow} a la rama principal aquello que estÃ¡ [**validado por un/a coordinador/a**]{.hl-yellow} del repositorio, asegurÃ¡ndose que todo funciona correctamente.

Cuando queramos incluirlo haremos [**click con botÃ³n derecho**]{.hl-yellow} en el icono de la rama secundaria y seleccionamos `Start a pull request to origin from...`

![](img/pull-request-menu.png)

. . .

Una [**pull request**]{.hl-yellow} serÃ¡ una [**peticiÃ³n al responsable de la rama principal**]{.hl-yellow} para incluir los cambios

---

## Pull request

::: columns
::: {.column width="60%"}
![](img/create-pull-request.png)
:::

::: {.column width="40%"}
En el cuadro que no se abre deberemos escribir:

-   La [**rama**]{.hl-yellow} a la que hacer el `merge` (normalmente la `main`)
-   TÃ­tulo y resumen de los cambios
-   Puedes incluso asignar un [**revisor**]{.hl-yellow} entre los colaboradores del repo.
-   Puedes asignar [**etiquetas**]{.hl-yellow}
:::
:::

---

## Pull request

Mientras no se acepte aparecerÃ¡ un [**icono de rama**]{.hl-yellow} y un +1 en Pull Requests

![](img/pending-branch.png){width="500"}

. . .

Si somos al mantenedor del repositorio, haciendo click en el menÃº nos saldrÃ¡n las ramas que nos quieren hacer hacer `merge`

![](img/menu-pr.png){width="500"}

---

## Pull request

Al hacer click se abrirÃ¡ un [**cuadro de Pull Request**]{.hl-yellow} para decidir si

-   [**Revisar**]{.hl-yellow} los cambios
-   [**Aprobar**]{.hl-yellow} el `merge`
-   [**AÃ±adir comentarios**]{.hl-yellow} al que ha solicitado el `merge` por si queremos solicitar algÃºn cambio [**antes de ser aprobado**]{.hl-yellow}

## ![](img/menu-pr-2.png)

## Pull request

Tras revisar todo y aprobarlo clickaremos en `Confirm merge`, y tras ello podremos decidir si esa rama que era paralela a la principal la queremos [**eliminar**]{.hl-yellow} o dejar visible a todos (consejo: dejar visible para tene [**trazabilidad**]{.hl-yellow} del proyecto de trabajo)

::: columns
::: {.column width="50%"}
![](img/merge-branch.png)
:::

::: {.column width="50%"}
![](img/delete-branch.png)
:::
:::
