---
title: "Bioestadística en R"
subtitle: "Introducción a la estadística en R"
title-slide-attributes:
  data-background-image: img/data-science-2.jpeg
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Máster de Bioinformática • Material elaborado en colaboración con Almudena Moreno Ribera y Silvia Pineda"
affiliation: Instituto de Salud Carlos III (ISCIII)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier Álvarez Liébana</strong>](...) • Máster de Bioinformática (ISCIII)"
    slide-number: c/t
execute:
  echo: true
---

::: r-fit-text
[¡Bienvenidos a R!]{.flow}
:::

[**Dejad vuestras hojas de cálculo y SPSS a un lado**]{style="color:#444442;"}

---

## ¡Buenas!

[**Correo**]{.hl-green}: [**javalv09\@ucm.es**](mailto:javalv09@ucm.es){.email}. [**Despacho**]{.hl-green}: 722 (3ª planta de la Facultad de Estudios Estadísticos de la UCM).

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
-   [**Javier Álvarez Liébana**]{.hl-yellow}, de Carabanchel (Bajo).

-   Licenciado en Matemáticas (UCM). [**Doctorado en estadística**]{.hl-yellow} (UGR).

-   Encargado de la [**visualización y análisis de datos covid**]{.hl-yellow} del Principado de Asturias (2021-2022).

-   Miembro de la [**Sociedad Española de Estadística e IO**]{.hl-yellow} y la [**Real Sociedad Matemática Española**]{.hl-yellow}.
:::
:::
:::

Actualmente, [**investigador y docente en la Facultad de Estadística de la UCM**]{.hl-yellow}. Divulgando por [**Twitter**](https://twitter.com/dadosdelaplace) e [**Instagram**](https://instagram.com/javieralvarezliebana)

---

## Objetivos

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
-   Quitarnos el [**miedo a los errores en programación**]{.hl-yellow} → a programar se aprende programando

-   Entender los [**conceptos básicos de R**]{.hl-yellow} desde cero → aprender a abstraer ideas y algoritmos

-   Utilidad de programar → flujos de trabajo [**reproducibles**, **transparentes**]{.hl-yellow} y mantenibles

-   Introducción al [**análisis y preprocesamiento**]{.hl-yellow} de datos 

-   Adquirir habilidades en el [**análisis descriptivo de los datos**]{.hl-yellow}

-   Adquirir habilidades en la [**modelización lineal**]{.hl-yellow}
:::
:::
:::

---

## Planificación {#planificacion}

::: column-screen-inset-right
::: {style="font-size:20px"}
| CLASE | SEMANA | FECHAS | TOPIC |  EJ. | CASO PRÁCTICO  | ENTREGA |     |     |     |
|:-------------:|:------:|:------:|:-----------------------------------------:|:--------------------------------------------------:|:------------------------------------:|:-------:|:---:|:---:|:---:|
| [1](#clase-1) |   S1   | 17 oct | Primeros pasos. Tipos de datos y vectores |   [💻](#tu-turno-1-1) [💻](#tu-turno-1-2) [💻](#tu-turno-1-3) |   [🐣](#caso-practico-1-1)   |    |     |     |     |
| [2](#clase-2) |   S2   | 22 oct |  Primeras bases de datos  |    [💻](#tu-turno-2-1) [💻](#tu-turno-2-2)  |   [🐣](#caso-practico-2-1) [🐣](#caso-practico-2-2) [🐣](#caso-practico-2-3)                                                   |         |     |     |     |
| [3](#clase-3) |   S2   | 24 oct |      Estructuras de control y Quarto      |                                         [💻](#tu-turno-3-1) [💻](#tu-turno-3-2)                                         |                                                                            [🐣](#caso-practico-3-1)                                                                            |         |     |     |     |
| [4](#clase-4) |   S3   | 29 oct |        Import, ggplot y tidyverse         | [💻](#tu-turno-4-1) [💻](#tu-turno-4-2) [💻](#tu-turno-4-3) [💻](#tu-turno-4-4) [💻](#tu-turno-4-5) [💻](#tu-turno-4-6) | [🐣](#caso-practico-4-1) [🐣](#caso-practico-4-2) [🐣](#caso-practico-4-3) [🐣](#caso-practico-4-4) [🐣](#caso-practico-4-5) [🐣](#caso-practico-4-6) [🐣](#caso-practico-4-7) |         |     |     |     |
:::
:::

---

## Casos prácticos: R base {#casos-practicos}

Practicar también con los 💻 **ejercicios resueltos** de las diapositivas. Los 🐣 indican el nivel de dificultad

::: column-screen-inset-right
::: {style="font-size:25px"}
| TEMA | DATASET | LINK | DIFICULTAD |
|:----------|:---------|:---------:|:-----------:|
| R base y vectores | airquality  | [Link](https://javieralvarezliebana.quarto.pub/intro-r-vectores-isciii/#caso-pr%C3%A1ctico-i-airquality-vectores) | 🐣 |
| Tibbles | pinniped  | [Link](https://javieralvarezliebana.quarto.pub/matrices-tibble-isciii/#caso-pr%C3%A1ctico-i-pinniped-dataset) | 🐣 |
| Tibbles | Taylor Swift  | [Link](https://javieralvarezliebana.quarto.pub/matrices-tibble-isciii/#caso-pr%C3%A1ctico-ii-an%C3%A1lisis-de-taylor-swift) | 🐣🐣 |
| Tibbles y textos | Discursos de Navidad | [Link](https://javieralvarezliebana.quarto.pub/matrices-tibble-isciii/#caso-pr%C3%A1ctico-iii-salto-de-longitud-practicando-textos) | 🐣🐣🐣 |
| Bucles y estructuras if-else | Simulados | [Link](https://javieralvarezliebana.quarto.pub/if-else-bucles-funciones-isciii/#caso-pr%C3%A1ctico-i-bucles-y-estructuras-condicionales) | 🐣🐣🐣🐣 |
| Funciones | Simulados | [Link](https://javieralvarezliebana.quarto.pub/if-else-bucles-funciones-isciii/#caso-pr%C3%A1ctico-ii-conversor-de-temperaturas) | 🐣🐣🐣 |
:::
:::

- [👾 Materiales extras R base](#extra-Rbase)

---

## Casos prácticos: tidyverse 

Practicar también con los 💻 **ejercicios resueltos** de las diapositivas. Los 🐣 indican el nivel de dificultad

::: column-screen-inset-right
::: {style="font-size:25px"}
| TEMA | DATASET | LINK | DIFICULTAD |
|:---------------|:----------------|:--------:|:-----------:|
| ¿Qué es el tidydata? | Datos de la OMS  | [Link](https://javieralvarezliebana.quarto.pub/tidydata-isciii/#caso-pr%C3%A1ctico-an%C3%A1lisis-de-datos-de-la-oms) | 🐣🐣 |
| Operaciones con filas | airquality  | [Link](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-ii-airquality-tidyverse) | 🐣 |
| Operaciones con columnas | Taylor Swift  | [Link](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-iii-taylor-swift) | 🐣🐣 |
| Operaciones con columnas | El señor de los anillos  | [Link](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-iii-extra-el-se%C3%B1or-de-los-anillos) | 🐣🐣🐣 |
| Resúmenes | Billboard | [Link](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-iv-billboard) | 🐣🐣 |
| Resúmenes | Datos de fútbol: Messi vs Cristiano Ronaldo | [Link](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-v-messi-vs-ronaldo) | 🐣🐣 |
| Resúmenes e importar/exportar | Encuesta del CIS sobre feminismo | [Link](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-vi-tabla-en-spss) | 🐣🐣🐣🐣 |
:::
:::

- [👾 Materiales extras tidyverse](#extra-tidyverse)

---

## Casos prácticos: estadística descriptiva en R

::: column-screen-inset-right
::: {style="font-size:25px"}
| TEMA | DATASET | LINK | DIFICULTAD |
|:---------------|:----------------|:--------:|:-----------:|
| Intro a la visualización de datos en R | Datos de covid del ISCIII  | [Link](https://javieralvarezliebana.quarto.pub/intro-dataviz-isciii/#caso-pr%C3%A1ctico-visualizaci%C3%B3n-covid) | 🐣 |
| Intro a la estadística descriptiva univariante | Encuesta de satisfacción  | [Link](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-encuesta-de-satisfacci%C3%B3n) | 🐣🐣 |
| Intro a la estadística bivariante: cuali vs cuali | Placebo vs medicamento | [Link](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-i-placebo-vs-f%C3%A1rmaco) | 🐣🐣 |
| Intro a la estadística bivariante: cuali vs cuali | tabaco vs bronquitis | [Link](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-ii-bronquitis-y-tabaco) | 🐣 |
| Intro a la estadística bivariante: cuali vs cuali | encuesta salud mental | [Link](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-iii-salud-mental) | 🐣🐣 |
:::
:::

- [👾 Recursos extras visualización](#recursos-dataviz)
- [👾 Materiales extras visualización](#extra-dataviz)

---

## Material extras

-   [💻 R base](#extra-Rbase)
-   [💻 Tidyverse](#extra-tidyverse)
-   [💻 Dataviz en R](#extra-dataviz)
-   [💻 Github](#github)

---

## Materiales

-   [**Diapositivas**]{.hl-yellow}: diapositivas en `Quarto` disponibles y actualizadas en [**https://javieralvarezliebana.es/docencia/biostats-ISCII**](https://javieralvarezliebana.es/docencia/biostats-ISCII){.uri}. En el menú de las diapositivas (abajo a la izquierda) tienes una [**opción para descargarlas en pdf**]{.hl-yellow} en `Tools`

- [🗃 **Datos**]{.hl-yellow}: datasets que usaremos a lo largo de la asignatura, disponibles en [**https://drive.google.com/drive/folders/1zDc_XqXnTxx8auEYW7aFfIsnzDXOcAiZ?usp=sharing**](https://drive.google.com/drive/folders/1zDc_XqXnTxx8auEYW7aFfIsnzDXOcAiZ?usp=sharing){.uri}

-   [📚 **Recursos de apoyo**]{.hl-yellow}: en inglés <https://r4ds.had.co.nz/> y en castellano <https://cdr-book.github.io/>, y <https://ivelasq.quarto.pub/intro-to-quarto/> para Quarto.

# Clase 1: [primeros pasos]{.flow} {#clase-1}

[**Instalando R y RStudio. Primeros pasos: ¿qué tipos de celdas (datos) existen?**]{style="color:#444442;"}

-   [💻 Ejercicios resueltos: R y RStudio](#tu-turno-1-1)
-   [💻 Ejercicios resueltos: tipos de datos](#tu-turno-1-2)
-   [💻 Ejercicios resueltos: vectores](#tu-turno-1-3)
-   [🐣 Workbook/caso práctico I](#caso-practico-1-1)
-   [📆 Planificación](#planificacion)

---

## Requisitos

Para el curso los únicos requisitos serán:

1.  [**Conexión a internet**]{.hl-yellow} (para la descarga de algunos datos y paquetes).

. . .

2.  [**Instalar R**]{.hl-yellow}: será nuestro lenguaje. La descarga la haremos (gratuitamente) desde <https://cran.r-project.org/>

. . .

3.  [**Instalar RStudio**]{.hl-yellow} desde <https://posit.co/download/rstudio-desktop/>

::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="420"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="420"}
:::
:::

---

## R vs RStudio

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="360"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="430"}
:::
:::

::: {.fragment .fade-in-then-out}
Programaremos como escribimos (castellano, por ejemplo) → `R` es [**lenguaje**]{.hl-yellow}
:::

::: {.fragment .fade-up}
-   Necesitaremos una [**gramática, un lenguaje**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}
-   Y un entorno, por ejemplo un [**Word**]{.hl-yellow} (`RStudio`), para escribirlo
:::
:::

---

## Instalación de R

El lenguaje `R` será nuestra [**gramática y ortografía**]{.hl-yellow} (nuestras reglas de juego)

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra en <https://cran.r-project.org/> y selecciona tu sistema operativo.

-   [**Paso 2**]{.hl-yellow}: para Mac basta con que hacer click en el **archivo .pkg**, y abrirlo una vez descargado. Para sistemas Windows, debemos clickar en **install R for the first time** y después en **Download R for Windows**. Una vez descargado, abrirlo como cualquier archivo de instalación.

-   [**Paso 3**]{.hl-yellow}: abrir el ejecutable de instalación.
:::

. . .

::: callout-warning
Siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), [**asegúrate de tener conexión a internet**]{.hl-orange}.
:::

---

## Primera operación {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalación, tras abrir `R`, deberías ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**Primer código**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el código en la consola y daremos «enter»). Tras ello haremos la suma `a + b`.

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## Primera operación {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalación, tras abrir `R`, deberías ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Primer código**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el código en la consola y daremos «enter»). Tras ello haremos la suma `a + b`.

```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

---

## Primera operación {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalación, tras abrir `R`, deberías ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Primer código**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el código en la consola y daremos «enter»). Tras ello haremos la suma `a + b`.

```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

. . .

::: callout-note
## Fíjate que...

En la consola aparece un número `[1]`: simplemente es un contador de elementos (como contar filas en un Word)
:::

---

## Instalación de R Studio

`RStudio` será el [**Word**]{.hl-yellow} que usaremos para escribir (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra la [web oficial de RStudio](https://posit.co/download/rstudio-desktop/) (ahora llamado Posit) y selecciona la descarga gratuita.

-   [**Paso 2**]{.hl-yellow}: selecciona el ejecutable que te aparezca acorde a tu sistema operativo.

-   [**Paso 3**]{.hl-yellow}: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro y dejar que termine la instalación.
:::

---

## Organización de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo código que antes (la suma de las variables) en ella. La consola será donde **ejecutaremos órdenes y mostraremos resultados**.

![](img/consola_rstudio.jpg){width="420"}

---

## Organización de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Environment**]{.hl-yellow}: la pantalla pequeña (puedes ajustar los márgenes con el ratón a tu gusto) que tenemos en la parte superior derecha. Nos mostrará las **variables que tenemos definidas**.

![](img/environment.jpg){width="420"}

---

## Organización de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha no servirá para buscar **ayuda de funciones**, además de para **visualizar gráficos**.

![](img/multiusos.jpg){width="420"}

---

## ¿Qué es R? ¿Por qué R?

![](img/meme_barco.jpg)

---

## ¿Qué es R? ¿Por qué R?

![](img/incel_excel.png)

`R` es la evolución del trabajo de los laboratorios Bell con el lenguaje `S`, que fue llevado al mundo del software libre por Ross Ihaka y Robert Gentleman en los años 90. La version `R 1.0.0` se publicó el 29 de febrero de 2000.

---

## ¿Qué es R? ¿Por qué R?

`R` es el [**lenguaje estadístico por excelencia**]{.hl-yellow}, creado por y para estadísticos/as, con 6 ventajas fundamentales [**frente a Excel, SAS, Stata o SPSS**]{.hl-red}:

. . .

-   [**Lenguaje de programación**]{.hl-yellow}: la obviedad → análisis [**replicables**]{.hl-purple}

. . .

-   [**Gratuito**]{.hl-yellow}: la filosofía de la comunidad de `R` es el compartir código bajo **copyleft** → **uso ético de dinero y algoritmos**

. . .

-   [**Software libre**]{.hl-yellow}: no solo es gratis sino que permite acceder libremente a código ajeno, incluso al **propio código fuente** → [**flexibilidad y transparencia**]{.hl-purple} (Free and Open Source Software FOSS)

---

## ¿Qué es R? ¿Por qué R?

`R` es el [**lenguaje estadístico por excelencia**]{.hl-yellow}, creado por y para estadísticos/as, con 6 ventajas fundamentales [**frente a Excel, SAS, Stata o SPSS**]{.hl-red}:

-   [**Lenguaje modular**]{.hl-yellow}: hemos instalado lo mínimo, pero existen códigos de otras personas que podemos reusar (casi 20 000 [**paquetes**]{.hl-yellow}) → [**ahorro de tiempo**]{.hl-purple} e [**innovación inmediata**]{.hl-purple}

. . .

-   [**Lenguaje de alto nivel**]{.hl-yellow}: facilita la programación (como Python) → [**menor curva de aprendizaje**]{.hl-purple}

. . .

-   [**Comunidad y empleabilidad**]{.hl-yellow}: junto con Python es el lenguaje más utilizado en el campo de la estadística y la ciencia de datos en investigación, docencia, empresas (Línea Directa, Mapfre, Telefónica, Orange, Apple, Spotify, Netflix, El País, Civio, HP, etc) y organismos públicos (ISCIII, CNIC, CNIO, INE, IGN, CIS, CEO, DGT, AEMET, RTVE, etc)

---

## ¿Por qué programar?

-   [**Automatizar**]{.hl-yellow} → te permitirá automatizar tareas recurrentes.

-   [**Replicabilidad**]{.hl-yellow} → podrás replicar tu análisis siempre de la misma manera.

-   [**Flexibilidad**]{.hl-yellow} → podrás adaptar el software a tus necesidades.

-   [**Transparencia**]{.hl-yellow} → ser auditado por la comunidad.

![](img/the_general_problem.png)

---

## Idea fundamental: paquetes

Una de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: códigos que otras personas han implementado para **resolver un problema**

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}
-   [**Instalación**]{.hl-yellow}: descargamos los códigos de la web (necesitamos internet) → [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)

```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}
-   [**Carga**]{.hl-yellow}: con el paquete descargado, indicamos qué paquetes queremos usar cada vez que abramos `RStudio` → [**traer el libro de la estantería**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::
:::
:::

---

## Idea fundamental: paquetes

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
Una vez instalado, hay **dos manera de usar un paquete** (traerlo de la estantería)

::: {.fragment fragment-index="1"}
-   [**Paquete entero**]{.hl-yellow}: con `library()`, usando el nombre del paquete sin comillas, cargamos en la sesión [**todo el libro**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}
-   [**Funciones concretas**]{.hl-yellow} usando `paquete::funcion` le índicamos que solo queremos una [**página concreta de ese libro**]{.hl-purple}

```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## Te vas equivocar

Durante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera → [**te vas equivocar**]{.hl-yellow}. No solo será importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.

. . .

-   [**Mensajes de error**]{.hl-red}: precedidos de **«Error in...»** y serán aquellos fallos que [**impidan la ejecución**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Mensajes de warning**]{.hl-orange}: precedidos de **«Warning in...»** son los (posibles) fallos más delicados ya que son incoherencias que [**no impiden la ejecución**]{.hl-orange}

```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```

---

## Scripts (documentos .R)

::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}
Un [**script**]{.hl-yellow} será el documento en el que programamos, nuestro archivo `.doc` (aquí con extensión `.R`) donde escribiremos las órdenes. Para **abrir nuestro primero script**, haz click en el menú en `File < New File < R Script`.

::: callout-warning
## Cuidado

Es importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habrás perdido**]{.hl-orange}.
:::
:::
:::

::: callout-warning
## Cuidado

`R` es [**case-sensitive**]{.hl-orange}: es sensible a mayúsculas y minúsculas por lo que `x` y `X` representa variables distintas.
:::

---

## Ejecutando el primer script

Ahora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros códigos**]{.hl-yellow}. ¿Cómo ejecutarlo?

. . .

1.  **Escribimos** el código a ejecutar.

. . .

2.  **Guardamos** el archivo .R haciendo click en `Save current document`.

. . .

3.  El código no se ejecuta salvo que se lo indiquemos. Tenemos **tres opciones de ejecutar un script**:

-   [**Copiar y pegar**]{.hl-yellow} en consola.
-   [**Seleccionar líneas**]{.hl-yellow} y `Ctrl+Enter`
-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el código **completo**.

---

## Sé organizado: proyectos

De la misma manera que en el ordenador solemos trabajar de manera [**ordenada por carpetas**]{.hl-yellow}, en `RStudio` podemos hacer lo mismo para trabajar de [**manera eficaz creando proyectos**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
Un [**proyecto será una «carpeta»**]{.hl-yellow} dentro de `RStudio`, de manera que nuestro directorio raíz automáticamente será la propia carpeta de proyecto (pudiendo pasar de un proyecto a otro con el menu superior derecho).

Podemos crear uno en una carpeta nueva o en una carpeta ya existente.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::

---

## 💻 Tu turno {#tu-turno-1-1}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Crea en tu ordenador una carpeta de la asignatura y crea dentro de ella el proyecto de `RStudio`: es ahí donde vas a guardar todo lo que hagamos a lo largo de este curso.Tras crear el proyecto tendrás un archivo `R Project`. A continuación crea en dicha carpeta dos subcarpetas: `datos` (es ahí donde irás guardando los distintos datasets que usaremos) y `scripts` (es ahí donde irás guardando los archivos `.R` de cada clase)

### [**Ejercicio 2**]{.hl-yellow}

📝 Dentro del proyecto crea un script `ejercicios-clase1.R` (dentro de la carpeta `scripts`). Una vez creado define en él una variable de nombre `a` y cuyo valor sea -1. Ejecuta el código de las 3 maneras explicadas.

```{r}
#| code-fold: true
a <- -1
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Añade debajo otra línea para definir una variable `b` con el valor 5. Tras ello guarda la multiplicación de ambas variables. Ejecuta el código como consideres.

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # sin guardar
multiplicacion <- a * b # guardado
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Modifica el código inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables y guarda el resultado.

```{r}
#| eval: false
c <- # deberías asignarle el valor 3
d <- # deberías asignarle el valor -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d # sin guardar
division <- c / d # guardado
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Asigna un valor positivo a `x` y calcula su raíz cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la función `abs()`.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

::: callout-note
## Toma nota

Comandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: líneas de código que hemos «encapsulado» bajo un nombre, y dado unos argumentos de entrada, ejecuta las órdenes (una especie de atajo). En las funciones los [**argumentos irán SIEMPRE entre paréntesis**]{.hl-yellow}
:::

### [**Ejercicio 6**]{.hl-yellow}

📝 Usando la variable `x` ya definida, completa/modifica el código inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.

```{r}
#| eval: false
z <- ? - ? # completa el código
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Define una variable `x` y asígnale el valor `-1`. Define otra `y` y asígnale el valor `0`. Tras ello realiza las operaciones a) `x` entre `y`; b) raíz cuadrada de `x`. ¿Qué obtienes?

```{r}
#| code-fold: true
#| eval: false
x <- -1
y <- 0

x / y
sqrt(x)
```

### [**Ejercicio 8**]{.hl-yellow}

📝 Escribe el código inferior en tu script. ¿Por qué crees que no funciona?

```{r}
#| error: true
x <- -1
y <- 0

X + y
```
:::

---

## De la CELDA a la TABLA

¿Qué [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg)

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenación** de valores del mismo tipo ([**vectores en R**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenación de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenación de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenación de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

---

## Pero antes...buenas prácticas

Antes de seguir, es importante que sepas algo cuánto antes: [**empezar en la programación puede ser frustrante**]{.hl-yellow}

. . .

Al igual que cuando aprendes un idioma nuevo, el primer obstáculo a solventar no es tanto qué decir sino cómo decirlo de manera correcta. Y en `R` pasa lo mismo, así que vamos a [**normalizar nuestra forma de programar**]{.hl-yellow} lo máximo posible para evitar errores futuros.

. . .

-   [**Tip 1**]{.hl-green}: [**asignar, evaluar y comparar no es lo mismo**]{.hl-yellow}. Si te has fijado en `R` estamos usando `<-` para asignar valores a variables. Usaremos `=` para evaluar argumentos en funciones y `==` para saber si dos elementos son iguales.

```{r}
#| eval: false
x <- 1 # asignar
x = 1 # evaluar
x == 1 # comparar
```

---

## Pero antes...buenas prácticas

-   [**Tip 2**]{.hl-green}: programa como escribes. Al igual que cuando redactas en castellano, acostúmbrate a incorporar [**espacios y saltos de línea**]{.hl-yellow} paranoquedarteciego (es una buena práctica y no un requisito porque `R` no procesa los espacios)

```{r}
#| eval: false
x <- 1 # óptimo
x<-1 # regu
x<- 1 # peor (decídete)
```

. . .

-   [**Tip 3**]{.hl-green}: no seas caótico/a, [**estandariza nombres**]{.hl-yellow}. Acostúmbrate siempre a nombrar las variables de la misma manera. El único requisito es que **debe empezar siempre por una letra** (y sin tildes). La forma más recomendable es la conocida como `snake_case`

```{r}
#| eval: false
variable_en_modo_snake_case
otraFormaMasDificilDeLeer
hay.gente.que.usa.esto
Incluso_Haygente.Caotica_que.NoMereceNuestraATENCION
```

---

## Pero antes...buenas prácticas

-   [**Tip 4**]{.hl-green}: facilita la lectura y escritura, [**pon límites**]{.hl-yellow}. En `Tools < Global Options` puedes personalizar algunas opciones de `RStudio`. En `Code < Display` podemos indicarle en `Show margin` que los scripts nos muestren un margen "imaginario" (no interacciona con el código) para "forzarnos" a realizar un salto de línea.

![](img/show_margin.jpg)

---

## Pero antes...buenas prácticas

-   [**Tip 5**]{.hl-green}: el [**tabulador es tu mejor amigo**]{.hl-yellow}. En `RStudio` tenemos una herramienta maravillosa: si escribes parte del nombre de una variable o función y tabulas, `RStudio` te autocompleta

![](img/tab-autocompletar.png)

---

## Pero antes...buenas prácticas

-   [**Tip 6**]{.hl-green}: ni un paréntesis soltero. Siempre que abras un paréntesis deberás cerrarlo. Para facilitar esta tarea entra en `Tools < Global Options < Code < Display` y activa la opción `Rainbow parentheses`

![](img/rainbow-parentheses.jpg)

---

## Pero antes...buenas prácticas

-   [**Tip 7**]{.hl-green}: fíjate en el lateral izquierdo. No solo podrás ver la línea de código por la que vas sino que, en caso de estar cometiendo un [**error de sintaxis**]{.hl-red}, el propio `RStudio` te avisará.

![](img/rstudio-error-sintaxis.png)

-   [**Tip 8**]{.hl-green}: intenta [**trabajar siempre por proyectos**]{.hl-yellow} (para esta clase, crea un script `clase2.R` en el proyecto que creamos en la anterior clase)

 

Ver más tips en <https://r4ds.had.co.nz/workflow-basics.html#whats-in-a-name>

---

## Celdas: tipos de datos

¿Existen [**variables más allá de los números en la ciencia de datos**]{.hl-yellow}? Piensa por ejemplo en los datos que podrías guardar de una persona:

::: {.fragment .fade-up}
-   La edad o el peso será un [**número**]{.hl-yellow}.

```{r}
edad <- 33
```
:::

::: {.fragment .fade-up}
-   Su nombre será una cadena de [**texto (conocida como string o char)**]{.hl-yellow}.

```{r}
nombre <- "javi"
```
:::

::: {.fragment .fade-up}
-   A la pregunta «¿estás matriculado en la Facultad?» la respuesta será lo que llamamos una [**variable lógica**]{.hl-yellow} (`TRUE` si está matriculado o `FALSE` en otro caso).

```{r}
matriculado <- TRUE
```
:::

::: {.fragment .fade-up}
-   Su fecha de nacimiento será precisamente eso, una [**fecha**]{.hl-yellow}.
:::

---

## Variables numéricas {auto-animate="true"}

El dato más sencillo (ya lo hemos usado) serán las [**variables numéricas**]{.hl-yellow}. Para saber la [**clase de dato en R**]{.hl-yellow} de una variable tenemos la función `class()`

```{r}
#| eval: false
#| code-line-numbers: "1"
a <- 5
```

---

## Variables numéricas {auto-animate="true"}

El dato más sencillo (ya lo hemos usado) serán las [**variables numéricas**]{.hl-yellow}. Para saber la [**clase de dato en R**]{.hl-yellow} de una variable tenemos la función `class()`

```{r}
#| eval: false
#| code-line-numbers: "2"
a <- 5
class(a)
```

. . .

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

Para saber su [**tipología (naturaleza o formato)**]{.hl-yellow} variable tenemos `typeof()`

```{r}
typeof(1) # 1 pero almacenado como un valor real (double, con decimales)
typeof(as.integer(1)) # 1 pero almacenado como un entero.
```

::: callout-note
## Fíjate que...

En `R` tenemos una colección de funciones que empiezan por `as.x()` y que sirven como [**funciones de conversión**]{.hl-yellow}: un dato que era de un tipo, lo convertimos a tipo `x`.
:::

---

## Variables numéricas

Además de los números «normales» tendremos el [**valor más/menos infinito**]{.hl-yellow} codificado como `Inf` o `-Inf`

```{r}
1/0
```

```{r}
-1/0
```

. . .

Y valores que [**no son números reales**]{.hl-yellow} *not a number* (indeterminaciones, complejos, etc) codificado como `NaN`

```{r}
0/0
```

```{r}
sqrt(-2)
```

---

## Variables numéricas

Con las variables numéricas podemos realizar las [**operaciones aritméticas**]{.hl-yellow} de una calculadora: sumar (`+`)...

```{r}
a + b
```

. . .

...raíz cuadrada (`sqrt()`)...

```{r}
sqrt(a)
```

. . .

... potencias (`^2`, `^3`)...

```{r}
a^2
```

. . .

...valor absoluto (`abs()`), etc.

```{r}
abs(a)
```

---

## Variables de texto

Imagina que además de la edad de una persona queremos guardar su nombre: ahora la variable será de tipo `character`

```{r}
nombre <- "Javier"
class(nombre)
```

. . .

Las [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones aritméticas**]{.hl-red} (sí otras operaciones como pegar o localizar patrones).

```{r}
#| error: true
nombre + 1 # error al sumar número a texto
```

. . .

::: callout-warning
## Recuerda que...

Las variables de tipo texto (character o string) van [**SIEMPRE entre comillas**]{.hl-orange}: no es lo mismo `TRUE` (valor lógico, binario) que `"TRUE"` (texto).
:::

---

## Primera función: paste

Como hemos comentado `R` llamaremos [**función**]{.hl-yellow} a un trozo de [**código encapsulado**]{.hl-yellow} bajo un nombre, y que depende de unos [**argumentos**]{.hl-yellow} de entrada. Nuestra primera función será `paste()`: dadas dos cadenas de texto nos permite pegarlas.

```{r}
paste("Javier", "Álvarez")
```

. . .

Fíjate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos añadir un [**argumento opcional**]{.hl-yellow} para indicarle el separador (en `sep = ...`).

```{r}
paste("Javier", "Álvarez", sep = "*")
```

---

## Primera función: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}
¿Cómo saber [**qué argumentos necesita una función**]{.hl-yellow}? Escribiendo en consola `? paste` te aparecerá una [**ayuda**]{.hl-yellow} en el panel multiusos.

En dicha ayuda podrás ver en su cabecera que argumentos ya tiene [**asignados por defecto**]{.hl-yellow} la función
:::
:::

. . .

Existe una función similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).

```{r}
paste0("Javier", "Álvarez")
```

---

## Primera función: paste

Los argumentos (y su detalle) también pueden ser consultado **tabulando (detras una coma)**.

![](img/tab-functions.png)

---

## Funciones: argumentos por defecto

Es muy importante entender el concepto de [**argumento por defecto de una función**]{.hl-yellow} en `R`: es un valor que la función usa pero a veces podemos no ver porque [**ya tiene un valor asignado**]{.hl-yellow}.

```{r}
# Hacen lo mismo
paste("Javier", "Álvarez")
paste("Javier", "Álvarez", sep = " ")
```

. . .

::: callout-note
## Toma nota

El operador `=` lo [**reservaremos para asignar argumentos**]{.hl-yellow} dentro de funciones. Para todas las demás asignaciones usaremos `<-`
:::

---

## Primer paquete: glue

Una forma más intuitiva de trabajar con textos es usar el paquete `{glue}`: lo primero que haremos será «comprar el libro» (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue") # solo la primra vez
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

Con la función `glue()` de dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, «la edad es de ... años», donde la edad está guardada en una variable.

```{r}
edad <- 33
glue("La edad es de {edad} años")
```

. . .

Dentro de las llaves también podemos [**ejecutar operaciones**]{.hl-yellow}

```{r}
unidades <- "días"
glue("La edad es de {edad * 365} {unidades}")
```

---

## Variables lógicas

Otro tipo fundamental serán las [**variables lógicas o binarias**]{.hl-yellow} (**dos valores**):

-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.
-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.

```{r}
soltero <- TRUE # ¿Es soltero? --> SÍ
class(soltero)
```

. . .

Dado que internamente están guardados como variables binarias, podemos [**realizar operaciones aritméticas**]{.hl-yellow} con ellas

```{r}
2 * TRUE
FALSE - 1
```

---

## Variables lógicas

Como veremos en breve, las variables lógicas en realidad puede tomar un tercer valor: `NA` o [**dato ausente**]{.hl-yellow}, representando las siglas de *not available*, y será muy habitual encontrarlo dentro de una base de datos.

```{r}
ausente <- NA
ausente + 1
```

. . .

::: callout-important
## Importante

Las variables lógicas [**NO son variables de texto**]{.hl-red}: `"TRUE"` es un texto, `TRUE` es un valor lógico.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Condiciones lógicas

Los valores lógicos suelen ser resultado de [**evaluar condiciones lógicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos [**comprobar**]{.hl-yellow} si una persona se llama Javi.

```{r}
nombre <- "María"
```

. . .

Con el [**operador lógico**]{.hl-yellow} `==` preguntamos sí lo que tenemos guardado a la izquierda es [**igual que**]{.hl-purple} lo que tenemos a la derecha: es una [**pregunta**]{.hl-yellow}

```{r}
nombre == "Javi"
```

. . .

Con su opuesto `!=` preguntamos [**si es distinto**]{.hl-purple}.

```{r}
nombre != "Javi"
```

. . .

::: callout-note
## Fíjate que...

No es lo mismo `<-` ([**asignación**]{.hl-yellow}) que `==` (estamos [**preguntando**]{.hl-yellow}, es una comparación lógica).
:::

---

## Condiciones lógicas

Además de las comparaciones «igual a» frente «distinto», también comparaciones de orden como [**menor que**]{.hl-purple} `<`, [**mayor que**]{.hl-purple} `>`, `<=` o `>=`.

**¿Tiene la persona menos de 32 años?**

```{r}
edad <- 34
edad < 32 # ¿Es la edad menor de 32 años?
```

. . .

**¿La edad es mayor o igual que 38 años?**

```{r}
edad >= 38
```

. . .

**¿El nombre guardado es Javi?**

```{r}
nombre <- "Javi"
nombre == "Javi"
```

---

## Variables de fecha

Un tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.

```{r}
fecha_char <- "2021-04-21"
```

Parece una simple cadena de texto pero [**debería representar un instante en el tiempo**]{.hl-yellow}. ¿Qué debería suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?

. . .

```{r}
#| error: true
fecha_char + 1
```

Las fechas [**NO pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha.

. . .

 

Para trabajar con fechas usaremos el paquete `{lubridate}`, que deberemos instalar antes de poder usarlo.

```{r}
#| eval: false
install.packages("lubridate")
```

---

## Variables de fecha

Una vez instalado, de todos los paquetes (libros) que tenemos, le indicaremos que nos cargue ese concretamente.

```{r}
library(lubridate) # instala si no lo has hecho

```

. . .

Para [**convertir a tipo fecha**]{.hl-yellow} usaremos la función `as_date()` del paquete `{lubridate}` (por defecto en formato `yyyy-mm-dd`)

 

::: columns
::: {.column width="50%"}
```{r}
#| error: true
# ¡no es una fecha, es un texto!
fecha_char + 1
class(fecha_char)
```
:::

::: {.column width="50%"}
```{r}
fecha <- as_date("2023-03-28")
fecha + 1
class(fecha)
```
:::
:::

---

## Variables de fecha

En `as_date()` el formato de fecha por defecto es `yyyy-mm-dd` así si la cadena de texto no se introduce de manera adecuada...

```{r}
as_date("28-03-2023")
```

. . .

Para [**cualquier otro formato debemos especificarlo**]{.hl-yellow} en el argumento opcional `format = ...` tal que `%d` representa días, `%m` meses, `%Y` en formato de 4 años y `%y` en formato de 2 años.

```{r}
as_date("28-03-2023", format = "%d-%m-%Y")
as_date("28-03-23", format = "%d-%m-%y")
as_date("03-28-2023", format = "%m-%d-%Y")
as_date("28/03/2023", format = "%d/%m/%Y")
```

---

## Variables de fecha

En dicho paquete tenemos funciones muy útiles para [**manejar fechas**]{.hl-yellow}:

-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.

```{r}
today()
```

. . .

-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}

```{r}
now()
```

. . .

-   Con `year()`, `month()` o `day()` podemos [**extraer el año, mes y día**]{.hl-purple}

```{r}
fecha <- today()
year(fecha)
month(fecha)
```

---

## Resúmenes de paquetes

![](img/lubridate.png)

::: callout-note
## Amplia contenido

Tienes un resumen en pdf de los paquetes más importantes en la [**carpeta correspondiente en el campus**]{.hl-green}
:::

---

## 💻 Tu turno {#tu-turno-1-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Define una variable que guarde tu edad (llamada `edad`) y otra con tu nombre (llamada `nombre`)

```{r}
#| code-fold: true
edad <- 33
nombre <- "Javi"
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Comprueba con dicha variable `edad` si NO tiene 60 años o si se llama `"Ornitorrinco"` (debes obtener variables lógicas como resultado)

```{r}
#| code-fold: true
#| eval: false
edad != 60 # distinto de
nombre == "Ornitorrinco" # igual a
```

### [**Ejercicio 3**]{.hl-yellow}

📝 ¿Por qué el código inferior da error?

```{r}
#| error: true
edad + nombre
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Define otra variable llamada `hermanos` que responda la pregunta «¿tienes hermanos?» y otra variable que almacene tu fecha de nacimiento (llamada `fecha_nacimiento`).

```{r}
#| code-fold: true
hermanos <- TRUE

library(lubridate) # sino lo tenías ya cargado
fecha_nacimiento <- as_date("1989-09-10")
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Define otra variable con tus apellidos (llamada `apellidos`) y usa `glue()` para tener, en una sola variable llamada `nombre_completo`, tu nombre y apellidos separando nombre y apellido por una coma

```{r}
#| code-fold: true
#| eval: false
apellidos <- "Álvarez Liébana"
glue("{nombre}, {apellidos}")
```

### [**Ejercicio 6**]{.hl-yellow}

📝 De `fecha_nacimiento` extrae el mes.

```{r}
#| code-fold: true
#| eval: false
month(fecha_nacimiento)
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Calcula los días que han pasado desde la fecha de tu nacimiento hasta hoy (con la fecha de nacimiento definida en el ejercicio 4).

```{r}
#| code-fold: true
#| eval: false
today() - fecha_nacimiento
```
:::

---

## Vectores: concatenar

Cuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenación**]{.hl-purple} de celdas (valores) del [**mismo tipo**]{.hl-purple} (lo que sería una columna de una tabla).

. . .

La forma más sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus **elementos entre paréntesis y separados por comas**

```{r}
edades <- c(32, 27, 60, 61)
edades
```

. . .

::: callout-tip
Un número individual `x <- 1` (o bien `x <- c(1)`) es en realidad un **vector de longitud uno** --\> todo lo que sepamos [**hacer con un número podemos hacerlo con un vector de ellos**]{.hl-green}.
:::

---

## Vectores: concatenar

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}
Como ves ahora en el `environment` tenemos una **colección de elementos** guardada

```{r}
edades
```
:::
:::

. . .

La [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`

```{r}
length(edades)
```

. . .

También podemos [**concatenar vectores**]{.hl-yellow} entre sí (los repite uno tras otro)

```{r}
c(edades, edades, 8)
```

---

## Secuencias numéricas

El vector más famoso será el de tipo numérico, y en concreto, las conocidas como [**secuencias numéricas**]{.hl-yellow} (por ejemplo, los días del mes), usadas para, entre otras cosas, indexar bucles.

. . .

El comando `seq(inicio, fin)` nos permite crear una [**secuencia numérica**]{.hl-yellow} desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.

```{r}
seq(1, 31)
```

. . .

Fíjate que si hacemos eso con [**caracteres no podremos hacerlo**]{.hl-red} ya que no hay un orden a priori entre textos.

```{r}
#| error: true
"a":"z"
```

---

## Secuencias numéricas

Un atajo es el comando `1:n`, que nos devuelve lo mismo que `seq(1, n)`

```{r}
1:7
```

Si el elemento inicial es mayor que el final, entenderá que la secuencia es [**en orden decreciente**]{.hl-purple}.

```{r}
7:-3
```

. . .

También podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos con el argumento `by = ...`

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

---

## Secuencias numéricas

Otras veces nos interesará definir una [**secuencia con una longitud concreta**]{.hl-yellow}

```{r}
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```

. . .

Incluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}

```{r}
rep(0, 7) # vector de 7 ceros
```

. . .

Dado que internamente son guardados como números también podremos hacer esto con [**fechas**]{.hl-yellow}.

```{r}
seq(as_date("2023-09-01"), as_date("2023-09-10"), by = 1)
```

---

## Vectores de caracteres

Un vector es una **concatenación** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente números. Vamos a crear una frase de ejemplo.

```{r}
frase <- "Me llamo Javi"
frase
length(frase)
```

. . .

En el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas

```{r}
vector <- c("Me", "llamo", "Javi")
vector
length(vector)
```

---

## Vectores de caracteres

¿Qué sucederá si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

Fíjate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}

. . .

```{r}
c(3, 4, TRUE, FALSE)
```

Es importante entender que los valores lógicos en realidad están [**almacenados internamente como 0/1**]{.hl-yellow}

---

## Operaciones con vectores

Con los vectores numéricos podemos hacer las mismas [**operaciones aritméticas**]{.hl-yellow} que con los números → un [**número es un vector**]{.hl-purple} (de longitud uno)

. . .

¿Qué sucederá si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Cuidado

Salvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}
:::

---

## Suma de vectores

Los vectores también pueden interactuar entre ellos, así que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)

```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Dado que la operación (por ejemplo, una suma) se realiza elemento a elemento, ¿qué sucederá si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?

. . .

```{r}
z <- c(1, 3, 5, 7)
x + z
```

Lo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que hará será reciclar del vector con menor longitud.

---

## Comparar vectores

Una operación muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones lógicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...

[**¿Qué días hizo menos de 22 grados?**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

Nos devolverá un [**vector lógico**]{.hl-yellow}, en función de si **cada elemento** cumple o no la condición pedida (de **igual longitud** que el vector preguntado)

. . .

Si tuviéramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese día), la condición evaluada también sería `NA`

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Comparar vectores

Las [**condiciones lógicas pueden ser combinadas**]{.hl-yellow} de dos maneras:

-   [**Intersección**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunción y**]{.hl-purple} con `&`) para devolver un `TRUE`

```{r}
x < 30 & x > 15
```

-   [**Unión**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunción o**]{.hl-purple} con `|`)

```{r}
x < 30 | x > 15
```

. . .

Con `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen

```{r}
any(x < 30)
all(x < 30)
```

---

## Acceder a elementos

Otra operación muy habitual es la de [**acceder a elementos**]{.hl-yellow}. La forma más sencilla es usar el operador `[i]` (acceder al elemento i-ésimo)

```{r}
edades <- c(20, 30, 33, NA, 61) 
edades[3] # accedemos a la edad de la tercera persona 
```

. . .

Dado que un número no es más que un vector de longitud uno, esta operación también la podemos aplicar usando un [**vector de índices a seleccionar**]{.hl-yellow}

```{r}
y <- c("hola", "qué", "tal", "estás", "?")
y[c(1:2, 4)] # primer, segundo y cuarto elemento
```

. . .

::: callout-tip
Para acceder al último, sin preocuparnos de cuál es, podemos pasarle como índice la propia longitud `x[length(x)]`
:::

---

## Eliminar elementos

Otras veces no querremos seleccionar sino [**eliminar algunos elementos**]{.hl-yellow}. Deberemos repetir la misma operación pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-ésimo del vector sino que lo «des-selecciona»

```{r}
y
y[-2]
```

. . .

En muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones lógicas**]{.hl-yellow}, en función de los valores, así que pasaremos como índice la propia condición (recuerda, `x < 2` nos devuelve un vector lógico)

```{r}
edades <- c(15, 21, 30, 17, 45)
nombres <- c("javi", "maría", "laura", "carla", "luis")
nombres[edades < 18] # nombres de los menores de edad
```

---

## Sumar vectores

También podemos hacer uso de [**operaciones estadísticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**¿Qué sucede cuando falta un dato (ausente)?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

Por defecto, si tenemos un dato ausente, la [**operación también será ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`

```{r}
sum(x, na.rm = TRUE)
```

---

## Sumar vectores

Como hemos comentado que los valores lógicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritméticas.

Por ejemplo, si queremos [**averiguar el número de elementos que cumplen una condición**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendrán asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar dicho vector lógico para obtener el número de elementos que cumplen

```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Suma acumulada

Otra operación habitual que puede sernos útil es la [**suma acumulada**]{.hl-yellow} con `cumsum()` que, dado un vector, nos devuelve un vector a su vez con el primero, el primero más el segundo, el primero más el segundo más el tercero...y así sucesivamente.

```{r}
x <- c(1, 5, 2, -1, 8)
cumsum(x)
```

[**¿Qué sucede cuando falta un dato (ausente)?**]{.hl-yellow}

```{r}
x <- c(1, -2, 3, NA, -1)
cumsum(x)
```

En el caso de la suma acumulada lo que sucede es que [**a partir de ese valor, todo lo acumulado posterior será ausente**]{.hl-yellow}.

---

## Diferencia

Otra operación habitual que puede sernos útil es la [**diferencia (con retardo)**]{.hl-yellow} con `diff()` que, dado un vector, nos devuelve un vector con el segundo menos el primero, el tercero menos el segundo, el cuarto menos el tercero...y así sucesivamente.

```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x)
```

. . .

Con el argumento `lag =` podemos indicar el [**retardo**]{.hl-yellow} de dicha diferencia (por ejemplo, `lag = 3` implica que se resta el cuarto menos el primero, el quinto menos el segundo, etc)

```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x, lag = 3)
```

---

## Media

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La más conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores atípicos o outliers (valores muy grandes o muy pequeños), la media se perturba con mucha facilidad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Percentiles

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Percentiles**]{.hl-yellow}: medidas de posición (nos dividen en partes iguales los datos).

```{r}
quantile(x) # por defecto percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

---

## Ordenar vectores

Por último, una acción habitual es saber [**ordenar valores**]{.hl-yellow}:

-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(edades)
sort(edades, decreasing = TRUE)
```

. . .

-   `order()`: devuelve el [**vector de índices**]{.hl-yellow} que tendríamos que usar para tener el vector ordenado

```{r}
order(x)
x[order(x)]
```

---

## 💻 Tu turno {#tu-turno-1-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Define el vector `x` como la concatenación de los 5 primeros números impares. Calcula la longitud del vector

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Accede al tercer elemento de `x`. Accede al último elemento (sin importar la longitud, un código que pueda ejecutarse siempre). Elimina el primer elemento.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Obtén los elementos de `x` mayores que 4. Calcula el vector `1/x` y guárdalo en una variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Crea un vector que represente los nombres de 5 personas, de los cuales uno es desconocido.

```{r}
#| code-fold: true
#| eval: false
nombres <- c("Javi", "Sandra", NA, "Laura", "Carlos")
nombres
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Encuentra del vector `x` de ejercicios anteriores los elementos mayores (estrictos) que 1 Y ADEMÁS menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Ejercicio 6**]{.hl-yellow}

📝 Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, ¿por qué su media no devuelve un número sino lo que se muestra en el código inferior?

```{r}
x <- c(1, -5, 8, NA, 10, -3, 9)
mean(x)
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6.

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
x[-2]
```

### [**Ejercicio 8**]{.hl-yellow}

📝 Dado el vector `x` del ejercicio anterior, ¿cuales tienen un dato ausente? Pista: las funciones `is.algo()` comprueban si el elemento es tipo `algo` (tabula)

```{r}
#| code-fold: true
#| eval: false
is.na(x)
```

### [**Ejercicio 9**]{.hl-yellow}

📝 Define el vector `x` como la concatenación de los 4 primeros números pares. Calcula el número de elementos de `x` menores estrictamente que 5.

```{r}
#| code-fold: true
#| eval: false
x[x < 5] 
sum(x < 5)
```

### [**Ejercicio 10**]{.hl-yellow}

📝 Calcula el vector `1/x` y obtén la versión ordenada (de menor a mayor) de las dos formas posibles

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Ejercicio 11**]{.hl-yellow}

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Ejercicio 12**]{.hl-yellow}

📝 Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 6. Encuentra una forma de averiguar si todos los elementos son o no negativos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```
:::

## 🐣 Caso práctico I: vectores {#caso-practico-1-1}

En el paquete `{datasets}` (ya instalado por defecto) tenemos diversos conjuntos de datos y uno de ellos es `airquality`. Debajo te he extraído 3 variables de dicho dataset (fíjate que se hace con `datos$variable`, ese dolar será importante en el futuro).

Los datos capturan [**medidas diarias (n = 153 observaciones) de la calidad del aire**]{.hl-yellow} en Nueva York, de mayo a septiembre de 1973. Se midieron **6 variables**: niveles de ozono, radiación solar, viento, temperatura, mes y día.

```{r}
library(datasets)
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/intro-r-vectores-isciii/)

# Clase 2: [primeras bases de datos]{.flow} {#clase-2}

[**Primera base de datos: matrices, data.frame y tibble**]{style="color:#444442;"}

-   [💻 Ejercicios resueltos: matrices](#tu-turno-2-1)
-   [💻 Ejercicios resueltos: data.frame y tibble](#tu-turno-2-2)
-   [🐣 Workbook/caso práctico: tibble](#caso-practico-2-1)
-   [🐣 Workbook/caso práctico: Quarto](#caso-practico-2-2)
-   [📆 Planificación](#planificacion)

---

## Primera base de datos

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una «tabla» que las recopile. La opción más inmediata son las [**matrices**]{.hl-yellow}: concatenación de variables del [**mismo tipo e igual longitud**]{.hl-purple}.

Imagina que tenemos estaturas y pesos de 4 personas. ¿Cómo [**crear un dataset con las dos variables**]{.hl-yellow}?

. . .

La opción más habitual es usando `cbind()`: [**concatenamos (bind) vectores en forma de columnas (c)**]{.hl-yellow}

```{r}
#| code-line-numbers: "3"
estaturas <- c(150, 160, 170, 180)
pesos <- c(63, 70, 85, 95)
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

---

## Primer intento: matrices

También podemos [**construir la matriz por filas**]{.hl-yellow} con la función `rbind()` (concatenar - bind - por filas - rows), aunque lo [**recomendable es tener cada variable en columna**]{.hl-green} e individuo en fila como luego veremos.

```{r}
rbind(estaturas, pesos) # Construimos la matriz por filas
```

. . .

-   Podemos [**«visualizar» la matriz**]{.hl-yellow} con `View(matriz)`.

. . .

-   Podemos [**comprobar las dimensiones**]{.hl-yellow} con `dim()`, `nrow()` y `ncol()`: las matrices son un tipo de **datos tabulados** (organizados en filas y columnas)

```{r}
dim(datos_matriz)
nrow(datos_matriz)
ncol(datos_matriz)
```

---

## Primer intento: matrices

También podemos [**«darle vuelta» (matriz transpuesta)**]{.hl-yellow} con `t()`.

```{r}
t(datos_matriz)
```

. . .

Dado que ahora tenemos dos dimensiones en nuestros datos, para [**acceder a elementos con `[]`**]{.hl-yellow} deberemos proporcionar **dos índices separados por comas**: índice de la fila y de la columna

```{r}
datos_matriz[2, 1] # segunda fila, primera columna
datos_matriz[1, 2] # primera fila, segunda columna 
```

---

## Primer intento: matrices

En algunas casos querremos obtener los [**datos totales de un individuo**]{.hl-yellow} (una fila concreta pero todas las columnas) o los valores de [**toda una variable**]{.hl-yellow} para todos los individuos (una columna concreta pero todas las filas). Para ello dejaremos [**sin rellenar uno de los índices**]{.hl-yellow}

```{r}
datos_matriz[2, ] # segundo individuo
datos_matriz[, 1] # primera variable
```

. . .

Mucho de lo aprendido con vectores podemos hacerlo con matrices, así podemos por ejemplo acceder a varias filas y/o columnas haciendo uso de las [**secuencias de enteros 1:n**]{.hl-yellow}

```{r}
datos_matriz[c(1, 3), 1] # primera variable para el primer y tercer individuo
```

---

## Primer intento: matrices

También podemos definir una [**matriz a partir de un vector numérico**]{.hl-yellow}, reorganizando los valores en forma de matriz (sabiendo que los elementos se van [**colocando por columnas**]{.hl-purple}).

```{r}
z <- matrix(1:9, ncol = 3) 
z
```

. . .

Incluso podemos [**definir una matriz de valores constantes**]{.hl-yellow}, por ejemplo de ceros (para luego rellenar)

```{r}
matrix(0, nrow = 2, ncol = 3)
```

---

## Operaciones con matrices

Con las matrices sucede como con los vectores: cuando aplicamos una [**operación aritmética lo hacemos elemento a elemento**]{.hl-yellow}

```{r}
z/5
```

. . .

Para realizar [**operaciones en un sentido matricial**]{.hl-yellow} deberemos añadir `%%`, por ejemplo, para multiplicar matrices será `%*%`

```{r}
z * t(z)
z %*% t(z)
```

---

## Operaciones con matrices

También podemos [**realizar operaciones por columnas/filas**]{.hl-yellow} sin recurrir a bucles con la función `apply()`, y le indicaremos como **argumentos**

-   la matriz
-   el sentido de la operación (`MARGIN = 1` por filas, `MARGIN = 2` por columnas)
-   la función a aplicar
-   argumentos extra que necesite la función

. . .

Por ejemplo, para aplicar una media a cada variable, será `mean` aplicada con `MARGIN = 2` (misma función para cada columna)

```{r}
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")
```

---

## 💻 Tu turno (matrices) {#tu-turno-2-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Modifica el código inferior para definir una matriz `x` de unos, de 3 filas y 7 columnas.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Ejercicio 2**]{.hl-yellow}

📝 A la matriz anterior, suma un 1 a cada número de la matriz y divide el resultado entre 5. Tras ello calcula su transpuesta

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 ¿Por qué el código inferior nos devuelve dicho mensaje de aviso?

```{r}
#| warning: TRUE
matrix(1:15, nrow = 4)
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Define la matriz `x <- matrix(1:12, nrow = 4)`. Tras ello obtén los datos del primer individuo, los datos de la tercera variable, y el elemento `(4, 1)`.

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # primera fila
x[, 3] # tercera columna
x[4, 1] # elemento (4, 1)
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Define una matriz de 2 variables y 3 individuos tal que cada variable capture la estatura y la edad 3 personas, de manera que la edad de la segunda persona sea desconocida (ausente). Tras ello calcula la media de cada variable (¡nos debe de volver un número!)

```{r}
#| code-fold: true
#| eval: false
datos <- cbind("edad" = c(20, NA, 25), "estatura" = c(160, 165, 170))
apply(datos, MARGIN = 2, FUN = "mean", na.rm = TRUE) # media por columnas

```

### [**Ejercicio 6**]{.hl-yellow}

📝 ¿Por qué devuelve error el código inferior? ¿Qué está mal?

```{r}
#| error: true
matriz <- cbind("edad" = c(15, 20, 25), "nombres" = c("javi", "sandra", "carlos"))
matriz
matriz + 1
```
:::

---

## Segundo intento: data.frame

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte (fíjate en el código inferior: las edades y los `TRUE/FALSE` los ha convertido a texto)

```{r}
#| code-line-numbers: "4-5"
edades <- c(14, 24, NA)
soltero <- c(TRUE, NA, FALSE)
nombres <- c("javi", "laura", "lucía")
matriz <- cbind(edades, soltero, nombres)
matriz
```

. . .

De hecho al no ser números ya no podemos realizar operaciones aritméticas

```{r}
#| error: true
matriz + 1
```

---

## Segundo intento: data.frame

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos en `R` lo que se conoce como [**data.frame**]{.hl-yellow}: concatenación de variables de igual longitud pero que pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
tabla <- data.frame(edades, soltero, nombres)
class(tabla)
tabla
```

---

## Segundo intento: data.frame

Dado que un `data.frame` es ya un intento de «base de datos» las variables no son meros vectores matemáticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple} que describan su significado

```{r}
library(lubridate)
tabla <-
  data.frame("edad" = edades, "estado" = soltero, "nombre" = nombres,
             "f_nacimiento" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
tabla
```

---

## Segundo intento: data.frame

[**¡TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} (estrictamente no podemos hablar de base de datos pero de momento como lo si fuesen). Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

![](img/view_tabla.jpg)

---

## Acceso a variables

Si queremos acceder a sus elementos, al ser de nuevo **datos tabulados**, podemos acceder como en las matrices ([**no recomendable**]{.hl-red}): de nuevo [**tenemos dos índices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera característica de la segunda persona
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
Pero también tiene las ventajas de una [**«base» de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} ([**lo recomendable**]{.hl-green} ya que las variables pueden cambiar de posición y ahora sí tienen un significado), poniendo el nombre de la tabla seguido del símbolo `$` (con el **tabulador**, nos aparecerá un menú de columnas a elegir)
:::
:::

---

## Funciones de consulta

-   `names()`: nos muestra los nombres de las variables

```{r}
names(tabla)
```

. . .

-   `dim()`: nos muestra las dimensiones (también `nrow()` y `ncol()`)

```{r}
dim(tabla)
```

. . .

-   Podemos acceder a las variables por su nombre

```{r}
tabla[c(1, 3), "nombre"]
tabla$nombre[c(1, 3)]
```

---

## Añadir variable

Si tenemos uno ya creado y queremos [**añadir una columna**]{.hl-yellow} es tan simple como usar la función `data.frame()` que ya hemos visto para concatenar la columna. Vamos añadir por ejemplo una nueva variable, el número de hermanos de cada individuo.

```{r}
# Añadimos una nueva columna con nº de hermanos/as
hermanos <- c(0, 2, 3)
tabla <- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

---

## Intento final: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}. La principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```

. . .

En adelante usaremos el formato `tibble` ([**data.frame mejorado**]{.hl-yellow}) del paquete `{tibble}`

```{r}
library(tibble)
datos_tb <- 
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
class(datos_tb)
datos_tb
```

---

## Intento final: tibble

```{r}
datos_tb <-
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
datos_tb
```

Las tablas en formato `tibble` nos permitirá una [**gestión más ágil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

-   [**Metainformación**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya automáticamente el número de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

---

## Intento final: tibble

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
datos_tb$invent
```

. . .

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de páginas web y documentos sencillos
:::

---

## Recapitulando

-   Cada [**celda puede ser de un tipo diverso**]{.hl-yellow}: números, texto, fechas, valores lógicos, etc

. . .

-   Un [**vector es una concatenación de celdas**]{.hl-yellow} (las futuras columnas de nuestras tablas) --\> En `R` por defecto las operaciones se hacen [**elemento a elemento**]{.hl-yellow}

. . .

-   Una [**matriz**]{.hl-yellow} nos permite concatenar [**variables del MISMO tipo y MISMA longitud**]{.hl-yellow} --\> datos tabulados

. . .

-   Un [**data.frame**]{.hl-yellow} nos permite concatenar [**variables de DISTINTO tipo y MISMA longitud**]{.hl-yellow} --\> usaremos [**tibble**]{.hl-yellow} como una opción mejorada de base de datos

---

## 💻 Tu turno (tb/df) {#tu-turno-2-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Carga del paquete `{datasets}` el conjunto de datos `airquality` (variables de la calidad del aire de Nueva York desde mayo hasta septiembre de 1973). ¿Es el conjunto de datos airquality de tipo tibble? En caso negativo, conviértelo a tibble (busca en la documentación del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Una vez convertido a `tibble` obtén el nombre de las variables y las dimensiones del conjunto de datos. ¿Cuántas variables hay? ¿Cuántos días se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Filtra solo los datos de la quinta observación

```{r}
#| code-fold: true
#| eval: false
airquality_tb[5, ]
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Modifica el código inferior para filtrar solo los datos del mes de agosto. ¿Cómo indicarle que queremos solo las filas que cumplan una condición concreta? (pista: en realidad todo son vectores "formateados")

```{r}
#| eval: false
airquality_tb[Month == 8, ]
```

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, ]
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Selecciona aquellos datos que no sean ni de julio ni de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month != 7 & airquality_tb$Month != 8, ]

# otra forma
airquality_tb[!(airquality_tb$Month %in% c(7, 8)), ]
```

### [**Ejercicio 6**]{.hl-yellow}

📝 Modifica el siguiente código para quedarte solo con las variable de ozono y temperatura (sin importar qué posición ocupen)

```{r}
#| eval: false
airquality_tb[, 3]
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Selecciona los datos de temperatura y viento de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, c("Temp", "Wind")]
```

### [**Ejercicio 8**]{.hl-yellow}

📝 Traduce a castellano el nombre de las variables.

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```
:::

---

## 🐣 Caso práctico I: tibble {#caso-practico-2-1}

Del paquete `{Biostatistics}` usaremos el conjunto de datos `pinniped`, que guarda los **datos de peso de cuerpo y cerebro** (desagregado por sexo y mono/poligamia) de 33 especies de mamíferos marinos.

```{r}
#| eval: false
Biostatistics::pinniped
```

```{r}
#| echo: false
#| warning: false
#| message: false
library(dplyr)
Biostatistics::pinniped |> slice(1:5)
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/matrices-tibble-isciii)

---

## 🐣 Caso práctico II: Taylor Swift {#caso-practico-2-2}

Del paquete `{taylor}` vamos a usar el conjunto de datos `taylor_album_songs` para poner en práctico lo aprendido sobre bases de datos y manejo de variables. Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/matrices-tibble-isciii)

```{r}
library(taylor)
taylor_album_songs
```

# Clase 3: [if-elses, bucles y Quarto]{.flow} {#clase-3}

[**Estructuras condicionales, bucles y Quarto**]{style="color:#444442;"}

-   [💻 Ejercicios resueltos: estructuras condicionales](#tu-turno-3-1)
-   [💻 Ejercicios resueltos: bucles](#tu-turno-3-2)
-   [🐣 Workbook/caso práctico: bucles y condicionales](#caso-practico-3-1)
-   [👾 Materiales extras R base](#extra-Rbase)
-   [📆 Planificación](#planificacion)

---

## Estructuras de control

Una [**estructura de control**]{.hl-yellow} se compone de una serie de comandos orientados a [**decidir el camino**]{.hl-yellow} que tu código debe recorrer

-   Si se cumple la condición A, ¿qué sucede?

-   ¿Y si sucede B?

-   ¿Cómo puedo repetir una misma expresión (dependiendo de una variable)?

. . .

Si has programado antes, quizás te sea familiar las conocidas como [**estructuras condicionales**]{.hl-yellow} tales como `if (blabla) {...} else {...}` o [**bucles**]{.hl-yellow} `for/while` (a evitar siempre que podamos).

---

## Estructura If

Una de las estructuras de control más famosas son las conocidas como [**estructuras condicionales**]{.hl-yellow} `if`.

> SI (IF) un conjunto de condiciones se cumple (TRUE), entonces ejecuta lo que haya dentro de las llaves

Por ejemplo, la estructura `if (x == 1) { código A }` lo que hará será [**ejecutar el código A entre llaves**]{.hl-yellow} pero [**SOLO SI**]{.hl-purple} la [**condición entre paréntesis es cierta**]{.hl-purple} (solo si `x` es 1). En cualquier otro caso, no hará nada.

. . .

Por ejemplo, definamos un vector de edades de 8 personas

```{r}
edad <- c(14, 17, 24, 56, 31, 20, 87, 73)
edad < 18
```

---

## Estructura If

Nuestra estructura condicional hará lo siguiente: [**si existe algún menor de edad, imprimirá**]{.hl-yellow} por pantalla un mensaje.

```{r}
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```

---

## Estructura If

```{r}
#| eval: false
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```

En caso de que las [**condiciones no sean ciertas**]{.hl-yellow} dentro de `if()` (`FALSE`), no sucede nada

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
}
```

**No obtenemos ningún mensaje** porque la condición `all(edad >= 18)` no es `TRUE`, así que no ejecuta nada.

---

## Estructura If-else

La estructura `if (condicion) { código A }` puede combinarse con un `else { código B }`: cuando la [**condición no está verificada**]{.hl-yellow}, se [**ejecutará el código alternativo B**]{.hl-yellow} dentro de `else { }`, permitiéndonos decidir que sucede cuando se cumple y cuando no.

. . .

Por ejemplo, `if (x == 1) { código A } else { código B }` ejecutará A si `x` es igual a 1 y B en cualquier otro caso.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else {
  
  print("Existe alguna persona menor de edad")
}
```

---

## Estructura If-else

Esta estructura `if - else` puede ser [**anidada**]{.hl-yellow}: imagina que queremos ejecutar un código si todos son menores; si no sucede, pero todos son mayores de 16, hacer otra cosa; en cualquier otra cosa, otra acción.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else if (all(edad >= 16)) {
  
  print("Hay algún menor de edad pero todos con 16 años o más")
  
} else { print("Hay alguna persona con menos de 16 años") }
```

::: callout-note
## Truco

Puedes **colapsar las estructuras** haciendo click en la flecha a la izquierda que aparece en tu script.
:::

---

## If-else vectorizado

Esta estructura condicional se puede [**vectorizar**]{.hl-yellow} (en una sola línea) con `if_else()` (del paquete `{dplyr}`), cuyos argumentos son

-   la condición a evaluar
-   lo que sucede cuando se cumple y cuando no
-   un argumento opcional para cuando la condición a evaluar es `NA`

Vamos a etiquetar sin son mayores/menores y un "desconocido" cuando no conocemos

```{r}
library(dplyr)
edad <- c(NA, edad)
if_else(edad >= 18, "mayor", "menor", missing = "desconocido")
```

En `R` base existe `ifelse()`: no deja especificar que hacer con los ausentes pero permite especificar distintos tipos de datos en `TRUE` y en `FALSE`.

---

## 💻 Tu turno {#tu-turno-3-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 ¿Cuál es la salida del siguiente código?

```{r}
#| eval: false
if_else(sqrt(9) < 2, sqrt(9), 0)
```

```{r}
#| eval: false
#| code-fold: true

La salida es 0 ya que sqrt(9) es igual 3, y dado que no es menor que 2, devuelve el segundo argumento que es 0
```

### [**Ejercicio 2**]{.hl-yellow}

📝 ¿Cuál es la salida del siguiente código?

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true

La salida es el vector c(0, NA, NA, 1) ya que sqrt(1) sí es menor que 2, sqrt(9) no lo es, y tanto en el caso de sqrt(NA) (raíz de ausente) como sqrt(-1) (devuelve NaN, not a number), su raíz cuadrada no puede verificarse si es menor que 2 o no, así que la salida es NA.
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Modifica el código inferior para que, cuando no se pueda verificar si la raíz cuadrada de un número es menor que 2, devuelva -1

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1, missing = -1)
```

### [**Ejercicio 4**]{.hl-yellow}

📝 ¿Cuál es son los valores de `x` e `y` del código inferior para `z <- 1`, `z <- -1` y `z <- -5`?

```{r}
#| eval: false
z <- -1
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
En primero caso x = 1 e y = -1. En el segundo caso x = 1 e y = 1. En el tercer caso -2.5 y 5
```

### [**Ejercicio 5**]{.hl-yellow}

📝 ¿Qué pasaría si ejecutamos el siguiente código? Spoiler: da error. ¿Por qué? ¿Cómo solucionarlo?

```{r}
#| eval: false
z <- c(-1, 1, 5)
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
Da error ya que en los `if (condición) { } else { }` "clásicos" necesitamos que
la condición tenga longitud uno (un solo valor TRU/FALSE)
```

```{r}
#| eval: false
#| code-fold: true
# para arreglarlo podemos hacer un if_else vectorial
z <- c(-1, 1, -5)
library(dplyr)
x <- if_else(z > 0, z^3, if_else(abs(z) < 2, z^4, z/2))
y <- if_else(z > 0, -sqrt(z), if_else(abs(z) < 2, sqrt(-z), abs(z)))
```

### [**Ejercicio 6**]{.hl-yellow}

📝 ¿Qué sucederá si ejecutamos el código inferior?

```{r}
#| eval: false
z <- "a"
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| code-fold: true
#| eval: false

# dará error ya que no es un argumento numérico
Error in z^3 : non-numeric argument to binary operator
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Del paquete `{lubridate}`, la función `hour()` nos devuelve la hora de una fecha dada, y la función `now()` nos devuelve fecha y hora del momento actual. Con ambas funciones haz que se imprima por pantalla (`cat()`) "buenas noches" solo a partir de las 21 horas.

```{r}
#| code-fold: true
#| eval: false

# Cargamos librería
library(lubridate)

# Fecha-hora actual
fecha_actual <- now()

# Estructura if
if (hour(fecha_actual) > 21) {
  
  cat("Buenas noches") # print/cat dos formas de imprimir por pantalla
}
```
:::

---

## Bucles {#bucles}

Aunque en la mayoría de ocasiones se pueden reemplazar por otras estructuras más eficientes y legibles, es importante conocer una de las expresiones de control más famosas: los [**bucles**]{.hl-yellow}.

-   `for { }`: permite [**repetir el mismo código**]{.hl-yellow} en un [**número prefijado y conocido**]{.hl-purple} de veces.

-   `while { }`: permite [**repetir el mismo código**]{.hl-yellow} pero en un [**número indeterminado de veces**]{.hl-purple} (hasta que una **condición** deje de cumplirse).

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de órdenes un número [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de índices.

Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacía `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los paréntesis indicaremos un índice y unos valores a recorrer, dentro de las llaves el código a ejecutar en cada iteración (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()
```

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de órdenes un número [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de índices.

Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacía `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los paréntesis indicaremos un índice y unos valores a recorrer, dentro de las llaves el código a ejecutar en cada iteración (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  
}
```

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de órdenes un número [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de índices.

Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacía `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los paréntesis indicaremos un índice y unos valores a recorrer, dentro de las llaves el código a ejecutar en cada iteración (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
```

---

## Bucles for

Fíjate que debido a que `R` funciona de manera [**vectorial por defecto**]{.hl-yellow}, el bucle es lo mismo que hacer `x + 1` directamente.

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
y

y2 <- x + 1
y2
```

---

## Bucles for

Otra opción habitual es indicar los índices de manera «automática»: desde el primero `1` hasta el último (que corresponde con la longitud de x `length(x)`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:length(x)) {
  y[i] <- x[i] + 1
}
y

```

---

## Bucles for

Así la [**estructura general de un bucle for**]{.hl-yellow} será siempre la siguiente

```{r}
#| eval: false
for (índice in conjunto) { 
  código (dependiente de i)
}
```

[**SIEMPRE**]{.hl-green} sabemos cuántas iteraciones tenemos (tantas como elementos haya en el conjunto a indexar)

---

## Evitando bucles

Como ya hemos aprendido con el paquete`{microbenchmark}` podemos chequear como [**los bucles suelen ser muy ineficientes**]{.hl-yellow} (de ahí que debamos evitarlos en la mayoría de ocasiones

```{r}
library(microbenchmark)
x <- 1:1000
microbenchmark(y <- x^2, 
               for (i in 1:100) { y[i] <- x[i]^2 },
               times = 500)
```

---

## Bucles for

Podemos ver otro ejemplo de bucle [**combinando números y textos**]{.hl-yellow}: definimos un vector de edades y de nombres, e imprimimos el nombre y edad i-ésima.

```{r}
nombres <- c("Javi", "Sandra", "Carlos", "Marcos", "Marta")
edades <- c(33, 27, 18, 43, 29)

for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} años")) 
  
}
```

---

## Bucles for

Aunque normalmente se suelen indexar con vectors numéricos, los bucles pueden ser [**indexados sobre cualquier estructura vectorial**]{.hl-yellow}, da igual de que tipo sea el conjunto

```{r}
library(stringr)
week_days <- c("monday", "tuesday", "wednesday", "thursday",
               "friday", "saturday", "sunday")

for (days in week_days) {
  
  print(str_to_upper(days))
}
```

---

## Bucles y condicionales

Vamos a **combinar las estructuras condicionales y los bucles**: usando el conjunto `swiss` del paquete `{datasets}`, vamos a asignar `NA` si los valores de fertilidad son mayores de 80.

```{r}
for (i in 1:nrow(swiss)) {
  
  if (swiss$Fertility[i] > 80) { 
    
    swiss$Fertility[i] <- NA
    
  }
}
```

. . .

Esto es exactamente igual a un `if_else()` vectorizado

```{r}
data("swiss")
swiss$Fertility <- if_else(swiss$Fertility > 80, NA, swiss$Fertility)
```

---

## Bucles while

Otra forma de crear un bucle es con la estructura `while { }`, que nos ejecutará un bucle [**un número desconocido de veces**]{.hl-yellow}, hasta que una condición [**deje de cumplirse**]{.hl-yellow} (de hecho puede que nunca termine). Por ejemplo, vamos a inializar una variable `ciclos <- 1`, que incrementaremos en cada paso, y no saldremos del bucle hasta que `ciclos > 4`.

```{r}
ciclos <- 1
while(ciclos <= 4) {
  
  print(glue("No todavía, vamos por el ciclo {ciclos}")) 
  ciclos <- ciclos + 1
  
}
```

---

## Bucles while

Un bucle `while` será siempre como sigue

```{r}
#| eval: false
while(condición) {
  
  código a hacer mientras la condición sea TRUE
  # normalmente aquí se actualiza alguna variable
  
}
```

---

## Bucles while

¿Qué sucede cuando la [**condición nunca es FALSE**]{.hl-yellow}? Pruébalo tu mismo

```{r}
#| eval: false
while (1 > 0) {
  
  print("Presiona ESC para salir del bucle")
  
}
```

 

::: callout-warning
## Cuidado

Un bucle `while { }` puede ser bastante «peligroso» sino controlamos bien cómo pararlo.
:::

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

-   `break`: permite [**abortar un bucle**]{.hl-yellow} incluso si no se ha llegado a su final

```{r}
for(i in 1:10) {
  if (i == 3) {
    
    break # si i = 3, abortamos bucle
    
  }
  print(i)
}
```

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

-   `next`: [**fuerza un bucle a avanzar a la siguiente iteración**]{.hl-yellow}

```{r}
for(i in 1:5) {
  if (i == 3) {
    
    next # si i = 3, la obvia y continua al siguiente
    
  }
  print(i)
}
```

---

## Bucles repeat

Aunque no es tan usado como las opciones anteriores, también contamos con `repeat { }` que ejecuta un [**bucle de manera infinita hasta que se indique abortar**]{.hl-yellow} con un break

```{r}
count <- 0
repeat { 
  
  count <- count + 1
  if (count >= 100) { break }
  
}
count
```

---

## Replicate

Aunque no es formalmente un bucle, otra forma de [**repetir código un número de veces**]{.hl-yellow} es hacer uso de `replicate()`: simplemente permite repetir lo mismo [**n veces**]{.hl-yellow}

```{r}
x <- 1:3
replicate(n = 3, x^2)
```

---

## Replicate

La función `replicate()` se suele usar para [**generar distintas repeticiones de elementos aleatorios**]{.hl-yellow}. Por ejemplo, imaginemos que queremos generar 3 muestras de distribuciones normales, en la que cada muestra tendrá 7 elementos. Para generar una se usa `rnorm(n = 7)` (r de resample, norm de normal, y si no se dice nada es media 0 y desv 1).

```{r}
replicate(n = 3, rnorm(n = 7))
```

---

## 💻 Tu turno {#tu-turno-3-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Modifica el código inferior para que se imprima un mensaje por pantalla si y solo si todos los datos de `airquality` son con mes distinto a enero

```{r}
#| eval: false
library(datasets)
months <- airquality$Month

if (months == 2) {
  print("No hay datos de enero")
}
```

```{r}
#| code-fold: true
#| eval: false
library(datasets)
months <- airquality$Month

if (all(months != 1)) {
  print("No hay datos de enero")
}
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Modifica el código inferior para guardar en una variable llamada `temp_alta` un `TRUE` si alguno de los registros tiene una temperatura superior a 90 grados Farenheit y `FALSE` en cualquier otro caso

```{r}
#| eval: false
temp <- airquality$Temp

if (temp == 100) {
  print("Algunos de los registros tienen temperaturas superiores a 90 grados Farenheit")
}
```

```{r}
#| eval: false
#| code-fold: true
# Option 1
temp <- airquality$Temp
temp_alta <- FALSE
if (any(temp > 90)) {
   temp_alta <- TRUE
}

# Option 2
temp_alta <- any(airquality$Temp > 90)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Modifica el código inferior para diseñar un bucle `for` de 5 iteraciones que solo recorra los primeros 5 impares (y en cada paso del bucle los imprima)

```{r}
#| eval: false
for (i in 1:5) {
  
  print(i)
}
```

```{r}
#| eval: false
#| code-fold: true
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i)
}
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Modifica el código inferior para diseñar un bucle `while` que empiece con un contador `count <- 1` y pare cuando llegue a 6

```{r}
#| eval: false
count <- 1
while (count == 2) {
  
  print(count)
}
```

```{r}
#| eval: false
#| code-fold: true
count <- 1
while (count < 6) {
  
  print(count)
  count <- count + 1
  
}
```
:::

---

## 🐣 Caso práctico I {#caso-practico-3-1}

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/if-else-bucles-funciones-isciii/) donde tendrás que diseñar algunos estudios de simulación haciendo uso de **bucles y estructuras condicionales**

---

## Comunicar: rmd y Quarto

Una de las [**principales fortalezas**]{.hl-yellow} de `R` es la [**facilidad para generar informes, libros, webs, apuntes y hasta diapositivas**]{.hl-yellow} (este mismo material por ejemplo). Para ello [**instalaremos**]{.hl-purple} antes

::: columns
::: {.column width="40%"}
-   el paquete `{rmarkdown}` (para generar archivos `.rmd`)

```{r}
#| eval: false
install.packages("rmarkdown")
```

-   instalar [**Quarto**](https://quarto.org/docs/get-started/) (si ya conocías `R`, el «nuevo» `.rmd` ahora como `.qmd`)
:::

::: {.column width="60%"}
![](img/quarto.png)
:::
:::

---

## Comunicar: rmd y Quarto

Hasta ahora solo hemos programado en scripts (archivos `.R`) dentro de proyectos, pero en muchas ocasiones [**no trabajaremos solos**]{.hl-yellow} y necesitaremos [**comunicar los resultados**]{.hl-yellow} en diferentes formatos:

-   apuntes (para nosotros mismos)
-   diapositivas
-   web
-   informes

Para todo ello usaremos [**Quarto**]{.hl-yellow} (ver más en <https://ivelasq.quarto.pub/intro-to-quarto/>)

---

## Comunicar: rmd y Quarto

Los archivos de extensión `.qmd` (o `.rmd` antes) nos permitirán fácilmente combinar:

-   [**Markdown**]{.hl-yellow}: [**lenguaje tipado**]{.hl-purple} que nos permite crear contenido simple (tipo wordpress, con texto, **negritas**, *cursivas*, etc) con un diseño legible.

. . .

-   [**Matemáticas (latex)**]{.hl-yellow}: lenguaje para escribir notación matemática como $x^2$ o $\sqrt{y}$ o $\int_{a}^{b} f(x) dx$

. . .

-   [**Código y salidas**]{.hl-yellow}: podremos no solo mostrar el paso final sino el código que has ido realizando (en `R`, `Python`, `C++`, `Julia`, ...), con [**cajitas de código llamadas CHUNKS**]{.hl-purple}.

. . .

-   Imágenes, [**gráficas**]{.hl-yellow}, tablas, estilos (css, js), etc.

---

## Comunicar: rmd y Quarto

La principal ventaja de realizar este tipo de material en Quarto/Rmarkdown es que, al hacerlo desde `RStudio`, puedes generar un [**informe o una presentación sin salirte del entorno de programación**]{.hl-yellow} en el que estás trabajando

De esta forma podrás analizar los datos, resumirlos y a la vez comunicarlos con la misma herramienta.

. . .

Recientemente el equipo de `RStudio` desarrolló [**Quarto**]{.hl-yellow}, una versión mejorada de Rmarkdown (archivos `.qmd`), con un formato un poco más estético y simple. Tienes toda la documentación y ejemplos en [**https://quarto.org/**](https://quarto.org/)

---

## Usos de Quarto

::: panel-tabset
### Webs

![](./img/website.png){height="350"}

### Libros

![](./img/book.png){height="350"}

### Blogs

![](./img/blog.png){height="350"}

### Presentaciones

![](./img/presentation.png){height="350"}

### Revistas

![](https://user-images.githubusercontent.com/163582/42351114-e5deaa1c-8078-11e8-90de-2aff57bba255.png){height="350"}
:::

Imágenes obtenidas de <https://ivelasq.quarto.pub/intro-to-quarto/#/working-with-the-rstudio-visual-editor>

---

## Nuestro primer informe

::: columns
::: {.column width="55%"}
![](img/quarto-create.png)
:::

::: {.column width="45%"}
Vamos a crear el [**primer fichero rmarkdown con Quarto**]{.hl-yellow} con extensión `.qmd`. Para ello solo necesitaremos hacer click en

`File << New File << Quarto Document`
:::
:::

---

## Nuestro primer informe

::: columns
::: {.column width="45%"}
![](img/quarto-format.png)
:::

::: {.column width="55%"}
Tras hacerlo nos aparecerán varias [**opciones de formatos de salida**]{.hl-yellow}:

-   archivo `.pdf`
-   archivo `.html` ([**recomendable**]{.hl-yellow}): documento dinámico, permite la interacción con el usuario, como una «página web».
-   archivo `.doc` (nada recomendable)
:::
:::

. . .

De momento dejaremos marcado el [**formato HTML que viene por defecto**]{.hl-yellow}, y escribiremos el [**título**]{.hl-yellow} de nuestro documento. Tras ello tendremos nuestro [**archivo .qmd**]{.hl-yellow} (ya no es un script .R como los que hemos abierto hasta ahora).

---

## Nuestro primer informe

::: columns
::: {.column width="60%"}
![](img/quarto-example.png)
:::

::: {.column width="40%"}
Deberías tener algo similar a la captura de la imagen con [**dos modos de edición**]{.hl-yellow}: `Source` (con código, la opción recomendada hasta que lo domines) y `Visual` (más parecido a un blog)
:::
:::

Para [**ejecutar TODO el documento**]{.hl-yellow} debes clickar `Render on Save` y darle a guardar.

---

## Salida de Quarto

![](img/quarto-prueba-html.png)

Deberías haber obtenido una [**salida en html similar a esta**]{.hl-yellow} (y se te ha generado en tu ordenador un [**archivo html**]{.hl-yellow})

---

## Editor: source vs visual

Como se indicaba, tienes dos formas de trabajar: con código puro y algo parecido a un Notion (blog)

![](./img/rstudio-source-visual.png)

Imagen obtenida de <https://ivelasq.quarto.pub/intro-to-quarto/#/working-with-the-rstudio-visual-editor>

---

## Nuestro primer informe

::: columns
::: {.column width="50%"}
![](img/quarto-example.png)
:::

::: {.column width="50%"}
Un fichero `.qmd` se [**divide básicamente en tres partes**]{.hl-yellow}:

-   [**Cabecera**]{.hl-yellow}: la parte que tienes al inicio entre `---`.

-   [**Texto**]{.hl-yellow}: que podremos formatear y mejorar con negritas (escrito como **negritas**, con doble astérisco al inicio y final), cursivas (*cursivas*, con barra baja al inicio y final) o destacar nombres de funciones o variables de R. Puedes añadir ecuaciones como $x^2$ (he escrito `$x^2$`, entre dólares).

-   [**Código R**]{.hl-yellow}
:::
:::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera están en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

::: columns
::: {.column width="60%"}
-   `title` y `subtitle`: el título/subtítulo del documento
-   `author`: autor del mismo
-   `format`: formato de salida (podremos personalizar)
    -   `theme`: si tienes algún archivo de estilos
    -   `toc`: si quieres índice o no
    -   `toc-location`: posición del índice
    -   `toc-title`: título del índice
-   `editor`: si estás en modo visual o source.
:::

::: {.column width="40%"}
``` yaml
---
title: "prueba"
format:
  html:
editor: visual
---
```
:::
:::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera están en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

::: columns
::: {.column width="60%"}
-   `title` y `subtitle`: el título/subtítulo del documento
-   `author`: autor del mismo
-   `format`: formato de salida (podremos personalizar)
    -   `theme`: si tienes algún archivo de estilos
    -   `toc`: si quieres índice o no
    -   `toc-location`: posición del índice
    -   `toc-title`: título del índice
-   `editor`: si estás en modo visual o source.
:::

::: {.column width="40%"}
``` yaml
---
title: "prueba"
author: "javier álvarez liébana"
format:
  html:
editor: visual
---
```
:::
:::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera están en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

::: columns
::: {.column width="60%"}
-   `title` y `subtitle`: el título/subtítulo del documento
-   `author`: autor del mismo
-   `format`: formato de salida (podremos personalizar)
    -   `theme`: si tienes algún archivo de estilos
    -   `toc`: si quieres índice o no
    -   `toc-location`: posición del índice
    -   `toc-title`: título del índice
-   `editor`: si estás en modo visual o source.
:::

::: {.column width="40%"}
``` yaml
---
title: "prueba"
author: "javier álvarez liébana"
format:
  html:
    style: style.css
    toc: true
editor: visual
---
```
:::
:::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera están en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

::: columns
::: {.column width="60%"}
-   `title` y `subtitle`: el título/subtítulo del documento
-   `author`: autor del mismo
-   `format`: formato de salida (podremos personalizar)
    -   `theme`: si tienes algún archivo de estilos
    -   `toc`: si quieres índice o no
    -   `toc-location`: posición del índice
    -   `toc-title`: título del índice
-   `editor`: si estás en modo visual o source.
:::

::: {.column width="40%"}
``` yaml
---
title: "prueba"
author: "javier álvarez liébana"
format:
  html:
    style: style.css
    toc: true
    toc-location: left
editor: visual
---
```
:::
:::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera están en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

::: columns
::: {.column width="60%"}
-   `title` y `subtitle`: el título/subtítulo del documento
-   `author`: autor del mismo
-   `format`: formato de salida (podremos personalizar)
    -   `theme`: si tienes algún archivo de estilos
    -   `toc`: si quieres índice o no
    -   `toc-location`: posición del índice
    -   `toc-title`: título del índice
-   `editor`: si estás en modo visual o source.
:::

::: {.column width="40%"}
``` yaml
---
title: "prueba"
author: "javier álvarez liébana"
format:
  html:
    style: style.css
    toc: true
    toc-location: left
    toc-title: Índice
editor: visual
---
```
:::
:::

---

## Texto de un qmd

Respecto a la escritura solo hay una [**cosa importante**]{.hl-yellow}: salvo que indiquemos lo contrario, [**TODO lo que vamos a escribir es texto (normal)**]{.hl-yellow}. No código R.

::: columns
::: {.column width="35%"}
![](img/quarto-prueba-qmd2.png){width="350"} ![](img/quarto-prueba-html2.png){width="320"}
:::

::: {.column width="65%"}
Vamos a empezar escribiendo una sección al inicio (`# Intro` y detrás por ej. la frase

> Este material ha sido diseñado por el profesor Javier Álvarez Liébana, docente en la Universidad Complutense de Madrid

Además al `Running Code` le añadiremos una almohadilla `#`: las [**almohadillas FUERA DE CHUNKS**]{.hl-yellow} nos servirán para crear [**epígrafes (secciones)**]{.hl-yellow} en el documento
:::
:::

---

## Índice de un qmd

::: columns
::: {.column width="40%"}
![](img/quarto-indice-qmd-2.png){width="370"} ![](img/quarto-indice-html2.png){width="370"}
:::

::: {.column width="60%"}
Para que el [**índice capture dichas secciones**]{.hl-yellow} modificaremos la cabecera del archivo como se observa en la imagen (puedes cambiar la localización del índice y el título si quieres para probar).
:::
:::

---

## Texto en un qmd

Vamos a [**personalizar un poco el texto**]{.hl-yellow} haciendo lo siguiente:

::: columns
::: {.column width="50%"}
![](img/quarto-texto-mejorado-qmd.png){width="370"} ![](img/quarto-texto-mejorado-html.png){width="370"}
:::

::: {.column width="50%"}
-   Vamos a añadir [**negrita al nombre**]{.hl-yellow} (poniendo \*\* al inicio y al final).

-   Vamos añadir [**cursiva**]{.hl-yellow} a la palabra material (poniendo \_ al inicio y al final).

-   Vamos añadir un [**enlace**]{.hl-yellow} <https://www.ucm.es>, asociándolo al nombre de la Universidad. Para ello el título lo ponemos entre corchetes y justo detrás el enlace entre paréntesis `[«Universidad Complutense de Madrid»](https://www.ucm.es)`
:::
:::

---

## Código en un qmd

Para [**añadir código R**]{.hl-yellow} debemos crear nuestras [**cajas de código llamadas chunks**]{.hl-yellow}: altos en el camino en nuestro texto markdown donde podremos incluir código de casi cualquier lenguaje (y sus salidas).

 

::: columns
::: {.column width="50%"}
![](img/quarto-chunk-qmd.png){width="470"}
:::

::: {.column width="50%"}
Para incluir uno deberá de ir [**encabezado**]{.hl-yellow} de la siguiente forma tienes un atajo `Command + Option + I` (Mac) o `Ctrl + Shift + I` (Windows)
:::
:::

---

## Código en un qmd

Dentro de dicha cajita (que tiene ahora otro color en el documento) [**escribiremos código R**]{.hl-yellow} como lo veníamos haciendo hasta ahora en los scripts.

::: columns
::: {.column width="50%"}
![](img/quarto-chunk-1-qmd.png){width="410"} ![](img/quarto-chunk-1-html.png){width="410"}
:::

::: {.column width="50%"}
Vamos por ejemplo a definir dos variables y su suma de la siguiente manera, escribiendo dicho código en nuestro `.qmd` (dentro de ese chunk)

```{r}
# Código R
x <- 1
y <- 2
x + y
```
:::
:::

---

## Etiquetando chunks

::: columns
::: {.column width="50%"}
![](img/quarto-tag-chunks-qmd.png){width="400"} ![](img/quarto-tag-chunks-html.png){width="400"}
:::

::: {.column width="50%"}
Los chunks pueden tener un [**nombre o etiqueta**]{.hl-yellow}, de forma que podamos referenciarlos de nuevo para no repetir código.
:::
:::

---

## Ejecutando chunks

::: columns
::: {.column width="40%"}
![](img/quarto-inline-qmd.png){width="400"} ![](img/quarto-inline-html.png){width="380"}
:::

::: {.column width="60%"}
En cada chunk aparecen [**dos botones**]{.hl-yellow}:

-   botón de [**play**]{.hl-yellow}: activa la [**ejecución y salida de ese chunk particular**]{.hl-yellow} (lo puedes visualizar dentro de tu propio `RStudio`)

-   botón de [**rebobinar**]{.hl-yellow}: activa la [**ejecución y salida de todos los chunk hasta ese**]{.hl-yellow} (sin llegar a él)

 

Además podemos [**incluir código R dentro de la línea de texto**]{.hl-yellow} (en lugar de mostrar el texto x ejecuta el código R mostrando la variable).
:::
:::

---

## Personalización de chunks

Los [**chunks podemos personalizarlos**]{.hl-yellow} con opciones al inicio del chunk precedido de `#|`:

-   `#| echo: false`: [**ejecuta código**]{.hl-green} y se [**muestra resultado**]{.hl-green} pero [**no visualiza código**]{.hl-red} en la salida.

-   `#| include: false`: [**ejecuta código**]{.hl-green} pero [**no muestra resultado**]{.hl-red} y [**no visualiza código**]{.hl-red} en la salida.

-   `#| eval: false`: [**no ejecuta código**]{.hl-red}, [**no muestra resultado**]{.hl-red} pero [**sí visualiza código**]{.hl-green} en la salida.

-   `#| message: false`: [**ejecuta código**]{.hl-green} pero [**no muestra mensajes de salida**]{.hl-red}.

-   `#| warning: false`: [**ejecuta código**]{.hl-green} pero [**no muestra mensajes de warning**]{.hl-red}.

-   `#| error: true`: [**ejecuta código**]{.hl-green} y [**permite que haya errores**]{.hl-green} mostrando el mensaje de error en la salida.

![](img/quarto-options-chunk.png){width="380"}

Estas opciones podemos aplicarlas chunk a chunk o fijar los parámetros de forma global con `knitr::opts_chunk$set()` al inicio del documento (dentro de un chunk).

---

## Personalizando chunks

Si queremos que aplique la **opción a todos los chunks por defecto** debemos incluirlo al final de la cabecera, como [**opciones de ejecución**]{.hl-yellow}

``` yaml
---
title: "¡Hola!"
format: html
editor: visual
execute:
  echo: false
---
```

---

## Organizando qmd

Además de texto y código podemos introducir lo siguiente:

-   [**Ecuaciones**]{.hl-yellow}: puedes añadir además ecuaciones como $x^2$ (he escrito `$x^2$`, la ecuación entre dólares).

-   [**Listas**]{.hl-yellow}: puedes itemizar elementos poniendo `*`

`* Paso 1: ...`

`* Paso 2: ...`

-   [**Cross-references**]{.hl-yellow}: puedes etiquetar partes del documento (la etiqueta se construye con `{#nombre-seccion}`) y llamarlas luego con `[Sección](@nombre-seccion)`

---

## Gráficas/imágenes en qmd

::: columns
::: {.column width="50%"}
![](img/quarto-fig-qmd.png){width="340"} ![](img/quarto-fig-html.png){width="390"}
:::

::: {.column width="50%"}
Por último, también podemos [**añadir pies de gráficas o imágenes**]{.hl-yellow} añadiendo `#| fig-cap: "..."`
:::
:::

. . .

::: columns
::: {.column width="65%"}
Fíjate que el [**caption está en el margen**]{.hl-yellow} (por ejemplo). Puedes cambiarlo introduciendo [**ajustes en la cabecera**]{.hl-yellow} (todo lo relativo a figuras empieza por `fig-`, y puedes ver las opciones tabulando). Tienes más información en [**https://quarto.org/**](https://quarto.org/){.uri}
:::

::: {.column width="35%"}
![](img/quarto-cabecera-desplegable.png){width="400"}
:::
:::

---

## Añadir estilos

::: columns
::: {.column width="50%"}
![](img/quarto-estilos-qmd.png){width="400"} ![](img/quarto-estilos-html.png){width="400"}
:::

::: {.column width="50%"}
Por último puedes añadir un [**tema personalizado**]{.hl-yellow} incluyendo un [**archivo de estilos**]{.hl-yellow} (archivo en formato `.scss` o `.css`). Te he dejado uno en <https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material>.

::: callout-important
## Importante

El archivo de estilos debe estar en la misma carpeta que el archivo `.qmd`
:::
:::
:::

---

## Añadir estilos

También puedes hacerlo de manera sencilla [**añadiendo a los textos un poco de HTML**]{.hl-yellow}. Por ejemplo, para personalizar el color de un texto va entre corchetes y justo tras el texto, entre llaves, las opciones de estilo

``` html
Esta palabra es [roja]{style="color:red;"} ...
```

``` html
... y esta [verde y en negrita]{style="color:green; font-weight: bold;"}
```

. . .

Esta palabra es [roja]{style="color:red;"} ...

... y esta [verde y en negrita]{style="color:green; font-weight: bold;"}

---

## Revealjs

Puedes añadir algunas «animaciones» usando lo que se conoce como Revealjs (javascript), especifcándolo en la cabecera y usando [**bloques**]{.hl-yellow} de dicho lenguaje delimitados por `:::` al inicio y final, y la palabra de la «herramienta» a usar. Por ejemplo `{.incremental}` hace una transición de los elementos.

``` yaml
format:
  revealjs
```

 

``` revealjs
::: {.incremental}
- Me
- llamo
- Javi
:::
```

::: incremental
-   Me
-   llamo
-   Javi
:::

---

## Bloques de llamada

También puedes usar los [**bloques de llamada**]{.hl-yellow} que por defecto son `note`, `tip`, `warning`, `caution` e `important` (aunque los puedes crear y personalizar). Para ello basta con usar `:::{.callout-tipo}` y el tipo que quieras

``` html
:::{.callout-tip}

Note that there are five types of callouts, including: 
`note`, `tip`, `warning`, `caution`, and `important`.

:::
```

. . .

::: callout-tip
Recuerda que los 5 tipos son `note`, `tip`, `warning`, `caution` e `important`.
:::

. . .

::: callout-caution
Úsalos con cabeza, a veces mucho recursos estético puede marear.
:::

---

## Múltiples columnas

Con `:::: columns` podemos definir una disposición de [**múltiples columnas**]{.hl-yellow} donde cada una viene definida por `::: {.column width="65%"} cosa :::`, indicando al lado del porcentaje cuanto quieres que ocupe cada columna (¡cuidado, no dejar espacios!)

``` html
:::: columns
::: {.column width="65%"}
Así se define un vector
:::
::: {.column width="35%"}
x <- c(1, 2, 3)
x
:::
::::
```

 

. . .

::: columns
::: {.column width="65%"}
Así se define un vector
:::

::: {.column width="35%"}
```{r}
x <- c(1, 2, 3)
x
```
:::
:::

# Clase 4: [intro a tidyverse]{.flow} {#clase-4}

[**Dataviz, importar/exportar e intro a tidyverse**]{style="color:#444442;"}

-   [Intro a tidydata](#tidydata)
-   [Intro a preprocesamiento con dplyr](#dplyr)
-   [Intro a resúmenes](#summarise)
-   [Intro a dataviz en R](#ggplot)

---

## Clase 4: [tidydata]{.flow} {#tidydata}

[**Dataviz, importar/exportar ggplot e intro a tidyverse**]{style="color:#444442;"}

-   [💻 Ejercicios resueltos: tidydata](#tu-turno-4-1)
-   [🐣 Workbook/caso práctico: tidy data](#caso-practico-4-1)
-   [📆 Planificación](#planificacion)

---

## R base vs Tidyverse 

Hasta ahora todo lo que hemos hecho en `R` lo hemos realizado en el paradigma de programación conocido como [**R base**]{.hl-yellow}. Y es que cuando `R` nació como lenguaje, muchos de los que programaban en él imitaron formas y metodologías heredadas de otros lenguajes, basado en el uso de

-   Bucles [**for**]{.hl-yellow} y [**while**]{.hl-yellow}

-   Estructuras [**if-else**]{.hl-yellow}

-   Estructuras [**\$ y \[\]**]{.hl-yellow}

Y aunque es necesario conocer dichas estructuras, en la [**mayoría de ocasiones hay opciones más modernas y vamos a poder evitarlas**]{.hl-red} en especial los bucles: es necesario conocer la gramática de un idioma para habler uno de sus dialectos.

---

## ¿Qué es tidyverse?

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

En ese contexto de programación funcional, hace una década nacía `{tidyverse}`, un [**«universo» de paquetes**]{.hl-yellow} para garantizar un flujo de trabajo eficiente, coherente y lexicográficamente sencillo de entender, basado en la idea de que [**nuestros datos están limpios y ordenados (tidy)**]{.hl-purple}

---

## ¿Qué es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)

-   `{lubridate}` manejo de fechas
-   `{rvest}`: web scraping
-   `{tidymodels}`: modelización/predicción
:::

::: {.column width="55%"}
-   `{tibble}`: optimizando data.frame
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv), `{readxl}` para importar archivos .xls y .xlsx
-   `{dplyr}`: gramática para depurar
-   `{stringr}`: manejo de textos
-   `{purrr}`: manejo de listas
-   `{forcats}`: manejo de cualitativas
-   `{ggplot2}`: visualización de datos
:::
:::

---

## Filosofía base: tidy data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

El [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducida por **Hadley Wickham** (el Dios al que rezamos) de [**estandarizar**]{.hl-yellow} el formato de los datos para

::: incremental
-   [**sistematizar**]{.hl-green} la depuración
-   hacer más [**sencillo**]{.hl-green} su manipulación.
-   código [**legible**]{.hl-green}
:::

---

## Reglas del tidy data

Lo primero por tanto será entender qué son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos están estandarizados.

::: columns
::: {.column width="50%"}
::: {.fragment .fade-in}
1.  Cada [**variable**]{.hl-yellow} en una [**única columna**]{.hl-purple}
:::

::: {.fragment .fade-in}
2.  Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}
:::

::: {.fragment .fade-in}
3.  Cada [**celda**]{.hl-yellow} con un [**único valor**]{.hl-purple}
:::

::: {.fragment .fade-in}
4.  Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5.  Si queremos cruzar [**múltiples tablas**]{.hl-yellow} debemos tener una [**columna común**]{.hl-purple}
:::
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
:::

---

## Tubería (pipe)

En `{tidyverse}` será clave el [**operador pipe (tubería)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): será una [**tubería que recorre los datos**]{.hl-yellow} y los transforma.

. . .

::: columns
::: {.column width="50%"}
En R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, sería

```{r}
#| eval: false
third(second(first(datos)))
```
:::

::: {.column width="50%"}
En `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones

```{r}
#| eval: false
datos |> first() |> second() |> third()
```
:::
:::

. . .

::: callout-caution
## Apunte importante

Desde la versión 4.1.0 de `R` disponemos de `|>`, un pipe **nativo** disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que dependía del paquete `{magrittr}` (bastante problemático).
:::

---

## Tubería (pipe)

La principal ventaja es que el [**código sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas código.

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::

::: {.column width="50%"}
<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
:::

---

## Datos SUCIOS: messy data

¿Pero qué aspecto tienen los [**datos no tidy**]{.hl-yellow}? Vamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).

```{r}
library(tidyr)
table4a
```

[**¿Qué puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="40%"}
```{r}
table4a
```
:::

::: {.column width="60%"}
❎ Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) → las columnas `1999` y `2000` en realidad deberían ser en sí [**valores de una variable**]{.hl-yellow} y no nombres de columnas.
:::
:::

. . .

Incluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el año y otra que guarde el valor de la variable de interés en cada uno de esos años. Y lo haremos con la función `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="50%"}
```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
               values_to = "cases")
```
:::

::: {.column width="50%"}
![](img/table4a.jpg)
:::
:::

-   `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}
-   `names_to`: nombre de la nueva variable a la quemandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).
-   `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table2`

```{r}
table2
```

[**¿Qué puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_wider()

::: columns
::: {.column width="60%"}
```{r}
#| echo: false
table2
```
:::

::: {.column width="40%"}
❎ Cada [**observación está dividido en dos filas**]{.hl-red} → los [**registros con el mismo año deberían ser el mismo**]{.hl-yellow}
:::
:::

. . .

Lo que haremos será lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table3`

```{r}
table3
```

[**¿Qué puede estar fallando?**]{.hl-red}

---

## Separar: separate()

::: columns
::: {.column width="60%"}
```{r}
table3
```
:::

::: {.column width="40%"}
❎ Cada [**celda contiene varios valores**]{.hl-red}
:::
:::

. . .

Lo que haremos será hacer uso de la función `separate()` para mandar [**separar cada valor**]{.hl-yellow} a una columna diferente.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

---

## Separar: separate()

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

Fíjate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deberían ser variables numéricas. Para ello podemos añadir el argumento opcional `convert = TRUE`

. . .

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

---

## Datos SUCIOS: messy data

Veamos el último ejemplo con la tabla `table5`

```{r}
table5
```

[**¿Qué puede estar fallando?**]{.hl-red}

---

## Unir unite()

::: columns
::: {.column width="50%"}
```{r}
table5
```
:::

::: {.column width="50%"}
❎ Tenemos [**mismos valores divididos en dos columnas**]{.hl-red}
:::
:::

. . .

Usaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y año en una misma columna

```{r}
table5 |> unite(col = year_completo, century, year, sep = "")
```

---

## 💻 Tu turno {#tu-turno-4-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Usa el dataset original `relig_income` en `{tidyr}` y trata de responder a la última pregunta: ¿cuántas personas agnósticas con ingresos superiores (o iguales) a 30 tenemos?

```{r}
#| code-fold: true
#| eval: false

sum(relig_income[relig_income$religion == "Agnostic",
             c("$30-40k", "$40-50k", "$50-75k", "$75-100k", "$100-150k", ">150k")])
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Convierte a tidy data

```{r}
#| code-fold: true
#| eval: false

relig_tidy <-
  relig_income |> 
  pivot_longer(cols = -religion, names_to = "ingresos", values_to = "personas")
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. ¿Es tidydata? En caso negativo, ¿qué falla? ¿Cómo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```
:::

---

## 🐣 Caso práctico I: tidy data {#caso-practico-4-1}

En el paquete `{tidyr}` contamos con el dataset `who2` (dataset de la Organización Mundial de la Salud). Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/tidydata-isciii/#caso-pr%C3%A1ctico-an%C3%A1lisis-de-datos-de-la-oms).

```{r}
who2
```

---

## Clase 4: [preprocesamiento con dplyr]{.flow} {#dplyr}

[**Intro a tidyverse**]{style="color:#444442;"}

-   [💻 Ejercicios resueltos: operaciones por filas](#tu-turno-4-2)
-   [🐣 Workbook/caso práctico: airquality](#caso-practico-4-2)
-   [💻 Ejercicios resueltos: operaciones por columnas](#tu-turno-4-3)
-   [🐣 Workbook/caso práctico: Taylor Swift](#caso-practico-4-3)
-   [👾 Materiales extras tidyverse](#extra-tidyverse)
-   [📆 Planificación](#planificacion)

---

## Preprocesamiento: dplyr

Dentro de `{tidyverse}` usaremos el paquete `{dplyr}` para el [**preprocesamiento y depuración**]{.hl-yellow} de los datos. La idea es que el [**código sea legible**]{.hl-yellow}, como si fuese una **lista de instrucciones** que al leerla nos diga de manera muy evidente lo que está haciendo.

Vamos a practicar con el dataset `starwars` del paquete cargado `{dplyr}`

```{r}
#| eval: false
library(tidyverse)
starwars
```

---

## Muestreo

::: columns
::: {.column width="60%"}
Una de las operaciones más comunes es lo que se conoce en estadística como [**muestreo**]{.hl-yellow}: una [**selección o filtrado de registros**]{.hl-yellow} (una submuestra)
:::

::: {.column width="40%"}
![](img/muestreo.jpeg){width="500"}
:::
:::

. . .

-   [**No aleatorio (por cuotas)**]{.hl-purple}: en base a condiciones lógicas sobre los registros (`filter()`)

. . .

-   [**No aleatorio (intencional/discreccional)**]{.hl-purple}: en base a posición (`slice()`)

. . .

-   [**Aleatorio simple**]{.hl-purple} (`slice_sample()`)

. . .

-   [**Aleatorio estratificado**]{.hl-purple} (`group_by()` + `slice_sample()`)

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

El más simple es cuando [**filtramos registros**]{.hl-yellow} en base a alguna condición lógica: con `filter()` se seleccionarán solo individuos que cumplan ciertas condiciones (muestreo no aleatorio por condiciones)

::: incremental
-   `==`, `!=`: [**igual**]{.hl-purple} o [**distinto**]{.hl-yellow} que (`|> filter(variable == "a")`)
-   `>`, `<`: [**mayor**]{.hl-purple} o [**menor**]{.hl-yellow} que (`|> filter(variable < 3)`)
-   `>=`, `<=`: [**mayor o igual**]{.hl-yellow} o [**menor o igual**]{.hl-purple} que (`|> filter(variable >= 5)`)
-   `%in%`: valores [**pertenencen**]{.hl-yellow} a un listado de opciones (`|> filter(variable %in% c("azul", "verde"))`)
-   `between(variable, val1, val2)`: si los valores (continuos) [**caen dentro de un rango**]{.hl-yellow} de valores (`|> filter(between(variable, 160, 180))`)
:::

---

## Filtrar filas: filter()

Dichas [**condiciones lógicas**]{.hl-yellow} las podemos [**combinar**]{.hl-yellow} de diferentes maneras (y, o, o excluyente)

![](img/tablas_verdad.png)

. . .

::: callout-tip
## Importante

Recuerda que dentro de `filter()` debe ir siempre algo que devuelva un [**vector de valores lógicos**]{.hl-green}.
:::

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¿Cómo harías para... [**filtrar**]{.hl-yellow} los personajes de [**ojos marrones**]{.hl-purple}?

. . .

[**¿Qué tipo de variable es?**]{.hl-yellow} --\> La variable `eye_color` es cualitativa así que está representada por textos

. . .

```{r}
#| echo: false
#| include: false
library(tidyverse)
```

```{r}
starwars |>
  filter(eye_color == "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¿Cómo harías para... [**filtrar**]{.hl-yellow} los personajes que [**no tienen ojos marrones**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color != "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¿Cómo harías para ... [**filtrar**]{.hl-yellow} los personajes que [**tengan los ojos marrones o azules**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color %in% c("blue", "brown"))
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Fíjate que `%in%` es equivalente a concatenar varios `==` con una conjunción o (`|`)

```{r}
starwars |>
  filter(eye_color == "blue" | eye_color == "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¿Cómo harías para ... [**filtrar**]{.hl-yellow} los personajes que [**midan entre 120 y 160 cm**]{.hl-purple}?

. . .

[**¿Qué tipo de variable es?**]{.hl-yellow} --\> La variable `height` es cuantitativa continua así que deberemos filtrar por rangos de valores (intervalos) --\> usaremos `between()`

. . .

```{r}
starwars |>
  filter(between(height, 120, 160))
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color == "brown" & species != "Human")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

¿Cómo harías... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos, o que tengan más de 60 años**]{.hl-purple}? Piénsalo bien: los [**paréntesis son importantes**]{.hl-yellow}: no es lo mismo $(a+b)*c$ que $a+(b*c)$

. . .

```{r}
starwars |>
  filter((eye_color == "brown" & species != "Human") | birth_year > 60)
```

---

## Eliminar ausentes: drop_na()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  retirar_ausentes(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(var1, var2, ...)
```
:::
:::

Hay un **filtro especial** para una de las operaciones más habituales en depuración: [**retirar los ausentes**]{.hl-yellow}. Para ello podemos usar dentro de un filtro `is.na()`, que nos devuelve `TRUE/FALSE` en función de si es ausente, o bien ...

. . .

Usar `drop_na()`: si no indicamos variable, elimina registros con ausente en cualquier variable. Más adelante veremos como [**imputar esos ausentes**]{.hl-yellow}

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(mass, height)
```

```{r}
#| echo: false
starwars |>
  drop_na(mass, height, sex) |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na()
```

```{r}
#| echo: false
starwars |>
  drop_na() |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::
:::

---

## Reordenar filas: arrange()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> ordenar(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(var1, var2, ...)
```
:::
:::

También podemos [**ordenar filas**]{.hl-yellow} en función de alguna variable con `arrange()`

```{r}
#| eval: false
starwars |> arrange(mass)
```

```{r}
#| echo: false
starwars |> arrange(mass) |> select(name:eye_color) |> slice(1:5) 
```

. . .

Por [**defecto de menor a mayor**]{.hl-yellow} pero podemos [**invertir el orden**]{.hl-purple} con `desc()`

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(desc(height))
```

```{r}
#| echo: false
starwars |> arrange(desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(mass, desc(height))
```

```{r}
#| echo: false
starwars |> arrange(mass, desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::
:::

---

## Eliminar duplicados: distinct()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> sin_duplicados(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> distinct(var1, var2, ...)
```
:::
:::

Muchas veces necesitaremos asegurarnos que no hay duplicados en alguna variable (DNI) y podemos [**eliminar filas duplicadas**]{.hl-yellow} con `distinct()`.

```{r}
starwars |> distinct(sex)
```

. . .

Para mantener todas las columnas de la tabla usaremos `.keep_all = TRUE`.

```{r}
#| eval: false
starwars |> distinct(sex, .keep_all = TRUE)
```

```{r}
#| echo: false
starwars |> distinct(sex, .keep_all = TRUE) |> slice(1:3)
```

---

## Añadir filas: bind_rows()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> encuadernar_filas(tibble2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> bind_rows(tibble2)
```
:::
:::

Por último, podemos [**concatenar nuevas filas**]{.hl-yellow} con `bind_rows()` con [**las nuevas observaciones en tabla**]{.hl-red} (si no cuadran columnas rellena con ausentes)

```{r}
datos <-
  tibble("nombre" = c("javi", "laura"), "edad" = c(33, 50))
datos
```

. . .

```{r}
datos |> bind_rows(tibble("nombre" = c("carlos", NA), "cp" = c(28045, 28019)))
```

---

## 💻 Tu turno {#tu-turno-4-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Selecciona del conjunto de starwars solo los personajes que sean androides o cuyo valor en `species` sea desconocido

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Droid" | is.na(species))
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Selecciona del conjunto de starwars solo los personajes cuyo peso esté entre 65 y 90 kg.

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(between(mass, 65, 90))
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Tras limpiar de ausentes en todas las variables, selecciona del conjunto de starwars solo los personajes que sean humanos y que vengan de Tatooine

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na() |> 
  filter(species == "Human" & homeworld == "Tatooine")
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Selecciona del conjunto original de starwars los personajes no humanos, `male` en el sexo y que midan entre 120 y 170 cm, o los personajes con ojos marrones o rojos.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter((species != "Human" & sex == "male" &
            between(height, 120, 170)) |
           eye_color %in% c("brown", "red"))
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Selecciona solo los personajes que sean humanos y de ojos marrones, para después ordernarlos en altura descendente y peso ascendente.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(eye_color == "brown" & species == "Human") |> 
  arrange(height, desc(mass))
```
:::

---

## Selección columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Hasta ahora todas las operaciones realizadas (aunque usásemos info de columnas) eran por filas. En elc aso de columnas, la acción más sencilla es [**seleccionar variables por nombre**]{.hl-yellow} con `select()`, dando como argumentos los nombres de columnas [**sin comillas**]{.hl-purple}.

```{r}
starwars |> select(name, hair_color)
```

---

## Selección columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

La función `select()` nos permite seleccionar varias variables a la vez, incluso [**concatenando sus nombres como si fuesen índices numéricos**]{.hl-yellow}

```{r}
#| eval: false
starwars |> select(name:eye_color) 
```

```{r}
#| echo: false
starwars |> select(name:eye_color) |> slice(1:4)
```

. . .

Y podemos [**deseleccionar columnas**]{.hl-yellow} con `-` delante

```{r}
#| eval: false
starwars |>  select(-mass, -(eye_color:starships))
```

```{r}
#| echo: false
starwars |> select(-mass, -(eye_color:starships)) |> slice(1:4)
```

---

## Selección columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Tenemos además [**palabras reservadas**]{.hl-yellow}: `everything()` [**todas las variables**]{.hl-purple}...

```{r}
#| eval: false
starwars |> select(mass, homeworld, everything())
```

```{r}
#| echo: false
starwars |> select(mass, homeworld, everything()) |> slice(1:4)
```

---

## Selección columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

También podemos jugar con [**patrones**]{.hl-yellow} en el nombre, aquellas que [**comiencen por un prefijo**]{.hl-purple} (`starts_with()`), [**terminen con un sufijo**]{.hl-purple} (`ends_with()`), [**contengan un texto**]{.hl-purple} (`contains()`) o cumplan una [**expresión regular**]{.hl-purple} (`matches()`).

```{r}
# variables cuyo nombre acaba en "color" y contengan sexo o género
starwars |> select(ends_with("color"), matches("sex|gender"))
```

---

## Selección columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

---

## Selección columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Por último, podemos seleccionar columnas por [**tipo de dato**]{.hl-yellow} haciendo uso de `where()` y dentro una función que devuelva un valor lógico de tipo de dato.

```{r}
# Solo columnas numéricas o de texto
starwars |> select(where(is.numeric) | where(is.character))
```

---

## Renombrar: rename()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> renombrar(nuevo = antiguo)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> rename(nuevo = antiguo)
```
:::
:::

A veces también podemos querer [**modificar la «metainformación»**]{.hl-yellow} de los datos, [**renombrando columnas**]{.hl-yellow}. Para ello usaremos de `rename()` poniendo [**primero el nombre nuevo**]{.hl-purple} y luego el [**antiguo**]{.hl-purple}.

```{r}
starwars |> rename(nombre = name, altura = height, peso = mass)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

En muchas ocasiones querremos [**modificar o crear variables**]{.hl-yellow} con `mutate()`.

. . .

Vamos a crear por ejemplo una nueva variable `height_m` con la altura en metros.

```{r}
starwars |> mutate(height_m = height / 100)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

Además con los argumentos opcionales podemos [**recolocar la columna modificada**]{.hl-yellow}

```{r}
starwars |> 
  mutate(height_m = height / 100,
         IMC = mass / (height_m^2), .before = name)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

::: callout-important
## Importante...

Cuando aplicamos `mutate()`, debemos de acordarnos que las [**operaciones se realizan de manera vectorial**]{.hl-yellow}, elemento a elemento, por lo que la función que usemos dentro debe devolver un vector de igual longitud. En caso contrario, [**devolverá una constante**]{.hl-red}
:::

. . .

```{r}
starwars |> 
  mutate(constante = mean(mass, na.rm = TRUE), .before = name)
```

---

## Recategorizar: if_else()

También podemos combinar `mutate()` con la expresión de control `if_else()` para [**recategorizar la variable**]{.hl-yellow}: si [**se cumple una condición**]{.hl-purple}, hace una cosa, en caso contrario otra.

```{r}
starwars |> 
  mutate(human = if_else(species == "Human", "Human", "Not Human"),
         .after = name) |> 
  select(name:mass)
```

---

## 💻 Tu turno {#tu-turno-4-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Filtra el conjunto de personajes y quédate solo con aquellos que en la variable `height` no tengan un dato ausente. Con los datos obtenidos del filtro anterior, selecciona solo las variables name, height, así como todas aquellas variables que CONTENGAN la palabra color en su nombre.

```{r}
#| code-fold: true
#| eval: false

starwars_2 <-
  starwars |> 
  drop_na(height) |> 
  select(name, height, contains("color"))
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Con los datos originales, comprueba cuántas modalidades únicas hay en la variable de color de pelo.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  distinct(hair_color) |> 
  nrow()
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Del dataset original, selecciona solo las variables numéricas y de tipo texto. Tras ello define una nueva variable llamada `under_18` que nos recategorice la variable de edad: `TRUE` si es menor de edad y `FALSE` en caso contrario

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(where(is.numeric) | where(is.character)) |> 
  mutate(under_18 = birth_year < 18)
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Del dataset original, crea una nueva columna llamada `auburn` (cobrizo/caoba) que nos diga TRUE si el color de pelo contiene dicha palabra y FALSE en caso contrario (reminder `str_detect()`).

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(auburn = str_detect(hair_color, "auburn"))
```
:::

---

## Clase 4: [construyendo resúmenes]{.flow} {#summarise}

[**Intro a tidyverse**]{style="color:#444442;"}

-   [💻 Ejercicios resueltos: resúmenes](#tu-turno-4-4)
-   [🐣 Workbook/caso práctico: billboard](#caso-practico-4-4)
-   [🐣 Workbook/caso práctico: fútbol](#caso-practico-4-5)
-   [👾 Materiales extras tidyverse](#extra-tidyverse)
-   [📆 Planificación](#planificacion)

---

## Contar: count()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
:::

Hasta ahora solo hemos transformado o consultado los datos pero no hemos generado estadísticas. Empecemos por lo sencillo: [**¿cómo contar (frecuencias)?**]{.hl-yellow}

. . .

Cuando lo usamos en solitario `count()` nos devolverá simplemente el número de registros , pero cuando lo usamos con variables `count()` calcula lo que se conoce como [**frecuencias**]{.hl-yellow}: [**número de elementos de cada modalidad**]{.hl-purple}.

```{r}
starwars |> count(sex)
```

---

## Contar: count()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
:::

Además si pasamos varias variables nos calcula lo que se conoce como una [**tabla de contigencia**]{.hl-yellow}. Con `sort = TRUE` nos devolverá el [**conteo ordenado**]{.hl-purple} (más frecuentes primero).

```{r}
starwars |> count(sex, gender, sort = TRUE)
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Una de las [**funciones más potentes**]{.hl-yellow} a combinar con las acciones vistas es `group_by()`, que nos permitirá [**agrupar nuestros registros**]{.hl-yellow} previamente

```{r}
starwars |> 
  group_by(sex) |>
  count() |>
  ungroup()
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Cuando apliquemos `group_by()` es importante entender que [**NO MODIFICA los datos**]{.hl-yellow}, sino que nos crea una [**variable de grupo**]{.hl-yellow} (subtablas por cada grupo) que modificará las acciones futuras: las [**operaciones se aplicarán a cada subtabla por separado**]{.hl-purple}

. . .

Por ejemplo, imaginemos que queremos extraer el personaje más alto con `slice_max()`.

```{r}
starwars |> slice_max(height)
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

¿Y si queremos [**extraer el personaje más alto pero...de cada uno de los sexos**]{.hl-yellow}?

. . .

```{r}
starwars |>
  group_by(sex) |> 
  slice_max(height) |> 
  ungroup()
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

::: columns
::: {.column width="50%"}
![](img/tidydatatutor_1.jpg)
:::

::: {.column width="50%"}
![](img/tidydatatutor_2.jpg)
:::
:::

La web <https://tidydatatutor.com/> permite visualizar las operaciones de `{tidyverse}` (con el pipe antiguo)

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |>
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |>
  ungroup()
```
:::
:::

::: callout-important
## Importante

Recuerda siempre [**hacer ungroup**]{.hl-red} para eliminar la variable de grupo creada
:::

. . .

En la nueva versión de `{dplyr}` ahora se [**permite incluir la variable de grupo**]{.hl-yellow} en la llamada a muchas funciones con el argumento `by = ...` o `.by = ...`

```{r}
#| eval: false
starwars |> slice_max(height, by = sex)
```

```{r}
#| echo: false
starwars |> slice_max(height, by = sex) |> select(name:eye_color)
```

---

## Resumir: summarise()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
:::

Por último tenemos `summarise()`, que nos permitirá sacar resúmenes estadísticos. Por ejemplo, vamos a [**calcular la media de las alturas**]{.hl-yellow}.

```{r}
starwars |> 
  drop_na(height) |> 
  summarise(media_altura = mean(height))
```

. . .

::: callout-warning
## Cuidado

Fíjate que `mutate()` devuelve [**tantas filas como registros originales**]{.hl-yellow}, mientras que con `summarise()` calcula un [**nuevo dataset de resumen**]{.hl-purple}, solo incluyendo aquello que esté indicado.
:::

---

## Resumir: summarise()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
:::

Si además esto lo [**combinamos con la agrupación**]{.hl-yellow} de `group_by()` o `.by = ...`, en pocas líneas de código puedes obtener [**estadísticas desagreagadas**]{.hl-purple}

```{r}
starwars |> 
  drop_na(sex, height, mass) |> 
  summarise(media_altura = mean(height),
            media_peso = mean(mass),
            .by = sex)
```

---

## Resumir: reframe()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> reframe()
```
:::
:::

En el nuevo `{dplyr}` han incluido `reframe()` para evitar problemas de `summarise()` cuando [**devolvemos más de un valor por variable**]{.hl-yellow}.

::: columns
::: {.column width="50%"}
```{r}
#| warning: true
starwars |>
  drop_na(mass) |>
  summarise(quantile(mass))
```
:::

::: {.column width="50%"}
```{r}
starwars |>
  drop_na(mass) |>
  reframe(quantile(mass))
```
:::
:::

---

## 💻 Tu turno {#tu-turno-4-4}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Calcula cuántos personajes hay de cada especie, ordenados de más a menor frecuencia.

```{r}
#| code-fold: true
#| eval: false
starwars |> count(species, sort = TRUE)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Tras eliminar ausentes en las variables de peso y estatura, añade una nueva variable que nos calcule el IMC de cada personaje, y determina el IMC medio de nuestros personajes desagregada por sexo

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass, height) |> 
  mutate(IMC = mass / ((height/100)^2)) |> 
  summarise(IMC_medio = mean(IMC), .by = sex)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Obtén el personaje más joven por cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  slice_min(birth_year, by = sex)
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Obtén la edad del personaje más joven y más viejo de cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(birth_year) |>
  summarise(min(birth_year), max(birth_year), .by = sex)
```
:::

---

## Clase 4: [dataviz en R]{.flow} {#ggplot}

[**Intro a ggplot. Exportar/importar**]{style="color:#444442;"}

-   [💻 Ejercicios resueltos: importar/exportar](#tu-turno-4-5)
-   [🐣 Workbook/caso práctico: encuesta CIS](#caso-practico-4-6)
-   [💻 Ejercicios resueltos: ggplot](#tu-turno-4-6)
-   [👾 Materiales extras visualización](#extra-dataviz)
-   [📆 Planificación](#planificacion)

---

## Dataviz en R: ggplot2

::: columns
::: {.column width="50%"}
El paquete `{ggplot2}` se basa en la idea de Wilkinson en [**«Grammar of graphics»**]{.hl-yellow}: dotar a los gráficos de una gramática propia. Una de las principales fortalezas de `R` es la [**visualización**]{.hl-yellow} con `{ggplot2}`.

```{r}
library(ggplot2)
```

La [**visualización de datos**]{.hl-yellow} debería ser una parte fundamental de todo análisis de datos. No es solo una cuestión estética.
:::

::: {.column width="50%"}
![](img/telling_dataviz.jpg){width="400"}
:::
:::

---

## Dataviz en R: ggplot2

La filosofía detrás de `{ggplot2}` es entender los [**gráficos como parte del flujo**]{.hl-yellow} de trabajo, dotándoles de una [**gramática**]{.hl-yellow}. El objetivo es empezar con un lienzo en blanco e ir [**añadiendo capas a tu gráfico**]{.hl-yellow}. La ventaja de `{ggplot2}` es poder [**mapear atributos estéticos**]{.hl-purple} (color, forma, tamaño) de objetos geométricos (puntos, barras, líneas) en función de los datos.

 

La **documentación** del paquete puedes consultarla en <https://ggplot2-book.org/introduction.html>

![](img/grammar_ggplot2.jpg)

---

## Dataviz en R: ggplot2

![](img/tarta_ggplot2.png)

---

## Dataviz en R: ggplot2

::: columns
::: {.column width="40%"}
![](img/tarta_recortada_ggplot2.jpg)
:::

::: {.column width="60%"}
Un gráfico se podrá componer de [**capas**]{.hl-yellow}

-   [**Datos (data)**]{.hl-purple}
-   [**Mapeado (aesthetics)**]{.hl-purple} de elementos estéticos: ejes, color, forma, etc (en función de los datos)
-   [**Geometría (geom)**]{.hl-purple}: puntos, líneas, barras, polígonos, etc.
-   [**Componer gráficas (facet)**]{.hl-purple}
-   [**Transformaciones (stat)**]{.hl-purple}: ordenar, resumir, etc.
-   [**Coordenadas (coord)**]{.hl-purple}: coordenadas cartesianas, polares, grids, etc.
-   [**Temas (theme)**]{.hl-purple}: fuente, tamaño de letra, subtítulos, captions, leyenda, ejes, etc.
:::
:::

---

## Importar/exportar

Veamos un **primer intento** para entender la filosofía ggplot pero para ello muchas veces [**necesitaremos importar datos externamente**]{.hl-yellow}. Una de las principales [**fortalezas**]{.hl-yellow} de `R` es que podemos importar datos muy fácilmente en diferentes formatos:

-   [**Formatos nativos de R**]{.hl-yellow}: archivos `.rda` y `.RData`.

-   [**Rectangular data**]{.hl-yellow}: archivos `.csv` y `.tsv`, archivos `.txt`, etc.

-   [**Datos en excel**]{.hl-yellow}: archivos `.xls` y`.xlsx`.

-   [**Datos desde SAS/Stata/SPSS**]{.hl-yellow}: archivos `.sas7bdat`, `.sav` y `.dat`.

-   [**Datos desde Google Drive**]{.hl-yellow}

-   [**Datos desde API's**]{.hl-yellow}: aemet, catastro, censo, spotify, etc.

---

## Formatos nativos

Los ficheros [**más sencillos**]{.hl-yellow} para importar a `R` (y que suelen ocupar menos espacio en disco) son sus propias [**extensiones nativas**]{.hl-yellow}: ficheros en formatos `.RData` y `.rda`. Para cargarlos basta con [**utilizar la función**]{.hl-yellow} `load()` proporcionándole la ruta del fichero.

-   Archivos `RData`: vamos a importar el archivo `world_bank_pop.RData` que incluye la tabla `world_bank_pop`

```{r}
load("./datos/world_bank_pop.RData")
world_bank_pop
```

---

## Formatos nativos

-   Archivos `.rda`: vamos a importar el dataset airquality desde `airquality.rda`

```{r}
load("./datos/airquality.rda")
as_tibble(airquality)
```

---

## Formatos nativos

Tenga en cuenta que los archivos cargados con `load()` se cargan [**automáticamente en el entorno**]{.hl-yellow} (con el nombre guardado originalmente), y no sólo se pueden cargar conjuntos de datos: `load()` nos permite cargar múltiples objetos (no sólo datos tabulares).

Los archivos nativos `.rda` y `.RData` son una forma adecuada de guardar el entorno de variables.

```{r}
load(file = "./datos/multiple_objects.rda")
```

::: callout-important
## Importante

Las [**rutas**]{.hl-yellow} deben ser siempre [**sin espacios, ñ, ni acentos**]{.hl-yellow}.
:::

---

## Datos tabulados: readr

El paquete `{readr}` dentro del entorno `{tidyverse}` contiene varias funciones útiles para [**cargar datos rectangulares (sin formatear pero tabulados)**]{.hl-yellow}.

::: columns
::: {.column width="50%"}
-   `read_csv()`: archivos `.csv` [**variables separadas por comas**]{.hl-purple}
-   `read_csv2()`: variables separadas por [**punto y coma**]{.hl-purple}
-   `read_tsv()`: variables separadas por [**tabuladores**]{.hl-purple}.
-   `read_table()`: variables separadas por [**espacios**]{.hl-purple}.
-   `read_delim()`: función generar con opción de [**especificar el delimitador**]{.hl-purple}.
:::

::: {.column width="50%"}
![](img/data-import-readr.png)
:::
:::

Todos ellos necesitan como **argumento la ruta del fichero** más **otros opcionales** (saltar cabecera o no, decimales, etc). Ver más en <https://readr.tidyverse.org/>

---

## Datos tabulados (.csv, .tsv)

La principal ventaja de `{readr}` es que [**automatiza el formato**]{.hl-yellow} para pasar de un fichero plano (sin formato) a un tibble (en filas y columnas, con formato).

. . .

-   Archivo `.csv`: con `read_csv()` cargaremos archivos [**separados por comas**]{.hl-purple}, pasando como [**argumento la ruta**]{.hl-yellow} en `file = ...`. Vamos a importar el conjunto de datos `chickens.csv` (sobre pollos de dibujos animados, por qué no). Si nos fijamos en la salida nos da el tipo de variables.

```{r}
library(readr)
chickens <- read_csv(file = "./datos/chickens.csv")
chickens
```

---

## Datos tabulados (.csv, .tsv)

El [**formato de la variable**]{.hl-yellow} se hará normalmente [**automáticamente**]{.hl-yellow} por `read_csv()`, y podemos consultarlo con `spec()`.

```{r}
spec(chickens)
```

---

## Datos tabulados (.csv, .tsv)

Aunque normalmente lo hace bien automáticamente podemos [**especificar el formato explícitamente**]{.hl-yellow} en `col_types = lista()` (en formato lista, con `col_xxx()` para cada tipo de variable, por ejemplo `eggs_laid` se importará como carácter).

```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_types = list(col_character(), col_character(),
                            col_character(), col_character()))
chickens
```

---

## Datos tabulados (.csv, .tsv)

Incluso podemos indicar que [**variables queremos seleccionar**]{.hl-yellow} (sin ocupar memoria), indicándolo en `col_select = ...` (en formato lista, con `col_select = ...`).

```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_select = c(chicken, sex, eggs_laid))
chickens
```

---

## Datos tabulados (.txt)

¿Qué ocurre cuando el [**separador no es correcto**]{.hl-red}?

. . .

Si usamos `read_csv()` espera que el separador entre columnas sea una coma pero, como puedes ver con el siguiente `.txt`, lo interpreta todo como una sola columna: [**no tiene coma y no sabe dónde separar**]{.hl-yellow}

```{r}
datos_txt <- read_csv(file = "./datos/massey-rating.txt")
dim(datos_txt)
as_tibble(datos_txt)
```

---

## Datos tabulados (.txt)

Para ello tenemos.

-   `read_csv2()` cuando el [**separador es punto y coma**]{.hl-yellow}, `read_tsv()` cuando es un [**tabulador**]{.hl-yellow} y `read_table()` cuando es un [**espacio**]{.hl-yellow}.

-   `read_delim()` en general.

```{r}
datos_txt <- read_table(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```

---

## Datos Excel (.xls, .xlsx)

Otro paquete de importación clave será el paquete `{readxl}` para [**importar datos desde Excel**]{.hl-yellow}. Tres funciones serán clave:

-   `read_xls()` específica para `.xls`, `read_xlsx()` específica para `.xlsx`.
-   `read_excel()`: tanto para `.xls` como para `.xlsx`.

. . .

Vamos a importar `deaths.xlsx` con los registros de defunciones de famosos.

```{r}
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths
```

---

## Datos Excel (.xls, .xlsx)

```{r}
deaths |> slice(1:6)
```

[**Una desgracia muy común**]{.hl-red} es que haya algún tipo de comentario o texto al principio del fichero, teniendo que [**saltar esas filas**]{.hl-yellow}.

---

## Datos Excel (.xls, .xlsx)

Podemos [**saltar estas filas**]{.hl-yellow} directamente en la carga con `skip = ...` (indicando el número de filas a saltar).

```{r}
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths
```

---

## Datos Excel (.xls, .xlsx)

Además con `col_names = ...` ya podemos renombrar las columnas en la importación ([**proporcionar nombres supone 1ª línea ya como dato**]{.hl-yellow})

```{r}
#| code-line-numbers: "2-3"
deaths <-
  read_xlsx(path = "./datos/deaths.xlsx", skip = 5,
            col_names = c("nombre", "profesion", "edad", "hijos", "nacimiento", "muerte"))
deaths
```

---

## Datos Excel (.xls, .xlsx)

También podemos [**cargar un Excel con varias hojas**]{.hl-yellow}: para [**indicar la hoja**]{.hl-yellow} (ya sea por su nombre o por su número) utilizaremos el argumento `sheet = ...`.

```{r}
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars
```

---

## Datos Excel (.xls, .xlsx)

Incluso podemos indicar el [**rango de celdas**]{.hl-yellow} a cargar con `range = ...`.

```{r}
iris <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "iris", range = "C1:E4")
iris
```

---

## Importar desde SAS/STATA/SPSS

El paquete `{haven}` dentro del universo tidyverse nos permitirá [**importar ficheros de los 3 software de pago más importantes**]{.hl-yellow}: SAS, SPSS y Stata.

```{r}
library(haven)

# SAS
iris_sas <- read_sas(data_file = "./datos/iris.sas7bdat")

# SPSS
iris_spss <- read_sav(file = "./datos/iris.sav")

# Stata
iris_stata <- read_dta(file = "./datos/iris.dta")
```

---

## Exportar

De la misma forma que podemos importar también podemos [**exportar**]{.hl-yellow}

-   exportar en `.RData` (opción recomendada para variables almacenadas en `R`). Recuerda que esta extensión [**sólo se puede utilizar en `R`**]{.hl-yellow}. Para ello, basta con utilizar `save(object, file = path)`.

```{r}
table <- tibble("a" = 1:4, "b" = 1:4)
save(table, file = "./datos/table.RData")
rm(table) # eliminar
load("./datos/table.RData")
table
```

---

## Exportar

La ventaja de `.RData` es que podemos [**exportar múltiples variables de nuestro environment**]{.hl-yellow}, no solo un único dataset.

```{r}
table <- tibble("a" = 1:4, "b" = 1:4)
a <- 1
b <- c("javi", "sandra")
save(table, a, b, file = "./datos/mult_obj.RData")
rm(list = c("a", "b", "table"))
load("./datos/mult_obj.RData")
table
```

---

## Exportar

-   [**exportado en `.csv`**]{.hl-yellow}. Para ello simplemente utilizamos `write_csv(object, file = path)`, y es el más recomendable para exportar bases de datos de tamaño pequeño o mediano. Ver <https://arrow.apache.org/docs/r/> para bases de datos masivas.

```{r}
write_csv(table, file = "./datos/table.csv")
read_csv(file = "./datos/table.csv")
```

---

## 💻 Tu turno {#tu-turno-4-5}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 El conjunto de datos `who2` del paquete `{tidyr}` que hemos utilizado en ejercicios anteriores, expórtalo a un formato nativo `R` en la carpeta `datos` de tu proyecto de RStudio

```{r}
#| code-fold: true
#| eval: false
library(tidyr)
save(who2, file = "./datos/who2.RData")
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Carga el conjunto de datos `who2` pero desde la carpeta data (importa el fichero creado en el ejercicio anterior)

```{r}
#| code-fold: true
#| eval: false
load("./datos/who2.RData")
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Repite lo mismo (exportar e importar) en 4 formatos: `.csv`, `.xlsx`, `.sav` (spss) y `.dta` (stata)

```{r}
#| code-fold: true
#| eval: false

# csv
library(readr)
write_csv(who2, file = "./datos/who2.csv")
who2_data <- read_csv(file = "./datos/who2.csv")

# excel
library(openxlsx)
write.xlsx(who2, file = "./datos/who2.xlsx")
who2_data <- read_xlsx(path = "./datos/who2.xlsx")

# sas y stata
library(haven)
write_sav(who2, path = "./datos/who2.sav")
who2_data <- read_spss(path = "./datos/who2.sav")

write_dta(who2, path = "./datos/who2.dta")
who2_data <- read_dta(path = "./datos/who2.dta")
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Repita la carga de `who2.csv` pero seleccione sólo las 4 primeras columnas ya cargadas.

```{r}
#| code-fold: true
#| eval: false
who_select <-
  read_csv(file = "./datos/who2.csv",
           col_select = c("country", "iso2", "iso3", "year"))
who_select
```
:::

---

## Primer intento: scatter plot

Ahora que sabemos importar archivos, vamos a importar el conjunto de datos `gapminder`: un fichero con **datos de esperanzas de vida, poblaciones y renta per cápita** de distintos países en distintos momentos temporales.

```{r}
library(readr)
gapminder <- read_csv(file = "./datos/gapminder.csv")
gapminder
```

---

## Primer intento: scatter plot

El fichero consta de 1704 registros y 6 variables: `country`, `continent`, `year`, `lifeExp` (esperanza de vida), `pop` (población) y `gdpPercap` (renta per cápita).

```{r}
glimpse(gapminder)
```

Para empezar con algo sencillo [**filtraremos solo los datos de 1997**]{.hl-yellow}

```{r}
gapminder_1997 <- gapminder[gapminder$year == 1997, ]
```

---

## Primer intento: scatter plot

Imagina que queremos dibujar un [**scatter plot**]{.hl-yellow} (diagrama de dispersión de puntos, que enfrenta a una variable `x` con una variable `y`).

 

Si tuviéses que [**construir capa a capa el gráfico**]{.hl-yellow}: ¿qué necesitarías?

---

## Ingredientes: datos

¿Qué [**elementos necesitamos**]{.hl-yellow} para realizar un diagrama de puntos? Para [**iniciar el lienzo VACÍO (de momento)**]{.hl-purple} necesitamos llamar una base de datos con `ggplot(datos)`

::: columns
::: {.column width="45%"}
-   [**Datos (data)**]{.hl-yellow}: conjunto `gapminder_1997`.

```{r}
#| eval: false
ggplot(gapminder_1997)
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997)
```
:::
:::

---

## Ingredientes: (x, y)

Ya tenemos linkada la base de datos pero necesitamos [**indicarle que variables de la tabla**]{.hl-yellow} queremos que relacione con el gráfico (en este caso necesita mínimo una `x` y otra `y`).

::: columns
::: {.column width="45%"}
-   [**Datos (data)**]{.hl-yellow}: conjunto `gapminder_1997`.

-   [**Mapeado**]{.hl-yellow}: indicar dentro de `aes()` (aesthetics) las variables en cada coordenada. Todo [**dentro de aes() será mapeado de la base de datos**]{.hl-purple}

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop))
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop))
```
:::
:::

---

## Geometría: geom_point()

De momento sigue vacío ya que aún no le hemos indicado lo más importante: [**¿qué tipo de gráfica queremos hacer?**]{.hl-yellow}. Para eso usaremos las [**capas geométricas**]{.hl-yellow} que empiezan por `geom_xxx()`.

::: columns
::: {.column width="45%"}
-   [**Geometría (geom)**]{.hl-yellow}: optaremos por **puntos** usando `geom_point()`.

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop)) +
  geom_point()
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(x = gdpPercap, y = pop)) +
  geom_point()
```
:::
:::

---

## Rol de los ejes: (x, y)

::: columns
::: {.column width="45%"}
Vamos a profundizar en ese mapeado: ¿cómo [**cambiar el rol**]{.hl-yellow} de los ejes (población en el eje X y renta per cápita en el eje Y)?

-   **Eje X**: población (variable `pop`)
-   **Eje Y**: renta per cápita (variable `gdpPercap`)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(x = pop, y = gdpPercap)) +
  geom_point() 
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop)) +
  geom_point() 
```
:::
:::

---

## Rol de los ejes: (x, y)

::: columns
::: {.column width="45%"}
¿Y un scatter plot con **esperanza de vida** en eje X frente a **renta per cápita**?

-   **Eje X**: esperanza de vida (variable `lifeExp`)
-   **Eje Y**: renta per cápita (variable `gdpPercap`)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point()
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point()
```
:::
:::

---

## Color, size, shape: fijos

Dentro de `geom_point()` tenemos varios **parámetros estéticos a configurar**:

-   `na.rm = ...`: si queremos que nos quite ausentes.

-   `color = ...`: color (si tiene dimensión, color del contorno)

-   `fill = ...`: color del relleno (si tiene dimensión)

. . .

::: columns
::: {.column width="45%"}
Empezaremos por un [**color fijo**]{.hl-yellow}, por ejemplo `"red"` (existen otros como `"blue"`, `"black"`, `"yellow"`, etc)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red")
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red")
```
:::
:::

---

## Color, size, shape: fijos

::: columns
::: {.column width="45%"}
-   `size = ...`: tamaño de la geometría (en este caso el [**tamaño de los puntos**]{.hl-yellow}), cuanto mayor sea el número, mayor será el tamaño de la geometría.

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7) 
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7)
```
:::
:::

---

## Color, size, shape: fijos

::: columns
::: {.column width="45%"}
-   `alpha = ...`: grado de opacidad del color (1 totalmente opaco, 0 totalmente transparente)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7,
             alpha = 0.4)
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7, alpha = 0.4)
```
:::
:::

---

## Color, size, shape: fijos

::: columns
::: {.column width="45%"}
-   `shape = ...`: forma de la geometría, en este caso del «punto» (ver todas las opciones en `vignette("ggplot2-specs")`)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red",
             fill = "black",
             size = 7,
             alpha = 0.4,
             shape = 23)
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", fill = "black",
             size = 7, alpha = 0.4, shape = 23)
```
:::
:::

---

## Color, size, shape: fijos

::: columns
::: {.column width="45%"}
-   `stroke = ...`: tamaño del contorno

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7,
             alpha = 0.4, stroke = 3)
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", alpha = 0.4,
             size = 7, stroke = 3)
```
:::
:::

---

## Color, size, shape: fijos

::: columns
::: {.column width="45%"}
Los colores también podemos asignárselos por su **código hexadecimal**, consultando en <https://htmlcolorcodes.com/es/>, eligiendo el color que queramos. El código hexadecimal siempre comenzará con `#`

```{r}
#| eval: false
# Color en hexadecimal
# https://htmlcolorcodes.com/es/
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "#A02B85",
             alpha = 0.4, size = 7) 
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "#A02B85", alpha = 0.4, size = 7)
```
:::
:::

---

## Mapeado estético: aes()

Hasta ahora los **atributos estéticos** se los hemos pasado fijos y [**constantes**]{.hl-yellow}. Pero la verdadera potencia y versatilidad de `ggplot` es que podemos [**mapear los atributos estéticos en función de los datos**]{.hl-yellow} en `aes()` para que **dependan de variables de los datos**.

. . .

::: columns
::: {.column width="45%"}
Por ejemplo, vamos a asignar un [**color a cada dato en función de su continente**]{.hl-yellow} con `aes(color = continent)`

```{r}
#| eval: false
# Tamaño fijo
# Color por continentes
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent)) +
  geom_point(size = 7)
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(size = 5)
```
:::
:::

---

## Mapeado estético: aes()

::: columns
::: {.column width="50%"}
Podemos combinarlo con lo que hemos hecho anteriormente:

-   [**color**]{.hl-yellow} en función del [**continente**]{.hl-purple}.

-   [**tamaño**]{.hl-yellow} en función de la [**población**]{.hl-purple}.

-   [**transparencia**]{.hl-yellow} la fijamos [**constante**]{.hl-purple} del 50%.

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7)
```

A este scatter plot particular se le conoce **BUBBLE CHART**
:::

::: {.column width="50%"}
```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7)
```
:::
:::

---

## Visualización multivariante

Reflexionemos sobre el gráfico anterior:

-   **color** en función del **continente**.
-   **tamaño** en función de la **población**
-   **transparencia** fija del 50%


Usando los datos hemos conseguido dibujar en un [**gráfico bidimensional 4 variables**]{.hl-yellow}: `lifeExp` y `gdpPercap` en los ejes , `continent` como color y `pop` como tamaño de la geometría, con muy pocas líneas de código.

---

## Escalas (scale): ejes

Es importante entender que [**hasta ahora solo hemos indicado que un atribut estético A dependa de una variable B de los datos**]{.hl-yellow}.



Por ejemplo, si `aes(color = variable)` le estoy diciendo que cada modalidad distinta de la variable adopte un color distinto pero...[**¿qué color?**]{.hl-yellow}

. . .

Para ello usaremos una de las capas más importantes, las [**capas de escalas**]{.hl-yellow} `scale_xxx()`.

---

## Escalas (scale): ejes

Hasta ahora dentro de `aes()` solo le indicábamos que variable mapeamos pero no sus ajustes.

::: columns
::: {.column width="47%"}
Por ejemplo, vamos a **configurar el eje x para tener marcas personalizadas** cada 10 unidades (`scale_x_continuous(breaks = ...)`)
:::

::: {.column width="53%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```
:::
:::

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  labs(x = "Esperanza de vida", y = "Renta per cápita",
       title = "Primer ggplot", caption = "J. Álvarez Liébana",
       color = "continente")
```

---

## Escalas (scale): colores

La misma idea la podemos aplicar a otro atríbuto como los [**colores**]{.hl-yellow} con `scale_color_...()` y `scale_fill_...()`: hemos indicado que mapeé dicho atributo por continente pero...¿qué colores usar?

. . .

::: columns
::: {.column width="50%"}
Con `scale_color_manual()` podemos indicar manualmente una [**paleta**]{.hl-yellow} (puedes buscar en <https://htmlcolorcodes.com/>)
:::

::: {.column width="50%"}
```{r}
#| echo: false
pal <- c("#A02B85", "#2DE86B", "#4FB2CA", "#E8DA2D", "#E84C2D")
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = pal) +
  labs(x = "Esperanza de vida", y = "Renta per cápita",
       title = "Primer ggplot", caption = "J. Álvarez Liébana",
       color = "continente")
```
:::
:::

```{r}
#| eval: false
pal <- c("#A02B85", "#2DE86B", "#4FB2CA", "#E8DA2D", "#E84C2D")
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = pal) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```

---

## Escalas (scale): colores

Otra opción es elegir alguna de las [**paletas de colores diseñadas**]{.hl-yellow} en el paquete `{ggthemes}`:

::: columns
::: {.column width="40%"}
-   `scale_color_colorblind()`: paleta de colores basada en los colores de [**daltónicos/as**]{.hl-yellow}.
:::

::: {.column width="60%"}
```{r}
#| echo: false
library(ggthemes)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```
:::
:::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```

---

## Escalas (scale): colores

Incluso cargar [**paletas de colores diseñadas en base a películas o arte**]{.hl-yellow}

::: columns
::: {.column width="44%"}
-   [**películas**]{.hl-yellow}: paquete `{harrypotter}` (repositorio de Github `aljrico/harrypotter`) usando `scale_color_hp_d()`.

```{r echo = FALSE,  out.width = "20%", fig.align = "center", fig.cap = "Paleta basada en la casa Ravenclaw"}
knitr::include_graphics("https://raw.githubusercontent.com/aljrico/harrypotter/master/readme_raw_files/palettes/ravenclaw.png")
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
library(harrypotter)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_hp_d(option = "ravenclaw")+
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```
:::
:::

```{r}
#| eval: false
devtools::install_github(repo = "aljrico/harrypotter") 
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  harrypotter::scale_color_hp_d(option = "ravenclaw")+
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```

---

## Escalas (scale): colores

Incluso cargar [**paletas de colores diseñadas en base a películas o arte**]{.hl-yellow}

::: columns
::: {.column width="45%"}
-   [**cuadros**]{.hl-yellow}: paquete `{MetBrewer}` (repositorio de Github `BlakeRMills/MetBrewer`) usando `scale_colour_manual(values = met.brewer(...))`.
:::

::: {.column width="55%"}
```{r}
#| echo: false
library(MetBrewer)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = met.brewer("Monet")) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```
:::
:::

```{r}
#| eval: false
devtools::install_github(repo = "BlakeRMills/MetBrewer") 
library(MetBrewer)

ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = met.brewer("Monet")) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```

---

## Escalas (scale): colores

Incluso cargar [**paletas de colores diseñadas en base a películas o arte**]{.hl-yellow}

::: columns
::: {.column width="45%"}
-   [**discos**]{.hl-yellow}: paquete `{peRReo}` (repositorio de Github `jbgb13/peRReo`) usando `scale_colour_manual(values = latin_palette())`.
:::

::: {.column width="55%"}
```{r}
#| echo: false
library(peRReo)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = latin_palette("rosalia")) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```
:::
:::

```{r}
#| eval: false
devtools::install_github(repo = "jbgb13/peRReo") 
library(peRReo)

ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = latin_palette("rosalia")) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```

---

## Escalas: otros atributos

Lo mismo que hemos hecho para los ejes o colores podemos hacer para el [**resto de atríbutos estéticos**]{.hl-yellow}

::: columns
::: {.column width="40%"}
Por ejemplo, vamos a indicarle que mapeé el tamaño en función de población pero indicándole el [**rango de valores**]{.hl-yellow} (continuo en este caso) entre los que moverse con `scale_size_continuous()`
:::

::: {.column width="60%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  scale_size_continuous(range = c(3, 17)) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```
:::
:::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  scale_size_continuous(range = c(3, 15)) +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente")
```

::: ::::

---

## Etiquetas sencillas: labs()

Podemos también [**personalizar de manera sencilla**]{.hl-yellow} haciendo uso de la capa `labs()`:

::: columns
::: {.column width="45%"}
-   `title,subtitle`: título/subtítulo
-   `caption`: pie de gráfica
-   `x, y`: nombres de los ejes
-   `size, color, fill, ...`: nombre en leyenda de las variables que codifiquen los atributos
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esp. de vida",
       y = "Renta per cápita",
       title = "Primer ggplot",
       caption = "J. Álvarez Liébana",
       color = "continente",
       size = "población")
```
:::
:::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita",
       title = "Primer ggplot", subtitle = "Datos de gapminder",
       caption = "J. Álvarez Liébana", color = "continente", size = "población")
```

---

## Eliminar de la leyenda

Podemos eliminar variables de la leyenda con `guides(atributo = "none")`

::: columns
::: {.column width="45%"}
```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, 
           x = lifeExp,
           color = continent, 
           size = pop)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida",
       y = "Renta per cápita",
       title = "Primer ggplot",
       caption = "J. Álvarez Liébana",
       color = "continente")
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida",
       y = "Renta per cápita",
       title = "Primer ggplot",
       caption = "J. Álvarez Liébana",
       color = "continente")
```
:::
:::

---

## Tema (básico)

Por último en este primer gráfico, vamos personalizar el tema con alguna de las capas `theme_...()`

::: columns
::: {.column width="45%"}
Por ejemplo, vamos a usar `theme_minimal()` para tener un tema "austero" y minimalista (aprenderemos a definir cada detalle de nuestro tema).
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```
:::
:::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cápita", title = "Primer ggplot",
       caption = "J. Álvarez Liébana", color = "continente") +
  theme_minimal()
```


---

## Gráficos de una variable

El anterior ejemplo era un **diagrama de dispersión** (bivariante) que nos permite jugar mucho con los parámetros pero empezaremos [**aprendiendo a analizar una sola variable**]{.hl-yellow} (estadística univariante).

. . .

::: columns
::: {.column width="40%"}
Para ello algo fundamental será conocer la naturaleza de la variable ya que [**habrá cosas que podamos hacer con un tipo de variables y no con otras**]{.hl-yellow}. Por ejemplo, vamos a tomar el fichero de datos `starwars` del paquete `{dplyr}` y vamos a **empezar un ggplot**

```{r}
#| eval: false
library(dplyr)
ggplot(starwars)
```
:::

::: {.column width="60%"}
```{r}
#| echo: false
library(dplyr)
ggplot(starwars)
```
:::
:::

---

## Gráficos de una variable

::: columns
::: {.column width="45%"}
Si quiésemos hacer un diagrama de dispersión sencillo como antes entre peso y estatura sería así

```{r}
#| eval: false
ggplot(starwars) +
  geom_point(aes(x = mass, y = height)) +
  theme_minimal()
```
:::

::: {.column width="55%"}
```{r}
#| echo: false
ggplot(starwars) +
  geom_point(aes(x = mass, y = height)) +
  theme_minimal()
```
:::
:::

¿Qué línea habrá cambiar si en lugar de hacer un diagrama de dispersión queremos hacer un [**histograma de la estatura**]{.hl-yellow}

. . .

Lo que [**diferencia a un gráfico de otro es la capa geométrica**]{.hl-yellow}, así que deberemos buscar un `geom_xxx()` distinto (en este caso `geom_histogram()`)

---

## Histogramas

Un [**histograma es una representación gráfica de la distribución de frecuencia**]{.hl-yellow} de un conjunto de datos **numéricos continuos**. Consiste en un gráfico de barras [**PERO donde ahora la base de cada barra representa un intervalo de valores**]{.hl-yellow}, y la altura de la barra indica la frecuencia o la densidad de datos dentro de ese intervalo: ahora la [**anchura de las barras sí es relevante**]{.hl-yellow} (cuantifica la anchura del intervalo en el que estamos agrupando los datos).

. . .

Los histogramas son especialmente útiles para visualizar la forma y la dispersión de los datos aunque [**dependen de un parámetro crítico**]{.hl-red} como es la cantidad de barras (o anchura de cada barra) de las que queramos disponer.

![](img//clipboard-984736011.png){fig-align="center" width="414"}

---

## Histogramas

Fíjate que si lo [**cambiamos tal cual produce error**]{.hl-red}. ¿Por qué?

```{r}
#| error: true
ggplot(starwars) + geom_histogram(aes(x = mass, y = height))
```

. . .

::: columns
::: {.column width="42%"}
La capa usada (histograma) solo admite una `x` o un `y` --\> habrás gráficos bivariantes y [**gráficos univariantes**]{.hl-yellow}

```{r}
#| eval: false
ggplot(starwars) +
  geom_histogram(aes(x = height)) +
  theme_minimal()
```
:::

::: {.column width="58%"}
```{r}
#| echo: false
ggplot(starwars) +
  geom_histogram(aes(x = height)) +
  theme_minimal()
```
:::
:::

---

## Histogramas

Los histogramas dependen de una [**decisión crítica**]{.hl-red} que cambiará por completo el gráfico: el número de barras (`bins = ...`).

```{r}
#| code-fold: true
ggplot(starwars) +
  geom_histogram(aes(x = height), bins = 8) +
  theme_minimal()
```

---


## Gráfico de densidad

Como hemos comentado una de las decisiones a tomar en un histograma es la anchura de las barras ya que dicho valor va a cambiar nuestra percepción de la distribución de los datos.

. . .

Una de las alternativas más conocidas son los conocidos como [**gráficos de densidad**]{.hl-yellow}, una especie de aproximación continua de dichas barras, proporcionando la curva que se intuye que define la forma de un histograma si hacemos las barras cada vez más finas.

![](img//clipboard-2738368484.png){fig-align="center" width="300"}

---

## Gráfico de densidad

Para realizar un gráfico de densidad debemos de usar simplemente `geom_density()` como capa geométrica

```{r}
#| code-fold: true
ggplot(starwars) +
  geom_density(aes(x = height)) +
  theme_minimal()
```

---

## Gráfico de densidad

Lo que hemo aprendido sobre los [**atributos estéticos de un gráfico**]{.hl-yellow} podemos aplicarlo a cualquier capa. Por ejemplo, vamos a decirle que el [**color y relleno de la densidad dependa del `sex`**]{.hl-yellow} (es decir, una densidad para cada uno).

```{r}
#| code-fold: true
#| warning: false
ggplot(starwars |> drop_na(sex)) +
  geom_density(aes(x = height, fill = sex, color = sex),
               alpha = 0.3) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

---

## Gráfico de densidad

El paquete `{ggridges}` y su función `geom_density_ridges()` nos permite [**visualizar densidades de distintos grupos en distintos niveles de altura**]{.hl-yellow}: en lugar de tener todas una encima de otra, podremos indicarle una variable `y`

```{r}
#| code-fold: true
#| warning: false
library(ggridges)
ggplot(starwars |> drop_na(sex)) +
  geom_density_ridges(aes(x = height, y = sex,
                          fill = sex, color = sex),
               alpha = 0.3) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

---


## Diagrama de sectores

Un [**gráfico de sectores**]{.hl-red}, también conocido como gráfico circular o pie chart en inglés, es una representación visual de datos que muestra la proporción de cada categoría dentro de un conjunto de datos en forma de un círculo dividido en sectores. Cada sector representa una categoría y su tamaño angular es proporcional a la frecuencia o proporción de esa categoría en relación con el total.

![](img/clipboard-2656977358.png){fig-align="center" width="590"}

---

## Diagrama de sectores

![](img/clipboard-2247838254.png){fig-align="center" width="590"}

---

## Diagrama de sectores

![](img/clipboard-2247838254.png){fig-align="center" width="550"}

![](img/clipboard-1745598244.png){fig-align="center" width="550"}

---

## Diagrama de barras

Utiliza [**barras rectangulares para mostrar la frecuencia, la magnitud o la proporción de diferentes categorías**]{.hl-yellow}. Cada barra representa una categoría específica y su longitud es proporcional a la cantidad o frecuencia que representa. Es importante [**no confundir con un histograma**]{.hl-red}: en un diagrama de barras la anchura de cada barra es una decisión meramente estética (incluso si dejas o no un hueco entre cada barra).

También pueden ser útiles para representar variables cuantitativas discretas (e.g., número de hijos).

![](img//clipboard-3388298140.png){fig-align="center" width="400"}


---

## Diagrama de cajas

Un [**diagrama de cajas (boxplots)**]{.hl-yellow} es una representación gráfica que proporciona un resumen de varias características importantes de un conjunto de datos numéricos basado en **medidas de posición**.

. . .

El diagrama de cajas muestra la distribución de los datos a lo largo de un eje vertical, dividiendo el conjunto de datos en cuartiles y proporcionando información sobre la dispersión y la simetría de la distribución. Es importante tener en cuenta que en este gráfico, tanto la centralidad representada (mediana) como las medidas de posición (cuartiles) como los valores atípicos, se hace [**en relación a la mediana y no a la media**]{.hl-yellow}.

![](img/clipboard-2370668930.png){fig-align="center" width="477"}

---

## Diagrama de cajas

Para realizarlos basta con usar `geom_boxplot()` como capa geométrica. Por ejemplo, vamos a realizar uno con la variable `height`

```{r}
#| code-fold: true
ggplot(starwars |> drop_na(height)) +
  geom_boxplot(aes(x = height)) +
  theme_minimal()
```

---

## Diagrama de cajas

Podemos **invertir la posición de los boxplots** indicándole la variable `y` en lugar de `x`.

```{r}
#| code-fold: true
ggplot(starwars |> drop_na(height)) +
  geom_boxplot(aes(x = height)) +
  theme_minimal()
```

---

## Diagrama de cajas

Podemos de nuevo incluir lo aprendido sobre atributos estéticos en estos gráficos. Por ejemplo, vamos a pintar un boxplot vertical (es decir `y = height`) por cada sexo (`x = sex`) distinguiendo los colores de cada uno.

```{r}
#| code-fold: true
ggplot(starwars |> drop_na(height, sex)) +
  geom_boxplot(aes(x = sex, y = height, fill = sex,
                   color = sex), alpha = 0.5) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

---

## Diagrama de cajas

La función `geom_boxplot()` nos permite incluso [**distinguir outliers**]{.hl-yellow} en color, forma y tamaño (empiezan todos los parámetros por `outlier...`)

```{r}
#| code-fold: true
ggplot(starwars |> drop_na(height, sex)) +
  geom_boxplot(aes(x = sex, y = height, fill = sex,
                   color = sex), alpha = 0.5,
               outlier.alpha = 0.8, outlier.shape = 23,
               outlier.size = 2, outlier.color = "#d72020",
               outlier.fill = "#d72020") +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

---

## Diagrama de cajas

Dichos gráficos podemos combinarlos con un [**gotelé de las observaciones**]{.hl-yellow} haciendo uso de `geom_jitter()`, indicándole con `width = ...` la anchura del gotelé (a más valor, más disperso y confuso).

```{r}
#| code-fold: true
ggplot(starwars |> drop_na(height, sex),
       aes(x = sex, y = height, fill = sex, color = sex)) +
  geom_boxplot(alpha = 0.5, outlier.alpha = 0) +
  geom_jitter(width = 0.3) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

---

## Gráficos de violín

Los gráficos de cajas y bigotes o boxplot son una alternativa que mejora los clásicos gráficos dinámita o error bar plots (ver [**incovenientes de boxplots**](https://hausetutorials.netlify.app/posts/2019-02-22-why-we-should-never-use-barplots-use-geomquasirandom-instead/)), uno de los gráficos más habituales en artículos científicos en el ámbito de la bioinformática y bioestadística.

A pesar de que son una mejor alternativa que los error bar plots, en muchas ocasiones puede ser interesante acompañar a nuestros boxplot con lo que se conoce como [**gráficos de violín**]{.hl-yellow} (algo parecido a dos gráficos de densidad, uno pegado al otro de manera simétrica)

![](img/clipboard-943497861.png){fig-align="center" width="477"}

---

## Gráficos de violín

Para el gráfico de violín basta con `geom_violin()` 

```{r}
#| code-fold: true
ggplot(starwars |> drop_na(height, sex),
       aes(x = sex, y = height,
           fill = sex, color = sex)) +
  geom_violin(alpha = 0.5) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

---

## Violin + boxplot 

Incluso puedes **combinarlo con un boxplot**

```{r}
#| code-fold: true
ggplot(starwars |> drop_na(height, sex),
       aes(x = sex, y = height,
           fill = sex, color = sex)) +
  geom_violin(alpha = 0.5) +
  geom_boxplot(alpha = 0.2, width = 0.2,
               outlier.alpha = 0.8) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

---

## Recursos para visualización {#recursos-dataviz}

- [**Tipos de gráficos**]: <https://data-to-viz.com/>
- [**Gráficos en ggplot**]: <https://r-graph-gallery.com/>
- [**Hay vida más allá de los boxplots**]: <https://z3tt.github.io/beyond-bar-and-box-plots/>


- [**Selector de colores**]: <https://htmlcolorcodes.com/>
- [**Selector de colores desde captura**]: <https://imagecolorpicker.com/>



---

## 💻 Tu turno {#tu-turno-4-6}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Toma el conjunto ya conocido de `starwars` del paquete `{dplyr}`. Realiza un diagrama de barras para contar las modalidades de la variable `sex` (solo eso, sin más opciones) eliminando antes los ausentes.

```{r}
#| code-fold: true
starwars |> 
  drop_na(sex) |> 
  ggplot() +
  geom_bar(aes(x = sex))
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Añade lo que consideres del gráfico anterior para hacer que el relleno dependa de cada valor de `sex`. Personaliza tú los colores.

```{r}
#| code-fold: true
starwars |> 
  drop_na(sex) |> 
  ggplot() +
  geom_bar(aes(x = sex, fill = sex), alpha = 0.7) +
  scale_fill_manual(values = c("#3b9559", "#e29c4d", "#4265b0", "#b0428b"))
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Añade lo que consideres del gráfico anterior para personalizar los títulos de los ejes, de la leyenda, poner un título al gráfico.

```{r}
#| code-fold: true
starwars |> 
  drop_na(sex) |> 
  ggplot() +
  geom_bar(aes(x = sex, fill = sex), alpha = 0.7) +
  scale_fill_manual(values = c("#3b9559", "#e29c4d", "#4265b0", "#b0428b")) +
  labs(x = "Sexo", y = "Frec. absoluta",
       title = "Distribución de sexo en personajes\nde Starwars",
       fill = "Sexo")
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Añade lo que consideres del gráfico anterior para hacer que el eje y tenga una marca de 10 en 10 valores. Incluye un tema diferente al de por defecto

```{r}
#| code-fold: true
starwars |> 
  drop_na(sex) |> 
  ggplot() +
  geom_bar(aes(x = sex, fill = sex), alpha = 0.7) +
  scale_fill_manual(values = c("#3b9559", "#e29c4d", "#4265b0", "#b0428b")) +
  scale_y_continuous(breaks = seq(0, 60, by = 10)) +
  labs(x = "Sexo", y = "Frec. absoluta",
       title = "Distribución de sexo en personajes\nde Starwars",
       fill = "Sexo") +
  theme_minimal()
```

### [**Ejercicio 5**]{.hl-yellow}

📝 ¿Cómo podrías modificar el código anterior para que cada barra se divida en función de la variable género? Cada barra (para cada sexo) se dividirá en dos géneros: masculino y femenino.

```{r}
#| code-fold: true
#| code-line-numbers: "4-5"
starwars |> 
  drop_na(sex) |> 
  ggplot() +
  geom_bar(aes(x = sex, fill = gender), alpha = 0.7) +
  scale_fill_manual(values = c("#e29c4d", "#4265b0")) +
  scale_y_continuous(breaks = seq(0, 60, by = 10)) +
  labs(x = "Sexo", y = "Frec. absoluta",
       title = "Distribución de sexo y género\nen personajes de Starwars",
       fill = "Género") +
  theme_minimal()
```

### [**Ejercicio 6**]{.hl-yellow}

📝 Replica el gráfico del ejercicio 4 pero haciendo uso de las frecuencias relativas (cálculas antes para poder visualizarla)

```{r}
#| code-fold: true
starwars |> 
  drop_na(sex) |> 
  count(sex) |> 
  mutate("frec_rel" = n/sum(n)) |> 
  ggplot() +
  geom_col(aes(x = sex, y = frec_rel, fill = sex), alpha = 0.7) +
  scale_fill_manual(values = c("#3b9559", "#e29c4d", "#4265b0", "#b0428b")) +
  scale_y_continuous(breaks = seq(0, 0.9, by = 0.1)) +
  labs(x = "Sexo", y = "Frec. absoluta",
       title = "Distribución de sexo en\n personajes de Starwars",
       fill = "Sexo") +
  theme_minimal()
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Visualiza un boxplot de la variable estatura distinguiendo por sexos

```{r}
#| code-fold: true
starwars |> 
  drop_na(height, sex) |> 
  ggplot() + # le decimos que los outlier
  geom_boxplot(aes(x = sex, y = height, color = sex, fill = sex), alpha = 0.5) +
  scale_color_manual(values = c("#3b9559", "#e29c4d", "#4265b0", "#b0428b")) +
  scale_fill_manual(values = c("#3b9559", "#e29c4d", "#4265b0", "#b0428b")) +
  guides(color = "none") + # para eliminar color de leyenda
  labs(x = "Sexo", y = "Estatura",
       title = "Distribución de la estatura vs sexo en\n personajes de Starwars",
       fill = "Sexo") +
  theme_minimal()
```



:::

---

## 🐣 Caso práctico: visualización covid

Vamos a practicar la visualización con la [**base de datos completa de covid del ISCIII**]{.hl-yellow} que vamos a cargar directamente desde la web: en lugar de poner la ruta del `.csv` de nuestro ordenador vamos a poder usar el link directamente (clickando con botón derecho del ratón en los archivos de <https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>)

```{r}
library(readr)
datos <- read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/intro-dataviz-isciii/#caso-pr%C3%A1ctico-visualizaci%C3%B3n-covid).

# Clases 5 y 6: [intro a descriptiva]{.flow} {#descriptiva}

[**Estadística univariante**]{style="color:#444442;"}

-   [💻 Tu turno: descriptiva univariante](#tu-turno-5-1)
-   [🐣 Caso práctico: encuestas de satisfacción](#caso-practico-5-1)
-   [👾 Materiales extras visualización](#extra-dataviz)
-   [📆 Planificación](#planificacion)

---

## Introducción

La estadística descriptiva es una rama de la estadística que se dedica a [**recolectar, organizar, presentar y analizar un conjunto de datos**]{.hl-yellow} para describir las características y comportamientos de dicho conjunto.


Además de para conocer y entender los datos es la fase en la que [**detectaremos errores e incongruencias**]{.hl-yellow}, teniendo muchas veces que hacer una [**depuración de datos**]{.hl-yellow} para dejar la base de datos preparada para su análisis.

---

## Resumen de etapas

1.  Recolección de datos.

2.  Organización y presentación de los datos (estudio de una variable).

3.  Relación entre variables (estudio bivariado).

---

## Fase 1: recolección

La podemos hacer a través de **encuestas, experimentos, observaciones, registros**, etc. Lo más importante en esta etapa es que los datos sean representativos del fenómeno o población que se estudia.


[**Ejemplo**]{.hl-green}: queremos llevar a cabo una [**investigación para analizar la satisfacción de los pacientes**]{.hl-yellow} con los servicios de urgencias de la red de hospitales públicos madrileños. ¿Qué muestra será más representativa?

a)  100 primeros pacientes que lleguen a urgencias del 12 de Octubre.

b)  Los 10 primeros pacientes que lleguen a las urgencias de todos los hospitales de la red de hospitales madrileños.

c)  Seleccionamos al azar 3 hospitales del grupo 3 (hospitales de gran complejidad), grupo 2 (complejidad intermedia) y grupo 3 (baja complejidad) y de cada uno de ellos seleccionamos un número proporcional de pacientes según el total de pacientes que llegan a cada hospital.

---

## Fase 1: recolección

[**Solución**]{.hl-yellow}:

c)  **Seleccionamos al azar 3 hospitales del grupo 3 (hospitales de gran complejidad), grupo 2 (hospitales de complejidad intermedia) y grupo 3 (hospitales de baja complejidad) y de cada uno de ellos seleccionamos un número proporcional de pacientes según el número total de pacientes que llegan a cada hospital**.

 

Con a) todas las conclusiones que saquemos del estudio serán aplicadas al Hospital 12 de Octubre. Con b) es una forma semi representativa pero válida de conseguir una muestra de forma fácil.

. . .

La rama de la estadística que se dedica a estudiar esta parte del análisis se conoce como [**muestreo**]{.hl-yellow}

---

## Fase 2: organización y presentación

Una vez recopilados los datos deben organizarse de manera que sean comprensibles y manejables. Para ello necesitaremos clasificar los datos en [**cuantitativos y cualitativos**]{.hl-yellow} y estudiar sus características según su tipo.

-   [**Messy data**]{.hl-red}: datos mal organizados o desordenados (múltiples individuos en cada fila, misma variable pero separada en varias columnas, etc).

-   [**Tidy data**]{.hl-green}: datos organizados y estandarizados (una variable en cada columna, un registro/individuo en cada fila y un solo valor en cada celda).

---

## Fase 2: organización y presentación

La información la poder **resumir o presentar** de distintas maneras.

-   [**Estadísticos o medidas**]{.hl-yellow}:

    -   Medidas cualitativas: tablas de frecuencias.

    -   Medidas cuantitativas: medidas numéricas de centralización y dispersión.

-   [**Gráficamente**]{.hl-yellow}:

    -   Medidas cualitativas: gráficos de barras, gofres, etc.

    -   Medidas cuantitativas: histogramas, densidades, boxplots, etc

---

## Fase 3: relación entre variables

Una vez hecho el estudio de cada variable por separado buscaremos [**relacionar dos variables de forma simultánea para buscar la asociación**]{.hl-yellow} entre ellas:

-   [**Cuali vs cuali**]{.hl-yellow}: tablas de frecuencias --\> pruebas de Fisher y chi-cuadrado --\> interpretación de OR y RR.

-   [**Cuanti vs cuanti**]{.hl-yellow}: correlación --\> test de correlaciones (o test de igualdad de distribuciones) --\> diagrmas de dispersión.

-   [**Cuanti vs cuali**]{.hl-yellow}: ANOVA.

---

## Conceptos básicos

En estadística es fundamental entender los conceptos de [**población, muestra y variable**]{.hl-yellow}, ya que son la base para cualquier análisis estadístico.

. . .

-   [**Población**]{.hl-yellow}

La población es el **conjunto completo de elementos o individuos** que tienen una característica común y sobre los cuales se desea obtener información. En la mayoría de casos el acceso a la **totalidad de la población es inviable** por motivos económicos, legales o éticos, así que en la mayoría de situaciones las conclusiones deberemos sacarlas haciendo uso de lo que se conoce como **muestra**.

. . .

**Ejemplo**: la diferencia entre censo y encuesta es que el primero recopila datos de todos los individuos de una población, mientras que el segundo trata de estimarlos o inferirlos a partir de una muestra representativa de la misma.

---

## Conceptos básicos

-   [**Muestra**]{.hl-yellow}: subconjunto de la población que se selecciona para su análisis con el fin de hacer inferencias o generalizaciones sobre la población completa. La muestra debe ser **representativa de la población** para que las conclusiones sean válidas.

-   **Muestreo aleatorio simple**: cada miembro de la población tiene la misma probabilidad de ser seleccionado.

-   **Muestreo estratificado**: la población se divide en subgrupos (estratos) y se toma una muestra de cada uno.

-   **Muestreo (no aleatorio) sistemático**: se selecciona cada n-ésimo miembro de la población.

-   **Muestreo (no aleatorio) por cuotas**: se seleccionan aquellos individuos que cumplan ciertas condiciones.

-   **Muestreo por conveniencia**: se elige a los miembros que son más fáciles de acceder, aunque este método puede introducir sesgos.

---

## Tipos de muestreo

[**Ejemplo 1**]{.hl-yellow}

-   **Población**: todos los pacientes que han sido atendidos en un hospital específico durante el último año.

-   **Muestra (aleatoria simple)**: Seleccionamosseleccionamos 200 pacientes de manera aleatoria del registro de pacientes del último año. Para asegurarnos de que la muestra sea representativa, podemos usar muestreo aleatorio simple, donde cada paciente tiene la misma probabilidad de ser seleccionado.

---

## Tipos de muestreo

[**Ejemplo 2**]{.hl-yellow}

-   **Población**: todos los estudiantes matriculados en una universidad durante el semestre actual.

-   **Muestra (aleatoria estratificada)**: seleccionamos 500 estudiantes utilizando muestreo estratificado para asegurar que diferentes subgrupos (estratos) de la población estén representados. Los estratos pueden ser facultades (mismo % de facultades representadas que en la población universitaria), género, clase social, etc.

---

## Tipos de muestreo

[**Ejemplo 3**]{.hl-yellow}

-   **Población**: todas las especies de árboles en un bosque determinado.

-   **Muestra (sistemática no aleatoria)**: Sseleccionamos parcelas de muestreo de 10m x 10m dentro del bosque y contabilizamos todas las especies de árboles presentes en esas parcelas. Esto se puede hacer utilizando muestreo sistemático.

---

## Tipos de muestreo

[**Ejemplo 4**]{.hl-yellow}

-   **Población**: todos los pacientes de covid de un hospital.

-   **Muestra (por cuotas no aleatoria)**: seleccionamos solo a las personas mayores de 65 años para realizar un estudio clínico inicial sobre los efectos secundarios de una posible vacuna de la covid-19.

Estos métodos aseguran, de una manera u otra, que las muestras sean representativas de sus respectivas poblaciones, lo que permite realizar análisis precisos y confiables.

---

## Conceptos básicos

-   [**Variable**]{.hl-yellow}

Una variable es **cualquier característica o atributo** que puede tomar diferentes valores entre los individuos de la población o muestra. Las variables pueden ser de varios tipos según su naturaleza:

-   [**Cualitativas (o categóricas)**]{.hl-purple}: describen cualidades o categorías. Ejemplos:

    -   Nominales: no tienen un orden intrínseco (e.g., género, estado civil).
    -   Ordinales: tienen un orden intrínseco (e.g., niveles de satisfacción, grado académico, sano-leve-grave).

---

## Conceptos básicos

-   [**Variable**]{.hl-yellow}

-   [**Cuantitativas**]{.hl-purple}: describen cantidades y pueden ser medidas numéricamente. Ejemplos:

    -   Discretas finitas: toman valores finitos (e.g., número de hijos, número de visitas al médico, escala de dolor).
    -   Discretas infinitas: toman valores infinitos (o que se podrían considerar como tal) pero podemos enumerarlas y sabemos siempre el siguiente elemento (e.g., número de pelos de nuestra cabellera, número de personas que pueden entrar en una tienda en un periodo dado).
    -   Continuas: pueden tomar cualquier valor dentro de un rango (e.g., altura, peso, tiempo de espera).

---

## Conceptos básicos

-   [**Modalidades**]{.hl-yellow}

Una modalidad es uno de los **valores** que toma una **variable dentro de una muestra**.

El **conjunto de modalidades posibles** que podría haber tomado (en tu población) se suele conocer también como soporte. Algunos ejemplos en función del tipo de variables son:

-   Color de ojos (cualitativa nominal): negro, azul y marrón (3 modalidades en esa muestra de un espectro de colores más amplio que podríamos tener como soporte).
-   Estado del paciente (cualitativa ordinal): sano, leve y grave (3 modalidades en esa muestra de un conjunto de opciones - por ejemplo, sano, leve, grave, UCI, fallecido - que podríamos tener).

---

## Conceptos básicos

-   [**Modalidades**]{.hl-yellow}

Una modalidad es uno de los valores que toma una variable dentro de una muestra. El **conjunto de modalidades** posibles que podría haber tomado (en tu **población**) se suele conocer también como **soporte**. Algunos ejemplos en función del tipo de variables son:

-   Número de hijos (cuantitativa discreta finita): 0, 1, 2 y 3 (4 modalidades en esa muestra de un conjunto de valores posibles - de 0 a...20 hijos - que podríamos tener en la población general).

-   Temperatura anual de Madrid (cuantitativa continua): un rango de -5ºC a 45ºC (un rango continuo de valores en los que se mueve nuestra variable en la muestra (de un rango más amplio, por ejemplo desde -20ºC a 50ºC que podría moverse de manera global si tuviésemos otra muestra).

---

## Ejercicio: tipo de variables

Piensa en tipos de variables que se pueden medir en cada uno de los ejemplos de población y muestra que hemos estudiado.

[**Ejemplo 1**]{.hl-yellow}

| Población                                                                                                              | Muestra                                                                                   | Variables                            |
|:--------------------------------------------------|:---------------------|:-------------------------------------|
| Todos los pacientes de un hospital de los queremos estudiar su grado de satisfcacción con la atención que han recibido | 200 pacientes seleccionados de forma aleatoria del registro de pacientes en el último año | **Cuantitativas**: **Cualitativas**: |

---

## Ejercicio: tipo de variables

[**Ejemplo 1: solución**]{.hl-yellow}

| Población                                                                                                              | Muestra                                                                                   | Variables                                                                                                                                                                                                                                                                                                                           |     |
|:--------------------------------------------------|:---------------------|:------------------------------------------------|-----|
| Todos los pacientes de un hospital de los queremos estudiar su grado de satisfcacción con la atención que han recibido | 200 pacientes seleccionados de forma aleatoria del registro de pacientes en el último año | **Cuantitativas**: edad (discreta), tiempo de espera (continua), grado de satisfacción en una escala del 0 al 10 (discreta), número de visitas en el último año (discreta). \| **Cualitativas**: género (nominal), estado civil (nominal), si viene acompañado (nominal), grado de satisfacción como bueno, regular malo (ordinal). |     |

---

## Ejercicio: tipo de variables

Piensa en tipos de variables que se pueden medir en cada uno de los ejemplos de población y muestra que hemos estudiado.

-   [**Ejemplo 2**]{.hl-yellow}

+--------------------------------------------+----------------------------------------------+--------------------+
| Población                                                                                                       | Muestra                                      | Variables          |
+:================================================================================================================+:=============================================+:===================+
| Todos los estudiantes matriculados en una universidad de los que queremos estudiar las calificaciones obtenidas | 500 estudiantes de las diferentes facultades | **Cuantitativas**: |
|                                                                                                                 |                                              |                    |
|                                                                                                                 |                                              | **Cualitativas**:  |
+--------------------------------------------+----------------------------------------------+--------------------+

---

## Ejercicio: tipo de variables

-   [**Ejemplo 2: solución**]{.hl-yellow}

| Población                                                                                                       | Muestra                                      | Variables                                                                                                                                                                   |
|:-------------------------------------------|:---------------------------------------------|:----------------------------------|
| Todos los estudiantes matriculados en una universidad de los que queremos estudiar las calificaciones obtenidas | 500 estudiantes de las diferentes facultades | **Cuantitativas**: calificaciones, edad (discreta), número de veces que se ha presentado al examen (discreta). **Cualitativas**: asignaturas (nominal), facultad (nominal). |

---

## Ejercicio: tipo de variables

Piensa en tipos de variables que se pueden medir en cada uno de los ejemplos de población y muestra que hemos estudiado.

-   [**Ejemplo 3**]{.hl-yellow}

+-------------+------------------------------------------------------------------+--------------------+
| Población                                                                        | Muestra                                                          | Variables          |
+:=================================================================================+:=================================================================+:===================+
| Especies de árboles en un bosque de los que queremos estudiar su estado de salud | selección sistemática de parcelas de 10m x 10m dentro del bosque | **Cuantitativas**: |
|                                                                                  |                                                                  |                    |
|                                                                                  |                                                                  | **Cualitativas**:  |
+-------------+------------------------------------------------------------------+--------------------+

---

## Ejercicio: tipo de variables

-   [**Ejemplo 3: solución**]{.hl-yellow}

| Población                                                                        | Muestra                                                          | Variables                                                                                                                                                                                                    |
|:------------|:-----------------------------------------------------------------|:-------------------------------------------------------------------|
| Especies de árboles en un bosque de los que queremos estudiar su estado de salud | Selección sistemática de parcelas de 10m x 10m dentro del bosque | **Cuantitativas**: altura del árbol (continua), diámetro del árbol (continua), edad del árbol (discreta). **Cualitativas**: especie del árbol (nominal), estado de salud (ordinal), tipo de suelo (nominal). |

---

## Características numéricas

Nos referimos a las medidas con las que se pretende resumir y condensar la información contenida en un conjunto de datos. Las mayoría de características numéricas las mediremos en variables cuantitativas.

-   [**Medidas de centralización y posición**]{.hl-yellow}

Son los valores que resumen el conjunto de los datos de forma que reflejan el **centro de la distribución** de la tabla de frecuencias

---

## Media

Es el [**valor medio o centro de gravedad**]{.hl-yellow} (el valor más cercano a todos los puntos a la vez). Es la suma de todos los valores dividida por el número total de valores.

$$\bar x= \frac{\sum^n_{i=1} x_i}{n}$$

---

## Ejemplos

-   [**Ejemplo 1**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3. ¿Cuál es su media?

$n=11$

$\sum^n_{i=1} x_i = 0+1+2+0+1+1+0+0+2+2+3 = 12$

$\bar x= \frac{\sum^n_{i=1} x_i}{n} = \frac{12}{11} = 1.09$ hijos

```{r}
x <- c(0, 1, 2, 0, 1, 1, 0, 0, 2, 2, 3)
mean(x)
```

---

## Ejemplos

-   [**Ejemplo 2**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3,10. ¿Cuál es su media?

$\bar x= \frac{\sum^n_{i=1} x_i}{n} = \frac{22}{12} = 1.83$ hijos

```{r}
x <- c(0, 1, 2, 0, 1, 1, 0, 0, 2, 2, 3, 10)
mean(x)
```

::: callout-warning
## Cuidado...

La media es una medida útil y ampliamente aplicada de la tendencia central, pero debe ser utilizada con precaución en conjuntos de datos que contienen valores atípicos o están distribuidos de manera asimétrica.
:::

---

## Mediana

Es el [**valor del medio SIEMPRE Y CUANDO ordenemos**]{.hl-yellow} los datos. Divide la distribución de frecuencias en dos partes.

Para calcularla debemos realizar los siguientes pasos:

1.  Ordenar los datos en orden creciente

2.  Según el número de observaciones (n):

    -   Si n es impar: La mediana es el valor que ocupa la posición central

    -   Si n es par: La mediana es el promedio de los dos valores central

---

## Ejemplos

-   [**Variables cuantitativas**]{.hl-yellow}

-   Conjunto de datos con un número impar de observaciones:

-   Datos: 3, 1, 4, 2, 5 (n=5)

-   Ordenados: 1, 2, 3, 4, 5

-   Mediana: 3 (el tercer valor)

-   Conjunto de datos con un número par de observaciones:

-   Datos: 7, 2, 4, 6 (n=4)

-   Ordenados: 2, 4, 6, 7

-   Mediana: (4 + 6) / 2 = 5

---

## Ejemplos

-   [**Variables cualitativas**]{.hl-yellow}

Conjunto de datos cualitativos ordinales (aunque sean cualitativas admite una jerarquía):

-   Datos: "notable", "suspenso", "sobresaliente", "suspenso", "notable", "aprobado", "notable" (n=7).

-   Ordenados: "suspenso", "suspenso", "aprobado", "notable", "notable", "notable", "sobresaliente".

-   Mediana: "notable".

::: callout-tip
## Consejo

La mediana es especialmente útil en **distribuciones asimétricas** o cuando se quiere una medida de tendencia central que no sea afectada por valores extremadamente altos o bajos.
:::

---

## Ejemplos

-   [**Ejemplo 1**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3. ¿Cuál es su mediana?

$n=11$

Ordenados: 0,0,0,0,1,1,1,2,2,2,3

Mediana: Posición 6 = 1 hijo

```{r}
#| code-fold: true
#| eval: false
x <- c(0,1,2,0,1,1,0,0,2,2,3)

median(x)
# 1
```

---

## Ejemplos

-   [**Ejemplo 2**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3,10. ¿Cuál es su mediana?

$n=12$

Ordenados: 0,0,0,0,1,1,1,2,2,2,3,10

Mediana: Posición 6 y 7 = 1 +1 /2 = 1 hijo

```{r}
#| code-fold: true
#| eval: false
x <- c(0,1,2,0,1,1,0,0,2,2,3, 10)

median(x)
# 1.833333
```

---

## Moda

Es el valor que [**presenta la máxima frecuencia**]{.hl-yellow} y se puede calcular para **todas las variables (también) cualitativas**.

1.  Unimodal:

    -   Datos: "negro", "negro", "amarillo", "verde", "amarillo", "negro". Moda: "negro".

2.  Bimodal:

    -   Datos: 1, 2, 3, 3, 4, 4, 5. Modas: 3 y 4 (ambos aparecen dos veces)

3.  Multimodal:

    -   Datos: 2, 2, 3, 3, 4, 4, 5, 5. Modas: 2, 3, 4, y 5 (todos aparecen dos veces)

4.  Sin moda (amodal):

    -   Datos: 1, 2, 3, 4, 5
    -   Moda: no hay moda (todos los valores aparecen solo una vez)

---

## Ejemplos

-   [**Ejemplo 1**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3. ¿Cuál es su moda?

```{r}
#| code-fold: true
library(tidyverse)
datos <- tibble("x" = c(0,1,2,0,1,1,0,0,2,2,3))

datos |>
  count(x)
```

La modalidad más frecuente es 0 por lo que la moda es 0.

---

## Cuantiles

Los [**cuantiles son valores que dividen un conjunto de datos en partes iguales**]{.hl-yellow} según la distribución de los datos (de nuevo asumiento que tenemos los datos ordenados de menor a mayor). Los cuantiles son útiles para comprender la distribución y la dispersión de los datos. Existen diferentes tipos de cuantiles, cada uno con un número específico de divisiones:

1.  Cuartiles: dividen el conjunto de datos en cuatro partes iguales.

2.  Deciles: dividen el conjunto de datos en diez partes iguales.

3.  Percentiles: dividen el conjunto de datos en cien partes iguales.

---

## Cuantiles

1.  [**Cuartiles**]{.hl-yellow}: dividen el conjunto de datos en cuatro partes iguales.

    -   Primer cuartil (Q1): divide el 25% inferior de los datos del 75% superior.

    -   Mediana (Q2): divide el 50% inferior del 50% superior. Es el segundo cuartil.

    -   Tercer cuartil (Q3): divide el 75% inferior del 25% superior.

---

## Cuantiles

2.  [**Deciles**]{.hl-yellow}: dividen el conjunto de datos en diez partes iguales.

    -   Primer decil (D1): divide el 10% inferior del 90% superior.

    -   Segundo decil (D2): divide el 20% inferior del 80% superior.

    -   Y así sucesivamente hasta el noveno decil (D9), que divide el 90% inferior del 10% superior.

---

## Cuantiles

3.  [**Percentiles**]{.hl-yellow}: dividen el conjunto de datos en cien partes iguales.

    -   Percentil 1 (P1): divide el 1% inferior del 99% superior.

    -   Percentil 2 (P2): divide el 2% inferior del 98% superior.

    -   Y así sucesivamente hasta el percentil 99 (P99), que divide el 99% inferior del 1% superior.

---

## Ejemplos

Supongamos que tenemos el siguiente conjunto de datos (que podemos ordenar): 10, 25, 4, 2, 14, 6, 18, 16, 8, 12, 20. ¿Cuáles son sus cuartiles?

```{r}
#| code-fold: true
datos <- tibble("x" = c(10, 25, 4, 2, 14, 6, 18, 16, 8, 12, 20))

datos |> 
  reframe("cuartiles" = quantile(x))
```

---

## Medidas de dispersión

Medidas (solo disponibles para cuantitativas) que nos indican [**cómo de lejos o cerca están las observaciones del valor central**]{.hl-yellow} que hemos calculado, es decir cuánto se alejan de la media o mediana.

 

Nos indican el grado de dispersión de la distribución de frecuencias.

---

## Recorrido o rango

Indica la diferencia entre el valor máximo y el valor mínimo en un conjunto de datos.

---

## Ejemplos

-   [**Ejemplo 1**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3. ¿Cuál es su recorrido?

-   Valor máximo = 3

-   Valor mínimo = 0

-   Recorrido= 3-0 = 3

```{r}
#| code-fold: true
#| eval: false
x <- c(0,1,2,0,1,1,0,0,2,2,3)

max(x)- min(x)
```

---

## Ejemplos

-   [**Ejemplo 2**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3,10. ¿Cuál es su recorrido?

-   Valor máximo = 10

-   Valor mínimo = 0

-   Recorrido= 10-0 = 10

```{r}
#| code-fold: true
#| eval: false
x <- c(0,1,2,0,1,1,0,0,2,2,3, 10)

max(x)- min(x)
```

::: callout-warning
## Cuidado...

El recorrido es útil cuando se necesita una medida rápida y simple de la dispersión, pero para análisis más detallados y robustos, se utilizan otras medidas de dispersión como la desviación estándar, la varianza o el rango intercuartílico.
:::

---

## Rango Intercuatílico (IQR)

Mide la [**amplitud del 50% central de un conjunto de datos**]{.hl-yellow}. Se calcula como la diferencia entre el tercer cuartil (Q3) y el primer cuartil (Q1), proporcionando una medida robusta de la variabilidad de los datos al no ser afectada por valores atípicos o extremos.

$$IQR = Q_3 - Q_1$$

---

## Varianza

Cuantifica [**cuánto varían los datos respecto a la media**]{.hl-yellow} del conjunto. Una varianza alta indica que los datos están más dispersos alrededor de la media, mientras que una varianza baja indica que los datos están más agrupados cerca de la media. [**Importante**]{.hl-green}: medimos las desviaciones al cuadrado para que no se cancelen signos.

$$s^2 = \frac{\sum_{i=1}^n (x_i - \bar x)^2}{n-1}$$

-   $x_i$ representa cada valor individual en el conjunto de datos.

-   $\bar x$ es la media de la muestra.

-   $n$ es el tamaño de la muestra.

---

## Desviación típica

Es la raíz cuadrada de la varianza y se calcula de la siguiente manera:

$$s = \sqrt {s^2} = \sqrt {\frac{\sum_{i=1}^n (x_i - \bar x)^2}{n-1}}$$

La [**desviación estándar**]{.hl-yellow} se interpreta en las mismas unidades que los datos originales, lo que la hace más intuitiva que la varianza. Indica la dispersión promedio de los datos respecto a la media.

---

## Estimación insesgada

Fíjate que en las **medidas de dispersión el promedio lo estamos realizando diviendo entre n-1 y no entre n**. Esto es debido a que los parámetros que hemos visto hasta ahora se conocen con un apellido: [**parámetros muestrales**]{.hl-yellow} (calculados con los datos disponibles en una muestra).

. . .

El objetivo con ellos es aproximar los [**verdaderos parámetros poblacionales**]{.hl-yellow} (la media real de la población, no la que calculas con tu tabla), y el mejor estimador posible de la varianza población (se conoce como estimador insesgado, sin sesgo) es la que hemos definido dividiendo entre n-1, de ahí que todos los softwares estadísticos nos calculen dicho valor (se la conoce también como cuasivarianza).

---

## Ejemplos

-   [**Ejemplo 1**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3. ¿Cuál es su varianza y desviación típica?

```{r}
x <- c(0,1,2,0,1,1,0,0,2,2,3)

var(x)
sd(x)
```

---

## Ejemplos

-   [**Ejemplo 2**]{.hl-yellow}

A los enfermeros de un centro de salud se les pregunta por el nº de hijos que tienen. Sus respuestas son 0,1,2,0,1,1,0,0,2,2,3,10. ¿Cuál es su varianza y desviación típica?

```{r}
x <- c(0,1,2,0,1,1,0,0,2,2,3, 10)

var(x)
sd(x)
```

---

## Coeficiente de variación

Uno de los problemas al [**comparar dispersiones**]{.hl-yellow} de dos variables diferentes es que tanto la varianza como la desviación típica [**dependen de la escala de los datos**]{.hl-red}.

Esto implica que una desviación de, por ejemplo, 0.5, puede representar una dispersión pequeña (si el rango de mis datos está entre 100 y 200, por ejemplo) pero puede representar una dispersión enorme si el rango de mis datos es también pequeño (por ejemplo, datos entre 0 y 1).

Para poder comparar dispersiones de variables de diferentes rangos (o incluso unidades) existe el conocido como coeficiente de variación (CV):

$$CV = \frac s {|\bar x|}$$

El **coeficiente de variación es siempre adimensional y positivo**.

---

## Tablas de frecuencias

Las variables cualitativas o cuantis discretas las vamos a [**resumir en tablas de frecuencias**]{.hl-yellow} donde se ordenan y estructuran los valores de una variable x de forma resumida de la siguiente manera:

-   **Frecuencia absoluta de x**: nº de veces que se repite cada modalidad de x.

-   **Frecuencia relativa de x**: proporción de veces que se repite cada modalidad de x.

-   **Frecuencia absoluta acumulada de x**: nº de observaciones menores o iguales que cada modalidad de x (solo apto para cuantitativas o cualitativas ordinales ya que necesitamos una estructura de orden).

-   **Frecuencia relativa acumulada de x**: proporción de valores menores o iguales que cada modalidad de x (solo apto para cuantitativas o cualitativas ordinales ya que necesitamos una estructura de orden).

---

## Tablas de frecuencias

| Valores | Frec abs | Frec rel | Frec abs acum | Frec rel acum |
|:-----------------------|:---------------------|:----------------------|:---------------------------------|:---------------------------------|
| $x_i$                  | $f_i$                | $p_i$                 | $F_i$                            | $P_i$                            |

---

## Ejemplo

En un estudio sobre el [**grupo sanguíneo realizado con** $n = 6313$ individuos]{.hl-yellow} se obtuvo la siguiente tabla de frecuencias La variable tiene $k = 4$ modalidades (O, A, B, AB).

| Valores | Frec abs | Frec rel | Frec abs acum | Frec rel acum |

|:-----------------------|:---------------------|:----------------------|:---------------------------------|:---------------------------------|
| $x_i$                  | $f_i$                | $p_i$                 | $F_i$                            | $P_i$                            |
| O                      | 2892                 | 2892/6313 = 0.458     | 2892                             | 0.458                            |
| A                      | 2625                 | 1625/6313 = 0.416     | 5517                             | 0.874                            |
| B                      | 570                  | 570/6313 = 0.09       | 6087                             | 0.964                            |
| AB                     | 226                  | 226/6313 = 0.036      | 6313                             | 1                                |
| TOTAL                  | 6313                 | 1                     | 6313                             | 1                                |

$$\sum^k_{i=1} f_i=n$$ $$\sum^k_{i=1} p_i = 1$$

---

## Ejemplo

¿Qué **conclusiones** sacarías al ver esta tabla?

. . .

La gran mayoría de esta muestra tiene grupo sanguíneo O ó A con un 46% y 42% respectivamente y que los grupos B y AB son minoritarios, siendo el AB la modalidad minoritaria.

---

## Ejemplo

Otro ejemplo:las edades en un grupo de $n = 25$ estudiantes universitarios

| Valores | Frec abs | Frec rel | Frec abs acum | Frec rel acum |

|:-----------------------|:---------------------|:----------------------|:---------------------------------|:---------------------------------|
| $x_i$                  | $f_i$                | $p_i$                 | $F_i$                            | $P_i$                            |
| 18                     | 6                    | 0.24                  | 6                                | 0.24                             |
| 19                     | 5                    | 0.20                  | 11                               | 0.44                             |
| 20                     | 3                    | 0.12                  | 14                               | 0.56                             |
| 21                     | 3                    | 0.12                  | 17                               | 0.68                             |
| 22                     | 3                    | 0.12                  | 20                               | 0.80                             |
| 23                     | 3                    | 0.12                  | 23                               | 0.92                             |
| 24                     | 2                    | 0.08                  | 25                               | 1                                |
| Total                  | 25                   | 1                     | 25                               | 1                                |

---

## Ejemplo

Contesta a las siguientes preguntas sobre la tabla anterior:

-   ¿Cuántos individuos tienen 21 años?

-   ¿Qué porcentaje de individuos tiene más de 19 años?

---

## Tablas de frecuencias

¿Qué pasa cuando tenemos una [**variable cuantitativa continua**]{.hl-red}?

Imagina que anotamos las puntuaciones obtenidas por 100 pacientes en un test psicológico en una escala continua del 0 al 100.

$x_i$: 11,42,58,25,48,18,45,35,59,29,35,2,37,68,70,31,44,84,64,82,26,42,51,29, 59,92,56,5,52,8,1,12,21,6,32,15,67,47,61,47,43,33,48,47,43,69,49,21,9,15,11,22, 29,14,31,46,19,49,51,71,52,32,51,44,58,60,43,65,73,62,3,17,39,22,40,65,30,31,16, 80,41,59,60,41,51,10,63,41,74,81,20,36,59,38,40,43,18,60,71,44.

¿Tiene sentido hacer una tabla de frecuencias? ¿Nos resume la información? ¿Qué podemos hacer?

---

### Ejemplo

| $x_i$     | $f_i$ | $p_i$ | $F_i$ | $P_i$ |
|:----------|:------|:------|:------|:------|
| \[0,10\]  | 8     | 0.08  | 8     | 0.08  |
| (10,20\]  | 12    | 0.12  | 20    | 0.20  |
| (20,30\]  | 10    | 0.1   | 30    | 0.30  |
| (30,40\]  | 14    | 0.14  | 44    | 0.44  |
| (40,50\]  | 21    | 0.21  | 65    | 0.65  |
| (50,60\]  | 16    | 0.16  | 81    | 0.81  |
| (60,70\]  | 10    | 0.10  | 91    | 0.91  |
| (70,80\]  | 5     | 0.05  | 96    | 0.96  |
| (80,90\]  | 3     | 0.03  | 99    | 0.99  |
| (90,100\] | 1     | 0.01  | 100   | 1     |
| Total     | 100   | 1     |       |       |

---

## Tablas de frecuencias

Los **resúmenes numéricos** deberíamos saber hacerlos en  `R` con `datos |> summarise()` pero... [**¿y las tablas de frecuencia o contigencia (unidimensionales de momento)?**]{.hl-yellow}

. . .

Por ejemplo, vamos a realizar un [**conteo de frecuencias de la variable `hair_color`**]{.hl-yellow} de starwars. Para ello en tidyverse basta usar `count()`

```{r}
starwars |>
  drop_na(hair_color) |> 
  count(hair_color)
```

---

## Tablas de frecuencias

```{r}
tabla_freq <-
  starwars |>
  drop_na(hair_color) |> 
  count(hair_color)
```

Si te fijas la [**frecuencia absoluta viene siempre como $n$**]{.hl-yellow} pero podemos **renombrarla**

```{r}
tabla_freq <-
  tabla_freq |> 
  rename(frec_abs = n)
tabla_freq
```

---

## Tablas de frecuencias

A esa tabla de frecuencias podemos añadirle la [**frecuencia relativa**]{.hl-yellow} calculada como cada frecuencia absoluta dividida por el total (la suma de todos)

```{r}
tabla_freq <-
  tabla_freq |> 
  mutate("frec_rel" = frec_abs / sum(frec_abs))
tabla_freq
```

---

## Tablas de frecuencias

Este proceso podemos obtenerlo de forma [**más sencilla con `R base`**]{.hl-yellow} (recuerda: funciones aplican a vectores aislados, que debes sacar de la tabla con `$` y sin tuberías) con la función `table()`

```{r}
tabla_freq <-
 table(starwars$hair_color)
tabla_freq
```

---

## Tablas de frecuencias

También podemos obtener en `R base` las [**frecuencias realtivas**]{.hl-yellow} aplicando `prop.table()` a la tabla de frecuencias anterior.

```{r}
prop.table(tabla_freq)
```

. . .

[**Moraleja**]{.hl-green}: no te cases de manera acérrima con una forma de hacer las cosas, ambos mundos van a ser necesarios.

---

## Paréntesis: sample

Imagina que queremos añadir una columna nueva llamada `rol` tal que a cada persona le asignamos de manera aleatoria `"bueno"` (con probabilidad 0.45), `"malo"` (con probabilidad 0.35), `"villano"` (con probabilidad 0.2)

. . .

Para [**generar experimentos aleatorios de una variable cualitativa**]{.hl-yellow} contamos con `sample(x = ..., size = ..., replace = ..., probs = ...)`:

* `x = c("cruz", "cara")`: las opciones que permitimos que salgan.
* `size = 20`: las veces que «tiramos la moneda».
* `replace = TRUE`: si permitimos reemplazamiento (pueden salir elementos repetidos) o no (en este caso solo podríamos tirar 2 veces).
* `prob = c(0.3, 0.7)`: las probabilidades de los posibles eventos

---

## Paréntesis: sample


* `x = c("cruz", "cara")`: las opciones que permitimos que salgan.
* `size = 20`: las veces que «tiramos la moneda».
* `replace = TRUE`: si permitimos reemplazamiento (pueden salir elementos repetidos) o no (en este caso solo podríamos tirar 2 veces).
* `prob = c(0.3, 0.7)`: las probabilidades de los posibles eventos

En nuestro caso de ejemplo estamos tirando una **moneda trucada (más caras que cruces) 20 veces**.

```{r}
sample(x = c("cruz", "cara"), size = 20, replace = TRUE, prob = c(0.3, 0.7))
```

---

## Tablas de frecuencias

Imagina que queremos añadir una columna nueva llamada `rol` tal que a cada persona le asignamos de manera aleatoria `"bueno"` (con probabilidad 0.45), `"malo"` (con probabilidad 0.35), `"villano"` (con probabilidad 0.2)

Tendremos que hacer un `sample()` con las 3 opciones (y sus probabilidades) de tamaño 87 (tenemos 87 personajes).

```{r}
starwars <- 
  starwars |> 
  mutate("rol" = sample(x = c("bueno", "malo", "villano"), size = 87,
                        replace = TRUE, prob = c(0.45, 0.35, 0.2)),
         .after = name)
starwars
```

---

## Tablas de frecuencias

Si te fijas esa variable no solo es cualitativa sino ordinal. Entre las variables cualitativas tenemos [**nominales**]{.hl-yellow} (género, sexo, estado civil, etc) y [**ordinales**]{.hl-yellow} (estado de salud, rol, etc). ¿Cómo distinguirlas?

. . .

La forma que tenemos en `R` de indicarle que una variable de tipo texto (universo informático) es una cualitativa y de qué tipo (universo estadística) es haciendo uso de lo que se conoce como [**factores**]{.hl-yellow}

---

## Paréntesis: factores

En `R` las [**variables cualitativas pueden ser tratadas como tales**]{.hl-yellow} convirtiendo una cadena de texto a lo que se conoce como [**factor**]{.hl-yellow}. Por ejemplo, supongamos que tenemos un vector de notas

```{r}
notas <- c("suspenso", "notable", "suspenso", "aprobado", "notable", "suspenso")
notas
```

. . .

Para [**convertir a factor nos basta con `factor()`**]{.hl-yellow}. ¿Qué notas diferente?

```{r}
notas_fct <- factor(notas)
notas_fct
```

---


## Paréntesis: factores

```{r}
notas_fct
```

Si te fijas ahora [**tenemos disponibles unos niveles (levels)**]{.hl-yellow}: son las posibles modalidades de nuestra variable cualitativa, el soporte, de manera que aunque borremos uno de ellos (vamos a borrar todos los aprobados), la opción sigue disponible si entrase un dato nuevo (algo así como un menú de opciones permitidas)

```{r}
notas_fct[notas_fct != "aprobado"]
```

---

## Paréntesis: factores

En el caso de las [**cualitativas ordinales podemos incluso establecer una jerarquía**]{.hl-yellow}, indicando explícitamente los niveles y `ordered = TRUE`

```{r}
notas_fct_ord <- factor(notas, levels = c("aprobado", "notable", "suspenso"),
                        ordered = TRUE)
notas_fct_ord
```

Fíjate que ahora tenemos una [**jerarquía**]{.hl-yellow} y aunque sea cualitativa podemos buscar [**elementos \<= o \>= que otros**]{.hl-yellow}

```{r}
notas_fct_ord[notas_fct_ord <= "notable"]
```

---

## Tablas de frecuencias

Volvamos a nuestro ejemplo: ¿cómo convertir nuestra nueva variable rol en una variable cualitativa ordinal (en orden de maldad)?

. . .

Debemos usar el concepto de factor pero para no aislar la variable de su tabla, lo introduciremos en un `mutate()`

```{r}
starwars <-
  starwars |> 
  mutate("rol" = factor(rol, levels = c("bueno", "malo", "villano"),
                        ordered = TRUE))
```

---

## Tablas de frecuencias

Cuando tenemos una variable ordinal no solo vamos a poder calcular la tabla de frecuencias absoluta y relativa...

```{r}
tabla_freq <-
  starwars |> 
  count(rol) |> 
  mutate("frec_rel" = n/sum(n))
tabla_freq

# o bien
table(starwars$rol)
```

---

## Tablas de frecuencias

...sino que al tener una [**jerarquía de orden**]{.hl-yellow} (fíjate que salen automáticamente ordenados) vamos a poder calcular las [**frecuencias acumuladas**]{.hl-yellow} con `cumsum()`

```{r}
tabla_freq <-
  tabla_freq |>
  mutate("frec_abs_acum" = cumsum(n),
         "frec_rel_acum" = cumsum(frec_rel))
tabla_freq

# o bien
cumsum(table(starwars$rol))
cumsum(prop.table(table(starwars$rol)))
```

---

## 💻 Tu turno {#tu-turno-5-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Para repasar lo aprendido vamos a poner todo en práctica con el dataset `SatisfaccionPacientes.csv` que tenéis subido al campus. [**¿Cómo importarlo?**]{.hl-yellow}.

```{r}
#| code-fold: true
library(readr) # dentro de tidyverse
# en mi caso tengo el .csv en una carpeta datos dentro del proyecto
datos <-
  read_csv(file = "./datos/SatisfaccionPacientes.csv") |> 
  # la función clean_names del paquete janitor 
  # nos normaliza nombres de variables
  janitor::clean_names()
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Aplica el código que sea necesario para responder a estas preguntas. ¿Cuál es el tamaño muestral? ¿Cuántas variables tenemos? ¿Cuántas modalidades tenemos en la variable `estado_civil` (y cuantas observaciones en cada una)?

```{r}
#| code-fold: true
#| eval: false
# Tamaño muestral / número de observaciones
n <- nrow(datos)

# Número de variables
p <- ncol(datos)

# ¿Qué modalidades tenemos?
datos |>  count(estado_civil)
```


### [**Ejercicio 3**]{.hl-yellow}

📝 Determina el tipo de variable (cuantitativa vs. cualitativa).

```{r}
#| code-fold: true
#| eval: false
# Variables cuantitativas: tiempo, grado satisfacción, número de visitas
# Variables cualitativas: género, estado civil, estado salud
glimpse(datos)
```

### [**Ejercicio 4**]{.hl-yellow}

📝  Obten tablas de frecuencias (absoluta y relativa) en el caso de las cualitativas NOMINALES. Con ella intenta responder a las preguntas: a) ¿cuántas mujeres hay? b) ¿qué % de individuos están casados?

```{r}
#| code-fold: true
#| eval: false
# no podemos calcular acumulados ya que genero es nominal
datos |>  count(genero) |> 
  rename(frecuencia_abs = n) |> 
  mutate(frecuencia_rel = frecuencia_abs/sum(frecuencia_abs))
# Hay 53 mujeres

datos |> count(estado_civil) |> 
  rename(frecuencia_abs = n) |> 
  mutate(frecuencia_rel = frecuencia_abs/sum(frecuencia_abs))
# Hay 26% personas casadas
```


### [**Ejercicio 5**]{.hl-yellow}

📝 Convierte de manera adecuada la variable `genero` y `estado_civil` a cualitativa nominal

```{r}
#| code-fold: true
datos <-
  datos |>
  mutate(estado_civil = factor(estado_civil),
         genero = factor(genero))
```

### [**Ejercicio 6**]{.hl-yellow}

📝 Calcula la media, mediana, rango intercuartílico y desviación típica de edad y tiempo de espera.

```{r}
#| code-fold: true
resumen <-
  datos |>
  summarise(media_edad = mean(edad), sd_edad = sd(edad), mediana_edad = median(edad),
           IQR_edad = quantile(edad, probs = 0.75) - quantile(edad, probs = 0.25),
           # tiempo espera
           media_tiempo_espera = mean(tiempo_espera), sd_tiempo_espera = sd(tiempo_espera),
           mediana_tiempo_espera = median(tiempo_espera),
           IQR_tiempo_espera = quantile(tiempo_espera, probs = 0.75) - quantile(tiempo_espera, probs = 0.25))
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Repite el anterior ejercicio pero obteniendo las métricas desagregadas por sexo.

```{r}
#| code-fold: true
resumen <-
  datos |>
  summarise(media_edad = mean(edad), sd_edad = sd(edad), mediana_edad = median(edad),
           IQR_edad = quantile(edad, probs = 0.75) - quantile(edad, probs = 0.25),
           # tiempo espera
           media_tiempo_espera = mean(tiempo_espera), sd_tiempo_espera = sd(tiempo_espera),
           mediana_tiempo_espera = median(tiempo_espera),
           IQR_tiempo_espera = quantile(tiempo_espera, probs = 0.75) - quantile(tiempo_espera, probs = 0.25),
          .by = genero)
```

### [**Ejercicio 8**]{.hl-yellow}

📝 Realiza un gráfico de violín para la variable `tiempo_espera` para cada género

```{r}
#| code-fold: true
#| eval: false
ggplot(datos) +
  geom_violin(aes(x = genero, y = tiempo_espera, fill = genero, color = genero),
              alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme_minimal()
```

:::

---

## 🐣 Caso práctico: encuesta de satisfacción {#caso-practico-5-1}

Vamos a seguir poniendo en práctica lo aprendido el dataset `SatisfaccionPacientes.csv` que tenéis subido al campus. 

&nbsp;

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-encuesta-de-satisfacci%C3%B3n)


# Clase 7: [bivariante cualitativa]{.flow} {#descriptiva-bivariante}

[**Inferencia y análisis de variables cualitativas**]{style="color:#444442;"}

-   [🐣 Caso práctico: placebo vs medicamento](#caso-practico-7-1)
-   [🐣 Caso práctico: tabaco vs bronquitis](#caso-practico-7-2)
-   [🐣 Caso práctico: encuesta salud mental](#caso-practico-7-3)
-   [👾 Materiales extras visualización](#extra-dataviz)
-   [📆 Planificación](#planificacion)

---

## Estadística bivariante

Todo lo que hemos hecho con una variable podemos hacerlo también de manera [**bivariante**]{.hl-yellow} considerando dos variables.

. . .

Uno de los principales objetivos de la estadística bivariante es [**determinar si existe relación o dependencia entre dos variables**]{.hl-yellow}, es decir, cuando un cambio en el valor de una de ellas se asocia a un cambio en el de la otra (una [**dependencia estadística no implica un efecto causal**]{.hl-red}).

. . .

La situación contraria, es decir, la ausencia de relación, se denomina [**independencia**]{.hl-yellow}.


---

## Tipos de análisis posibles

Una primera aproximación al estudio de dos variables será [**clasificar el tipo de análisis**]{.hl-yellow}

- [**Cuali vs cuali**]{.hl-yellow}:
  - **Resumen**: tablas de contigencia (frecuencia cruzada).
  - **Inferencia**: prueba $\chi^2$ de independencia o test de Fisher.
  - **Gráficos**: barras apiladas, gofres, gráficos de «flujo».

---

## Tipos de análisis posibles

Una primera aproximación al estudio de dos variables será [**clasificar el tipo de análisis**]{.hl-yellow}


- [**Cuani vs cuanti**]{.hl-yellow}:
  - **Resumen**: covarianza y correlación.
  - **Inferencia**: test de correlación (relación lineal) y test de Kolmogorov-Smirnov (¿ambas distribuciones son iguales?). Test de igualdad de medias o igualdad de varianzas
  - **Gráficos**: diagrama de dispersión, correlogramas, heatmaps.

---

## Tipos de análisis posibles

Una primera aproximación al estudio de dos variables será [**clasificar el tipo de análisis**]{.hl-yellow}


- [**Cuanti vs cuali**]{.hl-yellow}:
  - **Resumen**: medidas de centralización/dispersión/posición de la cuanti desagregado por los grupos de la cuali.
  - **Inferencia**: ANOVA (una vía, dos vías, ...). Test de igualdad de medias o igualdad de varianzas (desagregada por grupos)
  - **Gráficos**: boxplots, gráficos de violín (desagregados por grupos)


---

## Introducción a inferencia

¿Pero que es eso de la [**inferencia estadística**]{.hl-yellow}? Es un conjunto de métodos y técnicas que permite [**inferir conclusiones sobre una población a partir de una muestra**]{.hl-yellow} de datos.

. . .

Su propósito es utilizar la información muestral para estimar características de la población, probar hipótesis y realizar predicciones, basado en el cálculo de [**estadísticos**]{.hl-yellow}

-   [**Parámetro**]{.hl-yellow}: medida que describe una característica de la **población** (ejemplo: la media poblacional $\mu$ de la estatura de las mujeres en España).

-   [**Estadístico**]{.hl-yellow}: medida que describe una característica de la **muestra** (ejemplo: la media muestral $\overline{x}$ de un conjunto de 100 mujeres).

---

## Introducción a inferencia

Haciendo uso de **estadísticos que aproximen una correcta estimación de los parámetros**, los [**contraste de hipótesis**]{.hl-yellow} son procedimientos estadísticos para [**tomar decisiones sobre la validez de una afirmación acerca de una población**]{.hl-yellow} en función de los datos muestrales.

. . .

La idea es muy parecido a un **juicio**: con las pruebas (muestra) el jurado (estadístico) deben decidir sobre tu culpabilidad real (población), pudiendo ser declarado **culpable** o **no culpable**.

. . .

Este proceso implica formula

-   [**Hipótesis nula** $H_0$]{.hl-yellow}: es una afirmación generalmente representa una **posición de no efecto o no diferencia** (ejemplo: entras siendo no culpable a un juicio)

-   [**Hipótesis alternativa** $H_0$]{.hl-yellow}: es una afirmación que [**se acepta si se rechaza la hipótesis nula**]{.hl-yellow}. Representa un efecto o diferencia (ejemplo: culpable)

---

## Introducción a inferencia

-   [**Hipótesis nula** $H_0$]{.hl-yellow}: es una afirmación generalmente representa una **posición de no efecto o no diferencia** (ejemplo: entras siendo no culpable a un juicio)

-   [**Hipótesis alternativa** $H_1$]{.hl-yellow}: es una afirmación que [**se acepta si se rechaza la hipótesis nula**]{.hl-yellow}. Representa un efecto o diferencia (ejemplo: culpable)

La idea es similar a la del juicio: solo vamos a [**rechazar** $H_0$ (es decir, aceptar $H_1$) si hay MUCHAS EVIDENCIAS en la muestra]{.hl-yellow} (solo se condena culpable a una persona si hay muchas evidencias que demuestran su culpabilidad, pero el acusado no tiene que demostrar su inocencia).

. . .

Llamaremos [**nivel de significancia** $\alpha$]{.hl-yellow} a la probabilidad de [**rechazar la hipótesis nula cuando es verdadera**]{.hl-red} (condenar a un inocente, conocido como **error tipo I**. Normalmente $\alpha = 0.05$ aunque se pueden usar otros valores como 0.01 o 0.10 (a decidir ANTES de realizar el contraste.)

---

## Introducción a inferencia

[**Ejemplo**]{.hl-yellow}: supongamos que estamos probando si un nuevo medicamento tiene un efecto en la presión arterial $\mu$

$$H_0:~\mu = \mu_0~\text{(medicamento no tiene efecto sobre la presión arterial)}$$ $$H_1:~\mu \neq \mu_0~\text{(medicamento SI tiene efecto sobre la presión arterial)}$$

donde $\mu_0$ es la media de la presión arterial antes del tratamiento.


| Decisión  | $H_0$ es cierta | $H_1$ es cierta |
|:---------:|:---------------:|:---------------:|
| Se decide rechazar $H_0$ | Error de tipo I   |  Acierto   |
| Se decide no rechazar $H_0$ | Acierto   |  Error de tipo II  |

---

## p valor

El conocido como [**p-valor**]{.hl-yellow} es uno de los conceptos más importantes en estadística pero también peor usados. Puedes ver toda una revisión de qué significa y qué no en <https://pmc.ncbi.nlm.nih.gov/articles/PMC4877414/>

. . .

Podemos definir el [**p-valor**]{.hl-yellow} como un valor continuo que nos mide la [**compatibilidad de los datos observados con el modelo e hipótesis asumidas**]{.hl-yellow}: 1 indica compatibilidad perfecta y 0 incompatibilidad completa.

* [**No repesenta la probabilidad de que la hipótesis nula sea cierta**]{.hl-red}: el propio p-valor se calcula ASUMIENDO que lo es.

* [**No repesenta la probabilidad de que, por azar, se produzca nada**]{.hl-red}

---

## Bivariante cuali vs cuali

Una vez visto conceptos básicos de inferencia vamos a empezar por un [**análisis bivariante de dos variables cualitativas**]{.hl-yellow}

. . .

El primer paso siempre será intentar resumir la información mediante el uso de [**tablas de contigencia**]{.hl-yellow}, en este caso bidimensionales.

. . .

¿Cómo lo harías con **tidyverse**? ¿Y con **R base**?

---

## Tablas de contigencia

Vamos a tomar de nuevo nuestros datos de satisfacción de pacientes

```{r}
library(readr)
datos <-
  read_csv(file = "./datos/SatisfaccionPacientes.csv") |> 
  janitor::clean_names()
```

. . .

Para calcular una tabla bidimensional de frecuencias en tidyverse basta con **indicar dos variables en `count()`**

```{r}
datos |>
  count(genero, estado_civil)
```

---

## Tablas de contigencia

Lo habitual es mostrar esta tabla como una [**tabla con m filas y n columnas**]{.hl-yellow}, siendo $m$ el número de modalidades distintas de la primera variable (en este caso $m=2$, femenino y masculino) y $n$ el número de modalidades distintas de la segunda variable (en este caso $n = 4$). 

¿Cómo hacer que la variable `estado_civil` pivote para pasar de estar en vertical a estar «en horizontal»? (echa un repaso a la parte de tidy data)

. . .

```{r}
datos |>
  count(genero, estado_civil) |> 
  pivot_wider(names_from = estado_civil, values_from = n)
```

---

## Tablas de contigencia


Esto se puede hacer **mucho más sencillo de nuevo en `R base`** con `table()`


```{r}
table(datos$genero, datos$estado_civil)
```

---

## Tablas de contigencia


Fíjate que ahora podemos [**normalizar las frecuencias de 3 formas**]{.hl-yellow}: respecto al total de los datos, por filas (`margin = 1`) o por columnas (`margin = 2`).

```{r}
prop.table(table(datos$genero, datos$estado_civil))
prop.table(table(datos$genero, datos$estado_civil), margin = 1)
prop.table(table(datos$genero, datos$estado_civil), margin = 2)

```

---

## Tablas de contigencia

Haciendo uso de las tablas anteriores intenta responder a las siguientes preguntas:

a) ¿Qué cantidad de pacientes mujeres están solteras?

b) ¿Qué porcentaje, de entre los pacientes hombres, están viudos?

c) ¿Qué porcentaje, de entre los que están divorciados, son mujeres?

d) ¿Qué porcentaje (del total de pacientes) son hombres solteros?


```{r}
#| code-fold: true
# a) 22 mujeres
# b) 8.51%
# c) 57.89%
# d) 20%
```


---

## Tablas de contigencia

Puedes incluso visualizar dichas cantidades con `geom_tile()` indicándole que el relleno dependa del conteo `n`

```{r}
datos |>
  count(genero, estado_civil) |>
  ggplot() +
  geom_tile(aes(x = genero, y = estado_civil, fill = n)) +
  theme_minimal()
```

---

## Inferencia cuali vs cuali

Esas tablas de frecuencia serán las que usen los [**diferentes contrastes**]{.hl-yellow} para decidir si hay o no dependencia entre ellas.

&nbsp;

El contraste más conocido es la conocida como [**prueba de $\chi^2$ (chi-cuadrado)**]{.hl-yellow}: dada una tabla de contigencia entre dos cualitativas, el contraste [**compara dicha tabla con la que deberíamos obtener bajo la hipótesis nula de independencia**]{.hl-yellow}

Vamos a hacerlo con nuestras variables `genero` y `estado_civil`

---

## Prueba chi-cuadrado

$$H_0:~\text{genero y estado civil son independientes}$$

$$H_1:~\text{genero y estado civil son dependientes}$$

```{r}
table(datos$genero, datos$estado_civil)
```

. . .

[**Si la hipótesis nula fuese cierta**]{.hl-yellow}, ¿qué esperaríamos?

---

## Prueba chi-cuadrado

1. Elegimos uno de los factores y calculamos su **proporción en la tabla general** (53% vs 47% en este caso)

```{r}
prop.table(table(datos$genero))
```

. . .

2. Calculamos la **tabla de contigencia**  de ambas variables obteniendo lo que denotaremos como [**frecuencias observadas $O_{ij}$**]{.hl-yellow}

```{r}
table(datos$genero, datos$estado_civil)
```

---

## Prueba chi-cuadrado


3. **Si ambas variables fuesen independientes**, en cada columna tendríamos que tener **porcentajes parecidos a cuando lo hacemos sin desagregar** (53% mujeres y 47% hombres). Es decir, del total de casados (26) deberíamos tener $8.48$ mujeres y $7.52$ hombres; del total de divorciados (19) deberíamos tener $10.07$ mujeres y $8.93$ hombres; y así sucesivamente. Estas frecuencias las denotaremos como [**frecuencias esperadas $E_{ij}$**]{.hl-yellow}

$$E_{ij} = \frac{\text{suma fila i * suma fila j}}{\text{total}}$$


---

## Prueba chi-cuadrado


4. [**Resumimos lo que se desvía una de otra**]{.hl-yellow} mediante el [**estadístico chi-cuadrado**]{.hl-yellow}:

$$\begin{eqnarray}\chi^2 &=& \sum_{i,j} \frac{\left(O_{ij} - E_{ij} \right)^2}{E_{ij}} = \frac{(13.78 - 11)^2}{13.78} + \frac{(12.22 - 15)^2}{12.22} \nonumber \\
&+& \frac{(10.07 - 11)^2}{10.07} + \ldots + \frac{(6.11 - 4)^2}{6.11} = 2.75731\end{eqnarray}$$

. . .


5. Calculamos [**cómo de extremo es el valor del estadístico si la hipótesis nula fuese cierta**]{.hl-yellow}, proporcionándonos un **p-valor**.

---

## Prueba chi-cuadrado

Este proceso podemos hacerlo directamente aplicando `chisq.test()`, indicándole las variables (o su tabla de frecuencias)

```{r}
contraste <- chisq.test(datos$genero, datos$estado_civil)
```

* `...$statistic`: tenemos guardado el valor del estadístico

```{r}
contraste$statistic
```

* `...$observed`: tenemos guardada la tabla de frecuencias observada

```{r}
contraste$observed
```

---

## Prueba chi-cuadrado


* `...$expected`: tenemos guardada la tabla de frecuencias esperada

```{r}
contraste$expected
```

* `...$p.value`: tenemos guardado el p-valor.

```{r}
contraste$p.value
```

---

## Prueba chi-cuadrado


¿Cómo [**interpretar el contraste**]{.hl-yellow}?

```{r}
contraste
```

Como $p.value = 0.4306 > \alpha = 0.05$, no podemos rechazar la hipótesis nula: [**no hay evidencias suficientes en la muestra para concluir que haya dependencia**]{.hl-yellow}.

---

## Prueba de Fisher

Otra alternativa es el [**test exacto de Fisher**]{.hl-yellow}, una prueba estadística utilizada para [**determinar si hay una asociación significativa entre dos variables cualitativas**]{.hl-yellow} especialmente útil cuando las frecuencias esperadas son bajas y tenemos dos grupos en cada cualitativa (la tabla de frecuencias es $2 \times 2$). No entraremos en mucho detalle matemático pero usa la distribución real de una variable aleatoria que sigue lo que se conoce como distribución hipergeométrica.

&nbsp;

Como **curiosidad** dicha prueba nació cuando Fisher trataba de comprobar si una compañera, Muriel Birstol, era capaz de detectar en un té con leche si se había añadido primero el té o la leche en su taza (y del experiemnto del que nació la regla del $\alpha = 5%$).

---

## Prueba de Fisher

Para aplicarlo nos basta con usar `fisher.test()`.

```{r}
fisher.test(datos$genero, datos$estado_civil)
```

---

## Prueba de Fisher

Como hemos dicho es especialmente útil cuando tenemos solo 2 modalidades en cada cualitativa ya nos proporciona [**métricas de asociación**]{.hl-yellow}

Veamos un ejemplo con la tabla `placebo_medicamento.csv`

```{r}
datos_placebo <- read_csv(file = "./datos/placebo_medicamento.csv")
datos_placebo
```

---

## Prueba de Fisher


```{r}
fisher.test(datos_placebo$observado, datos_placebo$grupo_tratamiento)
```

Si te fijas ahora nos devuelve además un [**contraste de lo que se conoce como odds ratio (OR: razón de probabilidades)**]{.hl-yellow}

`alternative hypothesis: true odds ratio is not equal to 1`


---

## Métricas de asociación

```{r}
table(datos_placebo$observado, datos_placebo$grupo_tratamiento)
```

La interpretación de [**Odds ratio (OR)**]{.hl-yellow} es cuantificar la [**asociación entre dos variables respecto a una asociación espúrea**]{.hl-yellow} ¿Cuánto [**mejoran los que tomaron medicamento respecto a una posible mejora basal**]{.hl-yellow} (aleatoria) del placebo?

* [**Ratio de mejora en tratados**]{.hl-purple}: $13/3 = 4.33333$
* [**Ratio de mejora en placebo**]{.hl-purple}: $6/11 = 0.54545$

$$OR = \frac{13/3}{6/11} = \frac{13*11}{6*3} = 7.94$$

Los pacientes sometidos a tratamiento mejoran 7.9 veces más si el placebo mejorase por azar.

---

## Métricas de asociación

```{r}
table(datos_placebo$observado, datos_placebo$grupo_tratamiento)
```

Otra de las métricas habituales es la conocida como [**razón de prevalencias (Risk Ratio, RR)**]{.hl-yellow} que nos proporciona un [**ratio entre la probabilidad de prevalencia**]{.hl-yellow} de un evento en dos grupos.


* [**Prevalencia de mejora en tratados**]{.hl-purple}: $13/(3+13) = 0.8125$
* [**Prevalencia de mejora en placebo**]{.hl-purple}: $6/(11+6) = 0.35294$

$$RR = \frac{13/(3+13)}{6/(11+6)} = \frac{13*11}{6*3} = 2.30208$$
Los pacientes sometidos a tratamiento tienen más del doble de «riesgo» de mejorar que los pacientes con placebo.

---

## Métricas de asociación

Ambas métricas podemos estimarlas también con el paquete `{epitools}`

```{r}
library(epitools)
OR <- oddsratio(datos_placebo$observado, datos_placebo$grupo_tratamiento)
OR$measure
```

* Si $OR = 1$ no hay asociación entre las variables.
* Si $OR > 1$ hay una asociación positiva, es decir, la exposición está asociada con un mayor riesgo.
* Si $OR < 1$ hay una asociación negativa, es decir, la exposición está asociada con un menor riesgo.


---

## Métricas de asociación


```{r}
RR <- riskratio(datos_placebo$observado, datos_placebo$grupo_tratamiento)
RR$measure
```


* Si $RR = 1$ no hay diferencias en el riesgo entre los grupos.
* Si $RR > 1$ el grupo expuesto (en este caso medicado) tiene mayor riesgo (en este caso de mejorar)
* Si $RR < 1$ el grupo expuesto tiene menor riesgo.

---

## Gráficos de barras

Volvamos al ejemplo de encuesta de satisfacción: vamos a intentar relacionar las dos variables cualitativas `genero` y `estado_civil` para **complementar el análisis numérico realizado** (amén del `geom_tile()` que hemos hecho para visualizar la tabla de frecuencias)

. . .

Sabemos realizar un diagrama de barras de cada una por separado, [**¿cómo incluir la información de ambas con `geom_bar()`**]{.hl-yellow}

. . .

Piensa cómo hacerlo recordando que `geom_bar()` solo admite una coordenada `x = ...` o `y = ...`. ¿Cómo incluir la info de otra variable que no sea en `x` o `y`?

---

## Gráficos de barras

```{r}
#| code-fold: true
ggplot(datos) +
  geom_bar(aes(x = estado_civil, fill = genero), alpha = 0.6) +
  ggthemes::scale_fill_colorblind() +
  labs(x = "Estado civil", y = "Frec. absolutas",
       fill = "Género") +
  theme_minimal()
```

---

## Gráficos de barras

La función `geom_bar()` nos permite jugar un poco con el tipo de barras, que por defecto las muestra `stacked` (apiladas). Dicho ajuste podemos **cambiarlo con el argumento `position`**: si `position = "dodge"` las muestra de [**manera agrupada una detrás de otra**]{.hl-yellow}.

```{r}
#| code-fold: true
ggplot(datos) +
  geom_bar(aes(x = estado_civil, fill = genero),
           position = "dodge", alpha = 0.6) +
  ggthemes::scale_fill_colorblind() +
  labs(x = "Estado civil", y = "Frec. absolutas",
       fill = "Género") +
  theme_minimal()
```

---

## Gráficos de barras

La mejor opción para visualizar si hay asociación es que **cada barra de estado civil representa el total y nos muestre el % de cada sexo** en cada una: si fuesen independientes, el reparto por sexo en cada barra debería ser similar. Lo haremos con `position = "fill"`

```{r}
#| code-fold: true
ggplot(datos) +
  geom_bar(aes(x = estado_civil, fill = genero),
           position = "fill", alpha = 0.6) +
  ggthemes::scale_fill_colorblind() +
  labs(x = "Estado civil", y = "Frec. relativas",
       fill = "Género") +
  theme_minimal()
```


---

## Gráficos de barras

```{r}
#| code-fold: true
ggplot(datos) +
  geom_bar(aes(y = estado_civil, fill = genero),
           position = "fill", alpha = 0.6) +
  ggthemes::scale_fill_colorblind() +
  labs(x = "Estado civil", y = "Frec. relativas",
       fill = "Género") +
  theme_minimal()
```

---

## 💻 Tu turno {#tu-turno-6-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Calcula las tablas de frecuencias absoluta y relativa con las variables `genero` y `estado_salud`

```{r}
#| code-fold: true
#| eval: false
tabla_freq <- table(datos$genero, datos$estado_salud)
prop.table(tabla_freq)
prop.table(tabla_freq, margin = 1)
prop.table(tabla_freq, margin = 2)
```


### [**Ejercicio 2**]{.hl-yellow}

📝 Usando la tabla anterior:

* ¿Qué porcentaje, de entre las mujeres, tiene un buen estado de salud?

* ¿Qué porcentaje, de entre los hombres, tiene un estado de salud regular?

* ¿Qué porcentaje de los que tienen estado de salud malo, son mujeres?

```{r}
#| code-fold: true
# De entre las mujeres un 45.28% tiene un buen estado de salud
# De entre los hombres un 34.04% tiene un estado de salud regular
# Un 33.33% de los que tienen un estado de salud malo, son mujeres
```


### [**Ejercicio 3**]{.hl-yellow}

📝 Realiza ambos contrastes e intenta razonar la respuesta a la pregunta: ¿están estas dos variables asociadas? ¿Existe algún tipo de dependencia entre ellas? Hazlo considerando $\alpha = 0.05$.

```{r}
#| code-fold: true
#| eval: false
chisq.test(tabla_freq)$p.value
fisher.test(tabla_freq)$p.value

# En ambos casos p-value > alpha: no podemos rechazar la  hipótesis nula de independencia: no hay evidencias suficientes CON LA MUESTRA QUE TENEMOS para concluir que haya alguna asociación
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Las funciones `chisq.test()` y `fisher.test()` proporcionan un objeto htest que dentro contiene el p-valor (accediendo con `$p.value` dentr de él). ¿Cómo guardar ambos p-valores en una tabla resumen en tidyverse? Exporta los resultados a un `.csv`



```{r}
#| code-fold: true
resumen_dependencia <-
  datos |> 
  summarise("sig_chisq" = chisq.test(genero, estado_civil)$p.value,
            "sig_fisher" = fisher.test(genero, estado_civil)$p.value)
write_csv(resumen_dependencia, file = "./datos/resumen_dependencia.csv")
```

:::

---

## 🐣 Caso práctico I: placebo vs fármaco {#caso-practico-7-1}

En el fichero `placebo_medicamento_completo.csv` tenemos guardado los niveles de colesterol antes y después de un tratamiento: a 76 personas se les dio un medicamento para bajarlo y a 24 personas placebo.

```{r}
datos <- read_csv(file = "./datos/placebo_medicamento_completo.csv")
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-i-placebo-vs-f%C3%A1rmaco)

---

## 🐣 Caso práctico II: bronquitis y tabaco {#caso-practico-7-2}

En el fichero `fumadores.csv` tenemos datos de 96 pacientes sobre sí o fuman y quienes han desarrollado o no bronquitis.

```{r}
datos <- read_csv(file = "./datos/fumadores.csv")
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-ii-bronquitis-y-tabaco)

---

## 🐣 Caso práctico III: salud mental {#caso-practico-7-3}

En el fichero `datos_salud_mental.csv` tenemos información recopilada de 100 pacientes que acuden a un centro de salud mental. Se quiere realizar un estudio para ver el impacto que tienen distintas características sobre la ansiedad y depresión en estos 100 pacientes. Los datos incluyen una variedad de variables relacionadas con la salud mental, así como características demográficas y de estilo de vida.

```{r}
datos <- read_csv(file = "./datos/datos_salud_mental.csv")
```


Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/descriptiva-inferencia-isciii/#caso-pr%C3%A1ctico-iii-salud-mental)

# Clase 8: [inferencia cuanti]{.flow} {#descriptiva-bi-cuanti}

[**Estadística bivariante: análisis de variables cuantitativas. Correlación**]{style="color:#444442;"}

---

## Correlación

---

## Biserial...

---

## Intro regresión lineal

# Clase 9: [regresión lineal]{.flow} {#reg-lineal}

[**Primer modelo: regresión lineal**]{style="color:#444442;"}

---

## pendiente...


---

# Materiales extras {#materiales-extra}

-   [💻 R base](#extra-Rbase)
-   [💻 Tidyverse](#extra-tidyverse)
-   [💻 Dataviz en R](#extra-dataviz)
-   [💻 Github](#github)

# Materiales extras: R base {#extra-Rbase}

-   [💻 Bucles en R](#bucles)
-   [🐣 Casos prácticos bucles + if-else](https://javieralvarezliebana.quarto.pub/if-else-bucles-funciones-isciii/)
-   [💻 Funciones en R](#funciones)
-   [🐣 Casos prácticos funciones](#caso-practico-funciones-1)

---

## Creando funciones {#funciones} {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, además podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¿Cómo [**crear nuestra propia función**]{.hl-purple}? Veamos su **esquema básico**:

-   [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraños). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

-   Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

-   [**Cuerpo**]{.hl-yellow} de la función dentro de `{ }`.

-   Finalizamos la función con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function() {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, además podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¿Cómo [**crear nuestra propia función**]{.hl-purple}? Veamos su **esquema básico**:

-   [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraños). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

-   Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

-   [**Cuerpo**]{.hl-yellow} de la función dentro de `{ }`.

-   Finalizamos la función con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, además podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¿Cómo [**crear nuestra propia función**]{.hl-purple}? Veamos su **esquema básico**:

-   [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraños). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

-   Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

-   [**Cuerpo**]{.hl-yellow} de la función dentro de `{ }`.

-   Finalizamos la función con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  código a ejecutar
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, además podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¿Cómo [**crear nuestra propia función**]{.hl-purple}? Veamos su **esquema básico**:

-   [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraños). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

-   Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

-   [**Cuerpo**]{.hl-yellow} de la función dentro de `{ }`.

-   Finalizamos la función con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  código a ejecutar
  
  return(var_salida)
  
}
```

---

## Creando funciones

-   `arg1, arg2, ...`: serán los [**argumentos de entrada**]{.hl-yellow}, los argumentos que toma la función para ejecutar el código que tiene dentro

-   `código`: líneas de código que queramos que [**ejecute la función**]{.hl-yellow}.

-   `return(var_salida)`: se introducirán los [**argumentos de salida**]{.hl-yellow}.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # Código que queramos ejecutar
  código
  
  # Salida
  return(var_salida)
  
}
```

::: callout-important
## Importante

Todas las variables que definamos dentro de la función son [**variables LOCALES: solo existirán dentro de la función**]{.hl-yellow} salvo que especifiquemos lo contrario.
:::

---

## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de función para [**calcular el área de un rectángulo**]{.hl-yellow}.

Dado que el área de un rectángulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serán los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} será justo su **área** ($lado_1 * lado_2$).

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
}
```

---

## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de función para [**calcular el área de un rectángulo**]{.hl-yellow}.

Dado que el área de un rectángulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serán los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} será justo su **área** ($lado_1 * lado_2$).

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  
}
```

---

## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de función para [**calcular el área de un rectángulo**]{.hl-yellow}.

Dado que el área de un rectángulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serán los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} será justo su **área** ($lado_1 * lado_2$).

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  return(area)
  
}
```

---

## Uso de funciones

También podemos hacer una definición directa de las variables **sin almacenar por el camino**.

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  return(lado_1 * lado_2)
  
}
```

. . .

[**¿Cómo aplicar la función?**]{.hl-yellow}

```{r}
calcular_area(5, 3) # área de un rectángulo 5 x 3 
calcular_area(1, 5) # área de un rectángulo 1 x 5
```

---

## Uso de funciones

::: callout-tip
Aunque no sea necesario, es [**recomendable hacer explícita la llamada de los argumentos**]{.hl-green}, especificando en el código qué valor es para cada argumento para que no dependa de su orden, haciendo el código más legible
:::

```{r}
calcular_area(lado_1 = 5, lado_2 = 3) # área de un rectángulo 5 x 3 
calcular_area(lado_2 = 3, lado_1 = 5) # área de un rectángulo 5 x 3 
```

---

## Argumentos por defecto

Imagina ahora que nos damos cuenta que el 90% de las veces usamos dicha función para [**calcular por defecto el área de un cuadrado**]{.hl-yellow} (es decir, solo necesitamos un lado). Para ello, podemos definir [**argumentos por defecto**]{.hl-yellow} en la función: tomarán dicho valor salvo que le asignemos otro.

¿Por qué no asignar `lado_2 = lado_1` **por defecto**, para ahorrar líneas de código y tiempo?

. . .

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

---

## Argumentos por defecto

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

Ahora [**por defecto**]{.hl-yellow} el segundo lado será igual al primero (si se lo añadimos usará ambos).

```{r}
calcular_area(lado_1 = 5) # cuadrado
calcular_area(lado_1 = 5, lado_2 = 7) # rectángulo
```

---

## Salida múltiple

Compliquemos un poco la función y añadamos en la salida los valores de cada lado, etiquetados como `lado_1` y `lado_2`, [**empaquetando la salida en una vector**]{.hl-yellow}.

```{r}
#| code-line-numbers: "7-8"
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

---

## Salida múltiple

Podemos complicar un poco más la salida añadiendo una cuarta variable que nos diga, en función de los argumentos, [**si rectángulo o cuadrado**]{.hl-yellow}, teniendo que añadir en la salida una variable que de tipo caracter (o lógica).

```{r}
#| code-line-numbers: "7-9"
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rectángulo")))
  
}
calcular_area(5, 3)
```

. . .

[**Problema**]{.hl-red}: al intentar juntar números y texto, lo convierte todo a números. Podríamos guardarlo todo en un `tibble()` como hemos aprendido o en un objeto conocido en `R` como [**listas**]{.hl-yellow}

---

## Introducción a listas

Veamos un pequeño resumen de los datos que ya conocemos:

-   [**vectores**]{.hl-yellow}: colección de elementos de igual tipo. Pueden ser números, caracteres o valores lógicos, entre otros.

-   [**matrices**]{.hl-yellow}: colección BIDIMENSIONAL de elementos de igual tipo e igual longitud.

-   [**data.frame / tibble**]{.hl-yellow}: colección BIDIMENSIONAL de elementos de igual longitud pero de cualquier tipo.

. . .

Las [**listas**]{.hl-yellow} serán [**colecciones de variables de diferente tipo y diferente longitud**]{.hl-purple}, con estructuras totalmente heterógeneas (incluso una lista puede tener dentro a su vez otra lista).

---

## Introducción a listas

Vamos a crear [**nuestra primera lista**]{.hl-yellow} con `list()` con tres elementos: el nombre de nuestros padres/madres, nuestro lugar de nacimiento y edades de nuestros hermanos.

```{r}
var_1 <- c("Paloma", "Gregorio")
var_2 <- "Madrid"
var_3 <- c(25, 30, 26)

lista <- list("progenitores" = var_1, "lugar_nac" = var_2, "edad_hermanos" = var_3)
lista
```

---

## Introducción a listas

```{r}
length(lista)
```

Si observas el objeto que hemos definido como lista, su [**longitud**]{.hl-yellow} del es de 3 ya que tenemos **guardados tres elementos**: un vector de caracteres (de longitud 2), un caracter (vector de longitud 1), y un vector de números (de longitud 3)

. . .

Tenemos guardados elementos de [**distinto tipo**]{.hl-yellow} (algo que ya podíamos hacer) pero, además, de **longitudes dispares**.

```{r}
dim(lista) # devolverá NULL al no tener dos dimensiones
class(lista) # de tipo lista
```

---

## Introducción a listas

Si los juntásemos con un `tibble()`, al tener distinta longitud, obtendríamos un [**error**]{.hl-red}.

```{r}
#| error: true
library(tibble)
tibble("progenitores" = var_1, "lugar_nac" = va_2, "edad_hermanos" = var_3)
```

---

## Introducción a listas

-   [**Acceder por índice**]{.hl-yellow}: con el operador `[[i]]` accedemos al **elemento i-ésimo** de la lista.

```{r}
lista[[1]]
```

. . .

-   [**Acceder por nombre**]{.hl-yellow}: con `$nombre_elemento` accedemos por su nombre.

```{r}
lista$progenitores
```

. . .

En contraposición, el [**corchete simple**]{.hl-yellow} nos permite acceder a [**varios elementos**]{.hl-yellow} a la vez

```{r}
# Varios elementos
lista[1:2]
```

---

## Salida múltiple: listas

```{r}
#| code-line-numbers: "7-9"
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rectángulo")))
  
}
calcular_area(5, 3)
```

---

## Orden de los argumentos

Antes nos daba igual el orden de los argumentos pero ahora el [**orden de los argumentos de entrada importa**]{.hl-yellow}, ya que en la salida incluimos `lado_1` y `lado_2`.

. . .

::: callout-note
## Recomendación

Como se comentaba, altamente recomendable hacer la llamada a la función [**indicando explícitamente los argumentos**]{.hl-yellow} para mejorar **legibilidad e interpretabilidad**.

```{r}
# Equivalente a calcular_area(5, 3)
calcular_area(lado_1 = 5, lado_2 = 3)
```
:::

---

## Funciones: generando conocimiento

Parece una tontería lo que hemos hecho pero hemos cruzado una frontera importante: hemos pasado de [**consumir conocimiento**]{.hl-yellow} (código de otros paquetes, elaborado por otros/as), a [**generar conocimiento**]{.hl-purple}, creando nuestras propias funciones.

. . .

Las funciones van a ser claves en tu día a día ya que te permitirá automatizar código que vas a repetir una y otra vez: empaquetando ese código bajo un alias (nombre de la función) vas a [**poder usarlo una y otra vez sin necesidad de programarlo (por lo que hacer el doble de trabajo no implicará trabajar el doble)**]{.hl-yellow}

---

## Variables locales vs globales

Un aspecto importante sobre el que reflexionar con las funciones: ¿qué sucede si [**nombramos a una variable dentro**]{.hl-yellow} de una función a la que se nos ha **olvidado asignar** un valor dentro de la misma?

. . .

Debemos ser cautos al usar funciones en `R`, ya que debido a la [**«regla lexicográfica»**]{.hl-yellow}, si una variable no se define dentro de la función, `R` [**buscará dicha variable en el entorno**]{.hl-purple} de variables.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  print(x) # No devuelve nada, solo realiza la acción 
}
funcion_ejemplo()
```

---

## Variables locales vs globales

Si una variable [**ya está definida fuera de la función (entorno global)**]{.hl-yellow}, y además es usada dentro de cambiando su valor, el valor [**solo cambia dentro**]{.hl-yellow} pero [**no en el entorno global**]{.hl-red}.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  x <- 2
  print(x) # lo que vale dentro
}
```

```{r}
# lo que vale dentro
funcion_ejemplo() #<<
# lo que vale fuera
print(x) #<<
```

---

## Variables locales vs globales

Si queremos que además de cambiar localmente lo haga [**globalmente**]{.hl-yellow} deberemos usar la [**doble asignación**]{.hl-yellow} (`<<-`).

```{r}
x <- 1
y <- 2
funcion_ejemplo <- function() {
  
  # no cambia globalmente, solo localmente
  x <- 3 
  # cambia globalmente
  y <<- 0 #<<
  
  print(x)
  print(y)
}

funcion_ejemplo() # lo que vale dentro
x # lo que vale fuera
y # lo que vale fuera
```

---

## 💻 Tu turno {#tu-turno-3-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ej 1**]{.hl-yellow}

📝 Modifica el código inferior para definir una función llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.

```{r}
#| eval: false
nombre <- function(x, y) {
  suma <- # código a ejecutar
  return()
}
# Aplicamos la función
suma(3, 7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_suma <- function(x, y) {
  suma <- x + y
  return(suma)
}
funcion_suma(3, 7)
```

### [**Ej 2**]{.hl-yellow}

📝 Modifica el código inferior para definir una función llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado

```{r}
#| eval: false
nombre <- function(x, y) {
  producto <- # código de la multiplicación
  return()
}
producto(3)
producto(3, -7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_producto <- function(x, y = x) {
  producto <- x * y
  return(producto)
}
funcion_producto(3)
funcion_producto(3, -7)
```

### [**Ej 3**]{.hl-yellow}

📝 Define una función llamada `igualdad_nombres` que, dados dos nombres, nos diga si son iguales o no. Hazlo considerando importantes las mayúsculas, y sin que importen las mayúsculas. Usa el paquete `{stringr}`.

```{r}
#| code-fold: true
#| eval: false
# Distinguiendo mayúsculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Lucía")

# Sin importar mayúsculas (ver también str_equal)
igualdad_nombres <- function(persona_1, persona_2) {
  return(str_to_upper(persona_1) == str_to_upper(persona_2))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Lucía")
```

### [**Ej 4**]{.hl-yellow}

📝 Crea una función llamada `calculo_IMC` que, dados dos argumentos (peso y estatura en metros) y un nombre, devuelva una lista con el IMC ($peso/(estatura_m^2)$) y el nombre.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura) {
  
  return(list("nombre" = nombre, "IMC" = peso/(estatura^2)))
}
```

### [**Ej 5**]{.hl-yellow}

📝 Repite el ejercicio anterior pero con otro argumento opcional que se llame unidades (por defecto, `unidades = "metros"`). Desarrolla la función de forma que haga lo correcto si `unidades = "metros"` y si `unidades = "centímetros"`.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  
  return(list("nombre" = nombre,
              "IMC" = peso/(if_else(unidades == "metros", estatura, estatura/100)^2)))
}
```

### [**Ej 6**]{.hl-yellow}

📝 Crea un tibble ficticio de 7 personas, con tres variables (inventa nombre, y simula peso, estatura en centímetros), y adapta la función `calculo_IMC()` de forma que obtengamos una cuarta columna con su IMC.

```{r}
#| code-fold: true
#| eval: false
datos <- tibble("nombres" = c("javi", "sandra", "eva", "ana", "carlos", "leo", NA),
                "peso" = rnorm(n = 7, mean = 70, sd = 1),
                "estatura" = rnorm(n = 7, mean = 168, sd = 5))

# IMPORTANTE. if_else trabaja de manera vectorial, elemento a elemento: la longitud de la
# condición (unidades == "metros" es un vector lógico de longitud uno) debe ser igual que
# lo que le decimos que haga cuando es TRUE y FALSE (en este caso, condicion tiene longitud 1
# pero al aplicarla lo que devuelve es vector de tamaño 7, por eso hay que usar ifelse (sin _))
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  return(list("nombre" = nombre,
              "IMC" = peso/(ifelse(unidades == "metros", estatura, estatura/100)^2)))
}
datos |> mutate(IMC = calculo_IMC(nombres, peso, estatura, unidades = "centímetros")$IMC)
```

### [**Ej 7**]{.hl-yellow}

📝 Crea una función llamada `atajo` que tenga dos argumentos numéricos `x` e `y`. Si ambos son iguales, debes devolver `"iguales"` y hacer que la función acaba automáticamente (piensa cuándo una función sale). OJO: `x` e `y` podrían ser vectores. Si son distintos (de igual de longitud) calcula la proporción de elementos diferentes. Si son distintos (por ser distinta longitud), devuelve los elementos que no sean comunes.

```{r}
#| code-fold: true
#| eval: false
atajo <- function(x, y) {
  
  if (all(x == y) & length(x) == length(y)) { return("iguales") }
  else {
   
    if (length(x) == length(y)) {
      
      n_diff <- sum(x != y) / length(x)
      return(n_diff)
      
    } else {
      
      diff_elem <- unique(c(setdiff(x, y), setdiff(y, x)))
      return(diff_elem)
    }
    
  }
}
```
:::

---

## 🐣 Caso práctico I: conversor {#caso-practico-funciones-1}

Para practicar con funciones vamos a crear un completo **conversor de temperaturas** que, dada una temperatura en Fahrenheit, Celsius o Kelvin, la convierta a cualquiera de las otras

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/if-else-bucles-funciones-isciii/) hasta construirlo.

# Materiales extras: tidyverse {#extra-tidyverse}

-   [💻 Operaciones por filas](#dplyr-filas)
-   [💻 Operaciones por columnas](#dplyr-columnas)
-   [💻 Resúmenes](#dplyr-resumenes)
-   [💻 Importar y exportar](#importar-exportar)
-   [🐣 Casos prácticos](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-vi-tabla-en-spss)

## Rebanadas de datos: slice() {#dplyr-filas}

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice(posiciones)
```
:::
:::

A veces nos puede interesar realizar un [**muestreo no aleatorio discreccional**]{.hl-yellow}, o lo que es lo mismo, [**filtrar por posición**]{.hl-yellow}: con `slice(posiciones)` podremos seleccionar filas concretas pasando como argumento un [**vector de índices**]{.hl-yellow}

. . .

::: columns
::: {.column width="50%"}
```{r}
#| eval: false

# fila 1
starwars |>
  slice(1)
```

```{r}
#| echo: false
starwars |> slice(1) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false

# filas de la 7 a la 9
starwars |>
  slice(7:9)
```

```{r}
#| echo: false
starwars |> slice(7:9) |> select(name:hair_color)
```
:::
:::

. . .

```{r}
#| eval: false

# filas 2, 7, 10 y 31
starwars |>
  slice(c(2, 7, 10, 31))
```

```{r}
#| echo: false
starwars |>
  slice(c(2, 7, 10, 31)) |> select(name:sex)
```

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(posiciones)
```
:::
:::

Disponemos de opciones por defecto:

-   con `slice_head(n = ...)` y `slice_tail(n = ...)` podemos obtener la [**cabecera y cola**]{.hl-yellow} de la tabla

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_head(n = 2)
```

```{r}
#| echo: false
starwars |> slice_head(n = 2) |> select(name:hair_color)
```
:::

::: {.column width="\"50%"}
```{r}
#| eval: false
starwars |> slice_tail(n = 2)
```

```{r}
#| echo: false
starwars |> slice_tail(n = 2) |> select(name:hair_color)
```
:::
:::

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(posiciones)
```
:::
:::

Disponemos de opciones por defecto:

-   con `slice_max()` y `slice_min()` obtenemos la [**filas con menor/mayor valor de una variable**]{.hl-yellow} (si empate, todas salvo que `with_ties = FALSE`) que indicamos en `order_by = ...`

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_min(mass, n = 2)
```

```{r}
#| echo: false
starwars |> slice_min(n = 2, order_by = mass) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_max(height, n = 2)
```

```{r}
#| echo: false
starwars |> slice_max(n = 2, order_by = height) |> select(name:hair_color)
```
:::
:::

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

El conocido como [**muestreo aleatorio simple**]{.hl-yellow} se basa en [**seleccionar individuos aleatoriamente**]{.hl-yellow}, de forma que cada uno tenga ciertas [**probabilidades**]{.hl-yellow} de ser seleccionado. Con `slice_sample(n = ...)` podemos extraer n registros aleatoriamente (a priori equiprobables).

```{r}
starwars |> slice_sample(n = 2)
```

. . .

::: callout-important
## Importante...

[**«Aleatorio» no implica equiprobable**]{.hl-yellow}: es igual de aleatorio un dado normal que uno trucado. No hay cosas «más aleatorias» que otras, simplemente tienen subyacente distintas leyes de probabilidad.
:::

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

También podremos indicarle la [**proporción de datos a samplear**]{.hl-yellow} (en lugar del número) y si queremos que sea [**con reemplazamiento (que se puedan repetir)**]{.hl-yellow}.

```{r}
# 5% de registros aleatorios con reemplazamiento
starwars |> 
  slice_sample(prop = 0.05, replace = TRUE)

```

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

Como decíamos, «aleatorio» no es igual que «equiprobable», así que podemos pasarle un [**vector de probabilidades**]{.hl-yellow}. Por ejemplo, vamos a forzar que sea muy improbable sacar una fila que no sean las dos primeras

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

. . .

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

---

## 💻 Tu turno {#tu-turno-4-2-bis}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Extrae 3 registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(n = 3)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Extrae el 10% de los registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(prop = 0.1)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Extrae aleatoriamente 10 personajes pero de forma que la probabilidad de que salga cada uno sea proporcional a su peso (más pesados, más probable)

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass) |> 
  slice_sample(n = 10, weight_by = mass)
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Selecciona los 3 personajes más mayores.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_max(birth_year, n = 3)
```

### [**Ejercicio 5**]{.hl-yellow}

📝 De los personajes que son humanos y miden más de 160 cm, elimina duplicados en color de ojos, elimina ausentes en peso, selecciona los 3 más altos, y orden de mayor a menor peso. Devuelve la tabla.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Human" & height > 160) |> 
  distinct(eye_color, .keep_all = TRUE) |> 
  drop_na(mass) |> 
  slice_max(height, n = 3) |> 
  arrange(desc(mass))
```
:::

---

## 🐣 Caso práctico: airquality {#caso-practico-4-2}

Vamos a volver aun viejo conocido: en el paquete `{datasets}` (ya instalado por defecto) teníamos diversos conjuntos de datos y uno de ellos era `airquality` con el que ya trabajamos. Los datos capturan [**medidas diarias (n = 153 observaciones) de la calidad del aire**]{.hl-yellow} en Nueva York, de mayo a septiembre de 1973.

En ese momento lo trabajamos desde la perspectiva de R base y extrayendo algunas variables del mismo. El objetivo ahora será trabajarlo desde la perspectiva de `{tidyverse}` fijándonos en las diferencias de una y otra forma.

```{r}
#| eval: false
library(datasets)
airquality
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-ii-airquality-tidyverse).

---

## Recategorizar: case_when() {#dplyr-columnas}

Para [**recategorizaciones más complejas**]{.hl-yellow} tenemos `case_when()`, por ejemplo, para crear una categoría de los personajes en función de su altura.

```{r}
starwars |> 
  drop_na(height) |> 
  mutate(altura = case_when(height < 120 ~ "enanos",
                            height < 160 ~ "bajito",
                            height < 180 ~ "normal",
                            height < 200 ~ "alto",
                            TRUE ~ "gigante"), .before = name)
```

---

## Mover columnas: relocate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  recolocar(var1, despues_de = var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  relocate(var1, .after = var2)
```
:::
:::

Para facilitar la [**recolocación de variables**]{.hl-yellow} tenemos una función para ello, `relocate()`, indicándole en `.after` o `.before` [**detrás**]{.hl-purple} o [**delante**]{.hl-purple} de qué columnas queremos moverlas.

```{r}
starwars |> relocate(species, .before = name)
```

---

## 💻 Tu turno {#tu-turno-4bis-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano.

```{r}
#| code-fold: true
#| eval: false

starwars_2 |> 
  rename(nombre = name, altura = height, color_pelo = hair_color,
         color_piel = skin_color, color_ojos = eye_color)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Con los datos obtenidos del ejercicio 1, coloca la variable de color de pelo justo detrás de la variable de nombres.

```{r}
#| code-fold: true
#| eval: false

starwars_2 |>
  relocate(hair_color, .after = name)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Del dataset original, incluye una columna que calcule el IMC. Tras ello, crea una nueva variable que valga `NA` si no es humano, `delgadez` por debajo de 18, `normal` entre 18 y 30, `sobrepeso` por encima de 30.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(IMC = mass / ((height/100)^2),
         IMC_recat = case_when(species != "Human" ~ NA,
                               IMC < 18 ~ "delgadez",
                               IMC < 30 ~ "normal",
                               TRUE ~ "sobrepeso"),
         .after = name)
```
:::

---

## 🐣 Caso práctico: Taylor Swift {#caso-practico-4-3}

Vamos a volver al [**análisis de Taylor Swift**]{.hl-yellow} pero esta vez desde una perspectiva [**tidyverse**]{.hl-yellow}

```{r}
#| eval: false
library(taylor)
taylor_album_songs
```

```{r}
#| echo: false
library(taylor)
taylor_album_songs |> slice(1:5)
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-iii-taylor-swift)

---

## 🐣 Caso práctico: el señor de los anillos

Para practicar algunas funciones de `{dplyr}` vamos a usar datos de las películas de la [**trilogía de El Señor de los Anillos**]{.hl-yellow}. Los datos los cargaremos directamente desde la web (Github en este caso), sin pasar por el ordenador antes, simplemente **indicando como ruta la web donde está el archivo**

-   La comunidad del anillo -\> <https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Fellowship_Of_The_Ring.csv>

-   Las 2 torres -\> <https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Two_Towers.csv>

-   El Retorno del Rey -\> <https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Return_Of_The_King.csv>

---

## 🐣 Caso práctico: el señor de los anillos

```{r}
library(readr)
lotr_1 <-
  read_csv(file = "https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Fellowship_Of_The_Ring.csv")
lotr_2 <-
  read_csv(file = "https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Two_Towers.csv")
lotr_3 <-
  read_csv(file = "https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Return_Of_The_King.csv")
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-iii-extra-el-se%C3%B1or-de-los-anillos)

---

## Selectores: across() {#dplyr-resumenes}

Un truco es [**hacer uso de selectores**]{.hl-yellow} `across()` y `where()`. El primero nos permite [**actuar sobre varias columnas por nombre**]{.hl-purple} (con `mutate()` o `summarise()`)

```{r}
starwars |> summarise(medias = across(height:mass, mean, na.rm = TRUE), .by = sex)
```

. . .

El segundo, `where()`, nos permite hacer lo mismo pero [**seleccionando por tipo**]{.hl-yellow}.

```{r}
starwars |> 
  summarise(across(where(is.numeric), mean, na.rm = TRUE), .by = c(sex, gender))
```

---

## 🐣 Caso práctico: billboard {#caso-practico-4-4}

Vamos a hacer un **repaso de lo aprendido** en `{tidyverse}` con la tabla billboard del paquete `{tidyr}`. El dataset representa algo parecido a Los 40 principales (pero versión americana y un top 100 en lugar de 40): para cada artista y canción se guarda la fecha en la que entró en el ranking, y la posición que ocupaba en el ranking en cada una de las semanas (`wk1`, `wk2`, ...)

```{r}
#| eval: false
billboard
```

```{r}
#| echo: false
billboard[, 1:8]
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-iv-billboard)

---

## 🐣 Caso práctico: fútbol {#caso-practico-4-5}

Vamos a seguir **practicando lo aprendido** en `{tidyverse}` con el fichero `futbol.csv`, donde tenemos **datos de los jugadores de las 5 principales ligas de futbol masculinas**, desde 2005 hasta 2019, recopilando diferentes estadísticas. Los datos se han extraído directamente haciendo uso del paquete `{worldfootballR}`, que nos permite extraer datos de <https://www.fbref.com>

```{r}
datos <- read_csv(file = "./datos/futbol.csv")
datos
```

---

## 🐣 Caso práctico: fútbol

Las variables capturan la siguiente información:

-   `season`, `team`, `league`: temporada, equipo y liga
-   `player`, `country`, `position`, `date_birth`: nombre del jugador, país, posición y año de nacimiento.
-   `minutes_playing`, `matches`: minutos totales jugados y partidos jugados en media (es decir, cuantos partidos de 90 minutos ha jugado con los minutos jugados).
-   `goals`, `assist`: goles y asistencias totales
-   `pk`, `pk_attemp`, `goals_minus_pk`: penalties marcados, penalties tirados y goles marcados sin contar los penalties.
-   `yellow_card`, `red_card`: tarjetas amarillas/rojas.

[**Importante**]{.hl-red}: la variable `matches` debes crearla tú haciendo uso de `minutes_playing` (por ejemplo, si ha jugado 315 minutos, cuentan como 3.5 partidos)

---

## 🐣 Caso práctico: fútbol

```{r}
datos
```

 

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-v-messi-vs-ronaldo)

---

## Importar desde web {#importar-exportar}

Una de las principales ventajas de `R` es que podemos hacer uso de todas las funciones anteriores de [**importar pero directamente desde una web**]{.hl-yellow}, sin necesidad de realizar la descarga manual: en lugar de pasarle la ruta local le indicaremos el [**enlace**]{.hl-yellow}. Por ejemplo, vamos a descargar los datos covid del ISCIII (<https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>)

```{r}
#| eval: false
covid_data <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
covid_data
```

```{r}
#| echo: false
covid_data <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv", n_max = 500)
covid_data
```

---

## Importar desde wikipedia

El paquete `{rvest}`, uno de los más útiles de `{tidyverse}` nos permite [**importar (scrappear) directamente desde un `html`**]{.hl-yellow}. Por ejemplo, para exportar tablas de wikipedia basta con `read_html()` para importar el html, `html_element(«table»)` para extraer los objetos tabla, y `html_table()` para convertir la tabla html a `tibble`.

```{r}
library(rvest)
wiki_jump <- 'https://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression'
wiki_jump |> read_html() |> 
  html_element("table") |> 
  html_table()
```

---

## Importar desde google drive

Otra opción disponible (especialmente si trabajamos con otras personas trabajando) es [**importar desde una hoja de cálculo de Google Drive**]{.hl-yellow}, haciendo uso de `read_sheet()` del paquete `{googlesheets4}`.

La primera vez se te pedirá un permiso tidyverse para interactuar con tu drive

```{r}
library(googlesheets4)
google_sheet <-
  read_sheet("https://docs.google.com/spreadsheets/d/1Uz38nHjl3bmftxDpcXj--DYyPo1I39NHVf-xjeg1_wI/edit?usp=sharing")
google_sheet
```

---

## Importar desde API (aemet)

En muchas ocasiones para conectarnos a la API primero tendremos que [**registrarnos y obtener una clave**]{.hl-yellow}, este es el caso del paquete `{climaemet}` para acceder a [**datos meteorológicos de España**]{.hl-yellow} (<https://opendata.aemet.es/centrodedescargas/inicio>).

Una vez tengamos la clave API la registramos en nuestro RStudio para poder utilizarla en el futuro.

```{r}
#| eval: false
library(climaemet)

# Api key
apikey <- "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqYXZhbHYwOUB1Y20uZXMiLCJqdGkiOiI4YTU1ODUxMS01MTE3LTQ4MTYtYmM4OS1hYmVkNDhiODBkYzkiLCJpc3MiOiJBRU1FVCIsImlhdCI6MTY2NjQ2OTcxNSwidXNlcklkIjoiOGE1NTg1MTEtNTExNy00ODE2LWJjODktYWJlZDQ4YjgwZGM5Iiwicm9sZSI6IiJ9.HEMR77lZy2ASjmOxJa8ppx2J8Za1IViurMX3p1reVBU"

aemet_api_key(apikey, install = TRUE)
```

```{r}
#| echo: false
library(climaemet)
```

---

## Importar desde API (aemet)

Con este paquete podemos hacer una [**búsqueda de estaciones**]{.hl-yellow} para conocer tanto su código postal como su código identificador dentro de la red AEMET

```{r}
stations <- aemet_stations()
stations
```

---

## Importar desde API (aemet)

Por ejemplo, para obtener datos de la estación del aeropuerto de El Prat, Barcelona, el código a proporcionar es `«0076»`, obteniendo **datos horarios**.

```{r}
aemet_last_obs("0076")
```

---

## Importar desde API

Otras opciones

-   `{tidycensus}`: una herramienta para [**facilitar el proceso de descarga de datos censales**]{.hl-yellow} de Estados Unidos desde `R`

-   `{chessR}`: datos de partidas de ajedrez de las plataformas chess.com y lychess. Ver más en <https://github.com/JaseZiv/chessR>

-   `{spotifyr}`: datos de canciones de Spotify. Ver más en <https://www.rcharlie.com/spotifyr/>

-   `{gtrendsR}`: datos de Google Trends. Ver más en <https://github.com/PMassicotte/gtrendsR>

-   `{scholar}`: datos de Google Scholar. Ver más en <https://github.com/jkeirstead/scholar>

---

## 🐣 Caso práctico: encuesta CIS {#caso-practico-4-6}

[📊 Datos](https://drive.google.com/drive/folders/1zDc_XqXnTxx8auEYW7aFfIsnzDXOcAiZ?usp=sharing)

Vamos a poner en práctica la carga y preprocesado de un fichero generado por uno de los programas informáticos más utilizados (SPSS). El fichero contiene [**datos del barómetro del CIS (Centro de Investigaciones Sociológicas) «Percepciones sobre igualdad entre hombres y mujeres y estereotipos de género»**]{.hl-yellow} cuyo trabajo muestral se realizó del 6 al 14 de noviembre (4000 entrevistas a mayores de 16 años de ambos sexos en 1174 municipios y 50 provincias).

 

Intenta responder a las preguntas planteadas en el [**workbook (pendiente)**](https://javieralvarezliebana.quarto.pub/dplyr-import-isciii/#caso-pr%C3%A1ctico-vi-tabla-en-spss)

# Materiales extra: intro a dataviz en R {#extra-dataviz}

-   [💻 Historia del dataviz](#historia)

---

## Dataviz: historia {#historia}

La aparición de gráficos estadísticos es [**relativamente reciente en la ciencia**]{.hl-yellow} ya que hasta la Edad Media la única visualización estaba en los [**mapas**]{.hl-yellow}. [^1] Las propias palabras *chart* y *cartography* derivan del mismo origen latino, *charta*, aunque el primer uso de coordenadas viene de los egipcios. [^2] [^3]

[^1]: [«Gramática de las gráficas: pistas para mejorar las representaciones de datos» de Joaquín Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)

[^2]: [«Presentation Graphics» de Leland Wilkinson. International Encyclopedia of the Social & Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

[^3]: [«Quantitative Graphics in Statistics: A Brief History» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)\]

. . .

::: columns
::: {.column width="55%"}
No es hasta la Edad Media, cuando la [**navegación y la astronomía**]{.hl-yellow} empezaban a tomar relevancia, cuando aparece la primera gráfica (no propiamente estadística), del **movimiento cíclico de los planetas** (siglos X y XI)
:::

::: {.column width="45%"}
![](img/dataviz_historico_1.png){width="370"}
:::
:::

---

## Primer gráfico estadístico

La mayoría de expertos, como Tufte [^4] [^5], consideran este gráfico casi longitudinal como la [**primera visualización de datos**]{.hl-yellow} de la historia, hecha por **Van Langren** en 1644, representando la [**distancia entre Toledo y Roma**]{.hl-yellow}.

[^4]: [«Visual explanations: images and quantities, evidence and narrative» de E. Tufte](https://archive.org/details/visualexplanatio00tuft)

[^5]: [«PowerPoint is evil» de E. Tufte](https://www.wired.com/2003/09/ppt2/)

```{r}
#| echo: false
knitr::include_graphics("./img/longitud_dataviz.jpg")
```

```{r}
#| echo: false
knitr::include_graphics("./img/dataviz_historico_3.jpeg")
```

---

## Vizfails

::: columns
::: {.column width="55%"}
![](img/persona_dataviz.jpg)
:::

::: {.column width="45%"}
-   La figura elegida (persona caminando) sin relación con lo visualizado: [**mala metáfora**]{.hl-red}.

-   Los [**sectores señalados sin relación con el ítem**]{.hl-red} a representar, lo que dificulta su interpretación.

-   Los [**colores sin codificar**]{.hl-red}: no dan información de ningún tipo.

-   Las [**formas irregulares impiden la comparación**]{.hl-red} de las áreas (amén de que la suma total supera el 100%).

-   **Sin fuente**
:::
:::

---

## Vizfails

![](img/viz_fail_covid.jpg)

---

## Vizfails

![](img/viz_fail_uk.jpg)

---

## La importancia del CONTEXTO

Una **buena idea** puede estar mal ejecutada: la forma de llevarla a cabo es importante

![](img/semaforos.jpg)

---

## Dataviz: historia

En el siglo XVII hubo un boom de la estadística al empezar a aplicarse en [**demografía**]{.hl-yellow}. Uno de los autores más importantes fue [**J. Graunt**]{.hl-purple}, autor de «Natural and Political Observations Made upon the Bills of Mortality» (1662), estimando la población de Londres con las [**primeras tablas de natalidad y mortalidad**]{.hl-yellow}.

. . .

::: columns
::: {.column width="50%"}
Son precisamente las tablas de Graunt las que usó [**Christiaan Huygens**]{.hl-yellow} para generar la [**primera gráfica de densidad**]{.hl-yellow} de una distribución continua (esperanza de vida vs edad).
:::

::: {.column width="50%"}
```{r echo = FALSE,  out.width = "100%", fig.align = "center", fig.cap = "Primera función de densidad, extraída de https://omeka.lehigh.edu/exhibits/show/data_visualization/vital_statistics/huygen"}
knitr::include_graphics("./img/primera_densidad.jpg")
```
:::
:::

---

## Gráficos de Playfair

La figura que cambió el dataviz fue, sin lugar a dudas, el economista y político [**William Playfair (1759-1823)**]{.hl-yellow}, publicando en 1786 el **«Atlas político y comercial»** [^6] [^7] con 44 gráficas (43 series temporales y el diagrama de barras más famoso de la historia).

[^6]: [«Playfair and his charts» de H. Gray Funkhouser and Helen M. Walker (1935)](https://www.jstor.org/stable/45366440)

[^7]: [«A Letter on Our Agricultural Distresses, Their Causes and Remedies» de W. Playfair (1821)](http://onlinebooks.library.upenn.edu/webbin/book/lookupid?key=ha009726110)

::: columns
::: {.column width="50%"}
```{r echo = FALSE, out.width = "70%", fig.align = "center", fig.cap = "Extraídas de Funkhouser y Walker (1935)"}
knitr::include_graphics("./img/playfair_1.jpg")
```
:::

::: {.column width="50%"}
```{r echo = FALSE, out.width = "25%", fig.align = "center", fig.cap = "Extraídas de Funkhouser y Walker (1935)"}
knitr::include_graphics("./img/playfair_2.jpg")
```
:::
:::

---

## Gráficos de Playfair

Playfair es además el autor del [**gráfico de barras más famoso**]{.hl-yellow} (no fue el primero pero sí quien lo hizo *mainstream*).

::: columns
::: {.column width="50%"}
```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "Gráficas de Playfair de importaciones (barras grises) y exportaciones (negras) de Escocia en 1781, extraídas de la wikipedia."}
knitr::include_graphics("./img/playfair_5.jpg")
```
:::

::: {.column width="50%"}
```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "Primer diagrama de barras (P. Buache y G. de L’Isle), visualizando los niveles del Sena (1732 - 1766), extraída de https://friendly.github.io/HistDataVis"}
knitr::include_graphics("./img/playfair_6.jpg")
```
:::
:::

---

## Gráficos de Playfair

Playfair además fue el primero en [**combinar gráficos en la misma visualización**]{.hl-yellow} [^8] [^9]

[^8]: [«A Letter on Our Agricultural Distresses, Their Causes and Remedies» de W. Playfair (1821)](http://onlinebooks.library.upenn.edu/webbin/book/lookupid?key=ha009726110)

[^9]: [«An Inquiry Into the Permanent Causes of the Decline and Fall of Powerful and Wealthy Nations» de William Playfair (1821)](https://www.amazon.com/Permanent-Powerful-Nations-Prosperity-Prolonged/dp/140691830X)

::: columns
::: {.column width="50%"}
```{r echo = FALSE, out.width = "85%", fig.align = "center", fig.cap = "Visualiza 3 series temporales: precios (barras) del trigo, salarios (línea) y time-line con reinados, extraída de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/playfair_7.jpg")
```
:::

::: {.column width="50%"}
```{r echo = FALSE, out.width = "85%", fig.align = "center", fig.cap = "Time-line histórico, extraída de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/playfair_8.png")
```
:::
:::

---

## Primer scatter plot

Según J. Sevilla, se considera al astrónomo británico **John Frederick William Herschel** el autor del [**primer diagrama de dispersión o scatterplot**]{.hl-yellow} en 1833, visualizando el movimiento de la estrella doble Virginis (tiempo en el eje horizontal, posición angular en el eje vertical)

```{r echo = FALSE, out.width = "35%", fig.align = "center", fig.cap = "Extraído de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/herschel.jpg")
```

---

## Florence Nigthingale

::: columns
::: {.column width="65%"}
-   El 21 de octubre de 1854 [**Florence Nigthingale**]{.hl-yellow} fue enviada para mejorar las **condiciones sanitarias** de los soldados británicos en la guerra de Crimea.

-   A su regreso demostró que los [**soldados fallecían por las condiciones sanitarias**]{.hl-yellow}. Nigthingale es la creadora del famoso [**diagrama de rosa**]{.hl-yellow}, visualizando tres variables a la vez y su estacionalidad.

-   El 8 de febrero de 1955, The Times la describió como la **«ángel guardián» de los hospitales**, y acabó siendo conocida como [**«The Lady with the Lamp»**]{.hl-yellow} tras un poema de H. W. Longfellow (1857).

-   Años después se convirtió en la [**primera mujer en la Royal Statistical Society**]{.hl-yellow}.
:::

::: {.column width="35%"}
```{r echo = FALSE, out.width = "95%", fig.align = "center"}
knitr::include_graphics("./img/the_lady_with_the_lamp.png")
```
:::
:::

---

## Diagrama de rosa

Florence Nigthingale es la creadora del famoso [**diagrama de rosa**]{.hl-yellow}, permitiendo pintar [**tres variables a la vez y su estacionalidad**]{.hl-yellow}: **tiempo** (cada **gajo** es un mes), **nº de muertes** (**área** del gajo) y **causa** de la muerte (**color** del gajo: azules enfermedades infecciosas, rojas por heridas, negras otras causas).

```{r echo = FALSE, out.width = "75%", fig.align = "center"}
knitr::include_graphics("./img/rosa_nightingale.jpg")
```

---

## Recursos de dataviz

📚 [«The Functional Art: an introduction to information graphics and visualization» de Alberto Cairo](https://www.amazon.es/Functional-Art-Voices-That-Matter/dp/0321834739)

📚 [«Gramática de las gráficas: pistas para mejorar las representaciones de datos» de Joaquín Sevilla](https://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)

📚 [«A Brief History of Visualization» de Friendly et al. (2008)](https://www.researchgate.net/publication/226400313_A_Brief_History_of_Data_Visualization)

📚 [«Quantitative Graphics in Statistics: A Brief History» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)\]

📚 [«Presentation Graphics» de Leland Wilkinson. International Encyclopedia of the Social & Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

📚 [«The Grammar of Graphics» de Leland Wilkinson](https://www.amazon.es/Grammar-Graphics-Statistics-Computing/dp/0387245448)

📚 [«The Minard System: The Graphical Works of Charles-Joseph Minard» de Sandra Rendgen](https://www.amazon.es/gp/product/1616896337/ref=sw_img_1?smid=A1AT7YVPFBWXBL&psc=1)

📚 [«The Visual Display of Quantitative Information» de E. W. Tufte](https://www.amazon.es/Visual-Display-Quantitative-Information/dp/0961392142)

---

# Github {#github}

---

## ¿Qué es Github?

[**GitHub**]{.hl-yellow} es la plataforma colaborativa más conocida basada en el [**sistema de control de versiones Git**]{.hl-yellow}

. . .

-   [**¿Qué es Git?**]{.hl-purple} Git es un sistema de [**control de versiones**]{.hl-yellow}: una especie de [**Dropbox**]{.hl-yellow} para facilitar la [**programación colaborativa**]{.hl-yellow} entre un grupo de personas, permitiendo llevar la [**trazabilidad de los cambios**]{.hl-yellow} realizados.

. . .

-   [**¿Qué es Github?**]{.hl-purple} Nuestra [**plataforma/interfaz**]{.hl-yellow} para ejecutar el control de versiones: nos servirá no solo para trabajar colaborativamente sino para [**hacer transparente**]{.hl-yellow} el proceso de construcción de nuestros proyectos de código.

. . .

::: callout-important
## Importante

Desde el 4 de junio de 2018 Github es de Microsoft (ergo el código que subas también)
:::

---

## Visión general

Tras hacernos una cuenta en Github, [**arriba a la derecha**]{.hl-purple} tendremos un círculo, y haciendo click en [**Your Profile**]{.hl-purple}, veremos algo similar a esto

::: columns
::: {.column width="55%"}
![](img/github_1.png)
:::

::: {.column width="45%"}
-   [**Edit profile**]{.hl-purple}: nos permite añadir una [**descripción y foto de perfil**]{.hl-yellow}.

-   [**Overview**]{.hl-purple}: en ese panel de cuadrados se [**visualizará nuestra actividad**]{.hl-yellow} a lo largo del tiempo.

-   [**Repositories**]{.hl-purple}: el códugo será subido a [**repositorios**]{.hl-yellow}, el equivalente a nuestras carpetas compartidas en Dropbox.
:::
:::

---

## Primer uso: consumidor

Antes de aprender como crear repositorios, Github también nos servirá para

-   [**Acceder a código**]{.hl-purple} ajeno
-   [**Proponer mejoras**]{.hl-purple} a otros usuarios, e incluso proponer [**correcciones de error que detectemos**]{.hl-yellow} de software que usemos

. . .

-   [**Instalar paquetes de R**]{.hl-purple}. En muchas ocasiones los desarrolladores de paquetes suben las actualizaciones a CRAN cada cierto tiempo, y en otras el software no es suficientemente «amplio» para poder ser subido como paquete.

El código de paquetes que no tengamos subido en CRAN podremos [**instalarlo como código desde Github**]{.hl-yellow}

---

## Instalar desde Github

Por ejemplo, vamos a instalar un paquete llamado [`{peRReo}`](https://github.com/jbgb13/peRReo), cuya única función es darnos [**paletas de colores**]{.hl-yellow} basadas en portadas de [**álbumes de música urbana**]{.hl-yellow}

::: columns
::: {.column width="50%"}
![](img/perrreo.png)
:::

::: {.column width="50%"}
![](img/rosalia.png){width="360"}
:::
:::

. . .

Para ello antes tendremos que instalar un [**conjunto de paquetes para desarrolladores**]{.hl-yellow} llamado `{devtools}`, que nos permitirá la instalación desde Github

```{r}
#| eval: false
install.packages("devtools")
```

---

## Instalar desde Github

Las [**instrucciones de instalación**]{.hl-yellow} suelen venir detalladas en la portada del repositorio

::: columns
::: {.column width="50%"}
![](img/install_perreo.png)
:::

::: {.column width="50%"}
![](img/rosalia.png){width="310"}
:::
:::

. . .

En la mayoría de casos bastará con la función `install_github()` (del paquete que acabamos de instalar), pasándole como argumento la [**ruta del repositorio**]{.hl-yellow} (sin "github.com/").

```{r}
#| eval: false
devtools::install_github("jbgb13/peRReo")
```

Ya puedes perrear con ggplot ;)

---

## Descargar desde Github

La mayoría de veces lo que subamos no será un paquete de R como tal sino que [**subiremos un código más o menos organizado**]{.hl-yellow} y comentado. En ese caso podremos [**descargar el repo entero**]{.hl-yellow} haciendo click [**Code**]{.hl-green} y luego Download ZIP.

Por ejemplo, vamos a descargarnos los scripts de dataviz que han subido desde el [Centre d'Estudis d'Opinió](https://github.com/ceopinio/bop-grafics)

![](img/ceo_github.png)

---

## Ideal

![](img/abogados_simpson.jpeg){width="600"}

[**¿Lo ideal en caso de RTVE?**]{.hl-purple} Tener dos tipos de repositorios

-   Una [**colección de repositorios públicos (producción)**]{.hl-yellow} donde hacer transparente el código y los datos ([**ya validados**]{.hl-purple}), coordinado por un nº reducido de personas.

-   Una [**colección de repositorios privados (desarrollo)**]{.hl-yellow} donde esté todo el equipo colaborando y donde se haga el [**trabajo del día**]{.hl-purple}, con trazabilidad interna.

---

## Nuestro primer repositorio

Vamos a [**crear nuestro primero repositorio**]{.hl-yellow} que servirá además como [**carta de presentación**]{.hl-yellow} de nuestro perfil en Github.

1.  [**Repositories**]{.hl-purple}: hacemos click en las pestaña de Repositories.

2.  [**New**]{.hl-purple}: hacemos click en el [**botón verde New**]{.hl-green} para crear un nuevo repositorio

![](img/new_repo.png)

---

## Nuestro primer repositorio

-   [**Repository name**]{.hl-purple}: el [**nombre del repositorio**]{.hl-yellow}. En este caso vamos a crear un repositorio muy concreto: el nombre debe [**coincidir exactamente con tu nombre de usuario**]{.hl-yellow}

-   [**Description**]{.hl-purple}: descripción de tu repositorio. En este caso será un repo de presentación.

![](img/repo_init_1.png)

---

## Nuestro primer repositorio

-   [**Public vs private**]{.hl-purple}: con cada repositorio tendremos la opción de hacer el repositorio

    -   [**público**]{.hl-purple}: todos los usuarios podrán ver el código así cómo la trazabilidad de su desarrollo (qué se añade y cuándo). Es para mí la opción más recomendable cuando quieres darle [**visibilidad y transparencia**]{.hl-yellow} a tu trabajo
    -   [**privado**]{.hl-purple}: solo tendrán acceso al repositorio aquellos usuarios a los que se lo permitas. No se podrá visualizar ni instalar nada de él fuera de Github.

![](img/repo_init_2.png)

En este caso concreto, dado que será un repositorio de presentación, lo [**haremos público**]{.hl-yellow}.

---

## Nuestro primer repositorio

-   [**Add a README file**]{.hl-purple}: un README file será el archivo donde incluiremos las [**instrucciones y detalles de uso**]{.hl-yellow} a los demás (en el caso de `{peRReo}` era el archivo que contenía los detalles de instalación)

![](img/repo_init_3.png)

De momento [**ignoraremos los demás campos**]{.hl-red} para este primer repositorio.

---

## Nuestro primer repositorio

![](img/repo_init_1.png)

Por defecto Github asume que este repositorio, con el [**mismo nombre que nuestro usuario**]{.hl-yellow} será el repositorio que querremos que se presente de inicio cuando alguien entra en nuestro perfil, y será el repositorio donde \[**incluir en el README.md**\] una presentación de nosotros y un índice de tu trabajo (si quieres).

---

## Nuestro primer repositorio

![](img/profile_github_md.png)

Fíjate que ahora en nuestra [**portada tenemos dicho README.md**]{.hl-yellow} que podemos personalizar a nuestro gusto haciendo uso de [**html y markdown**]{.hl-yellow}.

Aquí puedes ver [**algunos ejemplos de README.MD**](https://github.com/matiassingers/awesome-readme)

---

## Repo de código

Una vez que tenemos nuestro README de presentación (recuerda que puedes [**personalizar a tu gusto con html y markdown**]{.hl-yellow}) vamos a crear un [**repositorio de código**]{.hl-yellow}.

. . .

Si ya era importante [**trabajar con proyectos**]{.hl-yellow} en `RStudio`, cuando lo combinamos con Github es aún más crucial que creemos un proyecto antes de subir el código, así que vamos a crear uno de prueba que se llame `repo-github-1`.

. . .

En dicho proyecto vamos a [**crear un script**]{.hl-yellow} (en mi caso llamado **codigo.R**) en el que deberás hacer los siguientes pasos:

---

## Repo de código

1.  [**Carga**]{.hl-yellow} directamente desde la página del [ISCIII](https://cnecovid.isciii.es/covid19/resources) el archivo llamado `casos_hosp_uci_def_sexo_edad_provres.csv`

```{r}
#| eval: false
#| code-fold: true
# Carga de datos desde ISCIII
datos_covid <- read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
```

. . .

2.  [**Filtra**]{.hl-yellow} datos de Madrid (`"M"`), de 2020 y con sexo conocido (hombre/mujer). Tras ello quédate con las columnas `fecha`, `sexo`, `grupo_edad`, `num_casos` (ese orden). Por último obtén la suma de casos diarios por fecha y sexo.

```{r}
#| eval: false
#| code-fold: true
# Depuración
datos_madrid <-
  datos_covid |>
  # Filtrado por Madrid y fecha
  filter(provincia_iso == "M" & fecha <= "2020-12-31" & sexo != "NC") |> 
  # Selección de columnas
  select(provincia_iso:fecha, num_casos) |> 
  # Resumen de casos diarios por fecha y sexo
  summarise(num_casos = sum(num_casos), .by = c(fecha, sexo))
  
```

---

## Repo de código

3.  [**Exporta el dataset a un csv**]{.hl-yellow} en una carpeta que se llame `exportado`

```{r}
#| eval: false
#| code-fold: true
# Exportamos datos
write_csv(datos_madrid, file = "./exportado/datos_madrid.csv")
```

. . .

::: columns
::: {.column width="40%"}
4.  Crea una [**gráfica de líneas**]{.hl-yellow} que tenga en el eje x fecha, en el eje y casos, con una curva por sexo (gráficas separadas).

```{r}
#| eval: false
#| code-fold: true
# Gráfica
ggplot(datos_madrid) +
  geom_line(aes(x = fecha, y = num_casos, color = sexo),
            alpha = 0.6, linewidth = 0.7) +
  scale_color_manual(values = c("#85519D", "#278862")) +
  facet_wrap(~sexo) +
  theme_minimal() +
  theme(legend.position = "bottom")
```
:::

::: {.column width="60%"}
![](./img/ggplot.png){width="380"}
:::
:::

. . .

5.  Tras ello [**exportamos la gráfica**]{.hl-yellow}

```{r}
#| eval: false
ggsave(filename = "./exportado/ggplot.png", plot = last_plot(),
       bg = "white", width = 12, height = 8)
```

---

## Repo de código

¿Cómo [**subimos el proyecto**]{.hl-yellow}? Vamos de nuevo a [**crear un proyecto de cero**]{.hl-yellow}. Antes no hemos hablado de dos campos importantes:

::: columns
::: {.column width="50%"}
![](./img/repo-1.png){width="460"}
:::

::: {.column width="50%"}
-   `Add .gitignore` nos permitirá [**seleccionar el lenguaje**]{.hl-yellow} en el que estará nuestro proyecto para que Github lo entienda al sincronizar (y no actualice cosas que no deba).

-   `Choose a license` nos permitirá [**seleccionar la licencia**]{.hl-yellow} que determinará las condiciones en las que otros podrán reusar tu código.
:::
:::

---

## Repo de código

::: columns
::: {.column width="50%"}
![](./img/repo-1-1.png)
:::

::: {.column width="50%"}
Si te fijas traer crearlo tenemos solo 3 archivos: el de licencia, el .gitignore y el readme.md (donde deberíamos escribir una guía de uso de lo que hayamos subido)
:::
:::

Para subir los archivos vamos a clickar en [**Add file \< Upload File**]{.hl-purple} y [**arrastraremos TODOS los archivos**]{.hl-yellow} de la carpeta de nuestro proyecto.

---

## Repo de código

Tras la subida de archivos tendremos un cuadro llamado [**Commit changes**]{.hl-purple}

![](./img/commit-1.png)

Un [**commit**]{.hl-purple} es una [**modificación del repositorio**]{.hl-yellow} con algo que se añade/elimine/modifique, y dicho cuadro es recomendable usarlo para [**resumir en qué consiste la modificación**]{.hl-yellow}, de manera que quede trazado el cambio.

---

## Repo de código

Haciendo click en el reloj donde indica el [**número de commits**]{.hl-yellow} accedemos al [**histórico de commits (cambios)**]{.hl-yellow} con hora, día, autor, comentarios, etc.

![](./img/commit-reloj.png)

---

## Repo de código

Vamos a realizar un [**cambio en nuestro código**]{.hl-yellow}: en tu código local (local --\> tu ordenador), en lugar de filtrar por Madrid haz el [**filtro por Barcelona**]{.hl-yellow}, guarda el código y sube en el repositorio el nuevo archivo (con el mismo nombre, Github hará la sobrescritura)

```{r}
#| eval: false
#| code-line-numbers: "3"
datos_bcn <-
  datos_covid |>
  filter(provincia_iso == "B" & fecha <= "2020-12-31" & sexo != "NC") |> 
  select(fecha, sexo, grupo_edad, num_casos) |> 
  summarise(num_casos = sum(num_casos), .by = c(fecha, sexo))
```

---

## Consulta de commits

![](./img/barcelona_covid.png){width="550"}

::: columns
::: {.column width="40%"}
Si ahora [**consultamos el commit**]{.hl-yellow}, al lado hay un número que lo identifica, y clickando en él nos resume los cambios: no solo [**almacena todas las versiones pasadas**]{.hl-yellow} sino que además nos [**muestra las diferencias entre los archivos cambiados**]{.hl-yellow}
:::

::: {.column width="60%"}
![](./img/commit_cambio.png)
:::
:::

---

## Trazabilidad de cambios

::: columns
::: {.column width="72%"}
![](./img/commit_split.png) ![](./img/commit_unified.png)
:::

::: {.column width="28%"}
Tenemos [**dos modos de visualización**]{.hl-yellow} de los cambios: el modo split nos muestra el antiguo y el nuevo, con las inclusiones en verde y lo que ya no está en rojo; y el modo unified nos muestra todo en un mismo documento.
:::
:::

---

## Recuperación de commits

![](./img/browse-repo.png)

Github nos permite incluso [**recuperar una versión del pasado**]{.hl-yellow} de nuestro repositorio, haciendo click en el tercer icono del commit.

---

## Recuperación de commits

![](./img/branch-commit.png)

Si te fijas ahora al lado de `1 branch` tenemos un [**menú desplegable**]{.hl-yellow} en el que antes ponía `main` y ahora un número identificador del commit. Ya hablaremos de la idea de [**rama (branch)**]{.hl-yellow}

---

## Repo con rmd/qmd

::: columns
::: {.column width="60%"}
Vamos a poner en práctica lo aprendido:

1.  Crea un nuevo repositorio en Github (llamado `repo-github-2`) donde habrá alojado con proyecto de R.

2.  Crea un proyecto en `RStudio` que se llame (por ejemplo) `proyecto-qmd`

3.  Una vez dentro del proyecto en `RStudio` haz click en `File < New File < Quarto Document`
:::

::: {.column width="40%"}
![](./img/primer-qmd.png)
:::
:::

Deberás tener un documento similar a este: un [**quarto markdown (.qmd)**]{.hl-yellow}, un documento que nos permitirá incluir [**markdown + código**]{.hl-yellow} (puede ser `R` o puede ser `Observable`, `D3`, etc).

---

## Repo con rmd/qmd

Este formato es ideal para:

-   [**Trabajar en equipo**]{.hl-yellow} construyendo el borrador de una pieza.
-   Tomar [**apuntes o informes**]{.hl-yellow} para uno mismo.
-   [**Presentar**]{.hl-yellow} tu trabajo a tus compañeros.

::: columns
::: {.column width="50%"}
![](./img/prueba-qmd-html.png)
:::

::: {.column width="50%"}
Si te fijas ahora nuestro repositorio tiene un archivo con formato `.html`...es decir...

[**¡Es una web!**]{.hl-yellow}
:::
:::

---

## Github pages

¿Cómo [**convertir nuestro repositorio en una web**]{.hl-yellow}?

![](./img/github-pages.png)

1.  Haz click en `Settings`
2.  Ve al apartado `Pages`
3.  En el subapartado `branch` selecciona la única rama que tenemos ahora (`main`)
4.  Selecciona la carpeta donde tengas el `.html` (en web complejas estará como en cualquier web en `docs`, en algo simple estará en la ruta raiz del repositorio)
5.  Haz click en `Save`

---

## Github pages

Si te fijas en la [**parte superior del repositorio**]{.hl-yellow} ahora tenemos un icono naranja, que nos indica que la [**web está en proceso de ser desplegada (deploy)**]{.hl-orange}

![](./img/github-naranja.png)

---

## Github pages

Pasados unos segundos (dependiendo del tamaño de la web y tu conexión a internet) ese [**icono pasará a ser un check verde**]{.hl-green}: habemus web

![](./img/github-verde.png)

El [**link de la web por defecto**]{.hl-yellow} será `{nombre_usuario}.github.io/{nombre_repo}`

---

## Github pages

![](./img/github-pages-deploy.png)

¡Un momento! Ahora mismo nuestra web [**no nos está mostrando nuestro .qmd**]{.hl-red}, sino por defecto el [**README.md**]{.hl-yellow}.

. . .

Para que Github entienda que queremos visualizar ese `.html` que hemos generado a partir del `.qmd` vamos en nuestro proyecto local a [**borrar**]{.hl-yellow} todo lo que no sea nuestro archivo `.Rproj` y nuestro archivo `.qmd`, y vamos a [**cambiar el nombre**]{.hl-yellow} a este último llamándolo `index.qmd`, y volvemos a compilarlo para [**generar un index.html**]{.hl-yellow}

---

## Github pages

Vamos a [**subir a Github ese nuevo proyecto**]{.hl-yellow} con el cambio de nombre (llamado `repo-github-3`) para ver luego las diferencias entre uno y otro

![](./img/repo-index-html.png)

---

## Github pages

Si [**repetimos el proceso para hacer una Page**]{.hl-yellow} y esperamos al tick verde...

::: columns
::: {.column width="50%"}
![](./img/index-html-qmd.png)
:::

::: {.column width="50%"}
Si a tu `.qmd` ya le llamas de inicio `index.qmd`, automáticamente, al detectar Github un `index.html`, interpreta que ese [**archivo index.html**]{.hl-yellow} es el que define la web (y puedes personalizar añadiendo un archivo `css` de estilos)

[**Habemus web**]{.hl-green} simplemente clickando en Pages :)
:::
:::

---

## Repo con diapositivas

Vamos a crear el último repositorio que se llamará `repo-diapos`, y crear un proyecto en `RStudio` del mismo nombre (por ejemplo). Una vez creado le daremos a `File < New File < Quarto Presentation`.

::: columns
::: {.column width="45%"}
![](img/quarto-slides.png)
:::

::: {.column width="55%"}
La forma de escribir será igual que un `.qmd` normal solo que ahora [**cada diapositiva la separaremos**]{.hl-yellow} con un `---` (usando archivos de estilos podemos personalizar lo que queramos)

Llama al archivo directamente `index.qmd`, súbelo a Github y con un click en Pages tienes una [**web con tus diapositivas**]{.hl-yellow}
:::
:::

---

## Uso de Gitkraken

La forma más [**sencilla para trabajar de manera colaborativa**]{.hl-yellow} en Github, y tenerlo sincronizado con nuestro local, es hacer uso de [Gitkraken](https://www.gitkraken.com/download)

::: columns
::: {.column width="50%"}
![](img/gitkraken-repo.png)
:::

::: {.column width="50%"}
Una vez dentro clickamos en el icono de la carpeta (`Repo Management`) y si ya tenemos el repositorio en Github seleccionamos `Clone`, indicando donde queremos clonar (en nuestro local) y que [**repositorio de Github queremos clonar**]{.hl-yellow}.
:::
:::

---

## Uso de Gitkraken

::: columns
::: {.column width="50%"}
![](img/view-change.png)
:::

::: {.column width="50%"}
Una vez clonado, la idea es que cada [**cambio que hagamos en local nos aparecerá en Gitkraken**]{.hl-yellow} como `View changes`.
:::
:::

---

## Uso de Gitkraken

Cuando tengas suficientes cambios como para [**actualizar el repositorio**]{.hl-yellow} (tampoco tiene sentido actualizar con cada edición), verás algo similar a esto con todos los [**commits realizados**]{.hl-yellow}

::: columns
::: {.column width="50%"}
![](img/stage-all-changes.png)
:::

::: {.column width="50%"}
Podrás decidir cuáles de los [**commits locales quieres incluir en remoto**]{.hl-yellow}, bien uno a uno o en `Stage all changes` (para todos)
:::
:::

---

## Uso de Gitkraken

Tras incluir los commits deberás incluir un [**título y descripción del commit**]{.hl-yellow}

![](img/titulo-commit.png)

---

## Uso de Gitkraken

Tras hacerlo verás que ahora tenemos [**dos iconos separados en una especie de árbol**]{.hl-yellow} (¿te acuerdas de la `branch` o rama?):

-   [**Ordenador**]{.hl-purple}: la versión del repositorio que tienes en tu [**ordenador**]{.hl-yellow}.

-   [**Logo**]{.hl-purple}: la versión del repositorio que tienes [**subida en remoto**]{.hl-yellow}

![](img/split-gitkraken.png)

---

## Uso de Gitkraken

Mientras eso suceda solo tendrás sincronizado tu ordenador con Gitkraken, pero no con Github. Para ello haremos [**click en Push**]{.hl-yellow} (con `Pull` podrás forzar a tener en local lo mismo que en remoto).

![](img/push-gitkraken.png)

---

## Branchs

Como hemos mencionado ya en varias ocasiones, hay un elefante en la habitación que aún no hemos mentado: las [**ramas o branchs**]{.hl-yellow} de un repositorio.

. . .

Imagina que estáis trabajando varios en un proyecto y teneís una versión que funciona pero que queréis [**modificar en paralelo a partir del estado actual**]{.hl-yellow} del repositorio.

. . .

Las [**ramas**]{.hl-yellow} nos permiten partir de una versión común del repositorio y hacer cambios que [**no afecten a los demás**]{.hl-yellow}

---

## Branchs

Para [**crear una rama**]{.hl-yellow} a partir del estado actual de repositorio haremos click en `Branch` y le pondremos un nombre

![](img/branch-button.png)

Una vez creada verás [**dos iconos**]{.hl-yellow} y un [**menú desplegable**]{.hl-yellow} con las distintas ramas en las que quieres hacer el commit. Imagina que realizas un cambio pero [**no quieres añadirlo a la rama principal**]{.hl-yellow}: puedes hacer el [**commit en tu rama propia en LOCAL**]{.hl-yellow} (lo harás en la rama activa de tu menú de branchs).

---

## Branchs

La primera vez te pedirá que escribas la [**rama en REMOTO**]{.hl-yellow} con la quieres sincronizar tu rama en local. [**Consejo**]{.hl-green}: ponle el mismo nombre en remoto que en local.

![](img/name-branch.png)

---

## Branchs

Fíjate que ahora tenemos el ordenador y el logo en el mismo sitio. Esto no significa que tengas ambas ramas en tu local, solo que [**Gitkraken tiene ambas sincronizadas**]{.hl-yellow}: clickando en cualquiera de ellas, tus archivos en tu ordenador cambiarán.

![](img/both-branchs.png)

---

## Pull request

Lo más recomendable es que [**solo se incorpore de una rama secundaria**]{.hl-yellow} a la rama principal aquello que está [**validado por un/a coordinador/a**]{.hl-yellow} del repositorio, asegurándose que todo funciona correctamente.

Cuando queramos incluirlo haremos [**click con botón derecho**]{.hl-yellow} en el icono de la rama secundaria y seleccionamos `Start a pull request to origin from...`

![](img/pull-request-menu.png)

. . .

Una [**pull request**]{.hl-yellow} será una [**petición al responsable de la rama principal**]{.hl-yellow} para incluir los cambios

---

## Pull request

::: columns
::: {.column width="60%"}
![](img/create-pull-request.png)
:::

::: {.column width="40%"}
En el cuadro que no se abre deberemos escribir:

-   La [**rama**]{.hl-yellow} a la que hacer el `merge` (normalmente la `main`)
-   Título y resumen de los cambios
-   Puedes incluso asignar un [**revisor**]{.hl-yellow} entre los colaboradores del repo.
-   Puedes asignar [**etiquetas**]{.hl-yellow}
:::
:::

---

## Pull request

Mientras no se acepte aparecerá un [**icono de rama**]{.hl-yellow} y un +1 en Pull Requests

![](img/pending-branch.png){width="500"}

. . .

Si somos al mantenedor del repositorio, haciendo click en el menú nos saldrán las ramas que nos quieren hacer hacer `merge`

![](img/menu-pr.png){width="500"}

---

## Pull request

Al hacer click se abrirá un [**cuadro de Pull Request**]{.hl-yellow} para decidir si

-   [**Revisar**]{.hl-yellow} los cambios
-   [**Aprobar**]{.hl-yellow} el `merge`
-   [**Añadir comentarios**]{.hl-yellow} al que ha solicitado el `merge` por si queremos solicitar algún cambio [**antes de ser aprobado**]{.hl-yellow}

## ![](img/menu-pr-2.png)

## Pull request

Tras revisar todo y aprobarlo clickaremos en `Confirm merge`, y tras ello podremos decidir si esa rama que era paralela a la principal la queremos [**eliminar**]{.hl-yellow} o dejar visible a todos (consejo: dejar visible para tene [**trazabilidad**]{.hl-yellow} del proyecto de trabajo)

::: columns
::: {.column width="50%"}
![](img/merge-branch.png)
:::

::: {.column width="50%"}
![](img/delete-branch.png)
:::
:::
