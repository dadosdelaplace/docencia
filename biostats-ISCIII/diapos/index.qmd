---
title: "Bioestadística en R"
subtitle: "Introducción a la estadística en R"
title-slide-attributes:
  data-background-image: img/data-science-2.jpeg
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Máster de Bioinformática • Javier Álvarez Liébana"
affiliation: Instituto de Salud Carlos III (ISCIII)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier Álvarez Liébana</strong>](...) • Máster de Bioinformática (ISCIII)"
    slide-number: c/t
execute:
  echo: true
---

::: r-fit-text
[¡Bienvenidos a R!]{.flow}
:::

[**Dejad vuestras hojas de cálculo y SPSS a un lado**]{style="color:#444442;"}

---

## ¡Buenas!

[**Correo**]{.hl-green}: **<javalv09@ucm.es>**. [**Despacho**]{.hl-green}: 722 (3ª planta de la Facultad de Estudios Estadísticos de la UCM). 

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
-   [**Javier Álvarez Liébana**]{.hl-yellow}, de Carabanchel (Bajo).

-   Licenciado en Matemáticas (UCM). [**Doctorado en estadística**]{.hl-yellow} (UGR).

-   Encargado de la [**visualización y análisis de datos covid**]{.hl-yellow} del Principado de Asturias (2021-2022).

-   Miembro de la [**Sociedad Española de Estadística e IO**]{.hl-yellow} y la [**Real Sociedad Matemática Española**]{.hl-yellow}.
:::
:::
:::


Actualmente, [**investigador y docente en la Facultad de Estadística de la UCM**]{.hl-yellow}. Divulgando por [**Twitter**](https://twitter.com/dadosdelaplace) e [**Instagram**](https://instagram.com/javieralvarezliebana)


---

## Objetivos

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
-   Quitarnos el [**miedo a los errores en programación**]{.hl-yellow} → a programar se aprende programando

-   Entender los [**conceptos básicos de R**]{.hl-yellow} desde cero → aprender a abstraer ideas y algoritmos

-   Utilidad de programar → flujos de trabajo [**reproducibles**, **transparentes**]{.hl-yellow} y mantenibles

-   Introducción al [**análisis y preprocesamiento**]{.hl-yellow} de datos → `{tidyverse}`

-   Adquirir habilidades en la [**visualización de datos**]{.hl-yellow} → `{ggplot2}`

-   Adquirir habilidades en la [**modelización lineal**]{.hl-yellow} 

:::
:::
:::


---

## Planificación {#planificacion}

::: column-screen-inset-right
::: {style="font-size:20px"}
|  CLASE | SEMANA | FECHAS | TOPIC | EJ. | WORKBOOK | ENTREGA | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
| [1](#clase-1) | S1 | 17 oct | Primeros pasos. Tipos de datos y vectores | [💻](#tu-turno-1-1) [💻](#tu-turno-1-2) [💻](#tu-turno-1-3) | [🐣](#caso-practico-1-1)  |  | 
| [2](#clase-2) | S2 | 22 oct | Primeras bases de datos |  [💻](#tu-turno-2-1) [💻](#tu-turno-2-2) |   [🐣](#caso-practico-2-1)  [🐣](#caso-practico-2-2) [🐣](#caso-practico-2-3)  |  |
| [3](#clase-3) | S2 | 24 oct | Estructuras de control y Quarto | [💻](#tu-turno-3-1) [💻](#tu-turno-3-2) | [🐣](#caso-practico-3-1)  | |
| [4](#clase-4) | S3 | 29 oct | Funciones y ggplot | [💻](#tu-turno-4-1) [💻](#tu-turno-4-2) | [🐣](#caso-practico-4-1) [🐣](#caso-practico-4-2)  | |
:::
:::

---

## Materiales

* [**Diapositivas**]{.hl-yellow}: diapositivas en `Quarto` disponibles y actualizadas en **<https://javieralvarezliebana.es/docencia/biostats-ISCII>**. En el menú de las diapositivas (abajo a la izquierda) tienes una [**opción para descargarlas en pdf**]{.hl-yellow} en `Tools`
  
&nbsp;

* [**Material**]{.hl-yellow}: [**cuadernos de trabajo**](https://javieralvarezliebana.es/docencia/biostats-ISCII/material/) y materiales extras y **resúmenes de paquetes**

* [🗃 **Datos**]{.hl-yellow}: datasets que usaremos a lo largo de la asignatura, disponibles en **<https://javieralvarezliebana.es/docencia/biostats-ISCII/material>**

* [📚 **Recursos de apoyo**]{.hl-yellow}: en inglés <https://r4ds.had.co.nz/> y en castellano <https://cdr-book.github.io/>, y <https://ivelasq.quarto.pub/intro-to-quarto/> para Quarto.


# Clase 1: [primeros pasos]{.flow} {#clase-1}

[**Instalando R y RStudio. Primeros pasos: ¿qué tipos de celdas (datos) existen?**]{style="color:#444442;"}


* [💻 Ejercicios resueltos: R y RStudio](#tu-turno-1-1)
* [💻 Ejercicios resueltos: tipos de datos](#tu-turno-1-2)
* [💻 Ejercicios resueltos: vectores](#tu-turno-1-3) 
* [🐣 Workbook/caso práctico I](#caso-practico-1-1)
* [📆 Planificación](#planificacion)

---

## Requisitos

Para el curso los únicos requisitos serán:

1.  [**Conexión a internet**]{.hl-yellow} (para la descarga de algunos datos y paquetes).

. . .

2.  [**Instalar R**]{.hl-yellow}: será nuestro lenguaje. La descarga la haremos (gratuitamente) desde <https://cran.r-project.org/>

. . .

3.  [**Instalar RStudio**]{.hl-yellow} desde <https://posit.co/download/rstudio-desktop/>


::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="420"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="420"}
:::
:::

---

## R vs RStudio

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="360"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="430"}
:::
:::

::: {.fragment .fade-in-then-out}
Programaremos como escribimos (castellano, por ejemplo) → `R` es [**lenguaje**]{.hl-yellow}
:::

::: {.fragment .fade-up}
-   Necesitaremos una [**gramática, un lenguaje**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}
-   Y un entorno, por ejemplo un [**Word**]{.hl-yellow} (`RStudio`), para escribirlo
:::
:::

---

## Instalación de R

El lenguaje `R` será nuestra [**gramática y ortografía**]{.hl-yellow} (nuestras reglas de juego)

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra en <https://cran.r-project.org/> y selecciona tu sistema operativo.

-   [**Paso 2**]{.hl-yellow}: para Mac basta con que hacer click en el **archivo .pkg**, y abrirlo una vez descargado. Para sistemas Windows, debemos clickar en **install R for the first time** y después en **Download R for Windows**. Una vez descargado, abrirlo como cualquier archivo de instalación.

-   [**Paso 3**]{.hl-yellow}: abrir el ejecutable de instalación.
:::

. . .

::: callout-warning
Siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), [**asegúrate de tener conexión a internet**]{.hl-orange}.
:::

---

## Primera operación {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalación, tras abrir `R`, deberías ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**Primer código**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el código en la consola y daremos «enter»). Tras ello haremos la suma `a + b`.

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## Primera operación {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalación, tras abrir `R`, deberías ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Primer código**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el código en la consola y daremos «enter»). Tras ello haremos la suma `a + b`.


```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

---

## Primera operación {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalación, tras abrir `R`, deberías ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Primer código**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el código en la consola y daremos «enter»). Tras ello haremos la suma `a + b`.


```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

. . .

::: callout-note
## Fíjate que...

En la consola aparece un número `[1]`: simplemente es un contador de elementos (como contar filas en un Word)
:::

---

## Instalación de R Studio

`RStudio` será el [**Word**]{.hl-yellow} que usaremos para escribir (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra la [web oficial de RStudio](https://posit.co/download/rstudio-desktop/) (ahora llamado Posit) y selecciona la descarga gratuita.

-   [**Paso 2**]{.hl-yellow}: selecciona el ejecutable que te aparezca acorde a tu sistema operativo.

-   [**Paso 3**]{.hl-yellow}: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro y dejar que termine la instalación.
:::

---

## Organización de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo código que antes (la suma de las variables) en ella. La consola será donde **ejecutaremos órdenes y mostraremos resultados**.

![](img/consola_rstudio.jpg){width="420"}

---

## Organización de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Environment**]{.hl-yellow}: la pantalla pequeña (puedes ajustar los márgenes con el ratón a tu gusto) que tenemos en la parte superior derecha. Nos mostrará las **variables que tenemos definidas**.

![](img/environment.jpg){width="420"}

---

## Organización de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha no servirá para buscar **ayuda de funciones**, además de para **visualizar gráficos**.

![](img/multiusos.jpg){width="420"}

---

## ¿Qué es R? ¿Por qué R?

![](img/meme_barco.jpg)

---


## ¿Qué es R? ¿Por qué R?

![](img/incel_excel.png)

`R` es la evolución del trabajo de los laboratorios Bell con el lenguaje `S`, que fue llevado al mundo del software libre por Ross Ihaka y Robert Gentleman en los años 90. La version `R 1.0.0` se publicó el 29 de febrero de 2000.


---

## ¿Qué es R? ¿Por qué R?

`R` es el [**lenguaje estadístico por excelencia**]{.hl-yellow}, creado por y para estadísticos/as, con 6 ventajas fundamentales [**frente a Excel, SAS, Stata o SPSS**]{.hl-red}:

. . .

-   [**Lenguaje de programación**]{.hl-yellow}: la obviedad → análisis [**replicables**]{.hl-purple}

. . .

-   [**Gratuito**]{.hl-yellow}: la filosofía de la comunidad de `R` es el compartir código bajo **copyleft** → **uso ético de dinero y algoritmos**

. . .

-   [**Software libre**]{.hl-yellow}: no solo es gratis sino que permite acceder libremente a código ajeno, incluso al **propio código fuente** → [**flexibilidad y transparencia**]{.hl-purple} (Free and Open Source Software FOSS)

---

## ¿Qué es R? ¿Por qué R?

`R` es el [**lenguaje estadístico por excelencia**]{.hl-yellow}, creado por y para estadísticos/as, con 6 ventajas fundamentales [**frente a Excel, SAS, Stata o SPSS**]{.hl-red}:


-   [**Lenguaje modular**]{.hl-yellow}: hemos instalado lo mínimo, pero existen códigos de otras personas que podemos reusar (casi 20 000 [**paquetes**]{.hl-yellow}) → [**ahorro de tiempo**]{.hl-purple} e [**innovación inmediata**]{.hl-purple}

. . .

-   [**Lenguaje de alto nivel**]{.hl-yellow}: facilita la programación (como Python) → [**menor curva de aprendizaje**]{.hl-purple}

. . .

- [**Comunidad y empleabilidad**]{.hl-yellow}: junto con Python es el lenguaje más utilizado en el campo de la estadística y la ciencia de datos en investigación, docencia, empresas (Línea Directa, Mapfre, Telefónica, Orange, Apple, Spotify, Netflix, El País, Civio, HP, etc) y organismos públicos (ISCIII, CNIC, CNIO, INE, IGN, CIS, CEO, DGT, AEMET, RTVE, etc) 


---

## ¿Por qué programar?

-   [**Automatizar**]{.hl-yellow} → te permitirá automatizar tareas recurrentes.

-   [**Replicabilidad**]{.hl-yellow} → podrás replicar tu análisis siempre de la misma manera.

-   [**Flexibilidad**]{.hl-yellow} → podrás adaptar el software a tus necesidades.

-   [**Transparencia**]{.hl-yellow} → ser auditado por la comunidad.

![](img/the_general_problem.png)

---

## Idea fundamental: paquetes

Una de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: códigos que otras personas han implementado para **resolver un problema**

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}
-   [**Instalación**]{.hl-yellow}: descargamos los códigos de la web (necesitamos internet) → [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)

```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}
-   [**Carga**]{.hl-yellow}: con el paquete descargado, indicamos qué paquetes queremos usar cada vez que abramos `RStudio` → [**traer el libro de la estantería**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::
:::
:::

---

## Idea fundamental: paquetes

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
Una vez instalado, hay **dos manera de usar un paquete** (traerlo de la estantería)

::: {.fragment fragment-index="1"}
-   [**Paquete entero**]{.hl-yellow}: con `library()`, usando el nombre del paquete sin comillas, cargamos en la sesión [**todo el libro**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}
-   [**Funciones concretas**]{.hl-yellow} usando `paquete::funcion` le índicamos que solo queremos una [**página concreta de ese libro**]{.hl-purple}

```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## Te vas equivocar

Durante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera → [**te vas equivocar**]{.hl-yellow}. No solo será importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.

. . .

-   [**Mensajes de error**]{.hl-red}: precedidos de **«Error in...»** y serán aquellos fallos que [**impidan la ejecución**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Mensajes de warning**]{.hl-orange}: precedidos de **«Warning in...»** son los (posibles) fallos más delicados ya que son incoherencias que [**no impiden la ejecución**]{.hl-orange}

```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```

---

## Scripts (documentos .R)


::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}
Un [**script**]{.hl-yellow} será el documento en el que programamos, nuestro archivo `.doc` (aquí con extensión `.R`) donde escribiremos las órdenes. Para **abrir nuestro primero script**, haz click en el menú en `File < New File < R Script`.

::: callout-warning
## Cuidado

Es importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habrás perdido**]{.hl-orange}.
:::

:::
:::



::: callout-warning
## Cuidado

`R` es [**case-sensitive**]{.hl-orange}: es sensible a mayúsculas y minúsculas por lo que `x` y `X` representa variables distintas.
:::


---

## Ejecutando el primer script

Ahora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros códigos**]{.hl-yellow}. ¿Cómo ejecutarlo?

. . .

1.  **Escribimos** el código a ejecutar.

. . .

2.  **Guardamos** el archivo .R haciendo click en `Save current document`.

. . .

3.  El código no se ejecuta salvo que se lo indiquemos. Tenemos **tres opciones de ejecutar un script**:

-   [**Copiar y pegar**]{.hl-yellow} en consola.
-   [**Seleccionar líneas**]{.hl-yellow} y `Ctrl+Enter`
-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el código **completo**.

---


## Sé organizado: proyectos

De la misma manera que en el ordenador solemos trabajar de manera [**ordenada por carpetas**]{.hl-yellow}, en `RStudio` podemos hacer lo mismo para trabajar de [**manera eficaz creando proyectos**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
Un [**proyecto será una «carpeta»**]{.hl-yellow} dentro de `RStudio`, de manera que nuestro directorio raíz automáticamente será la propia carpeta de proyecto (pudiendo pasar de un proyecto a otro con el menu superior derecho).

Podemos crear uno en una carpeta nueva o en una carpeta ya existente.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::


---

## 💻 Tu turno {#tu-turno-1-1}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Crea en tu ordenador una carpeta de la asignatura y crea dentro de ella el proyecto de `RStudio`: es ahí donde vas a guardar todo lo que hagamos a lo largo de este curso.Tras crear el proyecto tendrás un archivo `R Project`. A continuación crea en dicha carpeta dos subcarpetas: `datos` (es ahí donde irás guardando los distintos datasets que usaremos) y `scripts` (es ahí donde irás guardando los archivos `.R` de cada clase)

### [**Ejercicio 2**]{.hl-yellow}

📝 Dentro del proyecto crea un script `ejercicios-clase1.R` (dentro de la carpeta `scripts`). Una vez creado define en él una variable de nombre `a` y cuyo valor sea -1. Ejecuta el código de las 3 maneras explicadas.

```{r}
#| code-fold: true
a <- -1
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Añade debajo otra línea para definir una variable `b` con el valor 5. Tras ello guarda la multiplicación de ambas variables. Ejecuta el código como consideres.

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # sin guardar
multiplicacion <- a * b # guardado
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Modifica el código inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables y guarda el resultado.

```{r}
#| eval: false
c <- # deberías asignarle el valor 3
d <- # deberías asignarle el valor -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d # sin guardar
division <- c / d # guardado
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Asigna un valor positivo a `x` y calcula su raíz cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la función `abs()`.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

::: callout-note
## Toma nota

Comandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: líneas de código que hemos «encapsulado» bajo un nombre, y dado unos argumentos de entrada, ejecuta las órdenes (una especie de atajo). En las funciones los [**argumentos irán SIEMPRE entre paréntesis**]{.hl-yellow}
:::


### [**Ejercicio 6**]{.hl-yellow}

📝 Usando la variable `x` ya definida, completa/modifica el código inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.

```{r}
#| eval: false
z <- ? - ? # completa el código
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Define una variable `x` y asígnale el valor `-1`. Define otra `y` y asígnale el valor `0`. Tras ello realiza las operaciones a) `x` entre `y`; b) raíz cuadrada de `x`. ¿Qué obtienes?



```{r}
#| code-fold: true
#| eval: false
x <- -1
y <- 0

x / y
sqrt(x)
```

### [**Ejercicio 8**]{.hl-yellow}

📝 Escribe el código inferior en tu script. ¿Por qué crees que no funciona?


```{r}
#| error: true
x <- -1
y <- 0

X + y
```

:::



---

## De la CELDA a la TABLA

¿Qué [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg)

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenación** de valores del mismo tipo ([**vectores en R**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenación de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenación de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenación de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

---

## Pero antes...buenas prácticas

Antes de seguir, es importante que sepas algo cuánto antes: [**empezar en la programación puede ser frustrante**]{.hl-yellow}

. . .

Al igual que cuando aprendes un idioma nuevo, el primer obstáculo a solventar no es tanto qué decir sino cómo decirlo de manera correcta. Y en `R` pasa lo mismo, así que vamos a [**normalizar nuestra forma de programar**]{.hl-yellow} lo máximo posible para evitar errores futuros.

. . .

* [**Tip 1**]{.hl-green}: [**asignar, evaluar y comparar no es lo mismo**]{.hl-yellow}. Si te has fijado en `R` estamos usando `<-` para asignar valores a variables. Usaremos `=` para evaluar argumentos en funciones y `==` para saber si dos elementos son iguales.

```{r}
#| eval: false
x <- 1 # asignar
x = 1 # evaluar
x == 1 # comparar
```



---

## Pero antes...buenas prácticas

* [**Tip 2**]{.hl-green}: programa como escribes. Al igual que cuando redactas en castellano, acostúmbrate a incorporar [**espacios y saltos de línea**]{.hl-yellow} paranoquedarteciego (es una buena práctica y no un requisito porque `R` no procesa los espacios)

```{r}
#| eval: false
x <- 1 # óptimo
x<-1 # regu
x<- 1 # peor (decídete)
```

. . .

* [**Tip 3**]{.hl-green}: no seas caótico/a, [**estandariza nombres**]{.hl-yellow}. Acostúmbrate siempre a nombrar las variables de la misma manera. El único requisito es que **debe empezar siempre por una letra** (y sin tildes). La forma más recomendable es la conocida como `snake_case`

```{r}
#| eval: false
variable_en_modo_snake_case
otraFormaMasDificilDeLeer
hay.gente.que.usa.esto
Incluso_Haygente.Caotica_que.NoMereceNuestraATENCION
```

---

## Pero antes...buenas prácticas

* [**Tip 4**]{.hl-green}: facilita la lectura y escritura, [**pon límites**]{.hl-yellow}. En `Tools < Global Options` puedes personalizar algunas opciones de `RStudio`. En `Code < Display` podemos indicarle en `Show margin` que los scripts nos muestren un margen "imaginario" (no interacciona con el código) para "forzarnos" a realizar un salto de línea.

![](img/show_margin.jpg)


---

## Pero antes...buenas prácticas

* [**Tip 5**]{.hl-green}: el [**tabulador es tu mejor amigo**]{.hl-yellow}. En `RStudio` tenemos una herramienta maravillosa: si escribes parte del nombre de una variable o función y tabulas, `RStudio` te autocompleta

![](img/tab-autocompletar.png)  


---

## Pero antes...buenas prácticas

* [**Tip 6**]{.hl-green}: ni un paréntesis soltero. Siempre que abras un paréntesis deberás cerrarlo. Para facilitar esta tarea entra en `Tools < Global Options < Code < Display` y activa la opción `Rainbow parentheses`

![](img/rainbow-parentheses.jpg)



---

## Pero antes...buenas prácticas

* [**Tip 7**]{.hl-green}: fíjate en el lateral izquierdo. No solo podrás ver la línea de código por la que vas sino que, en caso de estar cometiendo un [**error de sintaxis**]{.hl-red}, el propio `RStudio` te avisará.

![](img/rstudio-error-sintaxis.png)

* [**Tip 8**]{.hl-green}: intenta [**trabajar siempre por proyectos**]{.hl-yellow} (para esta clase, crea un script `clase2.R` en el proyecto que creamos en la anterior clase)

&nbsp;

Ver más tips en <https://r4ds.had.co.nz/workflow-basics.html#whats-in-a-name>

---

## Celdas: tipos de datos

¿Existen [**variables más allá de los números en la ciencia de datos**]{.hl-yellow}? Piensa por ejemplo en los datos que podrías guardar de una persona:

::: {.fragment .fade-up}
-   La edad o el peso será un [**número**]{.hl-yellow}.

```{r}
edad <- 33
```
:::

::: {.fragment .fade-up}
-   Su nombre será una cadena de [**texto (conocida como string o char)**]{.hl-yellow}.

```{r}
nombre <- "javi"
```
:::

::: {.fragment .fade-up}
-   A la pregunta «¿estás matriculado en la Facultad?» la respuesta será lo que llamamos una [**variable lógica**]{.hl-yellow} (`TRUE` si está matriculado o `FALSE` en otro caso).

```{r}
matriculado <- TRUE
```
:::

::: {.fragment .fade-up}
-   Su fecha de nacimiento será precisamente eso, una [**fecha**]{.hl-yellow}.
:::

---

## Variables numéricas {auto-animate="true"}

El dato más sencillo (ya lo hemos usado) serán las [**variables numéricas**]{.hl-yellow}. Para saber la [**clase de dato en R**]{.hl-yellow}  de una variable tenemos la función `class()`

```{r}
#| eval: false
#| code-line-numbers: "1"
a <- 5
```



---

## Variables numéricas {auto-animate="true"}

El dato más sencillo (ya lo hemos usado) serán las [**variables numéricas**]{.hl-yellow}. Para saber la [**clase de dato en R**]{.hl-yellow}  de una variable tenemos la función `class()`


```{r}
#| eval: false
#| code-line-numbers: "2"
a <- 5
class(a)
```

. . .

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

Para saber su [**tipología (naturaleza o formato)**]{.hl-yellow} variable tenemos `typeof()`

```{r}
typeof(1) # 1 pero almacenado como un valor real (double, con decimales)
typeof(as.integer(1)) # 1 pero almacenado como un entero.
```

::: callout-note
## Fíjate que...

En `R` tenemos una colección de funciones que empiezan por `as.x()` y que sirven como [**funciones de conversión**]{.hl-yellow}: un dato que era de un tipo, lo convertimos a tipo `x`.
:::

---


## Variables numéricas


Además de los números «normales» tendremos el [**valor más/menos infinito**]{.hl-yellow} codificado como `Inf` o `-Inf`

```{r}
1/0
```

```{r}
-1/0
```

. . .

Y valores que [**no son números reales**]{.hl-yellow} _not a number_ (indeterminaciones, complejos, etc) codificado como `NaN`

```{r}
0/0
```

```{r}
sqrt(-2)
```



---

## Variables numéricas

Con las variables numéricas podemos realizar las [**operaciones aritméticas**]{.hl-yellow} de una calculadora: sumar (`+`)...

```{r}
a + b
```

. . .

...raíz cuadrada (`sqrt()`)...

```{r}
sqrt(a)
```

. . .

... potencias (`^2`, `^3`)...

```{r}
a^2
```

. . .

...valor absoluto (`abs()`), etc.

```{r}
abs(a)
```





---

## Variables de texto

Imagina que además de la edad de una persona queremos guardar su nombre: ahora la variable será de tipo `character`

```{r}
nombre <- "Javier"
class(nombre)
```

. . .

Las [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones aritméticas**]{.hl-red} (sí otras operaciones como pegar o localizar patrones).

```{r}
#| error: true
nombre + 1 # error al sumar número a texto
```

. . .

::: callout-warning
## Recuerda que...

Las variables de tipo texto (character o string) van [**SIEMPRE entre comillas**]{.hl-orange}: no es lo mismo `TRUE` (valor lógico, binario) que `"TRUE"` (texto).
:::

---

## Primera función: paste

Como hemos comentado `R` llamaremos [**función**]{.hl-yellow} a un trozo de [**código encapsulado**]{.hl-yellow} bajo un nombre, y que depende de unos [**argumentos**]{.hl-yellow} de entrada. Nuestra primera función será `paste()`: dadas dos cadenas de texto nos permite pegarlas.

```{r}
paste("Javier", "Álvarez")
```

. . .

Fíjate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos añadir un [**argumento opcional**]{.hl-yellow} para indicarle el separador (en `sep = ...`). 

```{r}
paste("Javier", "Álvarez", sep = "*")
```

---

## Primera función: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}
¿Cómo saber [**qué argumentos necesita una función**]{.hl-yellow}? Escribiendo en consola `? paste` te aparecerá una [**ayuda**]{.hl-yellow} en el panel multiusos.

En dicha ayuda podrás ver en su cabecera que argumentos ya tiene [**asignados por defecto**]{.hl-yellow} la función
:::
:::

. . .

Existe una función similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).

```{r}
paste0("Javier", "Álvarez")
```

---

## Primera función: paste

Los argumentos (y su detalle) también pueden ser consultado **tabulando (detras una coma)**.

![](img/tab-functions.png)

--- 

## Funciones: argumentos por defecto

Es muy importante entender el concepto de [**argumento por defecto de una función**]{.hl-yellow} en `R`: es un valor que la función usa pero a veces podemos no ver porque [**ya tiene un valor asignado**]{.hl-yellow}. 

```{r}
# Hacen lo mismo
paste("Javier", "Álvarez")
paste("Javier", "Álvarez", sep = " ")
```

. . .

::: callout-note
## Toma nota

El operador `=` lo [**reservaremos para asignar argumentos**]{.hl-yellow} dentro de funciones. Para todas las demás asignaciones usaremos `<-`
:::

---

## Primer paquete: glue

Una forma más intuitiva de trabajar con textos es usar el paquete `{glue}`: lo primero que haremos será «comprar el libro» (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue") # solo la primra vez
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

Con la función `glue()` de dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, «la edad es de ... años», donde la edad está guardada en una variable.

```{r}
edad <- 33
glue("La edad es de {edad} años")
```

. . .

Dentro de las llaves también podemos [**ejecutar operaciones**]{.hl-yellow}

```{r}
unidades <- "días"
glue("La edad es de {edad * 365} {unidades}")
```

---

## Variables lógicas

Otro tipo fundamental serán las [**variables lógicas o binarias**]{.hl-yellow} (**dos valores**):

-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.
-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.

```{r}
soltero <- TRUE # ¿Es soltero? --> SÍ
class(soltero)
```

. . .

Dado que internamente están guardados como variables binarias, podemos [**realizar operaciones aritméticas**]{.hl-yellow} con ellas

```{r}
2 * TRUE
FALSE - 1
```

---

## Variables lógicas

Como veremos en breve, las variables lógicas en realidad puede tomar un tercer valor: `NA` o [**dato ausente**]{.hl-yellow}, representando las siglas de *not available*, y será muy habitual encontrarlo dentro de una base de datos.

```{r}
ausente <- NA
ausente + 1
```


. . .

::: callout-important
## Importante

Las variables lógicas [**NO son variables de texto**]{.hl-red}: `"TRUE"` es un texto, `TRUE` es un valor lógico.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Condiciones lógicas

Los valores lógicos suelen ser resultado de [**evaluar condiciones lógicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos [**comprobar**]{.hl-yellow} si una persona se llama Javi.

```{r}
nombre <- "María"
```


. . .

Con el [**operador lógico**]{.hl-yellow} `==` preguntamos sí lo que tenemos guardado a la izquierda es [**igual que**]{.hl-purple} lo que tenemos a la derecha: es una [**pregunta**]{.hl-yellow}

```{r}
nombre == "Javi"
```

. . .

Con su opuesto `!=` preguntamos [**si es distinto**]{.hl-purple}.

```{r}
nombre != "Javi"
```

. . .

::: callout-note
## Fíjate que...

No es lo mismo `<-` ([**asignación**]{.hl-yellow}) que `==` (estamos [**preguntando**]{.hl-yellow}, es una comparación lógica).
:::

---

## Condiciones lógicas

Además de las comparaciones «igual a» frente «distinto», también comparaciones de orden como [**menor que**]{.hl-purple} `<`, [**mayor que**]{.hl-purple} `>`,  `<=` o `>=`.

**¿Tiene la persona menos de 32 años?**

```{r}
edad <- 34
edad < 32 # ¿Es la edad menor de 32 años?
```

. . .

**¿La edad es mayor o igual que 38 años?**

```{r}
edad >= 38
```

. . .

**¿El nombre guardado es Javi?**

```{r}
nombre <- "Javi"
nombre == "Javi"
```

---

## Variables de fecha

Un tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.

```{r}
fecha_char <- "2021-04-21"
```

Parece una simple cadena de texto pero [**debería representar un instante en el tiempo**]{.hl-yellow}. ¿Qué debería suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?

. . .

```{r}
#| error: true
fecha_char + 1
```


Las fechas [**NO pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha.

. . .

&nbsp;

Para trabajar con fechas usaremos el paquete `{lubridate}`, que deberemos instalar antes de poder usarlo.

```{r}
#| eval: false
install.packages("lubridate")
```

---

## Variables de fecha

Una vez instalado, de todos los paquetes (libros) que tenemos, le indicaremos que nos cargue ese concretamente.

```{r}
library(lubridate) # instala si no lo has hecho

```

. . .

Para [**convertir a tipo fecha**]{.hl-yellow} usaremos la función `as_date()` del paquete `{lubridate}` (por defecto en formato `yyyy-mm-dd`)

&nbsp;

:::: columns
::: {.column width="50%"}

```{r}
#| error: true
# ¡no es una fecha, es un texto!
fecha_char + 1
class(fecha_char)
```

:::

::: {.column width="50%"}

```{r}
fecha <- as_date("2023-03-28")
fecha + 1
class(fecha)
```

:::

::::

---

## Variables de fecha

En `as_date()` el formato de fecha por defecto es `yyyy-mm-dd` así si la cadena de texto no se introduce de manera adecuada...

```{r}
as_date("28-03-2023")
```

. . .

Para [**cualquier otro formato debemos especificarlo**]{.hl-yellow} en el argumento opcional `format = ...` tal que `%d` representa días, `%m` meses, `%Y` en formato de 4 años y `%y` en formato de 2 años.

```{r}
as_date("28-03-2023", format = "%d-%m-%Y")
as_date("28-03-23", format = "%d-%m-%y")
as_date("03-28-2023", format = "%m-%d-%Y")
as_date("28/03/2023", format = "%d/%m/%Y")
```


---

## Variables de fecha

En dicho paquete tenemos funciones muy útiles para [**manejar fechas**]{.hl-yellow}:

-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.

```{r}
today()
```

. . .

-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}

```{r}
now()
```

. . .

-   Con `year()`, `month()` o `day()` podemos [**extraer el año, mes y día**]{.hl-purple}

```{r}
fecha <- today()
year(fecha)
month(fecha)
```

---

## Resúmenes de paquetes

![](img/lubridate.png)

::: callout-note
## Amplia contenido

Tienes un resumen en pdf de los paquetes más importantes en la [**carpeta correspondiente en el campus**]{.hl-green}
:::

---

## 💻 Tu turno {#tu-turno-1-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Define una variable que guarde tu edad (llamada `edad`) y otra con tu nombre (llamada `nombre`)

```{r}
#| code-fold: true
edad <- 33
nombre <- "Javi"
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Comprueba con dicha variable `edad` si NO tiene 60 años o si se llama `"Ornitorrinco"` (debes obtener variables lógicas como resultado)

```{r}
#| code-fold: true
#| eval: false
edad != 60 # distinto de
nombre == "Ornitorrinco" # igual a
```

### [**Ejercicio 3**]{.hl-yellow}

📝 ¿Por qué el código inferior da error?

```{r}
#| error: true
edad + nombre
```


### [**Ejercicio 4**]{.hl-yellow}

📝 Define otra variable llamada `hermanos` que responda la pregunta «¿tienes hermanos?» y otra variable que almacene tu fecha de nacimiento (llamada `fecha_nacimiento`).

```{r}
#| code-fold: true
hermanos <- TRUE

library(lubridate) # sino lo tenías ya cargado
fecha_nacimiento <- as_date("1989-09-10")
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Define otra variable con tus apellidos (llamada `apellidos`) y usa `glue()` para tener, en una sola variable  llamada `nombre_completo`, tu nombre y apellidos separando nombre y apellido por una coma

```{r}
#| code-fold: true
#| eval: false
apellidos <- "Álvarez Liébana"
glue("{nombre}, {apellidos}")
```

### [**Ejercicio 6**]{.hl-yellow}

📝 De `fecha_nacimiento` extrae el mes.

```{r}
#| code-fold: true
#| eval: false
month(fecha_nacimiento)
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Calcula los días que han pasado desde la fecha de tu nacimiento hasta hoy (con la fecha de nacimiento definida en el ejercicio 4).

```{r}
#| code-fold: true
#| eval: false
today() - fecha_nacimiento
```
:::

---

## Vectores: concatenar

Cuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenación**]{.hl-purple} de celdas (valores) del [**mismo tipo**]{.hl-purple} (lo que sería una columna de una tabla).

. . .

La forma más sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus **elementos entre paréntesis y separados por comas**

```{r}
edades <- c(32, 27, 60, 61)
edades
```

. . .

::: callout-tip
Un número individual `x <- 1` (o bien `x <- c(1)`) es en realidad un **vector de longitud uno** --> todo lo que sepamos [**hacer con un número podemos hacerlo con un vector de ellos**]{.hl-green}.
:::

---

## Vectores: concatenar

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}
Como ves ahora en el `environment` tenemos una **colección de elementos** guardada

```{r}
edades
```
:::
:::

. . .



La [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`

```{r}
length(edades)
```

. . .

También podemos [**concatenar vectores**]{.hl-yellow} entre sí (los repite uno tras otro)

```{r}
c(edades, edades, 8)
```

---

## Secuencias numéricas

El vector más famoso será el de tipo numérico, y en concreto, las conocidas como [**secuencias numéricas**]{.hl-yellow} (por ejemplo, los días del mes), usadas para, entre otras cosas, indexar bucles.

. . .

El comando `seq(inicio, fin)` nos permite crear una [**secuencia numérica**]{.hl-yellow} desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.

```{r}
seq(1, 31)
```

. . .

Fíjate que si hacemos eso con [**caracteres no podremos hacerlo**]{.hl-red} ya que no hay un orden a priori entre textos.

```{r}
#| error: true
"a":"z"
```

---

## Secuencias numéricas


Un atajo es el comando `1:n`, que nos devuelve lo mismo que `seq(1, n)`

```{r}
1:7
```

Si el elemento inicial es mayor que el final, entenderá que la secuencia es [**en orden decreciente**]{.hl-purple}.

```{r}
7:-3
```

. . .

También podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos con el argumento `by = ...`

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

---

## Secuencias numéricas


Otras veces nos interesará definir una [**secuencia con una longitud concreta**]{.hl-yellow}

```{r}
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```

. . .

Incluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}

```{r}
rep(0, 7) # vector de 7 ceros
```

. . .


Dado que internamente son guardados como números también podremos hacer esto con [**fechas**]{.hl-yellow}.

```{r}
seq(as_date("2023-09-01"), as_date("2023-09-10"), by = 1)
```


---

## Vectores de caracteres

Un vector es una **concatenación** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente números. Vamos a crear una frase de ejemplo.

```{r}
frase <- "Me llamo Javi"
frase
length(frase)
```

. . .

En el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas

```{r}
vector <- c("Me", "llamo", "Javi")
vector
length(vector)
```

---

## Vectores de caracteres

¿Qué sucederá si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

Fíjate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}

. . .

```{r}
c(3, 4, TRUE, FALSE)
```

Es importante entender que los valores lógicos en realidad están [**almacenados internamente como 0/1**]{.hl-yellow}

---

## Operaciones con vectores

Con los vectores numéricos podemos hacer las mismas [**operaciones aritméticas**]{.hl-yellow} que con los números → un [**número es un vector**]{.hl-purple} (de longitud uno)

. . .

¿Qué sucederá si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Cuidado

Salvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}
:::

---

## Suma de vectores

Los vectores también pueden interactuar entre ellos, así que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)

```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Dado que la operación (por ejemplo, una suma) se realiza elemento a elemento, ¿qué sucederá si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?

. . .

```{r}
z <- c(1, 3, 5, 7)
x + z
```

Lo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que hará será reciclar del vector con menor longitud.

---

## Comparar vectores

Una operación muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones lógicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...

[**¿Qué días hizo menos de 22 grados?**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

Nos devolverá un [**vector lógico**]{.hl-yellow}, en función de si **cada elemento** cumple o no la condición pedida (de **igual longitud** que el vector preguntado)

. . .

Si tuviéramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese día), la condición evaluada también sería `NA`

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Comparar vectores

Las [**condiciones lógicas pueden ser combinadas**]{.hl-yellow} de dos maneras:

-   [**Intersección**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunción y**]{.hl-purple} con `&`) para devolver un `TRUE`

```{r}
x < 30 & x > 15
```

-   [**Unión**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunción o**]{.hl-purple} con `|`)

```{r}
x < 30 | x > 15
```

. . .

Con `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen

```{r}
any(x < 30)
all(x < 30)
```

---

## Acceder a elementos

Otra operación muy habitual es la de [**acceder a elementos**]{.hl-yellow}. La forma más sencilla es usar el operador `[i]` (acceder al elemento i-ésimo)

```{r}
edades <- c(20, 30, 33, NA, 61) 
edades[3] # accedemos a la edad de la tercera persona 
```

. . .


Dado que un número no es más que un vector de longitud uno, esta operación también la podemos aplicar usando un [**vector de índices a seleccionar**]{.hl-yellow}

```{r}
y <- c("hola", "qué", "tal", "estás", "?")
y[c(1:2, 4)] # primer, segundo y cuarto elemento
```

. . .

::: callout-tip
Para acceder al último, sin preocuparnos de cuál es, podemos pasarle como índice la propia longitud `x[length(x)]`
:::

---

## Eliminar elementos

Otras veces no querremos seleccionar sino [**eliminar algunos elementos**]{.hl-yellow}. Deberemos repetir la misma operación pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-ésimo del vector sino que lo «des-selecciona»

```{r}
y
y[-2]
```


. . .

En muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones lógicas**]{.hl-yellow}, en función de los valores, así que pasaremos como índice la propia condición (recuerda, `x < 2` nos devuelve un vector lógico)

```{r}
edades <- c(15, 21, 30, 17, 45)
nombres <- c("javi", "maría", "laura", "carla", "luis")
nombres[edades < 18] # nombres de los menores de edad
```

---


## Sumar vectores

También podemos hacer uso de [**operaciones estadísticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**¿Qué sucede cuando falta un dato (ausente)?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

Por defecto, si tenemos un dato ausente, la [**operación también será ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`

```{r}
sum(x, na.rm = TRUE)
```

---

## Sumar vectores

Como hemos comentado que los valores lógicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritméticas.


Por ejemplo, si queremos [**averiguar el número de elementos que cumplen una condición**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendrán asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar dicho vector lógico para obtener el número de elementos que cumplen

```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Suma acumulada

Otra operación habitual que puede sernos útil es la [**suma acumulada**]{.hl-yellow} con `cumsum()` que, dado un vector, nos devuelve un vector a su vez con el primero, el primero más el segundo, el primero más el segundo más el tercero...y así sucesivamente.

```{r}
x <- c(1, 5, 2, -1, 8)
cumsum(x)
```

[**¿Qué sucede cuando falta un dato (ausente)?**]{.hl-yellow}


```{r}
x <- c(1, -2, 3, NA, -1)
cumsum(x)
```

En el caso de la suma acumulada lo que sucede es que [**a partir de ese valor, todo lo acumulado posterior será ausente**]{.hl-yellow}.

---

## Diferencia

Otra operación habitual que puede sernos útil es la [**diferencia (con retardo)**]{.hl-yellow} con `diff()` que, dado un vector, nos devuelve un vector con el segundo menos el primero, el tercero menos el segundo, el cuarto menos el tercero...y así sucesivamente.


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x)
```

. . .

Con el argumento `lag = ` podemos indicar el [**retardo**]{.hl-yellow} de dicha diferencia (por ejemplo, `lag = 3` implica que se resta el cuarto menos el primero, el quinto menos el segundo, etc)


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x, lag = 3)
```

---

## Media

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La más conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores atípicos o outliers (valores muy grandes o muy pequeños), la media se perturba con mucha facilidad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Percentiles

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.


-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Percentiles**]{.hl-yellow}: medidas de posición (nos dividen en partes iguales los datos).

```{r}
quantile(x) # por defecto percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

---


## Ordenar vectores

Por último, una acción habitual es saber [**ordenar valores**]{.hl-yellow}:

-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(edades)
sort(edades, decreasing = TRUE)
```

. . .

-   `order()`: devuelve el [**vector de índices**]{.hl-yellow} que tendríamos que usar para tener el vector ordenado

```{r}
order(x)
x[order(x)]
```

---

## 💻 Tu turno {#tu-turno-1-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

📝 Define el vector `x` como la concatenación de los 5 primeros números impares. Calcula la longitud del vector

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Accede al tercer elemento de `x`. Accede al último elemento (sin importar la longitud, un código que pueda ejecutarse siempre). Elimina el primer elemento.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Obtén los elementos de `x` mayores que 4. Calcula el vector `1/x` y guárdalo en una variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Crea un vector que represente los nombres de 5 personas, de los cuales uno es desconocido.

```{r}
#| code-fold: true
#| eval: false
nombres <- c("Javi", "Sandra", NA, "Laura", "Carlos")
nombres
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Encuentra del vector `x` de ejercicios anteriores los elementos mayores (estrictos) que 1 Y ADEMÁS menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Ejercicio 6**]{.hl-yellow}

📝 Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`,  ¿por qué su media no devuelve un número sino lo que se muestra en el código inferior?

```{r}
x <- c(1, -5, 8, NA, 10, -3, 9)
mean(x)
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6. 

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
x[-2]
```

### [**Ejercicio 8**]{.hl-yellow}

📝 Dado el vector `x` del ejercicio anterior, ¿cuales tienen un dato ausente? Pista: las funciones `is.algo()` comprueban si el elemento es tipo `algo` (tabula)

```{r}
#| code-fold: true
#| eval: false
is.na(x)
```


### [**Ejercicio 9**]{.hl-yellow}

📝 Define el vector `x` como la concatenación de los 4 primeros números pares. Calcula el número de elementos de `x` menores estrictamente que 5.

```{r}
#| code-fold: true
#| eval: false
x[x < 5] 
sum(x < 5)
```


### [**Ejercicio 10**]{.hl-yellow}

📝 Calcula el vector `1/x` y obtén la versión ordenada (de menor a mayor) de las dos formas posibles

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Ejercicio 11**]{.hl-yellow}

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Ejercicio 12**]{.hl-yellow}

📝 Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 6. Encuentra una forma de averiguar si todos los elementos son o no negativos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

:::


## 🐣 Caso práctico I: vectores {#caso-practico-1-1}

En el paquete `{datasets}` (ya instalado por defecto) tenemos diversos conjuntos de datos y uno de ellos es `airquality`. Debajo te he extraído 3 variables de dicho dataset (fíjate que se hace con `datos$variable`, ese dolar será importante en el futuro).

Los datos capturan [**medidas diarias (n = 153 observaciones) de la calidad del aire**]{.hl-yellow} en Nueva York, de mayo a septiembre de 1973. Se midieron **6 variables**: niveles de ozono, radiación solar, viento, temperatura, mes y día.

```{r}
library(datasets)
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/intro-r-vectores-isciii/)


# Clase 2: [primeras bases de datos]{.flow} {#clase-2}

[**Primera base de datos: matrices, data.frame y tibble**]{style="color:#444442;"}

* [💻 Ejercicios resueltos: matrices](#tu-turno-2-1)
* [💻 Ejercicios resueltos: data.frame y tibble](#tu-turno-2-2) 
* [🐣 Workbook/caso práctico: tibble](#caso-practico-2-1)
* [🐣 Workbook/caso práctico: Quarto](#caso-practico-2-2)
* [📆 Planificación](#planificacion)


---

## Primera base de datos

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una «tabla» que las recopile. La opción más inmediata son las [**matrices**]{.hl-yellow}: concatenación de variables del [**mismo tipo e igual longitud**]{.hl-purple}.

Imagina que tenemos estaturas y pesos de 4 personas. ¿Cómo [**crear un dataset con las dos variables**]{.hl-yellow}?

. . .


La opción más habitual es usando `cbind()`: [**concatenamos (bind) vectores en forma de columnas (c)**]{.hl-yellow}

```{r}
#| code-line-numbers: "3"
estaturas <- c(150, 160, 170, 180)
pesos <- c(63, 70, 85, 95)
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

---

## Primer intento: matrices

También podemos [**construir la matriz por filas**]{.hl-yellow} con la función `rbind()` (concatenar - bind - por filas  - rows), aunque lo [**recomendable es tener cada variable en columna**]{.hl-green} e individuo en fila como luego veremos.

```{r}
rbind(estaturas, pesos) # Construimos la matriz por filas
```

. . .

- Podemos [**«visualizar» la matriz**]{.hl-yellow} con `View(matriz)`.

. . .

-   Podemos [**comprobar las dimensiones**]{.hl-yellow} con `dim()`, `nrow()` y `ncol()`: las matrices son un tipo de **datos tabulados** (organizados en filas y columnas)

```{r}
dim(datos_matriz)
nrow(datos_matriz)
ncol(datos_matriz)
```

---

## Primer intento: matrices

También podemos [**«darle vuelta» (matriz transpuesta)**]{.hl-yellow} con `t()`.

```{r}
t(datos_matriz)
```

. . .

Dado que ahora tenemos dos dimensiones en nuestros datos, para [**acceder a elementos con `[]`**]{.hl-yellow} deberemos proporcionar **dos índices separados por comas**: índice de la fila y de la columna 

```{r}
datos_matriz[2, 1] # segunda fila, primera columna
datos_matriz[1, 2] # primera fila, segunda columna 
```

---

## Primer intento: matrices

En algunas casos querremos obtener los [**datos totales de un individuo**]{.hl-yellow} (una fila concreta pero todas las columnas) o los valores de [**toda una variable**]{.hl-yellow} para todos los individuos (una columna concreta pero todas las filas). Para ello dejaremos [**sin rellenar uno de los índices**]{.hl-yellow}

```{r}
datos_matriz[2, ] # segundo individuo
datos_matriz[, 1] # primera variable
```

. . .

Mucho de lo aprendido con vectores podemos hacerlo con matrices, así podemos por ejemplo acceder a varias filas y/o columnas haciendo uso de las [**secuencias de enteros 1:n**]{.hl-yellow}

```{r}
datos_matriz[c(1, 3), 1] # primera variable para el primer y tercer individuo
```


---

## Primer intento: matrices

También podemos definir una [**matriz a partir de un vector numérico**]{.hl-yellow}, reorganizando los valores en forma de matriz (sabiendo que los elementos se van [**colocando por columnas**]{.hl-purple}).

```{r}
z <- matrix(1:9, ncol = 3) 
z
```

. . .

Incluso podemos [**definir una matriz de valores constantes**]{.hl-yellow}, por ejemplo de ceros (para luego rellenar)

```{r}
matrix(0, nrow = 2, ncol = 3)
```


---

## Operaciones con matrices

Con las matrices sucede como con los vectores: cuando aplicamos una [**operación aritmética lo hacemos elemento a elemento**]{.hl-yellow}

```{r}
z/5
```

. . .

Para realizar [**operaciones en un sentido matricial**]{.hl-yellow} deberemos añadir `%%`, por ejemplo, para multiplicar matrices será `%*%`


```{r}
z * t(z)
z %*% t(z)
```


---

## Operaciones con matrices

También podemos [**realizar operaciones por columnas/filas**]{.hl-yellow} sin recurrir a bucles con la función `apply()`, y le indicaremos como **argumentos**

-   la matriz
-   el sentido de la operación (`MARGIN = 1` por filas, `MARGIN = 2` por columnas)
-   la función a aplicar
- argumentos extra que necesite la función

. . .

Por ejemplo, para aplicar una media a cada variable, será `mean` aplicada con `MARGIN = 2` (misma función para cada columna)

```{r}
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")
```



---

## 💻 Tu turno (matrices) {#tu-turno-2-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 Modifica el código inferior para definir una matriz `x` de unos, de 3 filas y 7 columnas.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Ejercicio 2**]{.hl-yellow}

📝 A la matriz anterior, suma un 1 a cada número de la matriz y divide el resultado entre 5. Tras ello calcula su transpuesta

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 ¿Por qué el código inferior nos devuelve dicho mensaje de aviso?

```{r}
#| warning: TRUE
matrix(1:15, nrow = 4)
```



### [**Ejercicio 4**]{.hl-yellow}

📝 Define la matriz `x <- matrix(1:12, nrow = 4)`. Tras ello obtén los datos del primer individuo, los datos de la tercera variable, y el elemento `(4, 1)`.

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # primera fila
x[, 3] # tercera columna
x[4, 1] # elemento (4, 1)
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Define una matriz de 2 variables y 3 individuos tal que cada variable capture la estatura y la edad 3 personas, de manera que la edad de la segunda persona sea desconocida (ausente). Tras ello calcula la media de cada variable (¡nos debe de volver un número!)

```{r}
#| code-fold: true
#| eval: false
datos <- cbind("edad" = c(20, NA, 25), "estatura" = c(160, 165, 170))
apply(datos, MARGIN = 2, FUN = "mean", na.rm = TRUE) # media por columnas

```

### [**Ejercicio 6**]{.hl-yellow}

📝 ¿Por qué devuelve error el código inferior? ¿Qué está mal?

```{r}
#| error: true
matriz <- cbind("edad" = c(15, 20, 25), "nombres" = c("javi", "sandra", "carlos"))
matriz
matriz + 1
```



:::

---

## Segundo intento: data.frame

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte (fíjate en el código inferior: las edades y los `TRUE/FALSE` los ha convertido a texto)

```{r}
#| code-line-numbers: "4-5"
edades <- c(14, 24, NA)
soltero <- c(TRUE, NA, FALSE)
nombres <- c("javi", "laura", "lucía")
matriz <- cbind(edades, soltero, nombres)
matriz
```

. . .

De hecho al no ser números ya no podemos realizar operaciones aritméticas

```{r}
#| error: true
matriz + 1
```

---

## Segundo intento: data.frame

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos en `R` lo que se conoce como [**data.frame**]{.hl-yellow}: concatenación de variables de igual longitud pero que pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
tabla <- data.frame(edades, soltero, nombres)
class(tabla)
tabla
```

---

## Segundo intento: data.frame

Dado que un `data.frame` es ya un intento de «base de datos» las variables no son meros vectores matemáticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple} que describan su significado

```{r}
library(lubridate)
tabla <-
  data.frame("edad" = edades, "estado" = soltero, "nombre" = nombres,
             "f_nacimiento" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
tabla
```

---

## Segundo intento: data.frame

[**¡TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} (estrictamente no podemos hablar de base de datos pero de momento como lo si fuesen). Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

![](img/view_tabla.jpg)

---

## Acceso a variables

Si queremos acceder a sus elementos, al ser de nuevo **datos tabulados**, podemos acceder como en las matrices ([**no recomendable**]{.hl-red}): de nuevo [**tenemos dos índices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera característica de la segunda persona
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
Pero también tiene las ventajas de una [**«base» de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} ([**lo recomendable**]{.hl-green} ya que las variables pueden cambiar de posición y ahora sí tienen un significado), poniendo el nombre de la tabla seguido del símbolo `$` (con el **tabulador**, nos aparecerá un menú de columnas a elegir)
:::
:::

---

## Funciones de consulta

-   `names()`: nos muestra los nombres de las variables

```{r}
names(tabla)
```

. . .

-   `dim()`: nos muestra las dimensiones (también `nrow()` y `ncol()`)

```{r}
dim(tabla)
```

. . .

-   Podemos acceder a las variables por su nombre

```{r}
tabla[c(1, 3), "nombre"]
tabla$nombre[c(1, 3)]
```

---

## Añadir variable

Si tenemos uno ya creado y queremos [**añadir una columna**]{.hl-yellow} es tan simple como usar la función `data.frame()` que ya hemos visto para concatenar la columna. Vamos añadir por ejemplo una nueva variable, el número de hermanos de cada individuo.

```{r}
# Añadimos una nueva columna con nº de hermanos/as
hermanos <- c(0, 2, 3)
tabla <- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

---

## Intento final: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}. La principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```

. . .


En adelante usaremos el formato `tibble` ([**data.frame mejorado**]{.hl-yellow}) del paquete `{tibble}`

```{r}
library(tibble)
datos_tb <- 
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
class(datos_tb)
datos_tb
```

---

## Intento final: tibble

```{r}
datos_tb <-
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
datos_tb
```

Las tablas en formato `tibble` nos permitirá una [**gestión más ágil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

-   [**Metainformación**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya automáticamente el número de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

---

## Intento final: tibble

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
datos_tb$invent
```

. . .

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de páginas web y documentos sencillos
:::


---


## Recapitulando

-   Cada [**celda puede ser de un tipo diverso**]{.hl-yellow}: números, texto, fechas, valores lógicos, etc

. . .

-   Un [**vector es una concatenación de celdas**]{.hl-yellow} (las futuras columnas de nuestras tablas) --> En `R` por defecto las operaciones se hacen [**elemento a elemento**]{.hl-yellow}

. . .

-   Una [**matriz**]{.hl-yellow} nos permite concatenar [**variables del MISMO tipo y MISMA longitud**]{.hl-yellow} --> datos tabulados

. . .

-   Un [**data.frame**]{.hl-yellow} nos permite concatenar [**variables de DISTINTO tipo y MISMA longitud**]{.hl-yellow} --> usaremos [**tibble**]{.hl-yellow} como una opción mejorada de base de datos

---

## 💻 Tu turno (tb/df) {#tu-turno-2-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 Carga del paquete `{datasets}` el conjunto de datos `airquality` (variables de la calidad del aire de Nueva York desde mayo hasta septiembre de 1973). ¿Es el conjunto de datos airquality de tipo tibble? En caso negativo, conviértelo a tibble (busca en la documentación del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 2**]{.hl-yellow}

📝 Una vez convertido a `tibble` obtén el nombre de las variables y las dimensiones del conjunto de datos. ¿Cuántas variables hay? ¿Cuántos días se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```


### [**Ejercicio 3**]{.hl-yellow}

📝 Filtra solo los datos de la quinta observación

```{r}
#| code-fold: true
#| eval: false
airquality_tb[5, ]
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Modifica el código inferior para filtrar solo los datos del mes de agosto. ¿Cómo indicarle que queremos solo las filas que cumplan una condición concreta? (pista: en realidad todo son vectores "formateados")

```{r}
#| eval: false
airquality_tb[Month == 8, ]
```

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, ]
```

### [**Ejercicio 5**]{.hl-yellow}

📝 Selecciona aquellos datos que no sean ni de julio ni de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month != 7 & airquality_tb$Month != 8, ]

# otra forma
airquality_tb[!(airquality_tb$Month %in% c(7, 8)), ]
```

### [**Ejercicio 6**]{.hl-yellow}

📝 Modifica el siguiente código para quedarte solo con las variable de ozono y temperatura (sin importar qué posición ocupen)

```{r}
#| eval: false
airquality_tb[, 3]
```

### [**Ejercicio 7**]{.hl-yellow}

📝 Selecciona los datos de temperatura y viento de agosto. 

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, c("Temp", "Wind")]
```

### [**Ejercicio 8**]{.hl-yellow}

📝 Traduce a castellano el nombre de las variables.


```{r}
#| code-fold: true
#| eval: false
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```

:::




---

## 🐣 Caso práctico I: tibble {#caso-practico-2-1}

Del paquete `{Biostatistics}` usaremos el conjunto de datos `pinniped`, que guarda los **datos de peso de cuerpo y cerebro** (desagregado por sexo y mono/poligamia) de 33 especies de mamíferos marinos.


```{r}
Biostatistics::pinniped
```


Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/matrices-tibble-isciii)

---

## 🐣 Caso práctico II: Taylor Swift {#caso-practico-2-2}

Del paquete `{taylor}` vamos a usar el conjunto de datos `taylor_album_songs` para poner en práctico lo aprendido sobre bases de datos y manejo de variables. Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/matrices-tibble-isciii)


```{r}
library(taylor)
taylor_album_songs
```



# Clase 3: [if-elses, bucles y Quarto]{.flow} {#clase-3}

[**Estructuras condicionales, bucles y Quarto**]{style="color:#444442;"}

* [💻 Ejercicios resueltos: estructuras condicionales](#tu-turno-3-1) 
* [💻 Ejercicios resueltos: bucles](#tu-turno-3-2) 
* [🐣 Workbook/caso práctico: bucles y condicionales](#caso-practico-3-1)
* [📆 Planificación](#planificacion)

---

## Estructuras de control

Una [**estructura de control**]{.hl-yellow} se compone de una serie de comandos orientados a  [**decidir el camino**]{.hl-yellow} que tu código debe recorrer

* Si se cumple la condición A, ¿qué sucede?

* ¿Y si sucede B?

* ¿Cómo puedo repetir una misma expresión (dependiendo de una variable)?

. . .

Si has programado antes, quizás te sea familiar las conocidas como [**estructuras condicionales**]{.hl-yellow} tales como `if (blabla) {...} else {...}`  o [**bucles**]{.hl-yellow} `for/while` (a evitar siempre que podamos).

---

## Estructura If

Una de las estructuras de control más famosas son las conocidas como [**estructuras condicionales**]{.hl-yellow} `if`.

> SI (IF) un conjunto de condiciones se cumple (TRUE), entonces ejecuta lo que haya dentro de las llaves

Por ejemplo, la estructura `if (x == 1) { código A }` lo que hará será [**ejecutar el código A entre llaves**]{.hl-yellow} pero [**SOLO SI**]{.hl-purple} la [**condición entre paréntesis es cierta**]{.hl-purple} (solo si `x` es 1). En cualquier otro caso, no hará nada.

. . .

Por ejemplo, definamos un vector de edades de 8 personas

```{r}
edad <- c(14, 17, 24, 56, 31, 20, 87, 73)
edad < 18
```

---

## Estructura If


Nuestra estructura condicional hará lo siguiente: [**si existe algún menor de edad, imprimirá**]{.hl-yellow} por pantalla un mensaje.

```{r}
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```

---

## Estructura If

```{r}
#| eval: false
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```


En caso de que las [**condiciones no sean ciertas**]{.hl-yellow} dentro de `if()` (`FALSE`), no sucede nada


```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
}
```

**No obtenemos ningún mensaje** porque la condición `all(edad >= 18)` no es `TRUE`, así que no ejecuta nada.

---

## Estructura If-else

La estructura `if (condicion) { código A }` puede combinarse con un `else { código B }`: cuando la [**condición no está verificada**]{.hl-yellow}, se [**ejecutará el código alternativo B**]{.hl-yellow} dentro de `else { }`, permitiéndonos decidir que sucede cuando se cumple y cuando no.

. . .

Por ejemplo, `if (x == 1) { código A } else { código B }` ejecutará A si `x` es igual a 1 y B en cualquier otro caso.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else {
  
  print("Existe alguna persona menor de edad")
}
```

---

## Estructura If-else

Esta estructura `if - else` puede ser [**anidada**]{.hl-yellow}: imagina que queremos ejecutar un código si todos son menores; si no sucede, pero todos son mayores de 16, hacer otra cosa; en cualquier otra cosa, otra acción.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else if (all(edad >= 16)) {
  
  print("Hay algún menor de edad pero todos con 16 años o más")
  
} else { print("Hay alguna persona con menos de 16 años") }
```

::: callout-note
## Truco

Puedes **colapsar las estructuras** haciendo click en la flecha a la izquierda que aparece en tu script.

:::


---

## If-else vectorizado



Esta estructura condicional se puede [**vectorizar**]{.hl-yellow} (en una sola línea) con `if_else()` (del paquete `{dplyr}`), cuyos argumentos son

* la condición a evaluar
* lo que sucede cuando se cumple y cuando no
* un argumento opcional para cuando la condición a evaluar es `NA`

Vamos a etiquetar sin son mayores/menores y un "desconocido" cuando no conocemos

```{r}
library(dplyr)
edad <- c(NA, edad)
if_else(edad >= 18, "mayor", "menor", missing = "desconocido")
```

En `R` base existe `ifelse()`: no deja especificar que hacer con los ausentes pero permite especificar distintos tipos de datos en `TRUE` y en `FALSE`.

---

## 💻 Tu turno {#tu-turno-3-1}


[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 ¿Cuál es la salida del siguiente código?

```{r}
#| eval: false
if_else(sqrt(9) < 2, sqrt(9), 0)
```

```{r}
#| eval: false
#| code-fold: true

La salida es 0 ya que sqrt(9) es igual 3, y dado que no es menor que 2, devuelve el segundo argumento que es 0
```

### [**Ejercicio 2**]{.hl-yellow}

📝 ¿Cuál es la salida del siguiente código?

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true

La salida es el vector c(0, NA, NA, 1) ya que sqrt(1) sí es menor que 2, sqrt(9) no lo es, y tanto en el caso de sqrt(NA) (raíz de ausente) como sqrt(-1) (devuelve NaN, not a number), su raíz cuadrada no puede verificarse si es menor que 2 o no, así que la salida es NA.
```


### [**Ejercicio 3**]{.hl-yellow}

📝 Modifica el código inferior para que, cuando no se pueda verificar si la raíz cuadrada de un número es menor que 2, devuelva -1

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1, missing = -1)
```


### [**Ejercicio 4**]{.hl-yellow}

📝 ¿Cuál es son los valores de `x` e `y` del código inferior para `z <- 1`, `z <- -1` y `z <- -5`?

```{r}
#| eval: false
z <- -1
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
En primero caso x = 1 e y = -1. En el segundo caso x = 1 e y = 1. En el tercer caso -2.5 y 5
```

### [**Ejercicio 5**]{.hl-yellow}

📝 ¿Qué pasaría si ejecutamos el siguiente código? Spoiler: da error. ¿Por qué? ¿Cómo solucionarlo?

```{r}
#| eval: false
z <- c(-1, 1, 5)
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
Da error ya que en los `if (condición) { } else { }` "clásicos" necesitamos que
la condición tenga longitud uno (un solo valor TRU/FALSE)
```

```{r}
#| eval: false
#| code-fold: true
# para arreglarlo podemos hacer un if_else vectorial
z <- c(-1, 1, -5)
library(dplyr)
x <- if_else(z > 0, z^3, if_else(abs(z) < 2, z^4, z/2))
y <- if_else(z > 0, -sqrt(z), if_else(abs(z) < 2, sqrt(-z), abs(z)))
```

### [**Ejercicio 6**]{.hl-yellow}

📝 ¿Qué sucederá si ejecutamos el código inferior?

```{r}
#| eval: false
z <- "a"
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| code-fold: true
#| eval: false

# dará error ya que no es un argumento numérico
Error in z^3 : non-numeric argument to binary operator
```


### [**Ejercicio 7**]{.hl-yellow}

📝 Del paquete `{lubridate}`, la función `hour()` nos devuelve la hora de una fecha dada, y la función `now()` nos devuelve fecha y hora del momento actual. Con ambas funciones haz que se imprima por pantalla (`cat()`) "buenas noches" solo a partir de las 21 horas.

```{r}
#| code-fold: true
#| eval: false

# Cargamos librería
library(lubridate)

# Fecha-hora actual
fecha_actual <- now()

# Estructura if
if (hour(fecha_actual) > 21) {
  
  cat("Buenas noches") # print/cat dos formas de imprimir por pantalla
}
```


:::

---

## Bucles

Aunque en la mayoría de ocasiones se pueden reemplazar por otras estructuras más eficientes y legibles, es importante conocer una de las expresiones de control más famosas: los [**bucles**]{.hl-yellow}.

* `for { }`: permite [**repetir el mismo código**]{.hl-yellow} en un [**número prefijado y conocido**]{.hl-purple} de veces.

* `while { }`: permite [**repetir el mismo código**]{.hl-yellow} pero en un [**número indeterminado de veces**]{.hl-purple} (hasta que una **condición** deje de cumplirse).

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de órdenes un número [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de índices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacía `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los paréntesis indicaremos un índice y unos valores a recorrer, dentro de las llaves el código a ejecutar en cada iteración (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()
```

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de órdenes un número [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de índices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacía `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los paréntesis indicaremos un índice y unos valores a recorrer, dentro de las llaves el código a ejecutar en cada iteración (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  
}
```

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de órdenes un número [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de índices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacía `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los paréntesis indicaremos un índice y unos valores a recorrer, dentro de las llaves el código a ejecutar en cada iteración (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
```

---

## Bucles for

Fíjate que debido a que `R` funciona de manera [**vectorial por defecto**]{.hl-yellow}, el bucle es lo mismo que hacer `x + 1` directamente.

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
y

y2 <- x + 1
y2
```

---

## Bucles for

Otra opción habitual es indicar los índices de manera «automática»: desde el primero `1` hasta el último (que corresponde con la longitud de x `length(x)`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:length(x)) {
  y[i] <- x[i] + 1
}
y

```


---

## Bucles for

Así la [**estructura general de un bucle for**]{.hl-yellow} será siempre la siguiente

```{r}
#| eval: false
for (índice in conjunto) { 
  código (dependiente de i)
}
```

[**SIEMPRE**]{.hl-green} sabemos cuántas iteraciones tenemos (tantas como elementos haya en el conjunto a indexar)

---

## Evitando bucles


Como ya hemos aprendido con el paquete`{microbenchmark}` podemos chequear como [**los bucles suelen ser muy ineficientes**]{.hl-yellow} (de ahí que debamos evitarlos en la mayoría de ocasiones

```{r}
library(microbenchmark)
x <- 1:1000
microbenchmark(y <- x^2, 
               for (i in 1:100) { y[i] <- x[i]^2 },
               times = 500)
```

---
 
## Bucles for


Podemos ver otro ejemplo de bucle  [**combinando números y textos**]{.hl-yellow}: definimos un vector de edades y de nombres, e imprimimos el nombre y edad i-ésima.

```{r}
nombres <- c("Javi", "Sandra", "Carlos", "Marcos", "Marta")
edades <- c(33, 27, 18, 43, 29)

for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} años")) 
  
}
```


---

## Bucles for

Aunque normalmente se suelen indexar con vectors numéricos, los bucles pueden ser [**indexados sobre cualquier estructura vectorial**]{.hl-yellow}, da igual de que tipo sea el conjunto

```{r}
library(stringr)
week_days <- c("monday", "tuesday", "wednesday", "thursday",
               "friday", "saturday", "sunday")

for (days in week_days) {
  
  print(str_to_upper(days))
}
```

---

## Bucles y condicionales

Vamos a **combinar las estructuras condicionales y los bucles**: usando el conjunto `swiss` del paquete `{datasets}`, vamos a asignar `NA`  si los valores de fertilidad son mayores de 80.

```{r}
for (i in 1:nrow(swiss)) {
  
  if (swiss$Fertility[i] > 80) { 
    
    swiss$Fertility[i] <- NA
    
  }
}
```

. . .

Esto es exactamente igual a un `if_else()` vectorizado

```{r}
data("swiss")
swiss$Fertility <- if_else(swiss$Fertility > 80, NA, swiss$Fertility)
```


---

## Bucles while

Otra forma de crear un bucle es con la estructura `while { }`, que nos ejecutará un bucle [**un número desconocido de veces**]{.hl-yellow}, hasta que una condición [**deje de cumplirse**]{.hl-yellow} (de hecho puede que nunca termine). Por ejemplo, vamos a inializar una variable `ciclos <- 1`, que incrementaremos en cada paso, y no saldremos del bucle hasta que `ciclos > 4`.

```{r}
ciclos <- 1
while(ciclos <= 4) {
  
  print(glue("No todavía, vamos por el ciclo {ciclos}")) 
  ciclos <- ciclos + 1
  
}
```

---

## Bucles while

Un bucle `while` será siempre como sigue

```{r}
#| eval: false
while(condición) {
  
  código a hacer mientras la condición sea TRUE
  # normalmente aquí se actualiza alguna variable
  
}
```

---
  
## Bucles while

¿Qué sucede cuando la [**condición nunca es FALSE**]{.hl-yellow}? Pruébalo tu mismo

```{r}
#| eval: false
while (1 > 0) {
  
  print("Presiona ESC para salir del bucle")
  
}
```

&nbsp;

::: callout-warning
## Cuidado

Un bucle `while { }` puede ser bastante «peligroso» sino controlamos bien cómo pararlo.

:::

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `break`: permite [**abortar un bucle**]{.hl-yellow} incluso si no se ha llegado a su final

```{r}
for(i in 1:10) {
  if (i == 3) {
    
    break # si i = 3, abortamos bucle
    
  }
  print(i)
}
```

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `next`: [**fuerza un bucle a avanzar a la siguiente iteración**]{.hl-yellow} 

```{r}
for(i in 1:5) {
  if (i == 3) {
    
    next # si i = 3, la obvia y continua al siguiente
    
  }
  print(i)
}
```

---

## Bucles repeat

Aunque no es tan usado como las opciones anteriores, también contamos con `repeat { }` que ejecuta un [**bucle de manera infinita hasta que se indique abortar**]{.hl-yellow} con un break

```{r}
count <- 0
repeat { 
  
  count <- count + 1
  if (count >= 100) { break }
  
}
count
```


---

## Replicate

Aunque no es formalmente un bucle, otra forma de [**repetir código un número de veces**]{.hl-yellow} es hacer uso de `replicate()`: simplemente permite repetir lo mismo [**n veces**]{.hl-yellow}

```{r}
x <- 1:3
replicate(n = 3, x^2)
```

---

## Replicate

La función `replicate()` se suele usar para [**generar distintas repeticiones de elementos aleatorios**]{.hl-yellow}. Por ejemplo, imaginemos que queremos generar 3 muestras de distribuciones normales, en la que cada muestra tendrá 7 elementos. Para generar una se usa `rnorm(n = 7)` (r de resample, norm de normal, y si no se dice nada es media 0 y desv 1).

```{r}
replicate(n = 3, rnorm(n = 7))
```

---


## 💻 Tu turno {#tu-turno-3-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

📝 Modifica el código inferior para que se imprima un mensaje por pantalla si y solo si todos los datos de `airquality` son con mes distinto a enero

```{r}
#| eval: false
library(datasets)
months <- airquality$Month

if (months == 2) {
  print("No hay datos de enero")
}
```

```{r}
#| code-fold: true
#| eval: false
library(datasets)
months <- airquality$Month

if (all(months != 1)) {
  print("No hay datos de enero")
}
```


### [**Ejercicio 2**]{.hl-yellow}

📝 Modifica el código inferior para guardar en una variable llamada `temp_alta` un `TRUE` si alguno de los registros tiene una temperatura superior a 90 grados Farenheit y `FALSE` en cualquier otro caso
 
```{r}
#| eval: false
temp <- airquality$Temp

if (temp == 100) {
  print("Algunos de los registros tienen temperaturas superiores a 90 grados Farenheit")
}
```

 
```{r}
#| eval: false
#| code-fold: true
# Option 1
temp <- airquality$Temp
temp_alta <- FALSE
if (any(temp > 90)) {
   temp_alta <- TRUE
}

# Option 2
temp_alta <- any(airquality$Temp > 90)
```

### [**Ejercicio 3**]{.hl-yellow}

📝 Modifica el código inferior para diseñar un bucle `for` de 5 iteraciones que solo recorra los primeros 5 impares (y en cada paso del bucle los imprima)

```{r}
#| eval: false
for (i in 1:5) {
  
  print(i)
}
```

```{r}
#| eval: false
#| code-fold: true
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i)
}
```

### [**Ejercicio 4**]{.hl-yellow}

📝 Modifica el código inferior para diseñar un bucle `while` que empiece con un contador `count <- 1` y pare cuando llegue a 6

```{r}
#| eval: false
count <- 1
while (count == 2) {
  
  print(count)
}
```

```{r}
#| eval: false
#| code-fold: true
count <- 1
while (count < 6) {
  
  print(count)
  count <- count + 1
  
}
```


:::

---

## 🐣 Caso práctico I {#caso-practico-3-1}


Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/if-else-bucles-funciones-isciii/) donde tendrás que diseñar algunos estudios de simulación haciendo uso de **bucles y estructuras condicionales**


# Clase 4: [funciones y ggplot]{.flow} {#clase-4}

[**Funciones y ggplot**]{style="color:#444442;"}

* [💻 Ejercicios resueltos: funciones](#tu-turno-4-1) 
* [💻 Ejercicios resueltos: ggplot](#tu-turno-4-2) 
* [🐣 Workbook/caso práctico: funciones](#caso-practico-4-1)
* [🐣 Workbook/caso práctico: ggplot](#caso-practico-4-2)
* [📆 Planificación](#planificacion)

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, además podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¿Cómo [**crear nuestra propia función**]{.hl-purple}? Veamos su **esquema básico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraños). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la función dentro de `{ }`.

* Finalizamos la función con los [**argumentos de salida**]{.hl-yellow} con `return()`.



```{r}
#| eval: false
name_fun <- function() {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, además podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¿Cómo [**crear nuestra propia función**]{.hl-purple}? Veamos su **esquema básico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraños). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la función dentro de `{ }`.

* Finalizamos la función con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, además podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¿Cómo [**crear nuestra propia función**]{.hl-purple}? Veamos su **esquema básico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraños). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la función dentro de `{ }`.

* Finalizamos la función con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  código a ejecutar
  
}
```

---


## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, además podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¿Cómo [**crear nuestra propia función**]{.hl-purple}? Veamos su **esquema básico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraños). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la función dentro de `{ }`.

* Finalizamos la función con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  código a ejecutar
  
  return(var_salida)
  
}
```


---

## Creando funciones

* `arg1, arg2, ...`: serán los [**argumentos de entrada**]{.hl-yellow}, los argumentos que toma la función para ejecutar el código que tiene dentro

* `código`: líneas de código que queramos que [**ejecute la función**]{.hl-yellow}. 

* `return(var_salida)`: se introducirán los [**argumentos de salida**]{.hl-yellow}.


```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # Código que queramos ejecutar
  código
  
  # Salida
  return(var_salida)
  
}
```

::: callout-important
## Importante

Todas las variables que definamos dentro de la función son [**variables LOCALES: solo existirán dentro de la función**]{.hl-yellow} salvo que especifiquemos lo contrario.

:::

---

## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de función para [**calcular el área de un rectángulo**]{.hl-yellow}.

Dado que el área de un rectángulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serán los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} será justo su **área** ($lado_1 * lado_2$).

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
}
```

---


## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de función para [**calcular el área de un rectángulo**]{.hl-yellow}.

Dado que el área de un rectángulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serán los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} será justo su **área** ($lado_1 * lado_2$).

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  
}
```

---


## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de función para [**calcular el área de un rectángulo**]{.hl-yellow}.

Dado que el área de un rectángulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serán los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} será justo su **área** ($lado_1 * lado_2$).

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  return(area)
  
}
```

---

## Uso de funciones

También podemos hacer una definición directa de las variables **sin almacenar por el camino**.

```{r}
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  return(lado_1 * lado_2)
  
}
```

. . .

[**¿Cómo aplicar la función?**]{.hl-yellow}

```{r}
calcular_area(5, 3) # área de un rectángulo 5 x 3 
calcular_area(1, 5) # área de un rectángulo 1 x 5
```

---

## Uso de funciones

::: callout-tip

Aunque no sea necesario, es [**recomendable hacer explícita la llamada de los argumentos**]{.hl-green}, especificando en el código qué valor es para cada argumento para que no dependa de su orden, haciendo el código más legible
:::


```{r}
calcular_area(lado_1 = 5, lado_2 = 3) # área de un rectángulo 5 x 3 
calcular_area(lado_2 = 3, lado_1 = 5) # área de un rectángulo 5 x 3 
```

---

## Argumentos por defecto

Imagina ahora que nos damos cuenta que el 90% de las veces usamos dicha función para [**calcular por defecto el área de un cuadrado**]{.hl-yellow} (es decir, solo necesitamos un lado). Para ello, podemos definir [**argumentos por defecto**]{.hl-yellow} en la función: tomarán dicho valor salvo que le asignemos otro.

¿Por qué no asignar `lado_2 = lado_1` **por defecto**, para ahorrar líneas de código y tiempo?

. . .

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

---

## Argumentos por defecto


```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```


Ahora [**por defecto**]{.hl-yellow} el segundo lado será igual al primero (si se lo añadimos usará ambos).


```{r}
calcular_area(lado_1 = 5) # cuadrado
calcular_area(lado_1 = 5, lado_2 = 7) # rectángulo
```

---
 

## Salida múltiple

Compliquemos un poco la función y añadamos en la salida los valores de cada lado, etiquetados como `lado_1` y `lado_2`, [**empaquetando la salida en una vector**]{.hl-yellow}.

```{r}
#| code-line-numbers: "7-8"
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

---

## Salida múltiple

Podemos complicar un poco más la salida añadiendo una cuarta variable que nos diga, en función de los argumentos, [**si rectángulo o cuadrado**]{.hl-yellow}, teniendo que añadir en la salida una variable que de tipo caracter (o lógica).

```{r}
#| code-line-numbers: "7-9"
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rectángulo")))
  
}
calcular_area(5, 3)
```

. . .

[**Problema**]{.hl-red}: al intentar juntar números y texto, lo convierte todo a números. Podríamos guardarlo todo en un `tibble()` como hemos aprendido o en un objeto conocido en `R` como [**listas**]{.hl-yellow}

---

## Introducción a listas

Veamos un pequeño resumen de los datos que ya conocemos:

* [**vectores**]{.hl-yellow}: colección de elementos de igual tipo. Pueden ser números, caracteres o valores lógicos, entre otros.

* [**matrices**]{.hl-yellow}: colección BIDIMENSIONAL de elementos de igual tipo e igual longitud.

* [**data.frame / tibble**]{.hl-yellow}: colección BIDIMENSIONAL de elementos de igual longitud pero de cualquier tipo.

. . .

Las [**listas**]{.hl-yellow} serán [**colecciones de variables de diferente tipo y diferente longitud**]{.hl-purple}, con estructuras totalmente heterógeneas (incluso una lista puede tener dentro a su vez otra lista).

---

## Introducción a listas


Vamos a crear [**nuestra primera lista**]{.hl-yellow} con `list()` con tres elementos: el nombre de nuestros padres/madres, nuestro lugar de nacimiento y edades de nuestros hermanos.

```{r}
var_1 <- c("Paloma", "Gregorio")
var_2 <- "Madrid"
var_3 <- c(25, 30, 26)

lista <- list("progenitores" = var_1, "lugar_nac" = var_2, "edad_hermanos" = var_3)
lista
```



---

## Introducción a listas

```{r}
length(lista)
```

Si observas el objeto que hemos definido como lista, su [**longitud**]{.hl-yellow} del es de 3 ya que tenemos **guardados tres elementos**: un vector de caracteres (de longitud 2), un caracter (vector de longitud 1), y un vector de números (de longitud 3)

. . .

Tenemos guardados elementos de [**distinto tipo**]{.hl-yellow} (algo que ya podíamos hacer) pero, además, de **longitudes dispares**.

```{r}
dim(lista) # devolverá NULL al no tener dos dimensiones
class(lista) # de tipo lista
```

---

## Introducción a listas

Si los juntásemos con un `tibble()`, al tener distinta longitud, obtendríamos un [**error**]{.hl-red}.

```{r}
#| error: true
library(tibble)
tibble("progenitores" = var_1, "lugar_nac" = va_2, "edad_hermanos" = var_3)
```

---


## Introducción a listas

* [**Acceder por índice**]{.hl-yellow}: con el operador `[[i]]` accedemos al **elemento i-ésimo** de la lista.

```{r}
lista[[1]]
```

. . .

* [**Acceder por nombre**]{.hl-yellow}: con `$nombre_elemento` accedemos por su nombre.

```{r}
lista$progenitores
```

. . .

En contraposición, el [**corchete simple**]{.hl-yellow} nos permite acceder a [**varios elementos**]{.hl-yellow} a la vez

```{r}
# Varios elementos
lista[1:2]
```

---

## Salida múltiple: listas

```{r}
#| code-line-numbers: "7-9"
# Definición del nombre de función y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area <- lado_1 * lado_2
  
  # Resultado
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rectángulo")))
  
}
calcular_area(5, 3)
```

---

## Orden de los argumentos

Antes nos daba igual el orden de los argumentos pero ahora el [**orden de los argumentos de entrada importa**]{.hl-yellow}, ya que en la salida incluimos `lado_1` y `lado_2`. 

. . .

::: callout-note
## Recomendación

Como se comentaba, altamente recomendable hacer la llamada a la función [**indicando explícitamente los argumentos**]{.hl-yellow} para mejorar **legibilidad e interpretabilidad**.

```{r}
# Equivalente a calcular_area(5, 3)
calcular_area(lado_1 = 5, lado_2 = 3)
```

:::

---

## Funciones: generando conocimiento

Parece una tontería lo que hemos hecho pero hemos cruzado una frontera importante: hemos pasado de [**consumir conocimiento**]{.hl-yellow} (código de otros paquetes, elaborado por otros/as), a [**generar conocimiento**]{.hl-purple}, creando nuestras propias funciones.

. . .

Las funciones van a ser claves en tu día a día ya que te permitirá automatizar código que vas a repetir una y otra vez: empaquetando ese código bajo un alias (nombre de la función) vas a [**poder usarlo una y otra vez sin necesidad de programarlo (por lo que hacer el doble de trabajo no implicará trabajar el doble)**]{.hl-yellow}

---

## Variables locales vs globales

Un aspecto importante sobre el que reflexionar con las funciones: ¿qué sucede si [**nombramos a una variable dentro**]{.hl-yellow} de una función a la que se nos ha **olvidado asignar** un valor dentro de la misma?

. . .

Debemos ser cautos al usar funciones en `R`, ya que debido a la [**«regla lexicográfica»**]{.hl-yellow}, si una variable no se define dentro de la función, `R` [**buscará dicha variable en el entorno**]{.hl-purple} de variables.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  print(x) # No devuelve nada, solo realiza la acción 
}
funcion_ejemplo()
```

---

## Variables locales vs globales

Si una variable  [**ya está definida fuera de la función (entorno global)**]{.hl-yellow}, y además es usada dentro de cambiando su valor, el valor [**solo cambia dentro**]{.hl-yellow} pero [**no en el entorno global**]{.hl-red}.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  x <- 2
  print(x) # lo que vale dentro
}
```

```{r}
# lo que vale dentro
funcion_ejemplo() #<<
# lo que vale fuera
print(x) #<<
```

---

## Variables locales vs globales


Si queremos que además de cambiar localmente lo haga [**globalmente**]{.hl-yellow} deberemos usar la [**doble asignación**]{.hl-yellow} (`<<-`).

```{r}
x <- 1
y <- 2
funcion_ejemplo <- function() {
  
  # no cambia globalmente, solo localmente
  x <- 3 
  # cambia globalmente
  y <<- 0 #<<
  
  print(x)
  print(y)
}

funcion_ejemplo() # lo que vale dentro
x # lo que vale fuera
y # lo que vale fuera
```

---


## 💻 Tu turno {#tu-turno-3-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ej 1**]{.hl-yellow}

📝 Modifica el código inferior para definir una función llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.

```{r}
#| eval: false
nombre <- function(x, y) {
  suma <- # código a ejecutar
  return()
}
# Aplicamos la función
suma(3, 7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_suma <- function(x, y) {
  suma <- x + y
  return(suma)
}
funcion_suma(3, 7)
```

### [**Ej 2**]{.hl-yellow}

📝 Modifica el código inferior para definir una función llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado

```{r}
#| eval: false
nombre <- function(x, y) {
  producto <- # código de la multiplicación
  return()
}
producto(3)
producto(3, -7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_producto <- function(x, y = x) {
  producto <- x * y
  return(producto)
}
funcion_producto(3)
funcion_producto(3, -7)
```

### [**Ej 3**]{.hl-yellow}

📝 Define una función llamada `igualdad_nombres` que, dados dos nombres, nos diga si son iguales o no. Hazlo considerando importantes las mayúsculas, y sin que importen las mayúsculas. Usa el paquete `{stringr}`.

```{r}
#| code-fold: true
#| eval: false
# Distinguiendo mayúsculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Lucía")

# Sin importar mayúsculas (ver también str_equal)
igualdad_nombres <- function(persona_1, persona_2) {
  return(str_to_upper(persona_1) == str_to_upper(persona_2))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Lucía")
```

### [**Ej 4**]{.hl-yellow}

📝 Crea una función llamada `calculo_IMC` que, dados dos argumentos (peso y estatura en metros) y un nombre, devuelva una lista con el IMC ($peso/(estatura_m^2)$) y el nombre.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura) {
  
  return(list("nombre" = nombre, "IMC" = peso/(estatura^2)))
}
```

### [**Ej 5**]{.hl-yellow}

📝 Repite el ejercicio anterior pero con otro argumento opcional que se llame unidades (por defecto, `unidades = "metros"`). Desarrolla la función de forma que haga lo correcto si `unidades = "metros"` y si `unidades = "centímetros"`.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  
  return(list("nombre" = nombre,
              "IMC" = peso/(if_else(unidades == "metros", estatura, estatura/100)^2)))
}
```

 
### [**Ej 6**]{.hl-yellow}

📝 Crea un tibble ficticio de 7 personas, con tres variables (inventa nombre, y simula peso, estatura en centímetros), y adapta la función `calculo_IMC()` de forma que obtengamos una cuarta columna con su IMC.

```{r}
#| code-fold: true
#| eval: false
datos <- tibble("nombres" = c("javi", "sandra", "eva", "ana", "carlos", "leo", NA),
                "peso" = rnorm(n = 7, mean = 70, sd = 1),
                "estatura" = rnorm(n = 7, mean = 168, sd = 5))

# IMPORTANTE. if_else trabaja de manera vectorial, elemento a elemento: la longitud de la
# condición (unidades == "metros" es un vector lógico de longitud uno) debe ser igual que
# lo que le decimos que haga cuando es TRUE y FALSE (en este caso, condicion tiene longitud 1
# pero al aplicarla lo que devuelve es vector de tamaño 7, por eso hay que usar ifelse (sin _))
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  return(list("nombre" = nombre,
              "IMC" = peso/(ifelse(unidades == "metros", estatura, estatura/100)^2)))
}
datos |> mutate(IMC = calculo_IMC(nombres, peso, estatura, unidades = "centímetros")$IMC)
```


### [**Ej 7**]{.hl-yellow}

📝 Crea una función llamada `atajo` que tenga dos argumentos numéricos `x` e `y`. Si ambos son iguales, debes devolver `"iguales"` y hacer que la función acaba automáticamente (piensa cuándo una función sale). OJO: `x` e `y` podrían ser vectores. Si son distintos (de igual de longitud) calcula la proporción de elementos  diferentes. Si son distintos (por ser distinta longitud), devuelve los elementos que no sean comunes.

```{r}
#| code-fold: true
#| eval: false
atajo <- function(x, y) {
  
  if (all(x == y) & length(x) == length(y)) { return("iguales") }
  else {
   
    if (length(x) == length(y)) {
      
      n_diff <- sum(x != y) / length(x)
      return(n_diff)
      
    } else {
      
      diff_elem <- unique(c(setdiff(x, y), setdiff(y, x)))
      return(diff_elem)
    }
    
  }
}
```


:::


---

## 🐣 Caso práctico I: conversor {#caso-practico-4-1}

Para practicar con funciones vamos a crear un completo **conversor de temperaturas** que, dada una temperatura en Fahrenheit, Celsius o Kelvin, la convierta a cualquiera de las otras

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/if-else-bucles-funciones-isciii/) hasta construirlo.


---

## Dataviz: historia


La aparición de gráficos estadísticos es [**relativamente reciente en la ciencia**]{.hl-yellow} ya que hasta la Edad Media la única visualización estaba en los [**mapas**]{.hl-yellow}. [^1] Las propias palabras _chart_ y _cartography_ derivan del mismo origen latino, _charta_, aunque el primer uso de coordenadas viene de los egipcios. [^2] [^3]

. . .

:::: columns
::: {.column width="55%"}

No es hasta la Edad Media, cuando la [**navegación y la astronomía**]{.hl-yellow} empezaban a tomar relevancia, cuando aparece la primera gráfica (no propiamente estadística), del **movimiento cíclico de los planetas** (siglos X y XI)

:::

::: {.column width="45%"}
![](img/dataviz_historico_1.png){width="370"}
:::
::::
 

[^1]: [«Gramática de las gráficas: pistas para mejorar las representaciones de datos» de Joaquín Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)

[^2]: [«Presentation Graphics» de Leland Wilkinson. International Encyclopedia of the Social & Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

[^3]: [«Quantitative Graphics in Statistics: A Brief History» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)]


---

## Navegación y astronomía


Con una motivación similar, en torno a 1360 el matemático **Nicole Oresme** diseñó el [**primer gráfico de barras**]{.hl-yellow} (pero no estadístico), con la idea de visualizar a la vez dos **magnitudes físicas teóricas**. [^4]


![](img/dataviz_historico_2.jpeg){width="300"}


[^4]: [«The First (Known) Statistical Graph: Michael Florent van Langren and the 'Secret' of Longitude» de M. Friendly y P. M. Valero-Mora. The American Statistician (2010)](https://www.researchgate.net/publication/227369016_The_First_Known_Statistical_Graph_Michael_Florent_van_Langren_and_the_Secret_of_Longitude)

 
---

## Primer gráfico estadístico

La mayoría de expertos, como Tufte [^5] [^6], consideran este gráfico casi longitudinal como la [**primera visualización de datos**]{.hl-yellow} de la historia, hecha por **Van Langren** en 1644, representando la [**distancia entre Toledo y Roma**]{.hl-yellow}.


```{r}
#| echo: false
knitr::include_graphics("./img/longitud_dataviz.jpg")
``` 

```{r}
#| echo: false
knitr::include_graphics("./img/dataviz_historico_3.jpeg")
``` 


[^5]: [«Visual explanations: images and quantities, evidence and narrative» de E. Tufte](https://archive.org/details/visualexplanatio00tuft)

[^6]: [«PowerPoint is evil» de E. Tufte](https://www.wired.com/2003/09/ppt2/)



---

## Vizfails

::: columns
::: {.column width="55%"}
![](img/persona_dataviz.jpg)
:::

::: {.column width="45%"}
* La figura elegida (persona caminando) sin relación con lo visualizado: [**mala metáfora**]{.hl-red}.

* Los [**sectores señalados sin relación con el ítem**]{.hl-red} a representar, lo que dificulta su interpretación.

* Los [**colores sin codificar**]{.hl-red}: no dan información de ningún tipo.

* Las [**formas irregulares impiden la comparación**]{.hl-red} de las áreas (amén de que la suma total supera el 100%).

* **Sin fuente**

:::
::::


---

## Vizfails

![](img/viz_fail_covid.jpg)

---

## Vizfails

![](img/viz_fail_uk.jpg)

---

## La importancia del CONTEXTO

Una **buena idea** puede estar mal ejecutada: la forma de llevarla a cabo es importante

![](img/semaforos.jpg)

---

## Dataviz: historia

En el siglo XVII hubo un boom de la estadística al empezar a aplicarse en [**demografía**]{.hl-yellow}. Uno de los autores más importantes fue [**J. Graunt**]{.hl-purple}, autor de «Natural and Political Observations Made upon the Bills of Mortality» (1662), estimando la población de Londres con las [**primeras tablas de natalidad y mortalidad**]{.hl-yellow}.

. . .

::: columns
::: {.column width="50%"}

Son precisamente las tablas de Graunt las que usó [**Christiaan Huygens**]{.hl-yellow} para generar la [**primera gráfica de densidad**]{.hl-yellow} de una distribución continua (esperanza de vida vs edad).

:::

::: {.column width="50%"}

```{r echo = FALSE,  out.width = "100%", fig.align = "center", fig.cap = "Primera función de densidad, extraída de https://omeka.lehigh.edu/exhibits/show/data_visualization/vital_statistics/huygen"}
knitr::include_graphics("./img/primera_densidad.jpg")
``` 

:::
::::

---

## Gráficos de Playfair

La figura que cambió el dataviz fue, sin lugar a dudas, el economista y político [**William Playfair (1759-1823)**]{.hl-yellow}, publicando en 1786 el **«Atlas político y comercial»** [^11] [^12] con 44 gráficas (43 series temporales y el diagrama de barras más famoso de la historia).

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "70%", fig.align = "center", fig.cap = "Extraídas de Funkhouser y Walker (1935)"}
knitr::include_graphics("./img/playfair_1.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "25%", fig.align = "center", fig.cap = "Extraídas de Funkhouser y Walker (1935)"}
knitr::include_graphics("./img/playfair_2.jpg")
``` 

:::
::::

[^10]: [«Atlas político y comercial» de William Playfair (1786)](https://www.amazon.es/Playfairs-Commercial-Political-Statistical-Breviary/dp/0521855543)

[^11]: [«Playfair and his charts» de H. Gray Funkhouser and  Helen M. Walker (1935)](https://www.jstor.org/stable/45366440)

---



## Gráficos de Playfair

Playfair es además el autor del [**gráfico de barras más famoso**]{.hl-yellow} (no fue el primero pero sí quien lo hizo _mainstream_).

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "Gráficas de Playfair de importaciones (barras grises) y exportaciones (negras) de Escocia en 1781, extraídas de la wikipedia."}
knitr::include_graphics("./img/playfair_5.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "Primer diagrama de barras (P. Buache y G. de L’Isle), visualizando los niveles del Sena (1732 - 1766), extraída de https://friendly.github.io/HistDataVis"}
knitr::include_graphics("./img/playfair_6.jpg")
``` 
:::
::::

---

## Gráficos de Playfair


Playfair además fue el primero en [**combinar gráficos en la misma visualización**]{.hl-yellow} [^12] [^13]

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "85%", fig.align = "center", fig.cap = "Visualiza 3 series temporales: precios (barras) del trigo, salarios (línea) y time-line con reinados, extraída de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/playfair_7.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "85%", fig.align = "center", fig.cap = "Time-line histórico, extraída de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/playfair_8.png")
``` 

:::
::::

[^12]: [«A Letter on Our Agricultural Distresses, Their Causes and Remedies» de W. Playfair (1821)](http://onlinebooks.library.upenn.edu/webbin/book/lookupid?key=ha009726110)

[^13]: [«An Inquiry Into the Permanent Causes of the Decline and Fall of Powerful and Wealthy Nations» de William Playfair (1821)](https://www.amazon.com/Permanent-Powerful-Nations-Prosperity-Prolonged/dp/140691830X)

---

## Primer scatter plot

Según J. Sevilla, se considera al astrónomo británico **John Frederick William Herschel** el autor del [**primer diagrama de dispersión o scatterplot**]{.hl-yellow} en 1833, visualizando el movimiento de la estrella doble Virginis (tiempo en el eje horizontal, posición angular en el eje vertical)


```{r echo = FALSE, out.width = "35%", fig.align = "center", fig.cap = "Extraído de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/herschel.jpg")
``` 

---

## Florence Nigthingale

::: columns
::: {.column width="65%"}


* El 21 de octubre de 1854 [**Florence Nigthingale**]{.hl-yellow} fue enviada para mejorar las **condiciones sanitarias** de los soldados británicos en la guerra de Crimea. 

* A su regreso demostró que los [**soldados fallecían por las condiciones sanitarias**]{.hl-yellow}. Nigthingale es la creadora del famoso [**diagrama de rosa**]{.hl-yellow}, visualizando tres variables a la vez y su estacionalidad.

* El 8 de febrero de 1955, The Times la describió como la **«ángel guardián» de los hospitales**, y acabó siendo conocida como [**«The Lady with the Lamp»**]{.hl-yellow} tras un poema de H. W. Longfellow (1857).

* Años después se convirtió en la [**primera mujer en la Royal Statistical Society**]{.hl-yellow}.

:::

::: {.column width="35%"}

```{r echo = FALSE, out.width = "95%", fig.align = "center"}
knitr::include_graphics("./img/the_lady_with_the_lamp.png")
``` 

:::
::::

---

## Diagrama de rosa

Florence Nigthingale es la creadora del famoso [**diagrama de rosa**]{.hl-yellow}, permitiendo pintar [**tres variables a la vez y su estacionalidad**]{.hl-yellow}: **tiempo** (cada **gajo** es un mes), **nº de muertes** (**área** del gajo) y **causa** de la muerte (**color** del gajo: azules enfermedades infecciosas, rojas por heridas, negras otras causas).


```{r echo = FALSE, out.width = "75%", fig.align = "center"}
knitr::include_graphics("./img/rosa_nightingale.jpg")
``` 

---


## Recursos de dataviz


📚 [«The Functional Art: an introduction to information graphics and visualization» de Alberto Cairo](https://www.amazon.es/Functional-Art-Voices-That-Matter/dp/0321834739)


📚 [«Gramática de las gráficas: pistas para mejorar las representaciones de datos» de Joaquín Sevilla](https://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)


📚 [«A Brief History of Visualization» de Friendly et al. (2008)](https://www.researchgate.net/publication/226400313_A_Brief_History_of_Data_Visualization)

📚 [«Quantitative Graphics in Statistics: A Brief History» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)]

📚 [«Presentation Graphics» de Leland Wilkinson. International Encyclopedia of the Social & Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

📚 [«The Grammar of Graphics» de Leland Wilkinson](https://www.amazon.es/Grammar-Graphics-Statistics-Computing/dp/0387245448)


📚 [«The Minard System: The Graphical Works of Charles-Joseph Minard» de Sandra Rendgen](https://www.amazon.es/gp/product/1616896337/ref=sw_img_1?smid=A1AT7YVPFBWXBL&psc=1)

📚 [«The Visual Display of Quantitative Information» de E. W. Tufte](https://www.amazon.es/Visual-Display-Quantitative-Information/dp/0961392142)

---

## Dataviz en R: ggplot2

:::: columns
::: {.column width="50%"}

El paquete `{ggplot2}` se basa en la idea de Wilkinson en [**«Grammar of graphics»**]{.hl-yellow}: dotar a los gráficos de una gramática propia. Una de las principales fortalezas de `R` es la [**visualización**]{.hl-yellow} con `{ggplot2}`.

```{r}
library(ggplot2)
```

La [**visualización de datos**]{.hl-yellow} debería ser una parte fundamental de todo análisis de datos. No es solo una cuestión estética.
:::

::: {.column width="50%"}
![](img/telling_dataviz.jpg){width="400"}
:::
::::

---

## Dataviz en R: ggplot2

La filosofía detrás de `{ggplot2}` es entender los [**gráficos como parte del flujo**]{.hl-yellow} de trabajo, dotándoles de una [**gramática**]{.hl-yellow}. El objetivo es empezar con un lienzo en blanco e ir [**añadiendo capas a tu gráfico**]{.hl-yellow}. La ventaja de `{ggplot2}` es poder [**mapear atributos estéticos**]{.hl-purple} (color, forma, tamaño) de objetos geométricos (puntos, barras, líneas) en función de los datos.

&nbsp;


La **documentación** del paquete puedes consultarla en <https://ggplot2-book.org/introduction.html> 

![](img/grammar_ggplot2.jpg)


---

## Dataviz en R: ggplot2

![](img/tarta_ggplot2.png)

---

## Dataviz en R: ggplot2

:::: columns
::: {.column width="40%"}
![](img/tarta_recortada_ggplot2.jpg)
:::

::: {.column width="60%"}
Un gráfico se podrá componer de [**capas**]{.hl-yellow}

* [**Datos (data)**]{.hl-purple}
* [**Mapeado (aesthetics)**]{.hl-purple} de elementos estéticos: ejes, color, forma, etc (en función de los datos)
* [**Geometría (geom)**]{.hl-purple}: puntos, líneas, barras, polígonos, etc.
* [**Componer gráficas (facet)**]{.hl-purple}
* [**Transformaciones (stat)**]{.hl-purple}: ordenar, resumir, etc.
* [**Coordenadas (coord)**]{.hl-purple}: coordenadas cartesianas, polares, grids, etc.
* [**Temas (theme)**]{.hl-purple}: fuente, tamaño de letra, subtítulos, captions, leyenda, ejes, etc.

:::
::::

---

## Primer intento: scatter plot

Veamos un **primer intento** para entender la filosofía ggplot. Imagina que queremos dibujar un [**scatter plot**]{.hl-yellow} (diagrama de dispersión de puntos). Para ello vamos a usar el conjunto de datos `gapminder`, del paquete homónimo: un fichero con **datos de esperanzas de vida, poblaciones y renta per cápita** de distintos países en distintos momentos temporales.

```{r}
library(gapminder)
gapminder
```


---

## Primer intento: scatter plot

El fichero consta de 1704 registros y 6 variables: `country`, `continent`, `year`, `lifeExp` (esperanza de vida), `pop` (población)  y `gdpPercap` (renta per cápita).

```{r}
glimpse(gapminder)
```

Para empezar con algo sencillo [**filtraremos solo los datos de 1997**]{.hl-yellow}

```{r}
gapminder_1997 <-
  gapminder |>
  dplyr::filter(year == 1997) |> 
  tidyr::drop_na(gdpPercap, lifeExp, pop)
```

---

## Ingredientes: (x, y)


¿Qué [**elementos necesitamos**]{.hl-yellow} para realizar un diagrama de puntos? Para [**iniciar el lienzo**]{.hl-pùrple} necesitamos una base de datos y dos variables a representar.

. . .

:::: columns
::: {.column width="45%"}

* [**Datos (data)**]{.hl-yellow}: conjunto `gapminder_1997`.

* [**Mapeado**]{.hl-yellow}: indicar dentro de `aes()` (aesthetics) las variables en cada coordenada. Todo [**dentro de aes() será mapeado de los datos**]{.hl-purple}

```{r}
#| eval: false
ggplot(data = gapminder_1997,
       aes(x = gdpPercap, y = pop))
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop))
```

:::
::::

---


## Primera geometría: geom_point()

:::: columns
::: {.column width="45%"}

* [**Geometría (geom)**]{.hl-yellow}: optaremos por **puntos** usando `geom_point()`.

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop)) +
  geom_point()
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(x = gdpPercap, y = pop)) +
  geom_point()
```

:::
::::

---

## Rol de los ejes: (x, y)


:::: columns
::: {.column width="45%"}

Vamos a profundizar en ese mapeado: ¿cómo [**cambiar el rol**]{.hl-yellow} de los ejes (población en el eje X y renta per cápita en el eje Y)? 

* **Eje X**: población (variable `pop`)
* **Eje Y**: renta per cápita (variable `gdpPercap`)


```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = pop)) +
  geom_point() 
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop)) +
  geom_point() 
```
:::
::::



