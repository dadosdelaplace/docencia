---
title: "Tidydata"
subtitle: "Cuadernos pr√°cticos del M√°ster de Bioinform√°tica (curso 2024-2025)"
author: "Javier √Ålvarez Li√©bana"
format:
  html:
    theme: [default, style.scss]
    toc: true
    toc-title: √çndice
    toc-depth: 5
    toc-location: left
    number-sections: true
embed-resources: true
execute: 
  echo: true
---


## Tidydata

### R base vs tidyverse

Hasta ahora todo lo que hemos hecho en `R` lo hemos realizado en el paradigma de programaci√≥n conocido como [**R base**]{.hl-yellow}. Y es que cuando `R` naci√≥ como lenguaje, muchos de los que programaban en √©l imitaron formas y metodolog√≠as heredadas de otros lenguajes, basado en el uso de

-   Bucles [**for**]{.hl-yellow}

-   Bucles [**while**]{.hl-yellow}

-   Estructuras [**if-else**]{.hl-yellow}


Y aunque conocer dichas estructuras puede sernos en algunos casos interesantes, en la [**mayor√≠a de ocasiones han quedado caducas y vamos a poder evitarlas**]{.hl-red} (en especial los bucles) ya que `R` est√° especialmente [**dise√±ado para trabajar de manera funcional**]{.hl-yellow} (en lugar de elemento a elemento).

Profundizaremos en las diferencias m√°s adelante cuando tengamos algo m√°s de conocimiento.


### ¬øQu√© es tidyverse?

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

En ese contexto de programaci√≥n funcional, hace una d√©cada nac√≠a `{tidyverse}`, un [**¬´universo¬ª de paquetes**]{.hl-yellow} para garantizar un flujo de trabajo eficiente, coherente y lexicogr√°ficamente sencillo de entender, basado en la idea de que [**nuestros datos est√°n limpios y ordenados (tidy)**]{.hl-purple}

-   `{tibble}`: optimizando data.frame
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv), `{readxl}` para importar archivos .xls y .xlsx
-   `{dplyr}`: gram√°tica para depurar
-   `{stringr}`: manejo de textos
-   `{purrr}`: manejo de listas
-   `{forcats}`: manejo de cualitativas
-   `{ggplot2}`: visualizaci√≥n de datos
-   `{lubridate}` manejo de fechas
-   `{rvest}`: web scraping
-   `{tidymodels}`: modelizaci√≥n/predicci√≥n


Todos estos paquetes descansan sobre una idea: hay **muchas formas de trabajar de manera sucia y desordenada** pero solo una de trabajar de manera estandarizada.

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)



::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

El [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducida por **Hadley Wickham** (el Dios al que rezamos) de [**estandarizar**]{.hl-yellow} el formato de los datos para

::: incremental
-   [**sistematizar**]{.hl-green} la depuraci√≥n
-   hacer m√°s [**sencillo**]{.hl-green} su manipulaci√≥n.
-   c√≥digo [**legible**]{.hl-green}
:::


### Mandamientos del tidy data

Lo primero por tanto ser√° entender qu√© son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos est√°n estandarizados.

1.  Cada [**variable**]{.hl-yellow} en una [**√∫nica columna**]{.hl-purple}

2.  Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}

3.  Cada [**celda**]{.hl-yellow} con un [**√∫nico valor**]{.hl-purple}

4.  Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}

5.  Si queremos cruzar [**m√∫ltiples tablas**]{.hl-yellow} debemos tener una [**columna com√∫n**]{.hl-purple}

![](img/tidy_def.jpg){width="160%"}


En `{tidyverse}` ser√° clave el [**operador pipe (tuber√≠a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): ser√° una [**tuber√≠a que recorre los datos**]{.hl-yellow} y los transforma.

¬øPara qu√© sirve? En R base (hasta ahora) si quer√≠amos aplicar tres funciones `first()`, `second()` y `third()` en orden, ser√≠a (lo hemos visto un poco en el caso pr√°ctico de funciones si lo has hecho 0_0)

```{r}
#| eval: false
third(second(first(datos)))
```

En `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones

```{r}
#| eval: false
datos |> first() |> second() |> third()
```


::: callout-caution
## Apunte importante

Desde la versi√≥n 4.1.0 de `R` disponemos de `|>`, un pipe **nativo** disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que depend√≠a del paquete `{magrittr}` (bastante problem√°tico).
:::


La principal ventaja es que el [**c√≥digo sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas c√≥digo.


```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```


### Datos SUCIOS: messy data

¬øPero qu√© aspecto tienen los [**datos no tidy**]{.hl-yellow}? Vamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).


```{r}
library(tidyr)
table4a
```


[**¬øQu√© puede estar fallando?**]{.hl-red}



#### Pivotar: pivot_longer()


```{r}
table4a
```

‚ùé Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) ‚Üí las columnas `1999` y `2000` en realidad deber√≠an ser en s√≠ [**valores de una variable**]{.hl-yellow} y no nombres de columnas.

&nbsp;

Incluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el a√±o y otra que guarde el valor de la variable de inter√©s en cada uno de esos a√±os. Y lo haremos con la funci√≥n `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

![](img/table4a.jpg)

-   `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}
-   `names_to`: nombre de la nueva variable a la quemandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).
-   `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.

#### Pivotar: pivot_wider()

Veamos otro ejemplo con la tabla `table2`


```{r}
table2
```


[**¬øQu√© puede estar fallando?**]{.hl-red}


‚ùé Cada [**observaci√≥n est√° dividido en dos filas**]{.hl-red} ‚Üí los [**registros con el mismo a√±o deber√≠an ser el mismo**]{.hl-yellow}


Lo que haremos ser√° lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```

#### Separar: separate()

Veamos otro ejemplo con la tabla `table3`


```{r}
table3
```


[**¬øQu√© puede estar fallando?**]{.hl-red}


‚ùé Cada [**celda contiene varios valores**]{.hl-red}

Lo que haremos ser√° hacer uso de la funci√≥n `separate()` para mandar [**separar cada valor**]{.hl-yellow} a una columna diferente.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```



F√≠jate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deber√≠an ser variables num√©ricas. Para ello podemos a√±adir el argumento opcional `convert = TRUE`

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

#### Unir: unite()

Veamos el √∫ltimo ejemplo con la tabla `table5`


```{r}
table5
```


[**¬øQu√© puede estar fallando?**]{.hl-red}


‚ùé Tenemos [**mismos valores divididos en dos columnas**]{.hl-red}

Usaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y a√±o en una misma columna

```{r}
table5 |> unite(col = year_completo, century, year, sep = "")
```

### Ejemplo real: relig_income

Vamos a realizar un ejemplo juntos con la tabla `relig_income` del paquete `{tidyr}`. Como se indica en la ayuda `? relig_income`, la tabla representa la cantidad de personas que hay en cada tramo de ingresos anuales (20k = 20 000$) y en cada religi√≥n.

```{r}
relig_income
```

[**¬øEs tidydata?**]{.hl-yellow} 

&nbsp;

No lo es ya que en realidad [**solo deber√≠amos tener una variable de ingresos**]{.hl-red} y la tenemos dividida en 11: todas ellas es la misma variable solo que adopta un valor diferente.  [**¬øC√≥mo convertirla a tidy data?**]{.hl-green}. La idea es [**pivotar todas las columnas de ingresos**]{.hl-yellow} para que acaben en una sola columna llamada `income`, y los valores (el n√∫mero de personas) en otra llamada `people` (por ejemplo). La tabla la haremos m√°s larga y menos ancha as√≠ que...

```{r}
relig_tidy <-
  relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused", names_to = "income",
               values_to = "people")
relig_tidy 
```

&nbsp;

Vamos a hilar m√°s fino: ahora mismo en la variable `income` en realidad tenemos dos valores, el l√≠mite inferior y el superior de la renta. Vamos a [**separar dicha variable e ingresos**]{.hl-yellow} en dos, llamadas `income_inf` y `income_sup`


```{r}
relig_tidy |>
  # Separamos por -
  separate(income, into = c("income_inf", "income_sup"), sep = "-")
```


¬øEst√° ya bien? F√≠jate bien...

&nbsp;

Si te fijas la primera columna el `"$10k"` deber√≠a ser una cota superior, no inferior. ¬øC√≥mo indicarle que separe bien ese caso? Le indicaremos que separe si encuentra `"-"` o `"<"` (usamos `|` para separar ambas opciones)

```{r}
relig_tidy <-
  relig_tidy |>
  # Separamos por -
  separate(income, into = c("income_inf", "income_sup"), sep = "-|<")
```


Piensa ahora como podemos [**convertir los l√≠mites de ingresos a num√©ricas (eliminando s√≠mbolos, letras, etc)**]{.hl-yellow}. Para ello usaremos el paquete `{stringr}` que hemos visto antes, en concreto la funci√≥n `str_remove_all()` a la que le podemos pasar los caracteres que queremos eliminar (f√≠jate que `$` al ser un caracter reservado en `R` hay que indic√°rselo con `\\$`)

```{r}
library(stringr)
relig_tidy$income_inf <-
  str_remove_all(relig_tidy$income_inf, "\\$|>|k")
relig_tidy$income_sup <-
  str_remove_all(relig_tidy$income_sup, "\\$|>|k")

relig_tidy
```

F√≠jate que a veces tenemos `"Don't now/refused"`. ¬øQu√© deber√≠amos tener?

&nbsp;

Deber√≠a ser un [**dato ausente**]{.hl-yellow} as√≠ que usaremos `if_else()`: si contiene dicha frase, `NA`, en caso contrario su valor (consejo: `str_detect()` para detectar patrones en textos, y evitar tener que escribir toda la palabra sin errores)

```{r}
library(dplyr)
relig_tidy$income_inf <-
  if_else(str_detect(relig_tidy$income_inf, "refused"), NA, relig_tidy$income_inf)
relig_tidy$income_sup <-
  if_else(str_detect(relig_tidy$income_sup, "refused"), NA, relig_tidy$income_sup)
relig_tidy
```

En la primera l√≠nea, ese `""` tambi√©n deber√≠a ser `NA``

```{r}
relig_tidy$income_inf <-
  if_else(relig_tidy$income_inf == "", NA, relig_tidy$income_inf)
relig_tidy$income_suop <-
  if_else(relig_tidy$income_sup == "", NA, relig_tidy$income_sup)
```


Adem√°s si te fijas los n√∫meros son en realidad caracteres, as√≠ que vamos a [**convertirlos a n√∫meros**]{.hl-yellow}

```{r}
relig_tidy$income_inf <- as.numeric(relig_tidy$income_inf)
relig_tidy$income_sup <- as.numeric(relig_tidy$income_sup)
relig_tidy
```


¬øSe te ocurre alguna forma de **¬´cuantificar num√©ricamente¬ª** los valores ausentes que tenemos en este caso? Si te fijas en realidad cuando hay ausente en el l√≠mite inferior en realidad podr√≠amos poner un 0 (nadie puede ganar menos de eso) y cuando lo tenemos en el l√≠mite superior ser√≠a `Inf`

```{r}
relig_tidy$income_inf <-
  if_else(is.na(relig_tidy$income_inf), 0, relig_tidy$income_inf)
relig_tidy$income_sup <-
  if_else(is.na(relig_tidy$income_sup), Inf, relig_tidy$income_sup)
relig_tidy
```


Aunque nos haya llevado un rato este es el **c√≥digo completo resumido**

```{r}
#| eval: false
relig_tidy <-
  relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused", names_to = "income",
               values_to = "people") |>
  separate(income, into = c("income_inf", "income_sup"), sep = "-|<")

relig_tidy$income_inf <- str_remove_all(relig_tidy$income_inf, "\\$|>|k")
relig_tidy$income_sup <- str_remove_all(relig_tidy$income_sup, "\\$|>|k")

relig_tidy$income_inf <-
  if_else(str_detect(relig_tidy$income_inf, "refused") |
            relig_tidy$income_inf == "", 0, as.numeric(relig_tidy$income_inf))
relig_tidy$income_sup <-
  if_else(str_detect(relig_tidy$income_sup, "refused") |
            relig_tidy$income_sup == "", Inf, as.numeric(relig_tidy$income_sup))
```


¬øPor qu√© era [**importante tenerlo en tidydata**]{.hl-yellow}? Lo veremos m√°s adelante al visualizar los datos pero esto ya nos permite realizar filtros muy r√°pidos con muy poco c√≥digo.

Por ejemplo: ¬øcu√°ntas personas agn√≥sticas con ingresos superiores (o iguales) a 30 tenemos?

```{r}
# una l√≠nea de c√≥digo
sum(relig_tidy$people[relig_tidy$religion == "Agnostic" & relig_tidy$income_inf >= 30])
```


### üíª Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Usa el dataset original `relig_income` y trata de responder a la √∫ltima pregunta:  ¬øcu√°ntas personas agn√≥sticas con ingresos superiores (o iguales) a 30 tenemos? Compara el c√≥digo a realizar cuando tenemos tidydata a cuando no. ¬øCu√°l es m√°s legible si no supieses `R`? ¬øCu√°l tiene mayor probabilidad de error?

```{r}
#| code-fold: true
#| eval: false

sum(relig_income[relig_income$religion == "Agnostic",
             c("$30-40k", "$40-50k", "$50-75k", "$75-100k", "$100-150k", ">150k")])
```


### [**Ejercicio 2**]{.hl-yellow}

üìù Usando `relig_tidy` determina qui√©n tiene m√°s ingresos medios, ¬øcat√≥licos (`Catholic`) o agn√≥sticos (`Agnostic`)? Crea antes una variable `avg_income` (ingresos medios por intervalo): si hay 5 personas entre 20 y 30, y 3 personas entre 30 y 50, la media ser√≠a $(25*5 + 40*3)/8$ (si es `Inf` por arriba, `NA`)

```{r}
#| code-fold: true
#| eval: false
relig_tidy$avg_income <- 
  if_else(is.infinite(relig_tidy$income_sup), NA, (relig_tidy$income_sup + relig_tidy$income_inf)/2)

# Agnosticos vs catolicos
sum((relig_tidy$avg_income[relig_tidy$religion == "Agnostic"] * relig_tidy$people[relig_tidy$religion == "Agnostic"]), na.rm = TRUE) /
  sum(relig_tidy$people[relig_tidy$religion == "Agnostic"], na.rm = TRUE)

sum((relig_tidy$avg_income[relig_tidy$religion == "Catholic"] * relig_tidy$people[relig_tidy$religion == "Catholic"]), na.rm = TRUE) /
  sum(relig_tidy$people[relig_tidy$religion == "Catholic"], na.rm = TRUE)
```


### [**Ejercicio 3**]{.hl-yellow}

üìù Si debemos elegir budismo (`Buddhist`) e hinduismo (`Hindu`), ¬øcu√°l de las dos es la religi√≥n mayoritaria entre los que ganan m√°s de 50 000$ anuales?

```{r}
#| code-fold: true
#| eval: false

greatest_income <-
  relig_tidy[relig_tidy$income_inf >= 50 & relig_tidy$religion %in% c("Buddhist", "Hindu"), ]

sum(greatest_income$people[greatest_income$religion == "Buddhist"], na.rm = TRUE)
sum(greatest_income$people[greatest_income$religion == "Hindu"], na.rm = TRUE)
```


### [**Ejercicio 4**]{.hl-yellow}

üìù Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```


### [**Ejercicio 5**]{.hl-yellow}

üìù Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```

:::


## üê£ Caso pr√°ctico: an√°lisis de datos de la OMS

En el paquete `{tidyr}` contamos con el dataset `who2` (dataset de la Organizaci√≥n Mundial de la Salud - OMS)

```{r}
library(tidyr)
who2
```

√âchale un vistazo y piensa qu√© cosas te podr√≠a pedir para convertirlo a tidydata.

### Pregunta 1

> ¬øQu√© significan los datos? ¬øCu√°ntas variables y observaciones tenemos?

```{r}
#| code-fold: true
#| eval: false

library(tidyr)
? who2
```


### Pregunta 2

> ¬øEs tidy data? ¬øPor qu√©

```{r}
#| code-fold: true
#| eval: false

# No es tidy data porque en realidad todas las variable
# a partir de year es lo mismo: casos de tuberculosis
# Son todo casos, solo que en distintas edades o sexo o tipos
# de diagnosis, pero la variable es "cases"
```


### Pregunta 3

> Primer paso para tidy data: pivota la tabla (consejo: usa papel y boli para bocetar como deber√≠a quedar la base de datos) tal que exista una columna llamada `cases`

```{r}
#| code-fold: true
#| eval: false
who_tidy <-
  who2 |> 
  # f√≠jate que en lugar de elegir las 56 columnas
  # le decimos las que NO queremos pivotar
  # los nombres de columnas los mandamos a "type" (tipo de caso)
  pivot_longer(cols = -(country:year),
               names_to = "type",
               values_to = "cases")
who_tidy 
```


### Pregunta 4

> Si te fijas hay much√≠simas filas que no tiene sentido mantener ya que ¬°no tenemos casos! Investiga las opciones de `pivot_longer()` para ver como podemos directamente eliminarlas en el pivotaje

```{r}
#| code-fold: true
#| eval: false
who_tidy <-
  who2 |> 
  # con values_drop_na = TRUE eliminamos los NA
  pivot_longer(cols = -(country:year),
               names_to = "type",
               values_to = "cases",
               values_drop_na = TRUE)
who_tidy 
```

### Pregunta 5

> Si te fijas ahora en type tenemos codificada la informaci√≥n como diagnosis_sexo_edad. ¬øC√≥mo separarlo en 3 columnas? Investiga tanto `separate()` como las opciones de `pivot_longer()`

```{r}
#| code-fold: true
#| eval: false

# con separate
who_tidy <-
  who_tidy |> 
  separate(col = "type", into = c("diagnosis", "sex", "age"))

# con pivot_longer
who_tidy <-
  who2 |> 
  pivot_longer(cols = -(country:year),
               names_to = c("diagnosis", "sex", "age"),
               values_to = "cases",
               values_drop_na = TRUE,
               names_sep = "_")
who_tidy 
```

### Pregunta 6

> Por √∫ltimo, separa en dos (age_inf, age_sup) el tramo etario (que sean n√∫meros). Piensa c√≥mo hacerlo ya que no siempre son 4 n√∫meros


```{r}
#| code-fold: true
#| eval: false

# Usamos separate y le indicamos las posiciones, pero desde atr√°s 
# ya que siempre el l√≠mite superior es un n√∫mero de 2 cifras
# y usamos convert = TRUE para convertir a n√∫meros
who_tidy <-
  who_tidy |> 
  separate(col = "age", into = c("age_inf", "age_sup"),
           sep = -2, convert = TRUE)
```

