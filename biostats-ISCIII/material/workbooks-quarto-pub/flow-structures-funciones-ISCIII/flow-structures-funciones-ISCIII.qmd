---
title: "Estructuras de control, bucles y funciones"
subtitle: "Cuadernos pr√°cticos del M√°ster de Bioinform√°tica (curso 2024-2025)"
author: "Javier √Ålvarez Li√©bana"
format:
  html:
    theme: [default, style.scss]
    toc: true
    toc-title: √çndice
    toc-depth: 5
    toc-location: left
    number-sections: true
    embed-resources: true
execute: 
  echo: true
---


Una [**estructura de control**]{.hl-yellow} se compone de una serie de comandos orientados a  [**decidir el camino**]{.hl-yellow} que tu c√≥digo debe recorrer

* Si se cumple la condici√≥n A, ¬øqu√© sucede?

* ¬øY si sucede B?

* ¬øC√≥mo puedo repetir una misma expresi√≥n (dependiendo de una variable)?

&nbsp;

Si has programado antes, quiz√°s te sea familiar las conocidas como [**estructuras condicionales**]{.hl-yellow} tales como `if (blabla) {...} else {...}`  o [**bucles**]{.hl-yellow} `for/while` (a evitar siempre que podamos).


## Estructuras condicionales

Una de las estructuras de control m√°s famosas son las conocidas como [**estructuras condicionales**]{.hl-yellow}: si pasase algo... entonces...


### If

La m√°s simple es la conocida como `if`.

> SI (IF) un conjunto de condiciones se cumple (TRUE), entonces ejecuta lo que haya dentro de las llaves

Por ejemplo, la estructura

`if (x == 1) { c√≥digo A }`

lo que har√° ser√° [**ejecutar el c√≥digo A entre llaves**]{.hl-yellow} pero [**SOLO SI**]{.hl-purple} la [**condici√≥n entre par√©ntesis es cierta**]{.hl-purple} (solo si `x` es 1). En cualquier otro caso, no har√° nada.

Para ilustrarlo definamos un vector de edades de 8 personas

```{r}
edad <- c(14, 17, 24, 56, 31, 20, 87, 73)
edad < 18
```

Nuestra estructura condicional har√° lo siguiente: [**si existe alg√∫n menor de edad, imprimir√°**]{.hl-yellow} por pantalla un mensaje.

```{r}
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```



En caso de que las [**condiciones no sean ciertas**]{.hl-yellow} dentro de `if()` (`FALSE`), no sucede nada


```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
}
```

**No obtenemos ning√∫n mensaje** porque la condici√≥n `all(edad >= 18)` no es `TRUE`, as√≠ que no ejecuta nada.

### If-else

La estructura `if (condicion) { c√≥digo A }` puede combinarse con un

`if (condicion) { c√≥digo A } else { c√≥digo B }`

cuando la condici√≥n se verifica se har√° A, pero cuando la [**condici√≥n no se cumpla**]{.hl-yellow}, se [**ejecutar√° el c√≥digo alternativo B**]{.hl-yellow} dentro de `else { }`, permiti√©ndonos decidir que sucede cuando se cumple y cuando no.

Por ejemplo, `if (x == 1) { c√≥digo A } else { c√≥digo B }` ejecutar√° A si `x` es igual a 1 y B en cualquier otro caso. Piensa cu√°nto valdr√° `y` en el c√≥digo inferior:

```{r}
x <- 3

if (x == 1) {
  
  y <- 2
  
} else {
  
  y <- -1
  
}
```

En el ejemplo anterior `y` valdr√° -1 ya que la condici√≥n no se cumple y el c√≥digo tomar√° el camino del `else { ... }`. En el ejemplo anterior de las edades, vamos a imprimir por pantalla una frase si todos son mayores de edad y otra si no.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else {
  
  print("Existe alguna persona menor de edad")
}
```

&nbsp;

Esta estructura `if - else` puede ser [**anidada**]{.hl-yellow}: imagina que queremos ejecutar un c√≥digo si todos son menores; si no sucede, pero todos son mayores de 16, hacer otra cosa; en cualquier otra cosa, otra acci√≥n.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else if (all(edad >= 16)) {
  
  print("Hay alg√∫n menor de edad pero todos con 16 a√±os o m√°s")
  
} else { print("Hay alguna persona con menos de 16 a√±os") }
```

::: callout-note
## Truco

Puedes **colapsar las estructuras** haciendo click en la flecha a la izquierda que aparece en tu script.

:::


### If-else vectorizado


Esta estructura condicional se puede [**vectorizar**]{.hl-yellow} (en una sola l√≠nea) con `if_else()` (del paquete `{dplyr}` que veremos en profundidad m√°s adelante), cuyos argumentos son

* la condici√≥n a evaluar
* lo que sucede cuando se cumple y cuando no
* un argumento opcional para cuando la condici√≥n a evaluar es `NA`

Vamos a etiquetar sin son mayores/menores y un "desconocido" cuando no conocemos

```{r}
library(dplyr)
edad <- c(NA, edad)
if_else(edad >= 18, "mayor", "menor", missing = "desconocido")
```

En `R` base existe `ifelse()`: no deja especificar que hacer con los ausentes pero permite especificar distintos tipos de datos en `TRUE` y en `FALSE`.

### üíª Tu turno


[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù ¬øCu√°l es la salida del siguiente c√≥digo?

```{r}
#| eval: false
if_else(sqrt(9) < 2, sqrt(9), 0)
```

```{r}
#| eval: false
#| code-fold: true

La salida es 0 ya que sqrt(9) es igual 3, y dado que no es menor que 2, devuelve el segundo argumento que es 0
```

### [**Ejercicio 2**]{.hl-yellow}

üìù ¬øCu√°l es la salida del siguiente c√≥digo?

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true

La salida es el vector c(0, NA, NA, 1) ya que sqrt(1) s√≠ es menor que 2, sqrt(9) no lo es, y tanto en el caso de sqrt(NA) (ra√≠z de ausente) como sqrt(-1) (devuelve NaN, not a number), su ra√≠z cuadrada no puede verificarse si es menor que 2 o no, as√≠ que la salida es NA.
```


### [**Ejercicio 3**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para que, cuando no se pueda verificar si la ra√≠z cuadrada de un n√∫mero es menor que 2, devuelva -1

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1, missing = -1)
```


### [**Ejercicio 4**]{.hl-yellow}

üìù ¬øCu√°l es son los valores de `x` e `y` del c√≥digo inferior para `z <- 1`, `z <- -1` y `z <- -5`?

```{r}
#| eval: false
z <- -1
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
En primero caso x = 1 e y = -1. En el segundo caso x = 1 e y = 1. En el tercer caso -2.5 y 5
```

### [**Ejercicio 5**]{.hl-yellow}

üìù ¬øQu√© pasar√≠a si ejecutamos el siguiente c√≥digo? Spoiler: da error. ¬øPor qu√©? ¬øC√≥mo solucionarlo?

```{r}
#| eval: false
z <- c(-1, 1, 5)
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
Da error ya que en los `if (condici√≥n) { } else { }` "cl√°sicos" necesitamos que
la condici√≥n tenga longitud uno (un solo valor TRU/FALSE)
```

```{r}
#| eval: false
#| code-fold: true
# para arreglarlo podemos hacer un if_else vectorial
z <- c(-1, 1, -5)
library(dplyr)
x <- if_else(z > 0, z^3, if_else(abs(z) < 2, z^4, z/2))
y <- if_else(z > 0, -sqrt(z), if_else(abs(z) < 2, sqrt(-z), abs(z)))
```

### [**Ejercicio 6**]{.hl-yellow}

üìù ¬øQu√© suceder√° si ejecutamos el c√≥digo inferior?

```{r}
#| eval: false
z <- "a"
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| code-fold: true
#| eval: false

# dar√° error ya que no es un argumento num√©rico
Error in z^3 : non-numeric argument to binary operator
```


### [**Ejercicio 7**]{.hl-yellow}

üìù Del paquete `{lubridate}`, la funci√≥n `hour()` nos devuelve la hora de una fecha dada, y la funci√≥n `now()` nos devuelve fecha y hora del momento actual. Con ambas funciones haz que se imprima por pantalla (`cat()`) "buenas noches" solo a partir de las 21 horas.

```{r}
#| code-fold: true
#| eval: false

# Cargamos librer√≠a
library(lubridate)

# Fecha-hora actual
fecha_actual <- now()

# Estructura if
if (hour(fecha_actual) > 21) {
  
  cat("Buenas noches") # print/cat dos formas de imprimir por pantalla
}
```


:::


## Bucles

Aunque en la mayor√≠a de ocasiones se pueden reemplazar por otras estructuras m√°s eficientes y legibles, es importante conocer una de las expresiones de control m√°s famosas: los [**bucles**]{.hl-yellow}.

* `for { }`: permite [**repetir el mismo c√≥digo**]{.hl-yellow} en un [**n√∫mero prefijado y conocido**]{.hl-purple} de veces.

* `while { }`: permite [**repetir el mismo c√≥digo**]{.hl-yellow} pero en un [**n√∫mero indeterminado de veces**]{.hl-purple} (hasta que una **condici√≥n** deje de cumplirse).


### Bucles for

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de √≥rdenes un n√∫mero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de √≠ndices.

&nbsp;

Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vac√≠a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los par√©ntesis indicaremos un √≠ndice y unos valores a recorrer, dentro de las llaves el c√≥digo a ejecutar en cada iteraci√≥n (en este caso, rellenar `y` como `x + 1`)


```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  
  y[i] <- x[i] + 1
  
}
```

F√≠jate que debido a que `R` funciona de manera [**vectorial por defecto**]{.hl-yellow}, el bucle es lo mismo que hacer `x + 1` directamente.

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  
  y[i] <- x[i] + 1
  
}
y

y2 <- x + 1 # hacen lo mismo
y2
```


Otra opci√≥n habitual es indicar los √≠ndices de manera ¬´autom√°tica¬ª: desde el primero `1` hasta el √∫ltimo (que corresponde con la longitud de x `length(x)`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:length(x)) {
  
  y[i] <- x[i] + 1
  
}
y
```


As√≠ la [**estructura general de un bucle for**]{.hl-yellow} ser√° siempre la siguiente

```{r}
#| eval: false
for (√≠ndice in conjunto) { 
  c√≥digo (dependiente de i)
}
```

[**SIEMPRE**]{.hl-green} sabemos cu√°ntas iteraciones tenemos (tantas como elementos haya en el conjunto a indexar).

&nbsp;

Podemos ver otro ejemplo de bucle  [**combinando n√∫meros y textos**]{.hl-yellow}: definimos un vector de edades y de nombres, e imprimimos el nombre y edad i-√©sima.

```{r}
nombres <- c("Javi", "Sandra", "Carlos", "Marcos", "Marta")
edades <- c(33, 27, 18, 43, 29)
library(glue)

for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} a√±os")) 
  
}
```



Aunque normalmente se suelen indexar con vectors num√©ricos, los bucles pueden ser [**indexados sobre cualquier estructura vectorial**]{.hl-yellow}, da igual de que tipo sea el conjunto

```{r}
library(stringr)
week_days <- c("monday", "tuesday", "wednesday", "thursday",
               "friday", "saturday", "sunday")

for (days in week_days) {
  
  print(str_to_upper(days))
}
```

#### Bucles + condicionales

Vamos a **combinar las estructuras condicionales y los bucles**: usando el conjunto `swiss` del paquete `{datasets}`, vamos a asignar `NA`  si los valores de fertilidad son mayores de 80.

```{r}
for (i in 1:nrow(swiss)) {
  
  if (swiss$Fertility[i] > 80) { 
    
    swiss$Fertility[i] <- NA
    
  }
}
```


Esto es exactamente igual a un `if_else()` vectorizado

```{r}
data("swiss")
swiss$Fertility <- if_else(swiss$Fertility > 80, NA, swiss$Fertility)
```


#### Evitando bucles


Como ya hemos aprendido con el paquete`{microbenchmark}` podemos chequear como [**los bucles suelen ser muy ineficientes**]{.hl-yellow} (de ah√≠ que debamos evitarlos en la mayor√≠a de ocasiones

```{r}
library(microbenchmark)
x <- 1:1000
microbenchmark(y <- x^2, 
               for (i in 1:100) { y[i] <- x[i]^2 },
               times = 500)
```


### Bucles while

Otra forma de crear un bucle es con la estructura `while { }`, que nos ejecutar√° un bucle [**un n√∫mero desconocido de veces**]{.hl-yellow}, hasta que una condici√≥n [**deje de cumplirse**]{.hl-yellow} (de hecho puede que nunca termine). Por ejemplo, vamos a inializar una variable `ciclos <- 1`, que incrementaremos en cada paso, y no saldremos del bucle hasta que `ciclos > 4`.

```{r}
ciclos <- 1
while(ciclos <= 4) {
  
  print(glue("No todav√≠a, vamos por el ciclo {ciclos}")) 
  ciclos <- ciclos + 1
  
}
```

Un bucle `while` ser√° siempre como sigue

```{r}
#| eval: false
while(condici√≥n) {
  
  c√≥digo a hacer mientras la condici√≥n sea TRUE
  # normalmente aqu√≠ se actualiza alguna variable
  
}
```


¬øQu√© sucede cuando la [**condici√≥n nunca es FALSE**]{.hl-yellow}? Pru√©balo tu mismo

```{r}
#| eval: false
while (1 > 0) {
  
  print("Presiona ESC para salir del bucle")
  
}
```

&nbsp;

::: callout-warning
## Cuidado

Un bucle `while { }` puede ser bastante ¬´peligroso¬ª sino controlamos bien c√≥mo pararlo.

:::

#### parada del while

Debido a que puede ser problem√°tico no saber el n√∫mero predeterminado de veces que un `while` va a ejecutarse, contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `break`: permite [**abortar un bucle**]{.hl-yellow} incluso si no se ha llegado a su final

```{r}
for(i in 1:10) {
  if (i == 3) {
    
    break # si i = 3, abortamos bucle
    
  }
  print(i)
}
```


* `next`: [**fuerza un bucle a avanzar a la siguiente iteraci√≥n**]{.hl-yellow} 

```{r}
for(i in 1:5) {
  if (i == 3) {
    
    next # si i = 3, la obvia y continua al siguiente
    
  }
  print(i)
}
```


### Bucles repeat

Aunque no es tan usado como las opciones anteriores, tambi√©n contamos con `repeat { }` que ejecuta un [**bucle de manera infinita hasta que se indique abortar**]{.hl-yellow} con un break

```{r}
count <- 0
repeat { 
  
  count <- count + 1
  if (count >= 100) { break }
  
}
count
```


### Replicate

Aunque no es formalmente un bucle, otra forma de [**repetir c√≥digo un n√∫mero de veces**]{.hl-yellow} es hacer uso de `replicate()`: simplemente permite repetir lo mismo [**n veces**]{.hl-yellow}

```{r}
x <- 1:3
replicate(n = 3, x^2)
```


La funci√≥n `replicate()` se suele usar para [**generar distintas repeticiones de elementos aleatorios**]{.hl-yellow}. Por ejemplo, imaginemos que queremos generar 3 muestras de distribuciones normales, en la que cada muestra tendr√° 7 elementos. Para generar una se usa `rnorm(n = 7)` (r de resample, norm de normal, y si no se dice nada es media 0 y desv 1).

```{r}
replicate(n = 3, rnorm(n = 7))
```


### üíª Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para que se imprima un mensaje por pantalla si y solo si todos los datos de `airquality` son con mes distinto a enero

```{r}
#| eval: false
library(datasets)
months <- airquality$Month

if (months == 2) {
  print("No hay datos de enero")
}
```

```{r}
#| code-fold: true
#| eval: false
library(datasets)
months <- airquality$Month

if (all(months != 1)) {
  print("No hay datos de enero")
}
```


### [**Ejercicio 2**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para guardar en una variable llamada `temp_alta` un `TRUE` si alguno de los registros tiene una temperatura superior a 90 grados Farenheit y `FALSE` en cualquier otro caso
 
```{r}
#| eval: false
temp <- airquality$Temp

if (temp == 100) {
  print("Algunos de los registros tienen temperaturas superiores a 90 grados Farenheit")
}
```

 
```{r}
#| eval: false
#| code-fold: true
# Option 1
temp <- airquality$Temp
temp_alta <- FALSE
if (any(temp > 90)) {
   temp_alta <- TRUE
}

# Option 2
temp_alta <- any(airquality$Temp > 90)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para dise√±ar un bucle `for` de 5 iteraciones que solo recorra los primeros 5 impares (y en cada paso del bucle los imprima)

```{r}
#| eval: false
for (i in 1:5) {
  
  print(i)
}
```

```{r}
#| eval: false
#| code-fold: true
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i)
}
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para dise√±ar un bucle `while` que empiece con un contador `count <- 1` y pare cuando llegue a 6

```{r}
#| eval: false
count <- 1
while (count == 2) {
  
  print(count)
}
```

```{r}
#| eval: false
#| code-fold: true
count <- 1
while (count < 6) {
  
  print(count)
  count <- count + 1
  
}
```


:::


## üê£ Caso pr√°ctico I: bucles y estructuras condicionales

Para practicar estructuras de control vamos a realizar un [**ejercicio de simulaci√≥n**]{.hl-yellow}



### Pregunta 1

> Define una varible llamada `importe` que empiece en 100. Dise√±a un bucle de 20 iteraciones donde en cada iteraci√≥n, importe se reduzca a la mitad de su valor. Piensa que tipo de estructura de bucle deber√≠as usar. El valor final de `importe` deberia ser `0.000095367` (aprox)

```{r}
#| code-fold: true
#| eval: false

# Usamos un for ya que sabemos el n√∫mero de iteraciones 
# de manera prefijada (y no depende de nada)

# definimos inicialmente importe en 100
importe <- 100 

# para el bucle usamos por ejemplo i como √≠ndice, que va de 1 a 20
for (i in 1:20) {
  
  # el c√≥digo f√≠jate que es el mismo y no depende de i
  importe <- importe/2
}
importe
```


### Pregunta 2

> Dise√±a una estructura de bucle de manera que encuentres la iteraci√≥n en la que `importe` es menor que 0.001 por primera vez. Una vez encontrado gu√°rdalo en `iter` y para el bucle.


```{r}
#| code-fold: true
#| eval: false

# dos formas de hacerlo: for y while

# con for
importe <- 100 

# ya sabemos que en 20 es menor que 0.001 as√≠ que podemos poner
# dicha cantidad como tope sabiendo que no llegar√°
for (i in 1:20) {
  
  # si todav√≠a no es menor, seguimos dividiendo
  if (importe >= 0.001) {
    
    importe <- importe/2
    
  } else {
    
    # si ya es menor, guardamos la iteraci√≥n (piensa por qu√© i - 1)
    iter <- i - 1 
    
    # y paramos
    break
  }
  
}

# con while
importe <- 100 

iter <- 0 # debemos inicializar las iteraciones

# no sabemos cuantas iteraciones, solo que debe parar cuando
# importe est√© por debajo de dicha cantidad
while (importe >= 0.001) {
  
  importe <- importe/2
    
  # estructura cl√°sica de while: si se corre iteraci√≥n
  # actualizamos un valor (en este caso que cuente una iteraci√≥n)
  iter <- iter + 1
}

iter
```


### Pregunta 3

> En `R` tenemos la funci√≥n `%%`: si ponemos `a %% b` nos devuelve el resto que dar√≠a la divisi√≥n $a/b$. Por ejemplo, `4 %% 2` da 0 ya que 4 es un n√∫mero par (es decir, su resto al dividir entre 2 es 0). Si ponemos `13 %% 5` nos devuelve 3, ya que el resto de dividir 13 entre 5 es 3.

```{r}
# Resto al dividir entre 2
3 %% 2
4 %% 2
5 %% 2
6 %% 2

# Resto al dividir entre 3
9 %% 3
10 %% 3
11 %% 3
12 %% 3
```

> Empezando en un importe inicial `importe_inicial` de 100 (euros), dise√±a un bucle que te sume 3‚Ç¨ m√°s la iteraci√≥n por la que est√©s si el importe actual es par y te reste 5‚Ç¨ menos la iteraci√≥n por la que est√©s si es impar, SALVO que el importe ya est√© igual o por debajo de 0 (en ese caso no debe sumar ni retar). Ejemplo: si importe tiene 50 euros y est√°s en la iteraci√≥n 13, sumar√° 3 + 13 (66 en total); si importe tiene 51 euros y est√°s en la iteraci√≥n 13, restar√° 5 + 13 (33 en total); si importe tiene -2 euros y est√°s en la iteraci√≥n 13, sumar√° 3 + 13 (14 en total); si importe tiene -1 euros y est√°s en la iteraci√≥n 13, no har√° nada. Guarda los importes resultantes de cada iteraci√≥n (m√°ximo de 150 iteraciones). Empieza a partir de la iteraci√≥n 2

```{r}
#| code-fold: true
#| eval: false

importe_inicial <- 100
importe <- c(importe_inicial, rep(NA, 149))
for (i in 2:150) {
  
  if (importe[i - 1] %% 2 == 0) {
    
    importe[i] <- importe[i - 1] + 3 + i
    
  } else if (importe[i - 1] > 0) {
    
    importe[i] <- importe[i - 1] - (5 + i)
    
  } else {
    
    importe[i] <- importe[i - 1]
    
  }
}
```

> ¬øQu√© ha pasado?


### Pregunta 4

> En `R` la funci√≥n `sample(x = ..., size = ...)` va sernos muy √∫til: de una colecci√≥n de elementos `x`, selecciona un n√∫mero `size` al azar de ellos.

Por ejemplo, si queremos simular 3 veces el lanzamiento de un dado tenemos 6 elementos posibles (`x = 1:6`) y lo seleccionamos 3 veces (`size = 3`)

```{r}
sample(x = 1:6, size = 3)
```

Al ser aleatorio, cada vez que lo ejecutas saldr√° algo distinto

```{r}
sample(x = 1:6, size = 3)
```

¬øY si queremos tirar 10 veces?

```{r}
#| error: true
sample(x = 1:6, size = 10)
```

Al tener solo 6 elementos posibles y elegir 10, no puede, as√≠ que le tenemos que indicar que queremos un sample (muestreo) con reemplazamiento (como sucede en el dado, cada cara puede repetirse al volver a tirarlo)


```{r}
sample(x = 1:6, size = 10, replace = TRUE)
```

#### Pregunta 4.1

> Con lo anterior, imagina que est√°s en un concurso de televisi√≥n donde te dan a elegir 3 puertas: en una hay un premio millonarios y en las otras 2 una galleta oreo. Dise√±a el estudio de simulaci√≥n con bucles for para aproximar la probabilidad de que te toque el premio (obviamente tiene que darte aprox 0.3333). Realiza el experimento para 10, 50 intentos, 100 intentos, 500 intentos, 1000 intentos, 10 000 intentos, 20 000 intentos y 30 000 intentos (pista: necesitas un bucle dentro de otro). ¬øQu√© observas?

```{r}
#| code-fold: true
#| eval: false
library(dplyr)

# Definimos las posibilidades
puertas <- c(1, 2, 3)

# Definimos los intentos
intentos <- c(10, 50, 100, 500, 1000, 10000, 20000, 30000)

# Para cada escenario de intentos, definimos las veces que hemos ganado
# (al inicio empieza en 0 claro)
exitos <- rep(0, length(intentos))

# primer bucle: cantidad de intentos permitidos
for (i in 1:length(intentos)) {
  
  # segundo bucle: para cada intento, simulaciones una eleccion de 
  # puerta y un premio
  for (j in 1:intentos[i]) {
    
    # premio: de 3 puertas, solo est√° en una
    premio <- sample(x = puertas, size = 1)
    
    # puerta que seleccionas como concursante: de 3 puertas, te quedas con una
    eleccion <- sample(x = puertas, size = 1)
    
    # si la puerta seleccionada coincide con la que tiene el premio
    # sumas un √©xito, sino te quedas como est√°s
    exitos[i] <- if_else(eleccion == premio, exitos[i] + 1, exitos[i])
    
  }
  # Tras jugar, lo dividimos entre el n√∫mero de veces que has jugado
  # para tener una proporci√≥n
  exitos[i] <- exitos[i] / intentos[i]
}
exitos
```

#### Pregunta 4.2

> ¬øY si en cada ronda, te abriesen una de las puertas no premiadas que no has elegido, cambiar√≠as de puerta o te mantendr√≠as? Simula ambos casos y descubre cu√°l es la estrategia correcta (este problema se conoce como problema de Monty Hall y aparece incluso en pel√≠culas como 21 Black Jack)


```{r}
#| code-fold: true
#| eval: false

puertas <- c(1, 2, 3)
intentos <- c(10, 50, 100, 500, 1000, 10000, 20000, 30000)
exitos_mantengo <- exitos_cambio <- rep(0, length(intentos))

for (i in 1:length(intentos)) {
  for (j in 1:intentos[i]) {
    
    # puerta que seleccionas como concursante: de 3 puertas, te quedas con una
    eleccion_inicial <- sample(x = puertas, size = 1)
    
    # premio: de 3 puertas, solo est√° en una
    premio <- sample(x = puertas, size = 1)
    
    # De la no elegida, el presentador te abre una no premiada
    puerta_abierta <-
      puertas[puertas != eleccion_inicial & puertas != premio]
    
    # si solo hay una opci√≥n (es decir que tu eleccion inicial
    # y el premio son puertas distintas) no haces nada
    
    # Si hubiese 2 opciones (si tu eleccion y el premio coinciden)
    # te abrir√° una al azar
    if (length(puerta_abierta) > 1) {
      
      puerta_abierta <- sample(x = puerta_abierta, size = 1)
    }
      
    
    # si mantienes es como antes
    exitos_mantengo[i] <-
      if_else(eleccion_inicial == premio, exitos_mantengo[i] + 1, exitos_mantengo[i])
    
    # si cambias es a una puerta distinta de la inicial y de la abierta, la que quede
    cambio <- puertas[puertas != eleccion_inicial & puertas != puerta_abierta]
    exitos_cambio[i] <-
      if_else(cambio == premio, exitos_cambio[i] + 1, exitos_cambio[i])
    
  }
  # Tras jugar, lo dividimos entre el n√∫mero de veces que has jugado
  # para tener una proporci√≥n
  exitos_mantengo[i] <- exitos_mantengo[i] / intentos[i]
  exitos_cambio[i] <- exitos_cambio[i] / intentos[i]
}
exitos_mantengo
exitos_cambio
```

> ¬øQu√© sucede?


## Funciones en R

Cuando programamos no solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, adem√°s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas** o poder incluso exportarlo para que otras personas las usen.

### Estructura b√°sica

¬øC√≥mo [**crear nuestra propia funci√≥n**]{.hl-purple}? Veamos su **esquema b√°sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extra√±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funci√≥n dentro de `{ }`.

* Finalizamos la funci√≥n con los [**argumentos de salida**]{.hl-yellow} con `return()`.


```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  c√≥digo a ejecutar
  
  return(var_salida)
  
}
```

Si te fijas en el c√≥digo anterior, `arg1, arg2, ...` ser√°n los [**argumentos de entrada**]{.hl-yellow}, los argumentos que toma la funci√≥n para ejecutar el c√≥digo que tiene dentro.

Adem√°s hay otra parte que normalemnte siempre aparecer√° en la funci√≥n (no es necesario pero suele ser habitual que est√©): `return(var_salida)`, de manera que dentro de `return()` se introducir√°n los [**argumentos de salida**]{.hl-yellow}, lo que queremos que devuelva la funci√≥n

::: callout-important
## Importante

Todas las variables que definamos dentro de la funci√≥n son [**variables LOCALES: solo existir√°n dentro de la funci√≥n**]{.hl-yellow} salvo que especifiquemos lo contrario.

:::

#### Ejemplo: c√°lcular √°rea

Veamos un ejemplo muy simple de funci√≥n para [**calcular el √°rea de un rect√°ngulo**]{.hl-yellow}.

Dado que el √°rea de un rect√°ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos ser√°n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} ser√° justo su **√°rea** ($lado_1 * lado_2$).



```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  return(area)
  
}
```


Tambi√©n podemos hacer una definici√≥n directa de las variables **sin almacenar por el camino**.

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  return(lado_1 * lado_2)
  
}
```

[**¬øC√≥mo aplicar la funci√≥n?**]{.hl-yellow} Simplemente usando el nombre que le hemos dado y dentro de los par√©ntesis, separados por comas, los argumentos de entrada.

```{r}
calcular_area(5, 3) # √°rea de un rect√°ngulo 5 x 3 
calcular_area(1, 5) # √°rea de un rect√°ngulo 1 x 5
```

::: callout-tip


Aunque no sea necesario, es [**recomendable hacer expl√≠cita la llamada de los argumentos**]{.hl-green}, especificando en el c√≥digo qu√© valor es para cada argumento para que no dependa de su orden, haciendo el c√≥digo m√°s legible
:::


```{r}
calcular_area(lado_1 = 5, lado_2 = 3) # √°rea de un rect√°ngulo 5 x 3 
calcular_area(lado_2 = 3, lado_1 = 5) # √°rea de un rect√°ngulo 5 x 3 
```

### Argumentos por defecto

Imagina ahora que nos damos cuenta que el 90% de las veces usamos dicha funci√≥n para [**calcular por defecto el √°rea de un cuadrado**]{.hl-yellow} (es decir, solo necesitamos un lado). Para ello, podemos definir [**argumentos por defecto**]{.hl-yellow} en la funci√≥n: tomar√°n dicho valor salvo que le asignemos otro.

¬øPor qu√© no asignar `lado_2 = lado_1` **por defecto**, para ahorrar l√≠neas de c√≥digo y tiempo?


```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```


Ahora [**por defecto**]{.hl-yellow} el segundo lado ser√° igual al primero (si se lo a√±adimos usar√° ambos).


```{r}
calcular_area(lado_1 = 5) # cuadrado
calcular_area(lado_1 = 5, lado_2 = 7) # rect√°ngulo
```

### Salida m√∫ltiple

Compliquemos un poco la funci√≥n y a√±adamos en la salida los valores de cada lado, etiquetados como `lado_1` y `lado_2`, [**empaquetando la salida en una vector**]{.hl-yellow}.

```{r}
#| code-line-numbers: "7-8"
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

Podemos complicar un poco m√°s la salida a√±adiendo una cuarta variable que nos diga, en funci√≥n de los argumentos, [**si rect√°ngulo o cuadrado**]{.hl-yellow}, teniendo que a√±adir en la salida una variable que de tipo caracter (o l√≥gica).

```{r}
#| code-line-numbers: "7-9"
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
library(dplyr)
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rect√°ngulo")))
  
}
calcular_area(5, 3)
```

Pero f√≠jate que tenemos un [**problema**]{.hl-red}: al intentar juntar n√∫meros y texto, lo convierte todo a n√∫meros. Podr√≠amos guardarlo todo en un `tibble()` como hemos aprendido o en un objeto conocido en `R` como [**listas**]{.hl-yellow}

### Breve introducci√≥n a listas

Veamos un peque√±o resumen de los datos que ya conocemos:

* [**vectores**]{.hl-yellow}: colecci√≥n de elementos de igual tipo. Pueden ser n√∫meros, caracteres o valores l√≥gicos, entre otros.

* [**matrices**]{.hl-yellow}: colecci√≥n BIDIMENSIONAL de elementos de igual tipo e igual longitud.

* [**data.frame / tibble**]{.hl-yellow}: colecci√≥n BIDIMENSIONAL de elementos de igual longitud pero de cualquier tipo.

&nbsp;

Las [**listas**]{.hl-yellow} ser√°n [**colecciones de variables de diferente tipo y diferente longitud**]{.hl-purple}, con estructuras totalmente heter√≥geneas (incluso una lista puede tener dentro a su vez otra lista).

&nbsp;

Vamos a crear [**nuestra primera lista**]{.hl-yellow} con `list()` con tres elementos: el nombre de nuestros padres/madres, nuestro lugar de nacimiento y edades de nuestros hermanos.

```{r}
var_1 <- c("Paloma", "Gregorio")
var_2 <- "Madrid"
var_3 <- c(25, 30, 26)

lista <- list("progenitores" = var_1, "lugar_nac" = var_2, "edad_hermanos" = var_3)
lista
```



Si observas el objeto que hemos definido como lista, su [**longitud**]{.hl-yellow} del es de 3 ya que tenemos **guardados tres elementos**: un vector de caracteres (de longitud 2), un caracter (vector de longitud 1), y un vector de n√∫meros (de longitud 3)

```{r}
length(lista)
```


En una lista solemos tener guardados elementos de [**distinto tipo**]{.hl-yellow} (algo que ya pod√≠amos hacer) pero, adem√°s, de **longitudes dispares**.

```{r}
dim(lista) # devolver√° NULL al no tener dos dimensiones
class(lista) # de tipo lista
```


Si los junt√°semos con un `tibble()`, al tener distinta longitud, obtendr√≠amos un [**error**]{.hl-red}.

```{r}
#| error: true
library(tibble)
tibble("progenitores" = var_1, "lugar_nac" = va_2, "edad_hermanos" = var_3)
```

#### Operaciones b√°sicas

La m√°s b√°sica es poder [**acceder por √≠ndice**]{.hl-yellow} a sus elementos, con el operador `[[i]]`, accediendo al **elemento i-√©simo** de la lista.

```{r}
lista[[1]]
```

Tambi√©n podemos [**acceder por nombre**]{.hl-yellow} con `$nombre_elemento`.

```{r}
lista$progenitores
```

En contraposici√≥n, el [**corchete simple**]{.hl-yellow} nos permite acceder a [**varios elementos**]{.hl-yellow} a la vez

```{r}
# Varios elementos
lista[1:2]
```


#### Salida m√∫ltiple: listas

As√≠ haciendo uso de listas podemos hacer que la funci√≥n [**devuelva de manera conjunta**]{.hl-yellow} m√∫ltiples argumentos (sin importar su tipo ni longitud)

```{r}
#| code-line-numbers: "7-9"
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rect√°ngulo")))
  
}
calcular_area(5, 3)
```

Antes nos daba igual el orden de los argumentos pero ahora el [**orden de los argumentos de entrada importa**]{.hl-yellow}, ya que en la salida incluimos `lado_1` y `lado_2`. 


::: callout-note
## Recomendaci√≥n

Como se comentaba, altamente recomendable hacer la llamada a la funci√≥n [**indicando expl√≠citamente los argumentos**]{.hl-yellow} para mejorar **legibilidad e interpretabilidad**.

```{r}
# Equivalente a calcular_area(5, 3)
calcular_area(lado_1 = 5, lado_2 = 3)
```

:::


### Variables locales vs globales

Un aspecto importante sobre el que reflexionar con las funciones: ¬øqu√© sucede si [**nombramos a una variable dentro**]{.hl-yellow} de una funci√≥n a la que se nos ha **olvidado asignar** un valor dentro de la misma?

&nbsp;

Debemos ser cautos al usar funciones en `R`, ya que debido a la [**¬´regla lexicogr√°fica¬ª**]{.hl-yellow}, si una variable no se define dentro de la funci√≥n, `R` [**buscar√° dicha variable en el entorno**]{.hl-purple} de variables.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  print(x) # No devuelve nada, solo realiza la acci√≥n 
}
funcion_ejemplo()
```


Si una variable  [**ya est√° definida fuera de la funci√≥n (entorno global)**]{.hl-yellow}, y adem√°s es usada dentro de cambiando su valor, el valor [**solo cambia dentro**]{.hl-yellow} pero [**no en el entorno global**]{.hl-red}.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  x <- 2
  print(x) # lo que vale dentro
}
```

```{r}
# lo que vale dentro
funcion_ejemplo() #<<
# lo que vale fuera
print(x) #<<
```


Si queremos que adem√°s de cambiar localmente lo haga [**globalmente**]{.hl-yellow} deberemos usar la [**doble asignaci√≥n**]{.hl-yellow} (`<<-`).

```{r}
x <- 1
y <- 2
funcion_ejemplo <- function() {
  
  # no cambia globalmente, solo localmente
  x <- 3 
  # cambia globalmente
  y <<- 0 #<<
  
  print(x)
  print(y)
}

funcion_ejemplo() # lo que vale dentro
x # lo que vale fuera
y # lo que vale fuera
```


### üíª Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ej 1**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para definir una funci√≥n llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.

```{r}
#| eval: false
nombre <- function(x, y) {
  suma <- # c√≥digo a ejecutar
  return()
}
# Aplicamos la funci√≥n
suma(3, 7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_suma <- function(x, y) {
  suma <- x + y
  return(suma)
}
funcion_suma(3, 7)
```

### [**Ej 2**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para definir una funci√≥n llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado

```{r}
#| eval: false
nombre <- function(x, y) {
  producto <- # c√≥digo de la multiplicaci√≥n
  return()
}
producto(3)
producto(3, -7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_producto <- function(x, y = x) {
  producto <- x * y
  return(producto)
}
funcion_producto(3)
funcion_producto(3, -7)
```

### [**Ej 3**]{.hl-yellow}

üìù Define una funci√≥n llamada `igualdad_nombres` que, dados dos nombres, nos diga si son iguales o no. Hazlo considerando importantes las may√∫sculas, y sin que importen las may√∫sculas. Usa el paquete `{stringr}`.

```{r}
#| code-fold: true
#| eval: false
# Distinguiendo may√∫sculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Luc√≠a")

# Sin importar may√∫sculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(toupper(persona_1) == toupper(persona_2))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Luc√≠a")
```

### [**Ej 4**]{.hl-yellow}

üìù Crea una funci√≥n llamada `calculo_IMC` que, dados dos argumentos (peso y estatura en metros) y un nombre, devuelva una lista con el IMC ($peso/(estatura_m^2)$) y el nombre.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura) {
  
  return(list("nombre" = nombre, "IMC" = peso/(estatura^2)))
}
```

### [**Ej 5**]{.hl-yellow}

üìù Repite el ejercicio anterior pero con otro argumento opcional que se llame unidades (por defecto, `unidades = "metros"`). Desarrolla la funci√≥n de forma que haga lo correcto si `unidades = "metros"` y si `unidades = "cent√≠metros"`.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  
  return(list("nombre" = nombre,
              "IMC" = peso/(if_else(unidades == "metros", estatura, estatura/100)^2)))
}
```

 
### [**Ej 6**]{.hl-yellow}

üìù Crea un tibble ficticio de 7 personas, con tres variables (inventa nombre, y simula peso, estatura en cent√≠metros), y aplica la funci√≥n definida de forma que obtengamos una cuarta columna con su IMC.

```{r}
#| code-fold: true
#| eval: false
datos <-
  tibble("nombres" = c("javi", "sandra", "laura", "ana", "carlos", "leo", NA),
         "peso" = rnorm(n = 7, mean = 70, sd = 1),
         "estatura" = rnorm(n = 7, mean = 168, sd = 5))

# IMPORTANTE: if_else trabaja de manera vectorial, elemento a elemento
# esto significa que la longitud de la condici√≥n (en este caso unidades == "metros"
# solo es uno, no un vector l√≥gico) debe ser igual que lo que le decimos que haga 
# cuando es TRUE y cuando es FALSE (en este caso la condicion tiene longitud 1
# pero al aplicarla luego - dentro de un mutate a toda una variable de peso y estatura
# lo que devuelve es un vector de tama√±o 7, por eso hay que usar ifelse (sin _))
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  
  return(list("nombre" = nombre,
              "IMC" = peso/(ifelse(unidades == "metros", estatura, estatura/100)^2)))
}
datos |> 
  mutate(IMC = calculo_IMC(nombres, peso, estatura, unidades = "cent√≠metros")$IMC)
```


### [**Ej 7**]{.hl-yellow}

üìù Crea una funci√≥n llamada `atajo` que tenga dos argumentos num√©ricos `x` e `y`. Si ambos son iguales, debes devolver `"iguales"` y hacer que la funci√≥n acaba autom√°ticamente (piensa cu√°ndo una funci√≥n sale). OJO: `x` e `y` podr√≠an ser vectores. Si son distintos (de igual de longitud) calcula la proporci√≥n de elementos  diferentes. Si son distintos (por ser distinta longitud), devuelve los elementos que no sean comunes.

```{r}
#| code-fold: true
#| eval: false
atajo <- function(x, y) {
  
  if (all(x == y) & length(x) == length(y)) { return("iguales") }
  else {
   
    if (length(x) == length(y)) {
      
      n_diff <- sum(x != y) / length(x)
      return(n_diff)
      
    } else {
      
      diff_elem <- unique(c(setdiff(x, y), setdiff(y, x)))
      return(diff_elem)
    }
    
  }
}
```


:::


## üê£ Caso pr√°ctico II: conversor de temperaturas

Para practicar con el uso de funciones vamos a crear un conversor de temperaturas. Empecemos por lo sencillo. Intenta conceptuar la idea antes en un papel.

### Pregunta 1

> Define una funci√≥n llamada `celsius_to_kelvin` que, dada una temperatura en Celsius (por ejemplo, `temp` como argumento) la convierta a Kelvin seg√∫n la f√≥rmula de conversi√≥n inferior. Tras definir la funci√≥n apl√≠cala a un vector de temperaturas.

$$K = ¬∞C + 273.15$$

```{r}
#| code-fold: true
#| eval: false

# definimos nombre de la funci√≥n y argumentos
celsius_to_kelvin <- function(temp) {
  
  # convertimos
  kelvin <- temp + 273.15
  
  # devolvemos
  return(kelvin)
  
}

x <- c(-15, -3, 0, 15, 27.5)
celsius_to_kelvin(x)
```

### Pregunta 2

> Crea la funci√≥n contraria `kelvin_to_celsius` y apl√≠cala a otro vector de temperaturas. Tendr√°s que asegurarte que la temperatura en Kelvin no toma valores negativos (ya que es una escala absoluta). En caso de que no se cumpla, devolver `NA`.

```{r}
#| code-fold: true
#| eval: false

# definimos nombre de la funci√≥n y argumentos
kelvin_to_celsius <- function(temp) {
  
  # si es negativa en Kelvin, paramos y devolvemos ausente
  # en caso contrario, convertimos
  celsius <- if_else(temp < 0, NA, temp - 273.15)
  
  # Piensa porque no lo hemos hecho con un if (...) else (...)

  # devolvemos
  return(celsius)
  
}

y <- c(0, 250, 300, 350)
kelvin_to_celsius(y)
```

### Pregunta 3

> Crea una funci√≥n conjunta `conversor_temp` que tenga dos argumentos: temperatura y un argumento de texto que nos diga si es kelvin o celsius (y que por defecta la temperatura de entrada sea Celsius). La funci√≥n debe usar ese string para decidir en que direcci√≥n convierte (controla que en el argumento de texto no haya una opci√≥n distinta a las dos permitidas; en caso contrario, devolver error usando el comando stop("mensaje de error...")). Apl√≠cala a los vectores anteriores y chequea que da lo mismo.

```{r}
#| code-fold: true
#| eval: false

# definimos nombre de la funci√≥n y argumentos
# por defecto, unidades en celsius
conversor_temp <- function(temp, unidades = "celsius") {
  
  # chequeamos que unidades es correcto
  # dentro de los valroes permitidos
  if (unidades %in% c("celsius", "kelvin")) {
    
    if (unidades == "celsius") {
      
      temp_out <- celsius_to_kelvin(temp) 
      
    } else {
      
      temp_out <- kelvin_to_celsius(temp)
      
    }
    
  } else {
    
    # en caso contrario paramos la funci√≥n con un mensaje de error
    stop("Error: solo se permiten como unidades 'celsius' o 'kelvin'")
  }
  
  # devolvemos
  return(temp_out)
  
}

# F√≠jate que no hemos usado `if_else()` porque el n√∫mero de elementos
# a evaluar en la condici√≥n debe ser igual al n√∫mero de elementos que # devuelve, al hacerlo de manera vectorial.
conversor_temp(x)
conversor_temp(y, unidades = "kelvin")
```


### Pregunta 4

> Repite la funci√≥n anterior pero sin que importe si unidades est√° en may√∫scula o min√∫scula


```{r}
#| error: true
conversor_temp(y, unidades = "Kelvin")
```
```{r}
#| code-fold: true
#| eval: false

# definimos nombre de la funci√≥n y argumentos
# por defecto, unidades en celsius
library(stringr)
conversor_temp <- function(temp, unidades = "celsius") {
  
  # usamos str_to_lower para pasarlo todo a min√∫scula
  if (str_to_lower(unidades) %in% c("celsius", "kelvin")) {
    
    if (unidades == "celsius") {
      
      temp_out <- celsius_to_kelvin(temp) 
      
    } else {
      
      temp_out <- kelvin_to_celsius(temp)
      
    }
    
  } else {
    
    # en caso contrario paramos la funci√≥n con un mensaje de error
    stop("Error: solo se permiten como unidades 'celsius' o 'kelvin'")
  }
  
  # devolvemos
  return(temp_out)
  
}

conversor_temp(y, unidades = "Kelvin")
```

### Pregunta 5


> Repite todo el proceso anterior creando `conversor_temp2` pero para convertir entre Celsius y Fahrenheit siguiendo la f√≥rmula inferior

$$¬∫C = (¬∫F ‚àí 32) * \frac{5}{9}, \quad ¬∫F = 32 + ¬∫C * \frac{9}{5}$$
```{r}
#| code-fold: true
#| eval: false

# definimos las funciones de celsius a fahr y viceversa
celsius_to_fahr <- function(temp) {
  
  # convertimos
  fahr <- 32 + temp * (9/5)
  
  # devolvemos
  return(fahr)
  
}
celsius_to_fahr(x)

fahr_to_celsius <- function(temp) {
  
  # convertimos
  celsius <- (temp - 32) * (5/9)
  
  # devolvemos
  return(celsius)
  
}

z <- c(40, 60, 80, 100)
fahr_to_celsius(z)

# definimos nombre de la funci√≥n y argumentos
# por defecto, unidades en celsius
conversor_temp2 <- function(temp, unidades = "celsius") {
  
  # usamos str_to_lower para pasarlo todo a min√∫scula
  if (str_to_lower(unidades) %in% c("celsius", "fahr")) {
    
    if (unidades == "celsius") {
      
      temp_out <- celsius_to_fahr(temp) 
      
    } else {
      
      temp_out <- fahr_to_celsius(temp)
      
    }
    
  } else {
    
    # en caso contrario paramos la funci√≥n con un mensaje de error
    stop("Error: solo se permiten como unidades 'celsius' o 'fahr'")
  }
  
  # devolvemos
  return(temp_out)
  
}

conversor_temp2(x)
conversor_temp2(z, unidades = "fahr")
```

### Pregunta 6

> Para acabar, crea la superfunci√≥n `conversor_temp_total` que permita como argumento de entrada una temperatura en alguna de las 3 unidades, un texto que indique en qu√© unidades viene y otro que indique en qu√© unidades se quiere sacar.  Por defecto que convierta de celsius a kelvin.

```{r}
#| code-fold: true
#| eval: false

conversor_temp_total <-
  function(temp, unidades_entrada = "celsius",
           unidades_salida = "kelvin") {
  
  if (str_to_lower(unidades_entrada) %in% c("celsius", "fahr", "kelvin") &
      str_to_lower(unidades_salida) %in% c("celsius", "fahr", "kelvin")) {
    
    # Si las de salida son iguales que las de entrada, no hacemos nada
    if (unidades_entrada == unidades_salida) {
      
      return(temp)
      
    }
    
    else if (unidades_entrada == "celsius") {
      
      if (unidades_salida == "kelvin") {
        
        temp_out <- celsius_to_kelvin(temp) 
        
      # si no es kelvin (ni celsius porque entrada es distinto a salida)
      # solo queda una funcion (que sea fahr)
      } else { 
        
        temp_out <- celsius_to_fahr(temp) 
      }
      
    } else if (unidades_entrada == "kelvin") {
      
      if (unidades_salida == "celsius") {
        
        temp_out <- kelvin_to_celsius(temp) 
    
      } else { 
        
        temp_out <- celsius_to_fahr(kelvin_to_celsius(temp))
      }
      
    } else {
      
      if (unidades_salida == "celsius") {
        
        temp_out <- fahr_to_celsius(temp) 
    
      } else { 
        
        temp_out <- celsius_to_kelvin(fahr_to_celsius(temp))
      }
      
    }
    
  } else {
    
    # en caso contrario paramos la funci√≥n con un mensaje de error
    stop("Error: solo se permiten como unidades de entrada/salida 'celsius', 'kelvin' o 'fahr'")
  }
  
  # devolvemos
  return(temp_out)
  
}

conversor_temp_total(x, unidades_entrada = "celsius",
                     unidades_salida = "celsius")
conversor_temp_total(y, unidades_entrada = "kelvin",
                     unidades_salida = "kelvin")
conversor_temp_total(z, unidades_entrada = "fahr",
                     unidades_salida = "fahr")

conversor_temp_total(x, unidades_entrada = "celsius",
                     unidades_salida = "kelvin")
conversor_temp_total(y, unidades_entrada = "kelvin",
                     unidades_salida = "celsius")
conversor_temp_total(x, unidades_entrada = "celsius",
                     unidades_salida = "fahr")
conversor_temp_total(z, unidades_entrada = "fahr",
                     unidades_salida = "celsius")

conversor_temp_total(z, unidades_entrada = "fahr",
                     unidades_salida = "celsius")
conversor_temp_total(conversor_temp_total(z, unidades_entrada = "fahr",
                                          unidades_salida = "kelvin"),
                     unidades_entrad = "kelvin",
                     unidades_salida = "celsius")
```

