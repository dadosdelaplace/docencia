---
title: "Joins e importaci칩n: como combinar, exportar e importar en R"
subtitle: "Cuadernos pr치cticos de Software II del Grado en Ciencia de Datos Aplicada (curso 2024-2025)"
author: "Javier 츼lvarez Li칠bana"
format:
  html:
    theme: [default, style.scss]
    toc: true
    toc-title: 칈ndice
    toc-depth: 5
    toc-location: left
    number-sections: true
    embed-resources: true
execute: 
  echo: true
---

## Relacionando datos: joins

Al trabajar con datos [**no siempre tendremos la informaci칩n en una sola tabla**]{.hl-yellow} y a veces nos interesar치 cruzar la informaci칩n de distintas fuentes.


Para ello usaremos un cl치sico de todo lenguaje que maneja datos: los famosos [**join**]{.hl-yellow}, que nos permitir치n [**cruzar una o varias tablas**]{.hl-yellow}, haciendo uso de una [**columna identificadora**]{.hl-yellow} de cada una de ellas (por ejemplo, imagina que cruzamos datos de hacienda y de antecedentes penales, haciendo `join` por la columna `DNI`).

&nbsp;

La estructura b치sica es la siguiente:

```{r}
#| eval: false
tabla_1 |>
  xxx_join(tabla_2, by = id)
```

![](img/sql-joins.jpg)


Vamos a probar los distintos joins con un ejemplo sencillo

```{r}
library(tidyverse)
tb_1 <- tibble("key" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```


```{r}
tb_1
```

```{r}
tb_2
```

### Left join


* `left_join()`: mantiene [**todos los registros de la primera tabla**]{.hl-yellow}, y busca cuales tienen id tambi칠n en la segunda (en caso de [**no tenerlo se rellena con NA**]{.hl-yellow} los campos de la 2춹 tabla).

En nuestra caso queremos incorporar a `tb_1` la informaci칩n de `tb_2`, identificando los registros por la columna key (`by = "key"`, la columna por la que tiene que cruzar)



```{r}
tb_1  |> 
  left_join(tb_2, by = "key")
```


![](img/left_join.jpg)


```{r}
tb_1 |> 
  left_join(tb_2, by = "key")
```

F칤jate que los [**registros de la primera cuya key no ha encontrado en la segunda**]{.hl-yellow} les ha dado el valor de [**ausente**]{.hl-yellow}.

### Right join


* `right_join()`: mantiene [**todos los registros de la segunda tabla**]{.hl-yellow}, y busca cuales tienen id tambi칠n en la primera.


Vamos ahora a incorporar a `tb_2` la informaci칩n de `tb_1`, identificando los registros por la columna key (`by = "key"`)

```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```


![](img/right_join.jpg)



```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

F칤jate que ahora los [**registros de la segunda cuya key no ha encontrado en la primera**]{.hl-yellow} son los que les ha dado el valor de [**ausente**]{.hl-yellow}.

### Claves y sufijos

Las columnas clave que usaremos para el cruce [**no siempre se llamar치n igual**]{.hl-yellow}.

```{r}
tb_1 <- tibble("key_1" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```


* `by = c("key_2" = "key_2")`: le indicaremos en qu칠 columna de cada tabla est치n las claves por las que vamos a cruzar.

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```


```{r}
# Right
tb_1  |> 
  right_join(tb_2, by = c("key_1" = "key_2"))
```


Adem치s podemos [**cruzar por varias columnas a la vez**]{.hl-yellow} (interpretar치 como igual registro aquel que tenga el conjunto de claves igual), con `by = c("var1_t1" = "var1_t2", "var2_t1" = "var2_t2", ...)`. Modifiquemos el ejemplo anterior

```{r}
tb_1 <- tibble("k_11" = 1:3, "k_12" = c("a", "b", "c"),  "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("k_21" = c(1, 2, 4), "k_22" = c("a", "b", "e"), "val_y" = c("y1", "y2", "y3"))
```


```{r}
# Left
tb_1 |> 
  left_join(tb_2,
            by = c("k_11" = "k_21", "k_12" = "k_22"))
```


Tambi칠n podr칤a suceder que al cruzar dos tablas, haya [**columnas de valores que se llamen igual**]{.hl-yellow}


```{r}
tb_1 <- tibble("key_1" = 1:3, "val" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val" = c("y1", "y2", "y3"))
```


```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

F칤jate que [**por defecto nos a침ade los sufijos**]{.hl-yellow} `.x` y `.y` para indicarnos de que tabla vienen. Dicho [**sufijo podemos especific치rselo**]{.hl-yellow} en el argumento opcional `suffix = ...`, que nos permita [**distinguir las variables**]{.hl-yellow} de una tabla y de otra.


```{r}
# Left
tb_1 |>
  left_join(tb_2, by = c("key_1" = "key_2"), suffix = c("_tabla1", "_tabla2"))
```

### Full join


* `full_join()`: mantiene [**todos los registros de ambas**]{.hl-yellow} tablas.

Los dos anteriores casos forman lo que se conoce como [**outer joins**]{.hl-yellow}: cruces donde se mantienen observaciones que salgan en al menos una tabla. El tercer outer join es el conocido como `full_join()` que nos [**mantendr치 las observaciones de ambas**]{.hl-yellow} tablas, [**a침adiendo las filas**]{.hl-yellow} que no casen con la otra tabla.



```{r}
tb_1 |> 
  full_join(tb_2, by = c("key_1" = "key_2"))
```


![](img/full_join.jpg)

### Inner join

* `inner_join()`: solo sobreviven los [**registros cuyo id est칠 en ambas**]{.hl-yellow} tablas.

Frente a los outer join est치 lo que se conoce como [**inner join**]{.hl-yellow}, con `inner_join()`: un cruce en el que solo se mantienen las [**observaciones que salgan en ambas tablas**]{.hl-yellow}, solo mantiene aquellos registros matcheados.



```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

![](img/inner_join.png)


F칤jate que en t칠rminos de registros, `inner_join` si es conmutativa, **nos da igual el orden de las tablas**: lo 칰nico que cambia es el orden de las columnas que a침ade.


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```



```{r}
tb_2 |> 
  inner_join(tb_1, by = c("key_2" = "key_1"))
```

### Anti/semi join

Por 칰ltimo tenemos dos herramientas interesantes para [**filtrar (no cruzar) registros**]{.hl-yellow}: `semi_join()` y `anti_join()`. El [**semi join**]{.hl-yellow} nos deja en la [**primera tabla los registros que cuya clave est치 tambi칠n en la segunda**]{.hl-yellow} (como un inner join pero sin a침adir la info de la segunda tabla). Y el segundo, los anti join, hace justo lo contrario (aquellos que no est치n).


```{r}
# semijoin
tb_1 |> 
  semi_join(tb_2, by = c("key_1" = "key_2"))
```

```{r}
# antijoin
tb_1 |> 
  anti_join(tb_2, by = c("key_1" = "key_2"))
```



### 游눹 Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

Para los ejercicios usaremos las tablas disponibles en el paquete `{nycflights13}` (echa un vistazo antes)

```{r}
library(nycflights13)
```

* [**airlines**]{.hl-yellow}: nombre de aerol칤neas (con su abreviatura).
* [**airports**]{.hl-yellow}: datos de aeropuertos (nombres, longitud, latitud, altitud, etc).
* [**flights**]{.hl-yellow}: datos de vuelos.
* [**planes**]{.hl-yellow}: datos de los aviones.
* [**weather**]{.hl-yellow}: datos meteorol칩gicos horarios de las estaciones LGA, JFK y EWR.


::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

游닇 Del paquete `{nycflights13}` cruza la tabla `flights` con `airlines`. Queremos mantener todos los registros de vuelos, a침adiendo la informaci칩n de las aerol칤neas a dicha tabla.

```{r}
#| eval: false
#| code-fold: true
flights_airlines <-
  flights |> 
  left_join(airlines, by = "carrier")
flights_airlines
```

### [**Ejercicio 2**]{.hl-yellow}

游닇 A la tabla obtenida del cruce del apartado anterior, cruza despu칠s con los datos de los aviones en `planes`, pero incluyendo solo aquellos vuelos de los que tengamos informaci칩n de sus aviones (y viceversa). 


```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum")
flights_airlines_planes
```


### [**Ejercicio 3**]{.hl-yellow}

游닇 Repite el ejercicio anterior pero conservando ambas variables `year` (en una es el a침o del vuelo, en la otra es el a침o de construcci칩n del avi칩n), y distingui칠ndolas entre s칤



```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum",
             suffix = c("_flight", "_build_aircraft"))
flights_airlines_planes
```

### [**Ejercicio 4**]{.hl-yellow}

游닇 Al cruce obtenido del ejercicio anterior incluye la longitud y latitud de los aeropuertos en `airports`, distinguiendo entre la latitud/longitud del aeropuerto en destino y en origen.

```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes %>%
  left_join(airports %>% select(faa, lat, lon),
            by = c("origin" = "faa")) |> 
  rename(lat_origin = lat, lon_origin = lon) |> 
  left_join(airports %>% select(faa, lat, lon),
            by = c("dest" = "faa")) |> 
  rename(lat_dest = lat, lon_dest = lon)
```

### [**Ejercicio 5**]{.hl-yellow}

游닇 Filtra de `airports` solo aquellos aeropuertos de los que salgan vuelos. Repite el proceso filtrado solo aquellos a los que lleguen vuelos

```{r}
#| eval: false
#| code-fold: true
airports |> 
  semi_join(flights, by = c("faa" = "origin"))
airports |> 
  semi_join(flights, by = c("faa" = "dest"))
```


### [**Ejercicio 6**]{.hl-yellow}

游닇 쮻e cu치ntos vuelos no disponemos informaci칩n del avi칩n? Elimina antes los vuelos que no tengan identificar (diferente a NA) del avi칩n


```{r}
#| eval: false
#| code-fold: true
flights |> 
  drop_na(tailnum) |>
  anti_join(planes, by = "tailnum") |>
  count(tailnum, sort = TRUE) # de mayor a menor ya de paso
```

:::


## 游냒Caso pr치ctico I: Beatles y Rolling Stones

Vamos a empezar a practicar joins sencillos con la tabla `band_members` y `band_instruments` ya incluidos en el paquete `{dplyr}`.

```{r}
library(dplyr)
band_members
band_instruments
```

En la primera tenemos una serie de artistas y la banda a la que pertenecen; en la segunda tenemos una serie de artistas y el instrumento que tocan. Adem치s de realizar las acciones solicitadas intenta visualizar qu칠 tabla final tendr칤as antes de ejecutar el c칩digo..

### Pregunta 1

> Dada la tabla `band_members`, incorpora la informaci칩n de qu칠 instrumento toca cada miembro (`band_instruments`) de los que tienes en esa tabla.

```{r}
#| code-fold: true
left_join_band <-
  band_members |> 
  left_join(band_instruments, by = "name")
```

### Pregunta 2

> Dadas las tablas `band_members` y `band_instruments`, 쯤u칠 tipo de join deber칤as hacer para tener una tabla completa, sin ausencias, donde todos los miembros de la banda tengan la informaci칩n de su instrumento, y cada instrumento tenga un miembro asociado a 칠l?

```{r}
#| code-fold: true
inner_join_band <-
  band_members |>
  inner_join(band_instruments, by = "name")
```

### Pregunta 3

> Dada la tabla `band_instruments`, 쯖칩mo incorporar la informaci칩n de qui칠n toca cada instrumento (en caso de que la conozcamos)?

```{r}
#| code-fold: true
right_join_band <-
  band_members |>
  right_join(band_instruments, by = "name")

# other option
left_join_instruments <-
  band_instruments |> 
  left_join(band_members, by = "name")
```

### Pregunta 4

> Dadas las tablas `band_members` y `band_instruments`, 쯤u칠 tipo de join deber칤as hacer para tener una tabla con toda la informaci칩n, tanto de los miembros como de los instrumentos, aunque haya miembros cuyo instrumento no conozcas, e instrumentos cuyo portador no conozcas?

```{r}
#| code-fold: true
full_join_band <-
  band_members |>
  full_join(band_instruments, by = "name")
```

## 游냒 Caso pr치ctico II: renta municipios

En el archivo `municipios.csv` tenemos guardada la informaci칩n de los municipios de Espa침a a fecha de 2019.

* La variable `LAU_code` representa el c칩digo como unidad administrativa local seg칰n la estandarizaci칩n de la UE (ver m치s en <https://ec.europa.eu/eurostat/web/nuts/local-administrative-units>).

* La variable `codigo_ine` est치 construida uniendo el c칩digo de la provincia y el de la comunidad aut칩noma.

```{r}
# datos 2019
mun_data <- read_csv(file = "./datos/municipios.csv")
mun_data
```


Por otro lado el archivo `renta_mun` contiene datos de la renta per capita edmai de cada unidad administrativa (municipios, distritos, provincias, comunidades auton칩nomas, etc) para diferentes a침os.

```{r}
renta_mun <- read_csv(file = "./datos/renta_mun.csv")
renta_mun
```


Antes de empezar vamos a [**normalizar nombres de variables**]{.hl-yellow} haciendo uso de `clean_names()` del paquete `{janitor}`.

```{r}
mun_data <-
  mun_data |> 
  janitor::clean_names()
renta_mun <-
  renta_mun |> 
  janitor::clean_names()
```

### Pregunta 1

> Convierte a tidydata `renta_mun` obteniendo una tabla de 4 columnas: `unidad`, `year`, `renta` y `codigo_ine` (sin ausentes y cada dato del tipo correcto)

```{r}
#| code-fold: true
renta_mun_tidy <-
  renta_mun |> 
  pivot_longer(cols = contains("x"), names_to = "year",
               values_to = "renta", names_prefix = "x",
               names_transform = list(year = as.numeric),
               values_drop_na = TRUE)
```

### Pregunta 2

> Si te fijas en la tabla anterior, tenemos datos de diferentes unidades administrativas que no siempre son municipios. Sabiendo que todos los municipios tienen un c칩digo de 5 caracteres (que representan todos ellos n칰meros), filtra s칩lo aquellos registros que correspondan a unidades municipales.

```{r}
#| code-fold: true
renta_mun_tidy <-
  renta_mun_tidy |>
  filter(str_detect(codigo_ine, pattern = "[0-9]{5}") & 
           str_length(codigo_ine) == 5)
```

### Pregunta 3

> A continuaci칩n separa adecuadamente la variable de unidad en dos columnas: una con el c칩digo (que ya tiene, por lo que debe eliminar uno de los dos) y el nombre. Elimina los espacios sobrantes (echa un vistazo a las opciones del paquete `{stringr}`).

```{r}
#| code-fold: true
renta_mun_tidy <-
  renta_mun_tidy |>
  separate(col = "unidad", into = c("cod_rm", "name"), sep = 5) |> 
  select(-cod_rm) |> 
  mutate(name = str_trim(name)) 
```

### Pregunta 4

> 쮼n qu칠 a침o fue mayor la renta media? 쯏 m치s baja? 쮺u치l fue la renta mediana de los municipios de Espa침a en 2019?

```{r}
summary_renta <-
  renta_mun_tidy |> 
  summarise("mean_renta" = mean(renta, na.rm = TRUE),
            .by = year)
summary_renta |>
  slice_min(mean_renta, n = 1)
summary_renta |>
  slice_max(mean_renta, n = 1)

renta_mun_tidy |> 
  filter(year == 2019) |> 
  summarise("median_renta" = median(renta, na.rm = TRUE))
```


### Pregunta 5

> Haz lo que consideres para obtener la provincia con la renta media m치s alta en 2019 y la m치s baja. Aseg칰rate de obtener su nombre.

```{r}
#| code-fold: true
summary_by_prov <-
  renta_mun_tidy |> 
  filter(year == 2019) |> 
  left_join(mun_data, by = "codigo_ine", suffix = c("", "_rm")) |> 
  select(-contains("rm")) |> 
  summarise("mean_by_prov" = mean(renta, na.rm = TRUE),
            .by = c("cpro", "ine_prov_name"))

summary_by_prov |> 
  slice_max(mean_by_prov, n = 1)

summary_by_prov |> 
  slice_min(mean_by_prov, n = 1)
```

### Pregunta 6

> Obten de cada ccaa el nombre del municipio con mayor renta en 2019.

```{r}
#| code-fold: true
renta_mun_tidy |> 
  filter(year == 2019) |> 
  left_join(mun_data, by = "codigo_ine", suffix = c("", "_rm")) |> 
  select(-contains("rm")) |> 
  slice_max(renta, by = "codauto")
```



## Importar/exportar

Hasta ahora s칩lo hemos utilizado datos ya cargados en paquetes, pero muchas veces [**necesitaremos importar datos externamente**]{.hl-yellow}. Una de las principales [**fortalezas**]{.hl-yellow} de `R` es que podemos importar datos muy f치cilmente en diferentes formatos:



* [**Formatos nativos de R**]{.hl-yellow}: archivos `.rda`, `.RData` y `.rds`

* [**Rectangular data (datos tabulados)**]{.hl-yellow}: archivos `.csv` y `.tsv`

* [**Datos sin tabular**]{.hl-yellow}: archivos `.txt`.

* [**Datos en excel**]{.hl-yellow}: archivos `.xls` y`.xlsx`.

* [**Datos desde SAS/Stata/SPSS**]{.hl-yellow}: archivos `.sas7bdat`, `.sav` y `.dat`.

* [**Datos desde Google Drive**]{.hl-yellow}

* [**Datos desde API's**]{.hl-yellow}: aemet, catastro, censo, spotify, etc.

### Formatos nativos de R

Los ficheros [**m치s sencillos**]{.hl-yellow} para importar a `R` (y que suelen ocupar menos espacio en disco) son sus propias [**extensiones nativas**]{.hl-yellow}: ficheros en formatos `.RData`, `.rda` y `.rds`. Para cargar los primeros basta con [**utilizar la funci칩n**]{.hl-yellow} `load()` proporcion치ndole la ruta del fichero.

* Archivos `RData`: vamos a importar el archivo `world_bank_pop.RData` que incluye la tabla `world_bank_pop`


```{r}
load("./datos/world_bank_pop.RData")
world_bank_pop
```



* Archivos `.rda`: vamos a importar el dataset airquality desde `airquality.rda`

```{r}
load("./datos/airquality.rda")
airquality |> as_tibble()
```


Ten en cuenta que los archivos cargados con `load()` se cargan [**autom치ticamente en el entorno**]{.hl-yellow} (con el nombre guardado originalmente), y no s칩lo se pueden cargar conjuntos de datos: `load()` nos permite cargar m칰ltiples objetos (no s칩lo datos tabulares).

Los archivos nativos `.rda` y `.RData` son una forma adecuada de guardar el entorno.

```{r}
load(file = "./datos/multiple_objects.rda")
```



* Archivos `.rds`: para este tipo debemos utilizar `readRDS()`, y necesitamos incorporar un [**argumento `file`**]{.hl-yellow} con la ruta. En este caso vamos a importar [**datos de c치ncer de pulm칩n**]{.hl-purple} del North Central Cancer Treatment Group. Observe que ahora [**los archivos .rds incorporar solo una tabla, no un objeto en general**]{.hl-red}


```{r}
lung_cancer <-
  readRDS(file = "./datos/NCCTG_lung_cancer.rds") |>
  as_tibble()
lung_cancer
```


::: callout-important

## Importante

Las [**rutas**]{.hl-yellow deben ser siempre [**sin espacios, 침, ni acentos**]{.hl-yellow}. 


:::

### Datos tabulados: readr

El paquete `{readr}` dentro del entorno `{tidyverse}` contiene varias funciones 칰tiles para [**cargar datos rectangulares (sin formatear pero tabulados)**]{.hl-yellow}.


:::: columns
::: {.column width="50%"}

* `read_csv()`: archivos `.csv` [**variables separadas por comas**]{.hl-purple}
* `read_csv2()`: variables separadas por [**punto y coma**]{.hl-purple}
* `read_tsv()`: variables separadas por [**tabuladores**]{.hl-purple}.
* `read_table()`: variables separadas por [**espacios**]{.hl-purple}.
* `read_delim()`: funci칩n generar con opci칩n de [**especificar el delimitador**]{.hl-purple}.



![](img/data-import-readr.png)

Todos ellos necesitan como **argumento la ruta del fichero** m치s **otros opcionales** (saltar cabecera o no, decimales, etc). Ver m치s en <https://readr.tidyverse.org/>

#### Archivos .csv

La principal ventaja de `{readr}` es que [**automatiza el formato**]{.hl-yellow} para pasar de un fichero plano (sin formato) a un tibble (en filas y columnas, con formato).


* Archivo `.csv`: con `read_csv()` cargaremos archivos [**separados por comas**]{.hl-purple}, pasando como [**argumento la ruta**]{.hl-yellow} en `file = ...`. Vamos a importar el conjunto de datos `chickens.csv` (sobre pollos de dibujos animados, por qu칠 no). Si nos fijamos en la salida nos da el tipo de variables.

```{r}
library(readr)
chickens <- read_csv(file = "./datos/chickens.csv")
chickens
```


El [**formato de la variable**]{.hl-yellow} se har치 normalmente [**autom치ticamente**]{.hl-yellow} por `read_csv()`, y podemos consultarlo con `spec()`.


```{r}
spec(chickens)
```


Aunque normalmente lo hace bien autom치ticamente podemos [**especificar el formato expl칤citamente**]{.hl-yellow} en `col_types = lista()` (en formato lista, con `col_xxx()` para cada tipo de variable, por ejemplo `eggs_laid` se importar치 como car치cter). 


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_types = list(col_character(), col_character(),
                            col_character(), col_character()))
chickens
```


Incluso podemos indicar que [**variables queremos seleccionar**]{.hl-yellow} (sin ocupar memoria), indic치ndolo en `col_select = ...` (en formato lista, con `col_select = ...`).


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_select = c(chicken, sex, eggs_laid))
chickens
```

#### Archivos .txt, .tsv



쯈u칠 ocurre cuando el [**separador no es correcto**]{.hl-red}?


Si usamos `read_csv()` espera que el separador entre columnas sea una coma pero, como puedes ver con el siguiente `.txt`, lo interpreta todo como una sola columna: [**no tiene coma y no sabe d칩nde separar**]{.hl-yellow}


```{r}
datos_txt <- read_csv(file = "./datos/massey-rating.txt")
dim(datos_txt)
as_tibble(datos_txt)
```

Para ello tenemos.

* `read_csv2()` cuando el [**separador es punto y coma**]{.hl-yellow}, `read_tsv()` cuando es un [**tabulador**]{.hl-yellow} y `read_table()` cuando es un  [**espacio**]{.hl-yellow}.

* `read_delim()` en general.

```{r}
datos_txt <- read_table(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```


### Datos Excel (.xls, .xlsx)

Otro paquete de importaci칩n clave ser치 el paquete `{readxl}` para [**importar datos desde Excel**]{.hl-yellow}. Tres funciones ser치n clave:

* `read_xls()` espec칤fica para `.xls`, `read_xlsx()` espec칤fica para `.xlsx`.
* `read_excel()`: tanto para `.xls` como para `.xlsx`.


Vamos a importar `deaths.xlsx` con los registros de defunciones de famosos.

```{r}
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths
```



```{r}
deaths |> slice(1:6)
```

[**Una desgracia muy com칰n**]{.hl-red} es que haya alg칰n tipo de comentario o texto al principio del fichero, teniendo que [**saltar esas filas**]{.hl-yellow}.


Podemos [**saltar estas filas**]{.hl-yellow} directamente en la carga con `skip = ...` (indicando el n칰mero de filas a saltar).


```{r}
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths
```


Adem치s con `col_names = ...` ya podemos renombrar las columnas en la importaci칩n ([**proporcionar nombres supone 1춹 l칤nea ya como dato**]{.hl-yellow})


```{r}
#| code-line-numbers: "2-3"
deaths <-
  read_xlsx(path = "./datos/deaths.xlsx", skip = 5,
            col_names = c("nombre", "profesion", "edad", "hijos", "nacimiento", "muerte"))
deaths
```

A veces las  [**fechas de Excel tienen un formato incorrecto**]{.hl-red} (sorpresa): podemos utilizar `convertToDate()` del paquete `{openxlsx}` para convertirlo.



```{r}
library(openxlsx)
deaths$muerte <- convertToDate(deaths$muerte)
deaths
```
   

Tambi칠n podemos [**cargar un Excel con varias hojas**]{.hl-yellow}: para [**indicar la hoja**]{.hl-yellow} (ya sea por su nombre o por su n칰mero) utilizaremos el argumento `sheet = ...`.


```{r}
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars
```


Incluso podemos indicar el [**rango de celdas**]{.hl-yellow} a cargar con `range = ...`.

```{r}
iris <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "iris", range = "C1:E4")
iris
```

### Importar desde SAS/STATA/SPSS

El paquete `{haven}` dentro del universo tidyverse nos permitir치 [**importar ficheros de los 3 software de pago m치s importantes**]{.hl-yellow}: SAS, SPSS y Stata.


```{r}
library(haven)

# SAS
iris_sas <- read_sas(data_file = "./datos/iris.sas7bdat")

# SPSS
iris_spss <- read_sav(file = "./datos/iris.sav")

# Stata
iris_stata <- read_dta(file = "./datos/iris.dta")
```

### Exportar

De la misma forma que podemos importar tambi칠n podemos [**exportar**]{.hl-yellow}

* exportar en `.RData` (opci칩n recomendada para variables almacenadas en `R`). Recuerda que esta extensi칩n [**s칩lo se puede utilizar en `R`**]{.hl-yellow}. Para ello, basta con utilizar `save(object, file = path)`.

```{r}
table <- tibble("a" = 1:4, "b" = 1:4)
save(table, file = "./datos/table.RData")
rm(table) # eliminar
load("./datos/table.RData")
table
```


La ventaja de `.RData` es que podemos [**exportar m칰ltiples variables de nuestro environment**]{.hl-yellow}, no solo un 칰nico dataset.

```{r}
table <- tibble("a" = 1:4, "b" = 1:4)
a <- 1
b <- c("javi", "sandra")
save(table, a, b, file = "./datos/mult_obj.RData")
rm(list = c("a", "b", "table"))
load("./datos/mult_obj.RData")
table
```


* [**exportado en `.csv`**]{.hl-yellow}. Para ello simplemente utilizamos `write_csv(object, file = path)`, y es el m치s recomendable para exportar bases de datos de tama침o peque침o o mediano. Ver <https://arrow.apache.org/docs/r/> para bases de datos masivas.

```{r}
write_csv(table, file = "./datos/table.csv")
read_csv(file = "./datos/table.csv")
```

### Importar desde web

Una de las principales ventajas de `R` es que podemos hacer uso de todas las funciones anteriores de [**importar pero directamente desde una web**]{.hl-yellow}, sin necesidad de realizar la descarga manual: en lugar de pasarle la ruta local le indicaremos el [**enlace**]{.hl-yellow}. Por ejemplo, vamos a descargar los datos covid del ISCIII (<https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>)

```{r}
#| eval: false
covid_data <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
covid_data
```

```{r}
#| echo: false
covid_data <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv", n_max = 500)
covid_data
```

### Importar desde wikipedia

El paquete `{rvest}`, uno de los m치s 칰tiles de `{tidyverse}` nos permite [**importar (scrappear) directamente desde un `html`**]{.hl-yellow}. Por ejemplo, para exportar tablas de wikipedia basta con `read_html()` para importar el html, `html_element(춺table췉)` para extraer los objetos tabla, y `html_table()` para convertir la tabla html a `tibble`.


```{r}
library(rvest)
wiki_jump <- 'https://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression'
wiki_jump |> read_html() |> 
  html_element("table") |> 
  html_table()
```

### Importar desde google drive

Otra opci칩n disponible (especialmente si trabajamos con otras personas trabajando) es [**importar desde una hoja de c치lculo de Google Drive**]{.hl-yellow}, haciendo uso de `read_sheet()` del paquete `{googlesheets4}`.

La primera vez se te pedir치 un permiso tidyverse para interactuar con tu drive


```{r}
library(googlesheets4)
google_sheet <-
  read_sheet("https://docs.google.com/spreadsheets/d/1Uz38nHjl3bmftxDpcXj--DYyPo1I39NHVf-xjeg1_wI/edit?usp=sharing")
google_sheet
```

### Importar desde API

#### owid

Otra opci칩n interesante es la [**descarga de datos desde una API**]{.hl-yellow}: un intermediario entre una app o proveedor de datos y nuestro `R`. Por ejemplo, carguemos la librer칤a `{owidR}`, que nos permite descargar datos de la web <https://ourworldindata.org/>. Por ejemplo, la funci칩n `owid_covid()` carga sin darnos cuenta m치s de 400 000 registros con m치s de 60 variables de 238 pa칤ses.


```{r}
#| eval: false
library(owidR)
owid_covid() |> as_tibble()
```

```{r}
#| echo: false
library(owidR)
owid_covid() |> as_tibble() |> slice(1:7)
```

#### aemet

En muchas ocasiones para conectarnos a la API primero tendremos que [**registrarnos y obtener una clave**]{.hl-yellow}, este es el caso del paquete `{climaemet}` para acceder a [**datos meteorol칩gicos de Espa침a**]{.hl-yellow} (<https://opendata.aemet.es/centrodedescargas/inicio>).


Una vez tengamos la clave API la registramos en nuestro RStudio para poder utilizarla en el futuro.

```{r}
#| eval: false
library(climaemet)

# Api key
apikey <- "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqYXZhbHYwOUB1Y20uZXMiLCJqdGkiOiI4YTU1ODUxMS01MTE3LTQ4MTYtYmM4OS1hYmVkNDhiODBkYzkiLCJpc3MiOiJBRU1FVCIsImlhdCI6MTY2NjQ2OTcxNSwidXNlcklkIjoiOGE1NTg1MTEtNTExNy00ODE2LWJjODktYWJlZDQ4YjgwZGM5Iiwicm9sZSI6IiJ9.HEMR77lZy2ASjmOxJa8ppx2J8Za1IViurMX3p1reVBU"

aemet_api_key(apikey, install = TRUE)
```


```{r}
#| echo: false
library(climaemet)
```


Con este paquete podemos hacer una [**b칰squeda de estaciones**]{.hl-yellow} para conocer tanto su c칩digo postal como su c칩digo identificador dentro de la red AEMET

```{r}
stations <- aemet_stations()
stations
```

Por ejemplo, para obtener datos de la estaci칩n del aeropuerto de El Prat, Barcelona, el c칩digo a proporcionar es `춺0076췉`, obteniendo **datos horarios**.

```{r}
aemet_last_obs("0076")
```

#### US census

Una de las herramientas m치s 칰tiles de los 칰ltimos a침os es la conocida como `{tidycensus}`: una herramienta para [**facilitar el proceso de descarga de datos censales**]{.hl-yellow} de Estados Unidos desde `R`

```{r}
library(tidycensus)
```

* `get_decennial()`: para acceder a los [**datos de censos (US Decennial Census)**]{.hl-yellow}, se hacen cada 10 a침os (a침os 2000, 2010 y 2020).

* `get_acs()`: para acceder a los [**datos anuales y quinquenales (5 a침os)  de la ACS (American Community Survey)**]{.hl-yellow} (censo != encuesta)

* `get_estimates()`: para acceder a las [**estimaciones anuales de poblaci칩n, natalidad y mortalidad**]{.hl-yellow}

* `get_pums()`: para acceder a los [**microdatos (datos sin agregar) de la ACS (anonimizados a nivel individual)**]{.hl-yellow}

* `get_flows()`: para acceder a los datos de [**flujo de migraciones**]{.hl-yellow}


Por ejemplo vamos a descargarnos los **datos censales** (`get_decennial()`) a nivel estado (`geography = "state"`) de la poblaci칩n (variable `variables = "P001001"`) para el a침o 2010 (ver variables en `tidycensus::load_variables()`)

```{r}
total_population_10 <-
  get_decennial(geography = "state", 
  variables = "P001001",
  year = 2010)
total_population_10
```

#### otras

Otras opciones

* `{chessR}`: datos de partidas de ajedrez de las plataformas chess.com y lychess. Ver m치s en <https://github.com/JaseZiv/chessR>

* `{spotifyr}`: datos de canciones de Spotify. Ver m치s en <https://www.rcharlie.com/spotifyr/>

* `{gtrendsR}`: datos de Google Trends. Ver m치s en <https://github.com/PMassicotte/gtrendsR>

* `{scholar}`: datos de Google Scholar. Ver m치s en <https://github.com/jkeirstead/scholar>


### 游눹 Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

游닇 El conjunto de datos `who2` del paquete `{tidyr}` que hemos utilizado en ejercicios anteriores, exp칩rtalo a un formato nativo `R` en la carpeta `datos` de tu proyecto de RStudio

```{r}
#| code-fold: true
#| eval: false
library(tidyr)
save(who2, file = "./datos/who2.RData")
```

### [**Ejercicio 2**]{.hl-yellow}

游닇 Carga el conjunto de datos `who2` pero desde la carpeta data (importa el fichero creado en el ejercicio anterior)


```{r}
#| code-fold: true
#| eval: false
load("./datos/who2.RData")
```

### [**Ejercicio 3**]{.hl-yellow}

游닇 Repite lo mismo (exportar e importar) en 4 formatos: `.csv`, `.xlsx`, `.sav` (spss) y `.dta` (stata)

```{r}
#| code-fold: true
#| eval: false

# csv
library(readr)
write_csv(who2, file = "./datos/who2.csv")
who2_data <- read_csv(file = "./datos/who2.csv")

# excel
library(openxlsx)
write.xlsx(who2, file = "./datos/who2.xlsx")
who2_data <- read_xlsx(path = "./datos/who2.xlsx")

# sas y stata
library(haven)
write_sav(who2, path = "./datos/who2.sav")
who2_data <- read_spss(path = "./datos/who2.sav")

write_dta(who2, path = "./datos/who2.dta")
who2_data <- read_dta(path = "./datos/who2.dta")
```

### [**Ejercicio 4**]{.hl-yellow}

游닇 Repita la carga de `who2.csv` pero seleccione s칩lo las 4 primeras columnas ya cargadas.

```{r}
#| code-fold: true
#| eval: false
who_select <-
  read_csv(file = "./datos/who2.csv",
           col_select = c("country", "iso2", "iso3", "year"))
who_select
```


:::


## 游냒 Caso pr치ctico III: encuesta CIS

[游늵 Datos](https://drive.google.com/drive/folders/1HV3kAAHr4iWKvH5spsKWUwAdzWSBS8pw?usp=sharing)

Vamos a poner en pr치ctica la carga y preprocesado de un fichero generado por uno de los programas inform치ticos m치s utilizados (SPSS). El fichero contiene [**datos del bar칩metro del CIS (Centro de Investigaciones Sociol칩gicas) 춺Percepciones sobre igualdad entre hombres y mujeres y estereotipos de g칠nero췉**]{.hl-yellow} cuyo trabajo muestral se realiz칩 del 6 al 14 de noviembre (4000 entrevistas a mayores de 16 a침os de ambos sexos en 1174 municipios y 50 provincias).

### Pregunta 1

> Carga el archivo de extensi칩n `.sav` que tienes en la subcarpeta `CIS-feminismo` dentro de la carpeta de datos. Tras la carga normaliza los nombres de las variables con el paquete `{janitor}`.

```{r}
#| code-fold: true
library(haven)
data <-
  read_sav(file = "./datos/CIS-feminismo/3428.sav") |> 
  janitor::clean_names()
```

### Pregunta 2

> Usando tidyverse calcula la cantidad de elementos diferentes de cada variable y procede a eliminar aquellas cuyo valor sea constante (es decir solo haya una modalidad). Primero obt칠n el vector de nombres de dichas variables para luego poder usarlo en un `select()` (de manera que no dependa de los nombres de variables de la tabla)

```{r}
#| code-fold: true
rm_variables <-
  data |> 
  summarise(across(everything(), n_distinct)) |> 
  pivot_longer(cols = everything(), names_to = "variable", values_to = "n_values") |> 
  filter(n_values <= 1) |> 
  pull(variable)
data <-
  data |> 
  select(-rm_variables)
```

### Pregunta 3

> Haz lo mismo pero para eliminar aquellas variables que en cada fila tomen un valor distinto (no haya ni un solo repetido). Estas columnas har치n funciones de `id` del encuestado pero solo necesitamos una de ellas, elimina las dem치s.

```{r}
#| code-fold: true
rm_variables <-
  data |> 
  summarise(across(everything(), n_distinct)) |> 
  pivot_longer(cols = everything(), names_to = "variable", values_to = "n_values") |> 
  filter(n_values == nrow(data)) |> 
  pull(variable)
data <-
  data |> 
  select(-rm_variables[-1])
```

### Pregunta 4

> Para entender qu칠 significan las variables, tienes en la carpeta `CIS-feminismos` el cuestionario que se hizo a cada encuestada en `cues3428.pdf` y la ficha t칠cnica en `FT3428.pdf`. En estos documentos ver치s c칩mo, por ejemplo, las variables del cuestionario comienzan casi todas por `p...`, aunque tambi칠n tenemos otro tipo de variables relacionadas con las tareas del hogar (`tarhog...`), los hijos (`hijomenor...`), el cuidado de los ni침os (`cuidadohijos...`), las tareas de cuidado en general (`tareascuid...`) y otras variables relacionadas con la escala ideol칩gica, la religi칩n, el recuerdo de voto, etc. Adem치s, todas las variables que comienzan por `ia_xxx` se refieren a c칩digos relativos a posibles incidencias en la recogida de datos y las variables `peso...` al tipo de ponderaci칩n utilizado en el muestreo. Proceda a eliminar estos dos 칰ltimos tipos de variables.

```{r}
#| code-fold: true
data <-
  data |> 
  select(-contains("ia_"), -contains("peso"))
```

### Pregunta 5

> Calcula el n칰mero de entrevistas por comunidad aut칩noma (`ccaa`) y extrae las 5 con menos entrevistas.

```{r}
#| code-fold: true
#| eval: false
data |>
  count(ccaa, sort = TRUE)

data |>
  count(ccaa) |> 
  slice_min(n = 5, n)
```


### Pregunta 6

> Usa el paquete `{datapasta}` para copiar de la  [p치gina del INE](https://www.ine.es/jaxiT3/Datos.htm?t=2853) la poblaci칩n de cada provincia e importarlo a un tibble

```{r}
#| code-fold: true
# este c칩digo deber칤a generarse autom치ticamente: cuando instalas el
# paquete se instala un addin en R Studio (parte superior) que te
# permite ctrl+c una tabla y diferentes opciones para importarla
population <- 
  tibble::tribble(~Total, ~`47.385.107`,
                    "01 Andaluc칤a",   "8.472.407",
                       "02 Arag칩n",   "1.326.261",
      "03 Asturias, Principado de",   "1.011.792",
               "04 Balears, Illes",   "1.173.008",
                     "05 Canarias",   "2.172.944",
                    "06 Cantabria",     "584.507",
              "07 Castilla y Le칩n",   "2.383.139",
         "08 Castilla - La Mancha",   "2.049.562",
                     "09 Catalu침a",   "7.763.362",
         "10 Comunitat Valenciana",   "5.058.138",
                  "11 Extremadura",   "1.059.501",
                      "12 Galicia",   "2.695.645",
         "13 Madrid, Comunidad de",   "6.751.251",
            "14 Murcia, Regi칩n de",   "1.518.486",
  "15 Navarra, Comunidad Foral de",     "661.537",
                   "16 Pa칤s Vasco",   "2.213.993",
                    "17 Rioja, La",     "319.796",
                        "18 Ceuta",      "83.517",
                      "19 Melilla",      "86.261"
  )
```

### Pregunta 7

> Renombra de manera adecuada las variables de `population`, convierte la poblaci칩n a variable num칠rica y separa la variable de la comunidad aut칩noma en 2, una para el c칩digo y otro para el nomnbre (procesa ete 칰ltimo de manera adecuada con el paquete `{stringr}` para eliminar espacios en blanco).

```{r}
#| code-fold: true
population <-
  population |> 
  rename(ccaa = Total, pop = `47.385.107`) |> 
  mutate("pop" = as.numeric(str_replace_all(pop, "\\.", ""))) |> 
  separate(col = ccaa, into = c("cod_INE", "name"), sep = 2) |> 
  mutate(name = str_squish(name))
```

### Pregunta 8

> Incorpora la informaci칩n de la poblaci칩n a nuestra tabla del CIS. Tras incorporar dicha informaci칩n calcula una tabla resumen con el ratio entre el porcentaje de poblaci칩n que representa cada ccaa respecto al total de Espa침a y el porcentaje de encuestados de dicha comunidad respecto al total de encuestados. 쮺u치les son las 3 provincias m치s sobrerepresentadas? 쯏 las 3 m치s infrarrepresentads? 

```{r}
#| code-fold: true
#| eval: false
data <-
  data |> 
  left_join(population |> mutate("cod_INE" = as.numeric(cod_INE)),
            by = c("ccaa" = "cod_INE")) |> 
  relocate(name, pop, .after = "ccaa")

prop_surv_pop <-
  data |>
  summarise("prop_surv" = n() / sum(nrow(data)),
            "pop" = unique(pop),
            .by = ccaa) |> 
  mutate("prop_pop" = pop / sum(pop),
         "ratio" = prop_pop / prop_surv)

# sobre
prop_surv_pop |> 
  slice_min(ratio, n = 3)

# infra
prop_surv_pop |> 
  slice_max(ratio, n = 3)
```


## Listas

Ya hemos visto que las listas son un objeto en R que nos permite almacenar [**colecciones de variables de distinto tipo**]{.hl-yellow} (como con `data.frame` y `tibble`) pero tambi칠n [**diferentes longitudes**]{.hl-purple}, con estructuras totalmente heterog칠neas (incluso una lista puede tener dentro otra lista).

```{r}
nombre <- "Javi"
edad <- 34
notas <- c(7, 8, 5, 3, 10, 9)
progenitores <- c("Paloma", "Goyo")

# Podemos no ponerle nombre pero solo podremos acceder por 칤ndice
list_var <- list("nombre" = nombre, "edad" = edad,
                 "notas" = notas, "parents" = progenitores)
```


```{r}
list_var$nombre
list_var$progenitores
```



---

## Listas


Tambi칠n podemos hacer [**listas con otras listas dentro**]{.hl-yellow}, de forma que para acceder a cada nivel debamos utilizar el operador `[[]]`.

```{r}
list_of_lists <- list("list_1" = list_var[1:2], "list_2" = list_var[3:4])
names(list_of_lists)
```

```{r}
names(list_of_lists[[1]])
```

```{r}
list_of_lists[[1]][[1]]
```


춰Se nos permite almacenar [**datos n-dimensionales**]{.hl-yellow}!


Sin embargo una de las desventajas es [**no puede ser vectorizada**]{.hl-yellow} inmediatamente, por lo que cualquier operaci칩n aritm칠tica aplicada a una lista dar치 [**error**]{.hl-red}. Por ejemplo, en el c칩digo anterior, uno esperar칤a que hiciese la operaci칩n en cada elemento de la lista (en `a` y en `b`) pero no funciona.

```{r}
#| error: true
data <- list("a" = 1:5, "b" = 10:20)
data / 2
```


Para ello una de las opciones habituales (de `R` base) era hacer uso de la familia `lapply(lista, FUN = ...)`: aplica una funci칩n `FUN = ...` a cada elemento de la lista

```{r}
lapply(data, FUN = function(x) { x / 2})
```

Pero por defecto la salida de `lapply()` es siempre una [**lista de igual longitud**]{.hl-yellow}.


### Paquete purrr


Una opci칩n m치s flexible y vers치til es hacer uso del paquete `{purrr}` del entorno `{tidyverse}`.

```{r}
library(purrr)
```

Este paquete pretende imitar la [**programaci칩n funcional**]{.hl-yellow} de otros lenguajes como Scala o la [**estrategia map-reduce**]{.hl-yellow} de Hadoop (de Google).

![](img/purrr.png)

#### map()

La funci칩n m치s sencilla del paquete `{purrr}` es la funci칩n `map()`, que [**aplica una funci칩n vectorizada**]{.hl-yellow} a cada uno de los elementos de una lista. Veamos un primer ejemplo aplicado a vectores: imagina que tenemos la siguiente lista y queremos aplicar, a cada uno de sus elementos, la suma.

```{r}
x <- list("x1" = 1:4, "x2" = 11:20)
```


`map(lista, funci칩n)` nos permite [**mapear la lista**]{.hl-yellow} y aplicar la funci칩n que queramos elemento a elemento


```{r}
map(x, sum) 
```


![](img/map_purrr.png)

::: callout-warning
## Ten cuidado...

La [**salida por defecto de `map` es a su vez otra lista**]{.hl-yellow}.
:::


Veamos otro ejemplo que puedes sernos 칰til: imagina que tenemos [**dos muestras aleatorias de distinto tama침o**]{.hl-yellow}. La 칰nica forma en la que podemos almacenarlas juntas es con una lista pero...쯖칩mo hacer la media a ambas distribuciones sino podemos vectorizarlas?


```{r}
x <- list(rnorm(n = 1500, mean = 0, sd = 0.7),
          rnorm(n = 2800, mean = 2, sd = 1.5))
```


Con `map()` y la funci칩n `mean()` dentro

```{r}
map(x, mean)
```



쯏 si quisi칠ramos calcular la media de sus valores al cuadrado? En este caso [**no disponemos de una funci칩n ya definida**]{.hl-red} as칤 que tenemos dos opciones: definirla antes (con un nombre) o bien [**definir la funci칩n dentro del propio map**]{.hl-yellow}

```{r}
map(x, function(x) { mean(x^2) })
```



Una forma de [**definir la funci칩n m치s r치pido**]{.hl-yellow} es as칤:

```{r}
map(x, \(x) mean(x^2))
```


#### map_xxx()

Adem치s de ser [**m치s legible y eficiente**]{.hl-yellow}, con `{purrr}` podemos [**decidir el formato de salida**]{.hl-yellow} tras la operaci칩n

* salida como un [**vector num칠rico (decimales)**]{.hl-purple} con `map_dbl()`
* salida como un [**vector num칠rico (enteros)**]{.hl-purple} con `map_int()`
* salida como un [**vector de caracteres**]{.hl-purple} con  `map_chr()`
* salida como un [**vector num칠rico l칩gico**]{.hl-purple} con  `map_lgl()`

```{r}
library(glue)
map_dbl(x, mean)
map_chr(x, function(x) { glue("Mean is {round(mean(x), 3)}") })
map_lgl(x, function(x) { all(x < 3)})
```


Tambi칠n puede sernos 칰til para [**acceder a un elemento de CADA lista**]{.hl-yellow} si le pasas un [**n칰mero**]{.hl-yellow} en lugar de una funci칩n.

```{r}
c(x[[1]][3], x[[2]][3])
map_dbl(x, 3)
```

#### pluck()

Tambi칠n podemos hacer uso de `pluck()` para [**acceder al i-th objeto de la lista**]{.hl-yellow}.

```{r}
lista <- list("a" = starwars, "b" = billboard)
lista |> pluck(1)
```


#### map2()

Tambi칠n tenemos la opci칩n de **generalizarlo** para poder utilizar funciones que [**necesiten dos argumentos**]{.hl-yellow} (operaciones binarias) con `map2()`. Por ejemplo, supongamos que tenemos las siguientes dos listas, y queremos que suma el vector del primer elemento de ambas entre s칤, y lo mismo con el segundo

```{r}
x <- list("a" = 1:3, "b" = 4:6)
y <- list("a" = c(-1, 4, 0), "b" = c(5, -4, -1))
x$a + y$a
x$b + x$b
```


En `map2()` introducimos las 2 listas y una **funci칩n con 2 argumentos**

```{r}
map2(x, y, function(x, y) { x + y})
```



Podemos tambi칠n obtener la salida en forma de `data.frame` a침adiendo `list_rbind()` o `list_cbind()`, que [**convierte una lista en una tabla**]{.hl-yellow}.

```{r}
x <- c("a", "b")
y <- 1:2
map2(x, y, function(x, y) { tibble(x, y) })
map2(x, y, function(x, y) { tibble(x, y) }) |> list_rbind()
```

#### pmap()

Podemos generalizarlo a칰n m치s con `pmap_xxx()` que nos permite utilizar [**m칰ltiples argumentos (m칰ltiples listas para funci칩nes multivariantes)**]{.hl-amarillo}.

```{r}
x <- list(1, 1, 1)
y <- list(10, 20, 30)
z <- list(100, 200, 300)
pmap_dbl(list(x, y, z), sum)
```

#### walk()

Tenemos otros tipos de iteradores que, aunque asumen entradas, no devuelven nada, como `walk()` (s칩lo un argumento de entrada), `walk2()` (dos argumentos) y `pwalk()` (m칰ltiples argumentos), todos [**devuelven algo invisible**]{.hl-yellow}, s칩lo llaman a una funci칩n por sus [**efectos secundarios**]{.hl-yellow} en lugar de por su valor de retorno.

```{r}
list("a" = 1:3, "b" = 4:6) |>
  map2(list("a" = 11:13, "b" = 14:16),
       function(x, y) { x + y }) |> 
  walk(print)
```



### 游눹  Tu turno


::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

游닇 Define una lista de 4 elementos de distintos tipos y accede al segundo de ellos (incluir칠 uno que sea un tibble para que veas que en una lista cabe de todo).

```{r}
#| code-fold: true
#| eval: false
list_example <-
  list("name" = "Javier", "cp" = 28019,
       "siblings" = TRUE,
       "marks" = tibble("maths" = c(7.5, 8, 9),
                        "lang" = c(10, 5, 6)))
list_example
```

### [**Ejercicio 2**]{.hl-yellow}

游닇 From the list above, access the elements that occupy places 1 and 4 of the list defined above.

```{r}
#| code-fold: true
#| eval: false

list_example[c(1, 4)]

list_example$name
list_example$marks

list_example[c("name", "marks")]
```



### [**Ejercicio 3**]{.hl-yellow}

游닇  Load the `starwars` dataset from the `{dplyr}` package and access the second movie that appears in `starwars$films` (for each character). Determine which ones do not appear in more than one movie.

```{r}
second_film <- map(starwars$films, 2)
map_lgl(second_film, is.null)
```

### [**Ejercicio 4**]{.hl-yellow}

游닇 Convierte a tibble la base de datos `iris` incluida en `R base` (no necesitas ning칰n paquete, ya la tienes). Vamos a agrupar por species para despu칠s usar `group_split()`: nos genera una lista tal que cada elemento es la tabla para cada uno de los grupos (como un filter de cada grupo pero en un mismo objeto).

```{r}
iris_list <-
  iris |> as_tibble() |>
  group_by(Species) |> 
  group_split()
```

Accede a cada variable  `Sepal.Length` para cada una de las subtablas y haz la media (nos tendr칤a que salir un vector de medias)

```{r}
#| code-fold: true
#| eval: false
iris_list |> 
  map("Sepal.Length") |> 
  map_dbl(mean)
```


:::


## 游냒 Caso pr치ctico IV: encuesta de satisfacci칩n


Para este ejercicio usaremos la tabla de datos de satisfacci칩n de pacientes en un hospital guardada en el archivo `.csv` llamada `SatisfaccionPacientes.csv`


```{r}
library(tidyverse)
datos <-
  read_csv("./datos/SatisfaccionPacientes.csv") |> 
  # normalizaci칩n de nombres de variables
  janitor::clean_names()
datos
```

### Pregunta 1

> Aplica el c칩digo que sea necesario para determinar el tama침o muestral, el n칰mero de variables y el tipo de estas.

```{r}
#| code-fold: true

# Tama침o muestral / n칰mero de observaciones
n <- datos |> nrow()

# N칰mero de variables
p <- datos |> ncol()

# Tipo de variables
dplyr::glimpse(datos)
```


### Pregunta 2

> Usando tidyverse, obt칠n la tabla de frecuencias absolutas de la variable `genero`.

```{r}
#| code-fold: true
tabla_freq <-
  datos |> 
  count(genero)
```

### Pregunta 3

>  Incorpora a la tabla anterior las frecuencias relativas. 쯇odr칤amos calcular las frecuencias acumuladas? 쯇or qu칠?

```{r}
#| code-fold: true
tabla_freq <-
  tabla_freq |> 
  rename(frecuencia_abs = n) |> 
  mutate(frecuencia_rel = frecuencia_abs/sum(frecuencia_abs))

# No podemos acumuladas ya que necesitamos una jerarqu칤a de orden
# son cualis nominales, no ordinales
```

Haciendo uso de la tabla, **쯤u칠 % de pacientes son mujeres?**

Haz lo mismo tu solo con la variable `estado_civil` y determina el n칰mero de personas casadas (deber칤an ser 26).

### Pregunta 4

En `R` las [**variables cualitativas pueden ser tratadas como tales**]{.hl-yellow} convirtiendo una cadena de texto a lo que se conoce como [**factor**]{.hl-yellow}. Por ejemplo, supongamos que tenemos un vector de notas

```{r}
notas <- c("suspenso", "notable", "suspenso", "aprobado", "notable", "suspenso")
notas
```


Para [**convertir a factor nos basta con `factor()`**]{.hl-yellow}. 쯈u칠 notas diferente?

```{r}
notas_fct <- factor(notas)
notas_fct
```


Si te fijas ahora [**tenemos disponibles unos niveles (levels)**]{.hl-yellow}: son las posibles modalidades de nuestra variable cualitativa, el soporte, de manera que aunque borremos uno de ellos (vamos a borrar todos los aprobados), la opci칩n sigue disponible si entrase un dato nuevo (algo as칤 como un men칰 de opciones permitidas)

```{r}
notas_fct[notas_fct != "aprobado"]
```



En el caso de las [**cualitativas ordinales podemos incluso establecer una jerarqu칤a**]{.hl-yellow}, indicando expl칤citamente los niveles y `ordered = TRUE`

```{r}
notas_fct_ord <- factor(notas, levels = c("aprobado", "notable", "suspenso"),
                        ordered = TRUE)
notas_fct_ord
```

F칤jate que ahora tenemos una [**jerarqu칤a**]{.hl-yellow} y aunque sea cualitativa podemos buscar [**elementos <= o >= que otros**]{.hl-yellow}

```{r}
notas_fct_ord[notas_fct_ord <= "notable"]
```

> Haz que tu variable `estado_salud` sea una factor representando una cualitativa ordinal

```{r}
#| code-fold: true
datos <-
  datos |>
  mutate(estado_salud =
           factor(estado_salud, levels = c("Malo", "Regular", "Bueno", "Excelente"),
                  ordered = TRUE))

```

### Pregunta 5

> Calcula la tabla de frecuencias para `estado_salud` incluyendo todo lo que puedas (쯥e puede ahora calcular las frecuencias acumuladas). 쮺u치ntos pacientes est치n en un estado de salud regular o peor? (pisa: 59 personas).

```{r}
#| code-fold: true
#| eval: false
tabla_freq <- 
  datos |> 
  count(estado_salud) |> 
  rename(frecuencia_abs = n) |> 
  mutate(frecuencia_rel = frecuencia_abs/sum(frecuencia_abs),
         frecuencia_acum_abs = cumsum(frecuencia_abs),
         frecuencia_acum_rel = cumsum(frecuencia_rel))

datos |>
  count(estado_salud <= "Regular")
```


### Pregunta 6

> Calcula la media, mediana, cuartiles y desviaci칩n t칤pica de edad y tiempo de espera. Guarda los resultados en `resumen` y exp칩rtalo a un `resumen.csv`

```{r}
#| code-fold: true
resumen <-
  datos |>
  summarise(media_edad = mean(edad), sd_edad = sd(edad),
            mediana_edad = median(edad),
            Q1_edad = quantile(edad, probs = 0.25),
            Q3_edad = quantile(edad, probs = 0.75),
            # tiempo espera
            media_tiempo_espera = mean(tiempo_espera), 
            sd_tiempo_espera = sd(tiempo_espera),
            mediana_tiempo_espera = median(tiempo_espera),
            Q1_tiempo_espera = quantile(tiempo_espera, probs = 0.25),
            Q3_tiempo_espera = quantile(tiempo_espera, probs = 0.75))
write_csv(resumen, file = "./datos/resumen.csv")
```


### Pregunta 7

> Haz una tabla de frecuencias (absolutas) cruzada entre `genero` y `estado_salud` con tidyverse para que quede como la tabla inferior

```{r}
#| code-fold: true

# Primero cuento de manera bidimensional con count(var1, var2)
conteo_bidim <-
  datos |>
  count(genero, estado_salud)
conteo_bidim
```

### Pregunta 8

> Haciendo uso de la tabla anterior, 쯤u칠 debes hacer para obtener una tabla de frecuencias bidimensional como la de abajo? (la tabla de frecuencias en formato habitual)


```{r}
#| code-fold: true
# Despu칠s pivoto para que use la columna estado_salud
# como futuros nombres de variables (pivota de vertical a horizontal)
#   - names_from: de donde saldr치n los futuros nombres de columnas
#   - values_from: de donde sacamos los valores num칠ricos (en este caso n)
#     para rellenar la tabla
tabla_freq_abs <-
  conteo_bidim |> pivot_wider(names_from = estado_salud, values_from = n)
tabla_freq_abs
```


### Pregunta 9


Tambi칠n se puede hacer en `R base` con `table()` (que adem치s de ser m치s sencillo respeta la jerarqu칤a de la ordinal). [**Moraleja: a veces R base nos facilita la vida, no lo olvidemos porque lo vas a necesitar**]{.hl-yellow }

```{r}
tabla_freq <- table(datos$genero, datos$estado_salud)
tabla_freq
```

La tabla anterior se puede [**calcular con frecuencias relativa por filas y por columnas**]{.hl-yellow} (es decir,una que toda las filas sumen el total, 1, y otra que las columnas sumen 1) haciendo uso de `prop.table()` aplicada a la tabla anterior (si `margin = 1` normaliza por filas, si `margin = 2` por columnas).

```{r}
#| code-fold: true
prop.table(tabla_freq, margin = 1)
prop.table(tabla_freq, margin = 2)
```

[**Moraleja: tablas de frecuencia podemos hacerlas en tidyverse pero bidimensionales R base nos ayuda mejor. Deberemos viajar entre los dos mundos muchas veces**]{.hl-yellow}

> Haciendo uso de las tablas anteriores contesta a las siguientes preguntas:

* 쯈u칠 porcentaje de entre las mujeres tiene un buen estado de salud?

* 쯈u칠 porcentaje de entre los hombres tiene un estado de salud regular?

* 쯈u칠 porcentaje de los que tienen estado de salud malo son mujeres?

**Clicka debajo para ver la respuesta cuando lo tengas**

```{r}
#| code-fold: true

# De entre las mujeres un 45.28% tiene un buen estado de salud
# De entre los hombres un 34.04% tiene un estado de salud regular
# Un 33.33% de los que tienen un estado de salud malo, son mujeres
```

### Pregunta 10

**Un poquito de reminder de inferencia**. Haciendo uso de la tabla de frecuencias absolutas, ejecuta el c칩digo que consideres para responder a la pregunta: 쯘st치n estas dos variables (`estado_salud` y `genero`) asociadas? 쮼xiste alg칰n tipo de dependencia entre ellas? Hazlo considerando $\alpha = 0.05$.

```{r}
#| code-fold: true
#| eval: false

# Opci칩n 1: prueba de chi-cuadrado que nos permite sacar conclusiones
# sobre la independencia de dos variables cualitativas

# chisq.test() hace el contraste haciendo uso de la tabla de frec
chisq.test(tabla_freq)

# Como el p-value = 0.2322 y alpha = 5%, no podemos rechazar la
# hip칩tesis nula de independencia: no hay evidencias suficientes 
# CON LA MUESTRA QUE TENEMOS para concluir que haya alguna asociaci칩n
# entre g칠nero y estado de salud

# Opci칩n 2: test exacto de Fisher, especialmente 칰til cuando
# las frecuencias esperadas son bajas.
fisher.test(tabla_freq)
# Diferente p-valor pero misma conclusi칩n
```


Las funciones `chisq.test()` y `fisher.test()` pueden tomar como argumento una tabla de frecuencias ya resumida o puede tomar [**dos variables y la funci칩n ya realiza el conteo**]{.hl-yellow. Por ejemplo si hacemos `chisq.test(var1, var2)` obtenemos un objeto `htest` que dentro contiene el p-valor.

```{r}
test_chisq <- chisq.test(datos$genero, datos$estado_salud)
names(test_chisq)
```


Por tanto si aplicamos la funci칩n y hacemos despu칠s `$p.value` podemos obtener **directamente el valor num칠rico que nos interesa**

```{r}
chisq.test(datos$genero, datos$estado_salud)$p.value
```

### Pregunta 11

> 쮺칩mo usar tidyverse para tener en una tabla resumen ambos p-valores?

```{r}
#| code-fold: true
tabla_p_valores <-
  datos |> 
  summarise("sig_chisq" = chisq.test(genero, estado_salud)$p.value,
            "sig_fisher" = fisher.test(genero, estado_salud)$p.value)
```

### Pregunta 12

> C치lcula la matriz correlaciones de Pearson entre las variables num칠ricas. 쮼xiste dependencia LINEAL entre la variable edad y el tiempo de espera? (recuerda: correlaci칩n de Pearson solo mide asociaci칩n lineal). Echa un vistazo al paquete `{corrr}`

```{r}
#| code-fold: true

# Opci칩n 1
mat_cor <-
  datos |> 
  select(where(is.numeric)) |> 
  cor()

# Opci칩n 2
mat_cor <-
  datos |> 
  select(where(is.numeric)) |> 
  corrr::correlate()

# La correlaci칩n es de 0.0669 por lo que no parezca exista relaci칩n
```

### Pregunta 13

>  Calcula en una tabla resumen la correlaci칩n y el p-valor derivado de un test de correlaciones (`cor.test()`) entre ambas variables

```{r}
#| code-fold: true
cor_summary <-
  datos |> 
  summarise("cor" = cor(edad, tiempo_espera),
            "sig_cor" = cor.test(edad, tiempo_espera)$p.value)
# No parece existir evidencia significativa de dependencia lineal
```

### Pregunta 14

> Repite todo lo anterior con las variables tiempo de espera y grado de satisfacci칩n

```{r}
#| code-fold: true
mat_cor <- 
  datos |> 
  select(where(is.numeric)) |> 
  corrr::correlate()

cor_summary <-
  datos |> 
  summarise("cor" = cor(grado_satisfaccion, tiempo_espera),
            "sig_cor" = cor.test(grado_satisfaccion, tiempo_espera)$p.value)
# S칤 parece existir evidencia significativa de dependencia lineal
# concretamente negativa: a m치s espera, menor satisfacci칩n
```

