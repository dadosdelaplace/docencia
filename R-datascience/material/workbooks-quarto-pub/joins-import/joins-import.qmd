---
title: "Joins e importaci√≥n: como combinar, exportar e importar en R"
subtitle: "Cuadernos pr√°cticos de Software II del Grado en Ciencia de Datos Aplicada (curso 2024-2025)"
author: "Javier √Ålvarez Li√©bana"
format:
  html:
    theme: [default, style.scss]
    toc: true
    toc-title: √çndice
    toc-depth: 5
    toc-location: left
    number-sections: true
    embed-resources: true
execute: 
  echo: true
---

## Relacionando datos: joins

Al trabajar con datos [**no siempre tendremos la informaci√≥n en una sola tabla**]{.hl-yellow} y a veces nos interesar√° cruzar la informaci√≥n de distintas fuentes.


Para ello usaremos un cl√°sico de todo lenguaje que maneja datos: los famosos [**join**]{.hl-yellow}, que nos permitir√°n [**cruzar una o varias tablas**]{.hl-yellow}, haciendo uso de una [**columna identificadora**]{.hl-yellow} de cada una de ellas (por ejemplo, imagina que cruzamos datos de hacienda y de antecedentes penales, haciendo `join` por la columna `DNI`).

&nbsp;

La estructura b√°sica es la siguiente:

```{r}
#| eval: false
tabla_1 |>
  xxx_join(tabla_2, by = id)
```

![](img/sql-joins.jpg)


Vamos a probar los distintos joins con un ejemplo sencillo

```{r}
library(tidyverse)
tb_1 <- tibble("key" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```


```{r}
tb_1
```

```{r}
tb_2
```

### Left join


* `left_join()`: mantiene [**todos los registros de la primera tabla**]{.hl-yellow}, y busca cuales tienen id tambi√©n en la segunda (en caso de [**no tenerlo se rellena con NA**]{.hl-yellow} los campos de la 2¬™ tabla).

En nuestra caso queremos incorporar a `tb_1` la informaci√≥n de `tb_2`, identificando los registros por la columna key (`by = "key"`, la columna por la que tiene que cruzar)



```{r}
tb_1  |> 
  left_join(tb_2, by = "key")
```


![](img/left_join.jpg)


```{r}
tb_1 |> 
  left_join(tb_2, by = "key")
```

F√≠jate que los [**registros de la primera cuya key no ha encontrado en la segunda**]{.hl-yellow} les ha dado el valor de [**ausente**]{.hl-yellow}.

### Right join


* `right_join()`: mantiene [**todos los registros de la segunda tabla**]{.hl-yellow}, y busca cuales tienen id tambi√©n en la primera.


Vamos ahora a incorporar a `tb_2` la informaci√≥n de `tb_1`, identificando los registros por la columna key (`by = "key"`)

```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```


![](img/right_join.jpg)



```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

F√≠jate que ahora los [**registros de la segunda cuya key no ha encontrado en la primera**]{.hl-yellow} son los que les ha dado el valor de [**ausente**]{.hl-yellow}.

### Claves y sufijos

Las columnas clave que usaremos para el cruce [**no siempre se llamar√°n igual**]{.hl-yellow}.

```{r}
tb_1 <- tibble("key_1" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```


* `by = c("key_2" = "key_2")`: le indicaremos en qu√© columna de cada tabla est√°n las claves por las que vamos a cruzar.

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```


```{r}
# Right
tb_1  |> 
  right_join(tb_2, by = c("key_1" = "key_2"))
```


Adem√°s podemos [**cruzar por varias columnas a la vez**]{.hl-yellow} (interpretar√° como igual registro aquel que tenga el conjunto de claves igual), con `by = c("var1_t1" = "var1_t2", "var2_t1" = "var2_t2", ...)`. Modifiquemos el ejemplo anterior

```{r}
tb_1 <- tibble("k_11" = 1:3, "k_12" = c("a", "b", "c"),  "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("k_21" = c(1, 2, 4), "k_22" = c("a", "b", "e"), "val_y" = c("y1", "y2", "y3"))
```


```{r}
# Left
tb_1 |> 
  left_join(tb_2,
            by = c("k_11" = "k_21", "k_12" = "k_22"))
```


Tambi√©n podr√≠a suceder que al cruzar dos tablas, haya [**columnas de valores que se llamen igual**]{.hl-yellow}


```{r}
tb_1 <- tibble("key_1" = 1:3, "val" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val" = c("y1", "y2", "y3"))
```


```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

F√≠jate que [**por defecto nos a√±ade los sufijos**]{.hl-yellow} `.x` y `.y` para indicarnos de que tabla vienen. Dicho [**sufijo podemos especific√°rselo**]{.hl-yellow} en el argumento opcional `suffix = ...`, que nos permita [**distinguir las variables**]{.hl-yellow} de una tabla y de otra.


```{r}
# Left
tb_1 |>
  left_join(tb_2, by = c("key_1" = "key_2"), suffix = c("_tabla1", "_tabla2"))
```

### Full join


* `full_join()`: mantiene [**todos los registros de ambas**]{.hl-yellow} tablas.

Los dos anteriores casos forman lo que se conoce como [**outer joins**]{.hl-yellow}: cruces donde se mantienen observaciones que salgan en al menos una tabla. El tercer outer join es el conocido como `full_join()` que nos [**mantendr√° las observaciones de ambas**]{.hl-yellow} tablas, [**a√±adiendo las filas**]{.hl-yellow} que no casen con la otra tabla.



```{r}
tb_1 |> 
  full_join(tb_2, by = c("key_1" = "key_2"))
```


![](img/full_join.jpg)

### Inner join

* `inner_join()`: solo sobreviven los [**registros cuyo id est√© en ambas**]{.hl-yellow} tablas.

Frente a los outer join est√° lo que se conoce como [**inner join**]{.hl-yellow}, con `inner_join()`: un cruce en el que solo se mantienen las [**observaciones que salgan en ambas tablas**]{.hl-yellow}, solo mantiene aquellos registros matcheados.



```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

![](img/inner_join.png)


F√≠jate que en t√©rminos de registros, `inner_join` si es conmutativa, **nos da igual el orden de las tablas**: lo √∫nico que cambia es el orden de las columnas que a√±ade.


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```



```{r}
tb_2 |> 
  inner_join(tb_1, by = c("key_2" = "key_1"))
```

### Anti/semi join

Por √∫ltimo tenemos dos herramientas interesantes para [**filtrar (no cruzar) registros**]{.hl-yellow}: `semi_join()` y `anti_join()`. El [**semi join**]{.hl-yellow} nos deja en la [**primera tabla los registros que cuya clave est√° tambi√©n en la segunda**]{.hl-yellow} (como un inner join pero sin a√±adir la info de la segunda tabla). Y el segundo, los anti join, hace justo lo contrario (aquellos que no est√°n).


```{r}
# semijoin
tb_1 |> 
  semi_join(tb_2, by = c("key_1" = "key_2"))
```

```{r}
# antijoin
tb_1 |> 
  anti_join(tb_2, by = c("key_1" = "key_2"))
```



### üíª Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

Para los ejercicios usaremos las tablas disponibles en el paquete `{nycflights13}` (echa un vistazo antes)

```{r}
library(nycflights13)
```

* [**airlines**]{.hl-yellow}: nombre de aerol√≠neas (con su abreviatura).
* [**airports**]{.hl-yellow}: datos de aeropuertos (nombres, longitud, latitud, altitud, etc).
* [**flights**]{.hl-yellow}: datos de vuelos.
* [**planes**]{.hl-yellow}: datos de los aviones.
* [**weather**]{.hl-yellow}: datos meteorol√≥gicos horarios de las estaciones LGA, JFK y EWR.


::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Del paquete `{nycflights13}` cruza la tabla `flights` con `airlines`. Queremos mantener todos los registros de vuelos, a√±adiendo la informaci√≥n de las aerol√≠neas a dicha tabla.

```{r}
#| eval: false
#| code-fold: true
flights_airlines <-
  flights |> 
  left_join(airlines, by = "carrier")
flights_airlines
```

### [**Ejercicio 2**]{.hl-yellow}

üìù A la tabla obtenida del cruce del apartado anterior, cruza despu√©s con los datos de los aviones en `planes`, pero incluyendo solo aquellos vuelos de los que tengamos informaci√≥n de sus aviones (y viceversa). 


```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum")
flights_airlines_planes
```


### [**Ejercicio 3**]{.hl-yellow}

üìù Repite el ejercicio anterior pero conservando ambas variables `year` (en una es el a√±o del vuelo, en la otra es el a√±o de construcci√≥n del avi√≥n), y distingui√©ndolas entre s√≠



```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum",
             suffix = c("_flight", "_build_aircraft"))
flights_airlines_planes
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Al cruce obtenido del ejercicio anterior incluye la longitud y latitud de los aeropuertos en `airports`, distinguiendo entre la latitud/longitud del aeropuerto en destino y en origen.

```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes %>%
  left_join(airports %>% select(faa, lat, lon),
            by = c("origin" = "faa")) |> 
  rename(lat_origin = lat, lon_origin = lon) |> 
  left_join(airports %>% select(faa, lat, lon),
            by = c("dest" = "faa")) |> 
  rename(lat_dest = lat, lon_dest = lon)
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Filtra de `airports` solo aquellos aeropuertos de los que salgan vuelos. Repite el proceso filtrado solo aquellos a los que lleguen vuelos

```{r}
#| eval: false
#| code-fold: true
airports |> 
  semi_join(flights, by = c("faa" = "origin"))
airports |> 
  semi_join(flights, by = c("faa" = "dest"))
```


### [**Ejercicio 6**]{.hl-yellow}

üìù ¬øDe cu√°ntos vuelos no disponemos informaci√≥n del avi√≥n? Elimina antes los vuelos que no tengan identificar (diferente a NA) del avi√≥n


```{r}
#| eval: false
#| code-fold: true
flights |> 
  drop_na(tailnum) |>
  anti_join(planes, by = "tailnum") |>
  count(tailnum, sort = TRUE) # de mayor a menor ya de paso
```

:::


## üê£Caso pr√°ctico I: Beatles y Rolling Stones

Vamos a empezar a practicar joins sencillos con la tabla `band_members` y `band_instruments` ya incluidos en el paquete `{dplyr}`.

```{r}
library(dplyr)
band_members
band_instruments
```

En la primera tenemos una serie de artistas y la banda a la que pertenecen; en la segunda tenemos una serie de artistas y el instrumento que tocan. Adem√°s de realizar las acciones solicitadas intenta visualizar qu√© tabla final tendr√≠as antes de ejecutar el c√≥digo..

### Pregunta 1

> Dada la tabla `band_members`, incorpora la informaci√≥n de qu√© instrumento toca cada miembro (`band_instruments`) de los que tienes en esa tabla.

```{r}
#| code-fold: true
left_join_band <-
  band_members |> 
  left_join(band_instruments, by = "name")
```

### Pregunta 2

> Dadas las tablas `band_members` y `band_instruments`, ¬øqu√© tipo de join deber√≠as hacer para tener una tabla completa, sin ausencias, donde todos los miembros de la banda tengan la informaci√≥n de su instrumento, y cada instrumento tenga un miembro asociado a √©l?

```{r}
#| code-fold: true
inner_join_band <-
  band_members |>
  inner_join(band_instruments, by = "name")
```

### Pregunta 3

> Dada la tabla `band_instruments`, ¬øc√≥mo incorporar la informaci√≥n de qui√©n toca cada instrumento (en caso de que la conozcamos)?

```{r}
#| code-fold: true
right_join_band <-
  band_members |>
  right_join(band_instruments, by = "name")

# other option
left_join_instruments <-
  band_instruments |> 
  left_join(band_members, by = "name")
```

### Pregunta 4

> Dadas las tablas `band_members` y `band_instruments`, ¬øqu√© tipo de join deber√≠as hacer para tener una tabla con toda la informaci√≥n, tanto de los miembros como de los instrumentos, aunque haya miembros cuyo instrumento no conozcas, e instrumentos cuyo portador no conozcas?

```{r}
#| code-fold: true
full_join_band <-
  band_members |>
  full_join(band_instruments, by = "name")
```

## üê£ Caso pr√°ctico II: renta municipios

En el archivo `municipios.csv` tenemos guardada la informaci√≥n de los municipios de Espa√±a a fecha de 2019.

* La variable `LAU_code` representa el c√≥digo como unidad administrativa local seg√∫n la estandarizaci√≥n de la UE (ver m√°s en <https://ec.europa.eu/eurostat/web/nuts/local-administrative-units>).

* La variable `codigo_ine` est√° construida uniendo el c√≥digo de la provincia y el de la comunidad aut√≥noma.

```{r}
# datos 2019
mun_data <- read_csv(file = "./datos/municipios.csv")
mun_data
```


Por otro lado el archivo `renta_mun` contiene datos de la renta per capita edmai de cada unidad administrativa (municipios, distritos, provincias, comunidades auton√≥nomas, etc) para diferentes a√±os.

```{r}
renta_mun <- read_csv(file = "./datos/renta_mun.csv")
renta_mun
```


Antes de empezar vamos a [**normalizar nombres de variables**]{.hl-yellow} haciendo uso de `clean_names()` del paquete `{janitor}`.

```{r}
mun_data <-
  mun_data |> 
  janitor::clean_names()
renta_mun <-
  renta_mun |> 
  janitor::clean_names()
```

### Pregunta 1

> Convierte a tidydata `renta_mun` obteniendo una tabla de 4 columnas: `unidad`, `year`, `renta` y `codigo_ine` (sin ausentes y cada dato del tipo correcto)

```{r}
#| code-fold: true
renta_mun_tidy <-
  renta_mun |> 
  pivot_longer(cols = contains("x"), names_to = "year",
               values_to = "renta", names_prefix = "x",
               names_transform = list(year = as.numeric),
               values_drop_na = TRUE)
```

### Pregunta 2

> Si te fijas en la tabla anterior, tenemos datos de diferentes unidades administrativas que no siempre son municipios. Sabiendo que todos los municipios tienen un c√≥digo de 5 caracteres (que representan todos ellos n√∫meros), filtra s√≥lo aquellos registros que correspondan a unidades municipales.

```{r}
#| code-fold: true
renta_mun_tidy <-
  renta_mun_tidy |>
  filter(str_detect(codigo_ine, pattern = "[0-9]{5}") & 
           str_length(codigo_ine) == 5)
```

### Pregunta 3

> A continuaci√≥n separa adecuadamente la variable de unidad en dos columnas: una con el c√≥digo (que ya tiene, por lo que debe eliminar uno de los dos) y el nombre. Elimina los espacios sobrantes (echa un vistazo a las opciones del paquete `{stringr}`).

```{r}
#| code-fold: true
renta_mun_tidy <-
  renta_mun_tidy |>
  separate(col = "unidad", into = c("cod_rm", "name"), sep = 5) |> 
  select(-cod_rm) |> 
  mutate(name = str_trim(name)) 
```

### Pregunta 4

> ¬øEn qu√© a√±o fue mayor la renta media? ¬øY m√°s baja? ¬øCu√°l fue la renta mediana de los municipios de Espa√±a en 2019?

```{r}
summary_renta <-
  renta_mun_tidy |> 
  summarise("mean_renta" = mean(renta, na.rm = TRUE),
            .by = year)
summary_renta |>
  slice_min(mean_renta, n = 1)
summary_renta |>
  slice_max(mean_renta, n = 1)

renta_mun_tidy |> 
  filter(year == 2019) |> 
  summarise("median_renta" = median(renta, na.rm = TRUE))
```


### Pregunta 5

> Haz lo que consideres para obtener la provincia con la renta media m√°s alta en 2019 y la m√°s baja. Aseg√∫rate de obtener su nombre.

```{r}
#| code-fold: true
summary_by_prov <-
  renta_mun_tidy |> 
  filter(year == 2019) |> 
  left_join(mun_data, by = "codigo_ine", suffix = c("", "_rm")) |> 
  select(-contains("rm")) |> 
  summarise("mean_by_prov" = mean(renta, na.rm = TRUE),
            .by = c("cpro", "ine_prov_name"))

summary_by_prov |> 
  slice_max(mean_by_prov, n = 1)

summary_by_prov |> 
  slice_min(mean_by_prov, n = 1)
```

### Pregunta 6

> Obten de cada ccaa el nombre del municipio con mayor renta en 2019.

```{r}
#| code-fold: true
renta_mun_tidy |> 
  filter(year == 2019) |> 
  left_join(mun_data, by = "codigo_ine", suffix = c("", "_rm")) |> 
  select(-contains("rm")) |> 
  slice_max(renta, by = "codauto")
```



## Importar/exportar

Hasta ahora s√≥lo hemos utilizado datos ya cargados en paquetes, pero muchas veces [**necesitaremos importar datos externamente**]{.hl-yellow}. Una de las principales [**fortalezas**]{.hl-yellow} de `R` es que podemos importar datos muy f√°cilmente en diferentes formatos:



* [**Formatos nativos de R**]{.hl-yellow}: archivos `.rda`, `.RData` y `.rds`

* [**Rectangular data (datos tabulados)**]{.hl-yellow}: archivos `.csv` y `.tsv`

* [**Datos sin tabular**]{.hl-yellow}: archivos `.txt`.

* [**Datos en excel**]{.hl-yellow}: archivos `.xls` y`.xlsx`.

* [**Datos desde SAS/Stata/SPSS**]{.hl-yellow}: archivos `.sas7bdat`, `.sav` y `.dat`.

* [**Datos desde Google Drive**]{.hl-yellow}

* [**Datos desde API's**]{.hl-yellow}: aemet, catastro, censo, spotify, etc.

### Formatos nativos de R

Los ficheros [**m√°s sencillos**]{.hl-yellow} para importar a `R` (y que suelen ocupar menos espacio en disco) son sus propias [**extensiones nativas**]{.hl-yellow}: ficheros en formatos `.RData`, `.rda` y `.rds`. Para cargar los primeros basta con [**utilizar la funci√≥n**]{.hl-yellow} `load()` proporcion√°ndole la ruta del fichero.

* Archivos `RData`: vamos a importar el archivo `world_bank_pop.RData` que incluye la tabla `world_bank_pop`


```{r}
load("./datos/world_bank_pop.RData")
world_bank_pop
```



* Archivos `.rda`: vamos a importar el dataset airquality desde `airquality.rda`

```{r}
load("./datos/airquality.rda")
airquality |> as_tibble()
```


Ten en cuenta que los archivos cargados con `load()` se cargan [**autom√°ticamente en el entorno**]{.hl-yellow} (con el nombre guardado originalmente), y no s√≥lo se pueden cargar conjuntos de datos: `load()` nos permite cargar m√∫ltiples objetos (no s√≥lo datos tabulares).

Los archivos nativos `.rda` y `.RData` son una forma adecuada de guardar el entorno.

```{r}
load(file = "./datos/multiple_objects.rda")
```



* Archivos `.rds`: para este tipo debemos utilizar `readRDS()`, y necesitamos incorporar un [**argumento `file`**]{.hl-yellow} con la ruta. En este caso vamos a importar [**datos de c√°ncer de pulm√≥n**]{.hl-purple} del North Central Cancer Treatment Group. Observe que ahora [**los archivos .rds incorporar solo una tabla, no un objeto en general**]{.hl-red}


```{r}
lung_cancer <-
  readRDS(file = "./datos/NCCTG_lung_cancer.rds") |>
  as_tibble()
lung_cancer
```


::: callout-important

## Importante

Las [**rutas**]{.hl-yellow deben ser siempre [**sin espacios, √±, ni acentos**]{.hl-yellow}. 


:::

### Datos tabulados: readr

El paquete `{readr}` dentro del entorno `{tidyverse}` contiene varias funciones √∫tiles para [**cargar datos rectangulares (sin formatear pero tabulados)**]{.hl-yellow}.


:::: columns
::: {.column width="50%"}

* `read_csv()`: archivos `.csv` [**variables separadas por comas**]{.hl-purple}
* `read_csv2()`: variables separadas por [**punto y coma**]{.hl-purple}
* `read_tsv()`: variables separadas por [**tabuladores**]{.hl-purple}.
* `read_table()`: variables separadas por [**espacios**]{.hl-purple}.
* `read_delim()`: funci√≥n generar con opci√≥n de [**especificar el delimitador**]{.hl-purple}.



![](img/data-import-readr.png)

Todos ellos necesitan como **argumento la ruta del fichero** m√°s **otros opcionales** (saltar cabecera o no, decimales, etc). Ver m√°s en <https://readr.tidyverse.org/>

#### Archivos .csv

La principal ventaja de `{readr}` es que [**automatiza el formato**]{.hl-yellow} para pasar de un fichero plano (sin formato) a un tibble (en filas y columnas, con formato).


* Archivo `.csv`: con `read_csv()` cargaremos archivos [**separados por comas**]{.hl-purple}, pasando como [**argumento la ruta**]{.hl-yellow} en `file = ...`. Vamos a importar el conjunto de datos `chickens.csv` (sobre pollos de dibujos animados, por qu√© no). Si nos fijamos en la salida nos da el tipo de variables.

```{r}
library(readr)
chickens <- read_csv(file = "./datos/chickens.csv")
chickens
```


El [**formato de la variable**]{.hl-yellow} se har√° normalmente [**autom√°ticamente**]{.hl-yellow} por `read_csv()`, y podemos consultarlo con `spec()`.


```{r}
spec(chickens)
```


Aunque normalmente lo hace bien autom√°ticamente podemos [**especificar el formato expl√≠citamente**]{.hl-yellow} en `col_types = lista()` (en formato lista, con `col_xxx()` para cada tipo de variable, por ejemplo `eggs_laid` se importar√° como car√°cter). 


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_types = list(col_character(), col_character(),
                            col_character(), col_character()))
chickens
```


Incluso podemos indicar que [**variables queremos seleccionar**]{.hl-yellow} (sin ocupar memoria), indic√°ndolo en `col_select = ...` (en formato lista, con `col_select = ...`).


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_select = c(chicken, sex, eggs_laid))
chickens
```

#### Archivos .txt, .tsv



¬øQu√© ocurre cuando el [**separador no es correcto**]{.hl-red}?


Si usamos `read_csv()` espera que el separador entre columnas sea una coma pero, como puedes ver con el siguiente `.txt`, lo interpreta todo como una sola columna: [**no tiene coma y no sabe d√≥nde separar**]{.hl-yellow}


```{r}
datos_txt <- read_csv(file = "./datos/massey-rating.txt")
dim(datos_txt)
as_tibble(datos_txt)
```

Para ello tenemos.

* `read_csv2()` cuando el [**separador es punto y coma**]{.hl-yellow}, `read_tsv()` cuando es un [**tabulador**]{.hl-yellow} y `read_table()` cuando es un  [**espacio**]{.hl-yellow}.

* `read_delim()` en general.

```{r}
datos_txt <- read_table(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```


### Datos Excel (.xls, .xlsx)

Otro paquete de importaci√≥n clave ser√° el paquete `{readxl}` para [**importar datos desde Excel**]{.hl-yellow}. Tres funciones ser√°n clave:

* `read_xls()` espec√≠fica para `.xls`, `read_xlsx()` espec√≠fica para `.xlsx`.
* `read_excel()`: tanto para `.xls` como para `.xlsx`.


Vamos a importar `deaths.xlsx` con los registros de defunciones de famosos.

```{r}
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths
```



```{r}
deaths |> slice(1:6)
```

[**Una desgracia muy com√∫n**]{.hl-red} es que haya alg√∫n tipo de comentario o texto al principio del fichero, teniendo que [**saltar esas filas**]{.hl-yellow}.


Podemos [**saltar estas filas**]{.hl-yellow} directamente en la carga con `skip = ...` (indicando el n√∫mero de filas a saltar).


```{r}
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths
```


Adem√°s con `col_names = ...` ya podemos renombrar las columnas en la importaci√≥n ([**proporcionar nombres supone 1¬™ l√≠nea ya como dato**]{.hl-yellow})


```{r}
#| code-line-numbers: "2-3"
deaths <-
  read_xlsx(path = "./datos/deaths.xlsx", skip = 5,
            col_names = c("nombre", "profesion", "edad", "hijos", "nacimiento", "muerte"))
deaths
```

A veces las  [**fechas de Excel tienen un formato incorrecto**]{.hl-red} (sorpresa): podemos utilizar `convertToDate()` del paquete `{openxlsx}` para convertirlo.



```{r}
library(openxlsx)
deaths$muerte <- convertToDate(deaths$muerte)
deaths
```
   

Tambi√©n podemos [**cargar un Excel con varias hojas**]{.hl-yellow}: para [**indicar la hoja**]{.hl-yellow} (ya sea por su nombre o por su n√∫mero) utilizaremos el argumento `sheet = ...`.


```{r}
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars
```


Incluso podemos indicar el [**rango de celdas**]{.hl-yellow} a cargar con `range = ...`.

```{r}
iris <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "iris", range = "C1:E4")
iris
```

### Importar desde SAS/STATA/SPSS

El paquete `{haven}` dentro del universo tidyverse nos permitir√° [**importar ficheros de los 3 software de pago m√°s importantes**]{.hl-yellow}: SAS, SPSS y Stata.


```{r}
library(haven)

# SAS
iris_sas <- read_sas(data_file = "./datos/iris.sas7bdat")

# SPSS
iris_spss <- read_sav(file = "./datos/iris.sav")

# Stata
iris_stata <- read_dta(file = "./datos/iris.dta")
```

### Exportar

De la misma forma que podemos importar tambi√©n podemos [**exportar**]{.hl-yellow}

* exportar en `.RData` (opci√≥n recomendada para variables almacenadas en `R`). Recuerda que esta extensi√≥n [**s√≥lo se puede utilizar en `R`**]{.hl-yellow}. Para ello, basta con utilizar `save(object, file = path)`.

```{r}
table <- tibble("a" = 1:4, "b" = 1:4)
save(table, file = "./datos/table.RData")
rm(table) # eliminar
load("./datos/table.RData")
table
```


La ventaja de `.RData` es que podemos [**exportar m√∫ltiples variables de nuestro environment**]{.hl-yellow}, no solo un √∫nico dataset.

```{r}
table <- tibble("a" = 1:4, "b" = 1:4)
a <- 1
b <- c("javi", "sandra")
save(table, a, b, file = "./datos/mult_obj.RData")
rm(list = c("a", "b", "table"))
load("./datos/mult_obj.RData")
table
```


* [**exportado en `.csv`**]{.hl-yellow}. Para ello simplemente utilizamos `write_csv(object, file = path)`, y es el m√°s recomendable para exportar bases de datos de tama√±o peque√±o o mediano. Ver <https://arrow.apache.org/docs/r/> para bases de datos masivas.

```{r}
write_csv(table, file = "./datos/table.csv")
read_csv(file = "./datos/table.csv")
```

### Importar desde web

Una de las principales ventajas de `R` es que podemos hacer uso de todas las funciones anteriores de [**importar pero directamente desde una web**]{.hl-yellow}, sin necesidad de realizar la descarga manual: en lugar de pasarle la ruta local le indicaremos el [**enlace**]{.hl-yellow}. Por ejemplo, vamos a descargar los datos covid del ISCIII (<https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>)

```{r}
#| eval: false
covid_data <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
covid_data
```

```{r}
#| echo: false
covid_data <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv", n_max = 500)
covid_data
```

### Importar desde wikipedia

El paquete `{rvest}`, uno de los m√°s √∫tiles de `{tidyverse}` nos permite [**importar (scrappear) directamente desde un `html`**]{.hl-yellow}. Por ejemplo, para exportar tablas de wikipedia basta con `read_html()` para importar el html, `html_element(¬´table¬ª)` para extraer los objetos tabla, y `html_table()` para convertir la tabla html a `tibble`.


```{r}
library(rvest)
wiki_jump <- 'https://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression'
wiki_jump |> read_html() |> 
  html_element("table") |> 
  html_table()
```

### Importar desde google drive

Otra opci√≥n disponible (especialmente si trabajamos con otras personas trabajando) es [**importar desde una hoja de c√°lculo de Google Drive**]{.hl-yellow}, haciendo uso de `read_sheet()` del paquete `{googlesheets4}`.

La primera vez se te pedir√° un permiso tidyverse para interactuar con tu drive


```{r}
library(googlesheets4)
google_sheet <-
  read_sheet("https://docs.google.com/spreadsheets/d/1Uz38nHjl3bmftxDpcXj--DYyPo1I39NHVf-xjeg1_wI/edit?usp=sharing")
google_sheet
```

### Importar desde API

#### owid

Otra opci√≥n interesante es la [**descarga de datos desde una API**]{.hl-yellow}: un intermediario entre una app o proveedor de datos y nuestro `R`. Por ejemplo, carguemos la librer√≠a `{owidR}`, que nos permite descargar datos de la web <https://ourworldindata.org/>. Por ejemplo, la funci√≥n `owid_covid()` carga sin darnos cuenta m√°s de 400 000 registros con m√°s de 60 variables de 238 pa√≠ses.


```{r}
#| eval: false
library(owidR)
owid_covid() |> as_tibble()
```

```{r}
#| echo: false
library(owidR)
owid_covid() |> as_tibble() |> slice(1:7)
```

#### aemet

En muchas ocasiones para conectarnos a la API primero tendremos que [**registrarnos y obtener una clave**]{.hl-yellow}, este es el caso del paquete `{climaemet}` para acceder a [**datos meteorol√≥gicos de Espa√±a**]{.hl-yellow} (<https://opendata.aemet.es/centrodedescargas/inicio>).


Una vez tengamos la clave API la registramos en nuestro RStudio para poder utilizarla en el futuro.

```{r}
#| eval: false
library(climaemet)

# Api key
apikey <- "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqYXZhbHYwOUB1Y20uZXMiLCJqdGkiOiI4YTU1ODUxMS01MTE3LTQ4MTYtYmM4OS1hYmVkNDhiODBkYzkiLCJpc3MiOiJBRU1FVCIsImlhdCI6MTY2NjQ2OTcxNSwidXNlcklkIjoiOGE1NTg1MTEtNTExNy00ODE2LWJjODktYWJlZDQ4YjgwZGM5Iiwicm9sZSI6IiJ9.HEMR77lZy2ASjmOxJa8ppx2J8Za1IViurMX3p1reVBU"

aemet_api_key(apikey, install = TRUE)
```


```{r}
#| echo: false
library(climaemet)
```


Con este paquete podemos hacer una [**b√∫squeda de estaciones**]{.hl-yellow} para conocer tanto su c√≥digo postal como su c√≥digo identificador dentro de la red AEMET

```{r}
stations <- aemet_stations()
stations
```

Por ejemplo, para obtener datos de la estaci√≥n del aeropuerto de El Prat, Barcelona, el c√≥digo a proporcionar es `¬´0076¬ª`, obteniendo **datos horarios**.

```{r}
aemet_last_obs("0076")
```

#### US census

Una de las herramientas m√°s √∫tiles de los √∫ltimos a√±os es la conocida como `{tidycensus}`: una herramienta para [**facilitar el proceso de descarga de datos censales**]{.hl-yellow} de Estados Unidos desde `R`

```{r}
library(tidycensus)
```

* `get_decennial()`: para acceder a los [**datos de censos (US Decennial Census)**]{.hl-yellow}, se hacen cada 10 a√±os (a√±os 2000, 2010 y 2020).

* `get_acs()`: para acceder a los [**datos anuales y quinquenales (5 a√±os)  de la ACS (American Community Survey)**]{.hl-yellow} (censo != encuesta)

* `get_estimates()`: para acceder a las [**estimaciones anuales de poblaci√≥n, natalidad y mortalidad**]{.hl-yellow}

* `get_pums()`: para acceder a los [**microdatos (datos sin agregar) de la ACS (anonimizados a nivel individual)**]{.hl-yellow}

* `get_flows()`: para acceder a los datos de [**flujo de migraciones**]{.hl-yellow}


Por ejemplo vamos a descargarnos los **datos censales** (`get_decennial()`) a nivel estado (`geography = "state"`) de la poblaci√≥n (variable `variables = "P001001"`) para el a√±o 2010 (ver variables en `tidycensus::load_variables()`)

```{r}
total_population_10 <-
  get_decennial(geography = "state", 
  variables = "P001001",
  year = 2010)
total_population_10
```

#### otras

Otras opciones

* `{chessR}`: datos de partidas de ajedrez de las plataformas chess.com y lychess. Ver m√°s en <https://github.com/JaseZiv/chessR>

* `{spotifyr}`: datos de canciones de Spotify. Ver m√°s en <https://www.rcharlie.com/spotifyr/>

* `{gtrendsR}`: datos de Google Trends. Ver m√°s en <https://github.com/PMassicotte/gtrendsR>

* `{scholar}`: datos de Google Scholar. Ver m√°s en <https://github.com/jkeirstead/scholar>


### üíª Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù El conjunto de datos `who2` del paquete `{tidyr}` que hemos utilizado en ejercicios anteriores, exp√≥rtalo a un formato nativo `R` en la carpeta `datos` de tu proyecto de RStudio

```{r}
#| code-fold: true
#| eval: false
library(tidyr)
save(who2, file = "./datos/who2.RData")
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Carga el conjunto de datos `who2` pero desde la carpeta data (importa el fichero creado en el ejercicio anterior)


```{r}
#| code-fold: true
#| eval: false
load("./datos/who2.RData")
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Repite lo mismo (exportar e importar) en 4 formatos: `.csv`, `.xlsx`, `.sav` (spss) y `.dta` (stata)

```{r}
#| code-fold: true
#| eval: false

# csv
library(readr)
write_csv(who2, file = "./datos/who2.csv")
who2_data <- read_csv(file = "./datos/who2.csv")

# excel
library(openxlsx)
write.xlsx(who2, file = "./datos/who2.xlsx")
who2_data <- read_xlsx(path = "./datos/who2.xlsx")

# sas y stata
library(haven)
write_sav(who2, path = "./datos/who2.sav")
who2_data <- read_spss(path = "./datos/who2.sav")

write_dta(who2, path = "./datos/who2.dta")
who2_data <- read_dta(path = "./datos/who2.dta")
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Repita la carga de `who2.csv` pero seleccione s√≥lo las 4 primeras columnas ya cargadas.

```{r}
#| code-fold: true
#| eval: false
who_select <-
  read_csv(file = "./datos/who2.csv",
           col_select = c("country", "iso2", "iso3", "year"))
who_select
```


:::


## üê£ Caso pr√°ctico III: encuesta CIS

[üìä Datos](https://drive.google.com/drive/folders/1HV3kAAHr4iWKvH5spsKWUwAdzWSBS8pw?usp=sharing)

Vamos a poner en pr√°ctica la carga y preprocesado de un fichero generado por uno de los programas inform√°ticos m√°s utilizados (SPSS). El fichero contiene [**datos del bar√≥metro del CIS (Centro de Investigaciones Sociol√≥gicas) ¬´Percepciones sobre igualdad entre hombres y mujeres y estereotipos de g√©nero¬ª**]{.hl-yellow} cuyo trabajo muestral se realiz√≥ del 6 al 14 de noviembre (4000 entrevistas a mayores de 16 a√±os de ambos sexos en 1174 municipios y 50 provincias).

### Pregunta 1

> Carga el archivo de extensi√≥n `.sav` que tienes en la subcarpeta `CIS-feminismo` dentro de la carpeta de datos. Tras la carga normaliza los nombres de las variables con el paquete `{janitor}`.

```{r}
#| code-fold: true
library(haven)
data <-
  read_sav(file = "./datos/CIS-feminismo/3428.sav") |> 
  janitor::clean_names()
```

### Pregunta 2

> Usando tidyverse calcula la cantidad de elementos diferentes de cada variable y procede a eliminar aquellas cuyo valor sea constante (es decir solo haya una modalidad). Primero obt√©n el vector de nombres de dichas variables para luego poder usarlo en un `select()` (de manera que no dependa de los nombres de variables de la tabla)

```{r}
#| code-fold: true
rm_variables <-
  data |> 
  summarise(across(everything(), n_distinct)) |> 
  pivot_longer(cols = everything(), names_to = "variable", values_to = "n_values") |> 
  filter(n_values <= 1) |> 
  pull(variable)
data <-
  data |> 
  select(-rm_variables)
```

### Pregunta 3

> Haz lo mismo pero para eliminar aquellas variables que en cada fila tomen un valor distinto (no haya ni un solo repetido). Estas columnas har√°n funciones de `id` del encuestado pero solo necesitamos una de ellas, elimina las dem√°s.

```{r}
#| code-fold: true
rm_variables <-
  data |> 
  summarise(across(everything(), n_distinct)) |> 
  pivot_longer(cols = everything(), names_to = "variable", values_to = "n_values") |> 
  filter(n_values == nrow(data)) |> 
  pull(variable)
data <-
  data |> 
  select(-rm_variables[-1])
```

### Pregunta 4

> Para entender qu√© significan las variables, tienes en la carpeta `CIS-feminismos` el cuestionario que se hizo a cada encuestada en `cues3428.pdf` y la ficha t√©cnica en `FT3428.pdf`. En estos documentos ver√°s c√≥mo, por ejemplo, las variables del cuestionario comienzan casi todas por `p...`, aunque tambi√©n tenemos otro tipo de variables relacionadas con las tareas del hogar (`tarhog...`), los hijos (`hijomenor...`), el cuidado de los ni√±os (`cuidadohijos...`), las tareas de cuidado en general (`tareascuid...`) y otras variables relacionadas con la escala ideol√≥gica, la religi√≥n, el recuerdo de voto, etc. Adem√°s, todas las variables que comienzan por `ia_xxx` se refieren a c√≥digos relativos a posibles incidencias en la recogida de datos y las variables `peso...` al tipo de ponderaci√≥n utilizado en el muestreo. Proceda a eliminar estos dos √∫ltimos tipos de variables.

```{r}
#| code-fold: true
data <-
  data |> 
  select(-contains("ia_"), -contains("peso"))
```

### Pregunta 5

> Calcula el n√∫mero de entrevistas por comunidad aut√≥noma (`ccaa`) y extrae las 5 con menos entrevistas.

```{r}
#| code-fold: true
#| eval: false
data |>
  count(ccaa, sort = TRUE)

data |>
  count(ccaa) |> 
  slice_min(n = 5, n)
```


### Pregunta 6

> Usa el paquete `{datapasta}` para copiar de la  [p√°gina del INE](https://www.ine.es/jaxiT3/Datos.htm?t=2853) la poblaci√≥n de cada provincia e importarlo a un tibble

```{r}
#| code-fold: true
# este c√≥digo deber√≠a generarse autom√°ticamente: cuando instalas el
# paquete se instala un addin en R Studio (parte superior) que te
# permite ctrl+c una tabla y diferentes opciones para importarla
population <- 
  tibble::tribble(~Total, ~`47.385.107`,
                    "01 Andaluc√≠a",   "8.472.407",
                       "02 Arag√≥n",   "1.326.261",
      "03 Asturias, Principado de",   "1.011.792",
               "04 Balears, Illes",   "1.173.008",
                     "05 Canarias",   "2.172.944",
                    "06 Cantabria",     "584.507",
              "07 Castilla y Le√≥n",   "2.383.139",
         "08 Castilla - La Mancha",   "2.049.562",
                     "09 Catalu√±a",   "7.763.362",
         "10 Comunitat Valenciana",   "5.058.138",
                  "11 Extremadura",   "1.059.501",
                      "12 Galicia",   "2.695.645",
         "13 Madrid, Comunidad de",   "6.751.251",
            "14 Murcia, Regi√≥n de",   "1.518.486",
  "15 Navarra, Comunidad Foral de",     "661.537",
                   "16 Pa√≠s Vasco",   "2.213.993",
                    "17 Rioja, La",     "319.796",
                        "18 Ceuta",      "83.517",
                      "19 Melilla",      "86.261"
  )
```

### Pregunta 7

> Renombra de manera adecuada las variables de `population`, convierte la poblaci√≥n a variable num√©rica y separa la variable de la comunidad aut√≥noma en 2, una para el c√≥digo y otro para el nomnbre (procesa ete √∫ltimo de manera adecuada con el paquete `{stringr}` para eliminar espacios en blanco).

```{r}
#| code-fold: true
population <-
  population |> 
  rename(ccaa = Total, pop = `47.385.107`) |> 
  mutate("pop" = as.numeric(str_replace_all(pop, "\\.", ""))) |> 
  separate(col = ccaa, into = c("cod_INE", "name"), sep = 2) |> 
  mutate(name = str_squish(name))
```

### Pregunta 8

> Incorpora la informaci√≥n de la poblaci√≥n a nuestra tabla del CIS. Tras incorporar dicha informaci√≥n calcula una tabla resumen con el ratio entre el porcentaje de poblaci√≥n que representa cada ccaa respecto al total de Espa√±a y el porcentaje de encuestados de dicha comunidad respecto al total de encuestados. ¬øCu√°les son las 3 provincias m√°s sobrerepresentadas? ¬øY las 3 m√°s infrarrepresentads? 

```{r}
#| code-fold: true
#| eval: false
data <-
  data |> 
  left_join(population |> mutate("cod_INE" = as.numeric(cod_INE)),
            by = c("ccaa" = "cod_INE")) |> 
  relocate(name, pop, .after = "ccaa")

prop_surv_pop <-
  data |>
  summarise("prop_surv" = n() / sum(nrow(data)),
            "pop" = unique(pop),
            .by = ccaa) |> 
  mutate("prop_pop" = pop / sum(pop),
         "ratio" = prop_pop / prop_surv)

# sobre
prop_surv_pop |> 
  slice_min(ratio, n = 3)

# infra
prop_surv_pop |> 
  slice_max(ratio, n = 3)
```


## Listas

Ya hemos visto que las listas son un objeto en R que nos permite almacenar [**colecciones de variables de distinto tipo**]{.hl-yellow} (como con `data.frame` y `tibble`) pero tambi√©n [**diferentes longitudes**]{.hl-purple}, con estructuras totalmente heterog√©neas (incluso una lista puede tener dentro otra lista).

```{r}
nombre <- "Javi"
edad <- 34
notas <- c(7, 8, 5, 3, 10, 9)
progenitores <- c("Paloma", "Goyo")

# Podemos no ponerle nombre pero solo podremos acceder por √≠ndice
list_var <- list("nombre" = nombre, "edad" = edad,
                 "notas" = notas, "parents" = progenitores)
```


```{r}
list_var$nombre
list_var$progenitores
```



---

## Listas


Tambi√©n podemos hacer [**listas con otras listas dentro**]{.hl-yellow}, de forma que para acceder a cada nivel debamos utilizar el operador `[[]]`.

```{r}
list_of_lists <- list("list_1" = list_var[1:2], "list_2" = list_var[3:4])
names(list_of_lists)
```

```{r}
names(list_of_lists[[1]])
```

```{r}
list_of_lists[[1]][[1]]
```


¬°Se nos permite almacenar [**datos n-dimensionales**]{.hl-yellow}!


Sin embargo una de las desventajas es [**no puede ser vectorizada**]{.hl-yellow} inmediatamente, por lo que cualquier operaci√≥n aritm√©tica aplicada a una lista dar√° [**error**]{.hl-red}. Por ejemplo, en el c√≥digo anterior, uno esperar√≠a que hiciese la operaci√≥n en cada elemento de la lista (en `a` y en `b`) pero no funciona.

```{r}
#| error: true
data <- list("a" = 1:5, "b" = 10:20)
data / 2
```


Para ello una de las opciones habituales (de `R` base) era hacer uso de la familia `lapply(lista, FUN = ...)`: aplica una funci√≥n `FUN = ...` a cada elemento de la lista

```{r}
lapply(data, FUN = function(x) { x / 2})
```

Pero por defecto la salida de `lapply()` es siempre una [**lista de igual longitud**]{.hl-yellow}.


### Paquete purrr


Una opci√≥n m√°s flexible y vers√°til es hacer uso del paquete `{purrr}` del entorno `{tidyverse}`.

```{r}
library(purrr)
```

Este paquete pretende imitar la [**programaci√≥n funcional**]{.hl-yellow} de otros lenguajes como Scala o la [**estrategia map-reduce**]{.hl-yellow} de Hadoop (de Google).

![](img/purrr.png)

#### map()

La funci√≥n m√°s sencilla del paquete `{purrr}` es la funci√≥n `map()`, que [**aplica una funci√≥n vectorizada**]{.hl-yellow} a cada uno de los elementos de una lista. Veamos un primer ejemplo aplicado a vectores: imagina que tenemos la siguiente lista y queremos aplicar, a cada uno de sus elementos, la suma.

```{r}
x <- list("x1" = 1:4, "x2" = 11:20)
```


`map(lista, funci√≥n)` nos permite [**mapear la lista**]{.hl-yellow} y aplicar la funci√≥n que queramos elemento a elemento


```{r}
map(x, sum) 
```


![](img/map_purrr.png)

::: callout-warning
## Ten cuidado...

La [**salida por defecto de `map` es a su vez otra lista**]{.hl-yellow}.
:::


Veamos otro ejemplo que puedes sernos √∫til: imagina que tenemos [**dos muestras aleatorias de distinto tama√±o**]{.hl-yellow}. La √∫nica forma en la que podemos almacenarlas juntas es con una lista pero...¬øc√≥mo hacer la media a ambas distribuciones sino podemos vectorizarlas?


```{r}
x <- list(rnorm(n = 1500, mean = 0, sd = 0.7),
          rnorm(n = 2800, mean = 2, sd = 1.5))
```


Con `map()` y la funci√≥n `mean()` dentro

```{r}
map(x, mean)
```



¬øY si quisi√©ramos calcular la media de sus valores al cuadrado? En este caso [**no disponemos de una funci√≥n ya definida**]{.hl-red} as√≠ que tenemos dos opciones: definirla antes (con un nombre) o bien [**definir la funci√≥n dentro del propio map**]{.hl-yellow}

```{r}
map(x, function(x) { mean(x^2) })
```



Una forma de [**definir la funci√≥n m√°s r√°pido**]{.hl-yellow} es as√≠:

```{r}
map(x, \(x) mean(x^2))
```


#### map_xxx()

Adem√°s de ser [**m√°s legible y eficiente**]{.hl-yellow}, con `{purrr}` podemos [**decidir el formato de salida**]{.hl-yellow} tras la operaci√≥n

* salida como un [**vector num√©rico (decimales)**]{.hl-purple} con `map_dbl()`
* salida como un [**vector num√©rico (enteros)**]{.hl-purple} con `map_int()`
* salida como un [**vector de caracteres**]{.hl-purple} con  `map_chr()`
* salida como un [**vector num√©rico l√≥gico**]{.hl-purple} con  `map_lgl()`

```{r}
library(glue)
map_dbl(x, mean)
map_chr(x, function(x) { glue("Mean is {round(mean(x), 3)}") })
map_lgl(x, function(x) { all(x < 3)})
```


Tambi√©n puede sernos √∫til para [**acceder a un elemento de CADA lista**]{.hl-yellow} si le pasas un [**n√∫mero**]{.hl-yellow} en lugar de una funci√≥n.

```{r}
c(x[[1]][3], x[[2]][3])
map_dbl(x, 3)
```

#### pluck()

Tambi√©n podemos hacer uso de `pluck()` para [**acceder al i-th objeto de la lista**]{.hl-yellow}.

```{r}
lista <- list("a" = starwars, "b" = billboard)
lista |> pluck(1)
```


#### map2()

Tambi√©n tenemos la opci√≥n de **generalizarlo** para poder utilizar funciones que [**necesiten dos argumentos**]{.hl-yellow} (operaciones binarias) con `map2()`. Por ejemplo, supongamos que tenemos las siguientes dos listas, y queremos que suma el vector del primer elemento de ambas entre s√≠, y lo mismo con el segundo

```{r}
x <- list("a" = 1:3, "b" = 4:6)
y <- list("a" = c(-1, 4, 0), "b" = c(5, -4, -1))
x$a + y$a
x$b + x$b
```


En `map2()` introducimos las 2 listas y una **funci√≥n con 2 argumentos**

```{r}
map2(x, y, function(x, y) { x + y})
```



Podemos tambi√©n obtener la salida en forma de `data.frame` a√±adiendo `list_rbind()` o `list_cbind()`, que [**convierte una lista en una tabla**]{.hl-yellow}.

```{r}
x <- c("a", "b")
y <- 1:2
map2(x, y, function(x, y) { tibble(x, y) })
map2(x, y, function(x, y) { tibble(x, y) }) |> list_rbind()
```

#### pmap()

Podemos generalizarlo a√∫n m√°s con `pmap_xxx()` que nos permite utilizar [**m√∫ltiples argumentos (m√∫ltiples listas para funci√≥nes multivariantes)**]{.hl-amarillo}.

```{r}
x <- list(1, 1, 1)
y <- list(10, 20, 30)
z <- list(100, 200, 300)
pmap_dbl(list(x, y, z), sum)
```

#### walk()

Tenemos otros tipos de iteradores que, aunque asumen entradas, no devuelven nada, como `walk()` (s√≥lo un argumento de entrada), `walk2()` (dos argumentos) y `pwalk()` (m√∫ltiples argumentos), todos [**devuelven algo invisible**]{.hl-yellow}, s√≥lo llaman a una funci√≥n por sus [**efectos secundarios**]{.hl-yellow} en lugar de por su valor de retorno.

```{r}
list("a" = 1:3, "b" = 4:6) |>
  map2(list("a" = 11:13, "b" = 14:16),
       function(x, y) { x + y }) |> 
  walk(print)
```



### üíª  Tu turno


::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Define una lista de 4 elementos de distintos tipos y accede al segundo de ellos (incluir√© uno que sea un tibble para que veas que en una lista cabe de todo).

```{r}
#| code-fold: true
#| eval: false
list_example <-
  list("name" = "Javier", "cp" = 28019,
       "siblings" = TRUE,
       "marks" = tibble("maths" = c(7.5, 8, 9),
                        "lang" = c(10, 5, 6)))
list_example
```

### [**Ejercicio 2**]{.hl-yellow}

üìù From the list above, access the elements that occupy places 1 and 4 of the list defined above.

```{r}
#| code-fold: true
#| eval: false

list_example[c(1, 4)]

list_example$name
list_example$marks

list_example[c("name", "marks")]
```



### [**Ejercicio 3**]{.hl-yellow}

üìù  Load the `starwars` dataset from the `{dplyr}` package and access the second movie that appears in `starwars$films` (for each character). Determine which ones do not appear in more than one movie.

```{r}
second_film <- map(starwars$films, 2)
map_lgl(second_film, is.null)
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Convierte a tibble la base de datos `iris` incluida en `R base` (no necesitas ning√∫n paquete, ya la tienes). Vamos a agrupar por species para despu√©s usar `group_split()`: nos genera una lista tal que cada elemento es la tabla para cada uno de los grupos (como un filter de cada grupo pero en un mismo objeto).

```{r}
iris_list <-
  iris |> as_tibble() |>
  group_by(Species) |> 
  group_split()
```

Accede a cada variable  `Sepal.Length` para cada una de las subtablas y haz la media (nos tendr√≠a que salir un vector de medias)

```{r}
#| code-fold: true
#| eval: false
iris_list |> 
  map("Sepal.Length") |> 
  map_dbl(mean)
```


:::


## üê£ Caso pr√°ctico IV: encuesta de satisfacci√≥n


Para este ejercicio usaremos la tabla de datos de satisfacci√≥n de pacientes en un hospital guardada en el archivo `.csv` llamada `SatisfaccionPacientes.csv`


```{r}
library(tidyverse)
datos <-
  read_csv("./datos/SatisfaccionPacientes.csv") |> 
  # normalizaci√≥n de nombres de variables
  janitor::clean_names()
datos
```

### Pregunta 1

> Aplica el c√≥digo que sea necesario para determinar el tama√±o muestral, el n√∫mero de variables y el tipo de estas.

```{r}
#| code-fold: true

# Tama√±o muestral / n√∫mero de observaciones
n <- datos |> nrow()

# N√∫mero de variables
p <- datos |> ncol()

# Tipo de variables
dplyr::glimpse(datos)
```


### Pregunta 2

> Usando tidyverse, obt√©n la tabla de frecuencias absolutas de la variable `genero`.

```{r}
#| code-fold: true
tabla_freq <-
  datos |> 
  count(genero)
```

### Pregunta 3

>  Incorpora a la tabla anterior las frecuencias relativas. ¬øPodr√≠amos calcular las frecuencias acumuladas? ¬øPor qu√©?

```{r}
#| code-fold: true
tabla_freq <-
  tabla_freq |> 
  rename(frecuencia_abs = n) |> 
  mutate(frecuencia_rel = frecuencia_abs/sum(frecuencia_abs))

# No podemos acumuladas ya que necesitamos una jerarqu√≠a de orden
# son cualis nominales, no ordinales
```

Haciendo uso de la tabla, **¬øqu√© % de pacientes son mujeres?**

Haz lo mismo tu solo con la variable `estado_civil` y determina el n√∫mero de personas casadas (deber√≠an ser 26).

### Pregunta 4

En `R` las [**variables cualitativas pueden ser tratadas como tales**]{.hl-yellow} convirtiendo una cadena de texto a lo que se conoce como [**factor**]{.hl-yellow}. Por ejemplo, supongamos que tenemos un vector de notas

```{r}
notas <- c("suspenso", "notable", "suspenso", "aprobado", "notable", "suspenso")
notas
```


Para [**convertir a factor nos basta con `factor()`**]{.hl-yellow}. ¬øQu√© notas diferente?

```{r}
notas_fct <- factor(notas)
notas_fct
```


Si te fijas ahora [**tenemos disponibles unos niveles (levels)**]{.hl-yellow}: son las posibles modalidades de nuestra variable cualitativa, el soporte, de manera que aunque borremos uno de ellos (vamos a borrar todos los aprobados), la opci√≥n sigue disponible si entrase un dato nuevo (algo as√≠ como un men√∫ de opciones permitidas)

```{r}
notas_fct[notas_fct != "aprobado"]
```



En el caso de las [**cualitativas ordinales podemos incluso establecer una jerarqu√≠a**]{.hl-yellow}, indicando expl√≠citamente los niveles y `ordered = TRUE`

```{r}
notas_fct_ord <- factor(notas, levels = c("aprobado", "notable", "suspenso"),
                        ordered = TRUE)
notas_fct_ord
```

F√≠jate que ahora tenemos una [**jerarqu√≠a**]{.hl-yellow} y aunque sea cualitativa podemos buscar [**elementos <= o >= que otros**]{.hl-yellow}

```{r}
notas_fct_ord[notas_fct_ord <= "notable"]
```

> Haz que tu variable `estado_salud` sea una factor representando una cualitativa ordinal

```{r}
#| code-fold: true
datos <-
  datos |>
  mutate(estado_salud =
           factor(estado_salud, levels = c("Malo", "Regular", "Bueno", "Excelente"),
                  ordered = TRUE))

```

### Pregunta 5

> Calcula la tabla de frecuencias para `estado_salud` incluyendo todo lo que puedas (¬øse puede ahora calcular las frecuencias acumuladas). ¬øCu√°ntos pacientes est√°n en un estado de salud regular o peor? (pisa: 59 personas).

```{r}
#| code-fold: true
#| eval: false
tabla_freq <- 
  datos |> 
  count(estado_salud) |> 
  rename(frecuencia_abs = n) |> 
  mutate(frecuencia_rel = frecuencia_abs/sum(frecuencia_abs),
         frecuencia_acum_abs = cumsum(frecuencia_abs),
         frecuencia_acum_rel = cumsum(frecuencia_rel))

datos |>
  count(estado_salud <= "Regular")
```


### Pregunta 6

> Calcula la media, mediana, cuartiles y desviaci√≥n t√≠pica de edad y tiempo de espera. Guarda los resultados en `resumen` y exp√≥rtalo a un `resumen.csv`

```{r}
#| code-fold: true
resumen <-
  datos |>
  summarise(media_edad = mean(edad), sd_edad = sd(edad),
            mediana_edad = median(edad),
            Q1_edad = quantile(edad, probs = 0.25),
            Q3_edad = quantile(edad, probs = 0.75),
            # tiempo espera
            media_tiempo_espera = mean(tiempo_espera), 
            sd_tiempo_espera = sd(tiempo_espera),
            mediana_tiempo_espera = median(tiempo_espera),
            Q1_tiempo_espera = quantile(tiempo_espera, probs = 0.25),
            Q3_tiempo_espera = quantile(tiempo_espera, probs = 0.75))
write_csv(resumen, file = "./datos/resumen.csv")
```


### Pregunta 7

> Haz una tabla de frecuencias (absolutas) cruzada entre `genero` y `estado_salud` con tidyverse para que quede como la tabla inferior

```{r}
#| code-fold: true

# Primero cuento de manera bidimensional con count(var1, var2)
conteo_bidim <-
  datos |>
  count(genero, estado_salud)
conteo_bidim
```

### Pregunta 8

> Haciendo uso de la tabla anterior, ¬øqu√© debes hacer para obtener una tabla de frecuencias bidimensional como la de abajo? (la tabla de frecuencias en formato habitual)


```{r}
#| code-fold: true
# Despu√©s pivoto para que use la columna estado_salud
# como futuros nombres de variables (pivota de vertical a horizontal)
#   - names_from: de donde saldr√°n los futuros nombres de columnas
#   - values_from: de donde sacamos los valores num√©ricos (en este caso n)
#     para rellenar la tabla
tabla_freq_abs <-
  conteo_bidim |> pivot_wider(names_from = estado_salud, values_from = n)
tabla_freq_abs
```


### Pregunta 9


Tambi√©n se puede hacer en `R base` con `table()` (que adem√°s de ser m√°s sencillo respeta la jerarqu√≠a de la ordinal). [**Moraleja: a veces R base nos facilita la vida, no lo olvidemos porque lo vas a necesitar**]{.hl-yellow }

```{r}
tabla_freq <- table(datos$genero, datos$estado_salud)
tabla_freq
```

La tabla anterior se puede [**calcular con frecuencias relativa por filas y por columnas**]{.hl-yellow} (es decir,una que toda las filas sumen el total, 1, y otra que las columnas sumen 1) haciendo uso de `prop.table()` aplicada a la tabla anterior (si `margin = 1` normaliza por filas, si `margin = 2` por columnas).

```{r}
#| code-fold: true
prop.table(tabla_freq, margin = 1)
prop.table(tabla_freq, margin = 2)
```

[**Moraleja: tablas de frecuencia podemos hacerlas en tidyverse pero bidimensionales R base nos ayuda mejor. Deberemos viajar entre los dos mundos muchas veces**]{.hl-yellow}

> Haciendo uso de las tablas anteriores contesta a las siguientes preguntas:

* ¬øQu√© porcentaje de entre las mujeres tiene un buen estado de salud?

* ¬øQu√© porcentaje de entre los hombres tiene un estado de salud regular?

* ¬øQu√© porcentaje de los que tienen estado de salud malo son mujeres?

**Clicka debajo para ver la respuesta cuando lo tengas**

```{r}
#| code-fold: true

# De entre las mujeres un 45.28% tiene un buen estado de salud
# De entre los hombres un 34.04% tiene un estado de salud regular
# Un 33.33% de los que tienen un estado de salud malo, son mujeres
```

### Pregunta 10

**Un poquito de reminder de inferencia**. Haciendo uso de la tabla de frecuencias absolutas, ejecuta el c√≥digo que consideres para responder a la pregunta: ¬øest√°n estas dos variables (`estado_salud` y `genero`) asociadas? ¬øExiste alg√∫n tipo de dependencia entre ellas? Hazlo considerando $\alpha = 0.05$.

```{r}
#| code-fold: true
#| eval: false

# Opci√≥n 1: prueba de chi-cuadrado que nos permite sacar conclusiones
# sobre la independencia de dos variables cualitativas

# chisq.test() hace el contraste haciendo uso de la tabla de frec
chisq.test(tabla_freq)

# Como el p-value = 0.2322 y alpha = 5%, no podemos rechazar la
# hip√≥tesis nula de independencia: no hay evidencias suficientes 
# CON LA MUESTRA QUE TENEMOS para concluir que haya alguna asociaci√≥n
# entre g√©nero y estado de salud

# Opci√≥n 2: test exacto de Fisher, especialmente √∫til cuando
# las frecuencias esperadas son bajas.
fisher.test(tabla_freq)
# Diferente p-valor pero misma conclusi√≥n
```


Las funciones `chisq.test()` y `fisher.test()` pueden tomar como argumento una tabla de frecuencias ya resumida o puede tomar [**dos variables y la funci√≥n ya realiza el conteo**]{.hl-yellow. Por ejemplo si hacemos `chisq.test(var1, var2)` obtenemos un objeto `htest` que dentro contiene el p-valor.

```{r}
test_chisq <- chisq.test(datos$genero, datos$estado_salud)
names(test_chisq)
```


Por tanto si aplicamos la funci√≥n y hacemos despu√©s `$p.value` podemos obtener **directamente el valor num√©rico que nos interesa**

```{r}
chisq.test(datos$genero, datos$estado_salud)$p.value
```

### Pregunta 11

> ¬øC√≥mo usar tidyverse para tener en una tabla resumen ambos p-valores?

```{r}
#| code-fold: true
tabla_p_valores <-
  datos |> 
  summarise("sig_chisq" = chisq.test(genero, estado_salud)$p.value,
            "sig_fisher" = fisher.test(genero, estado_salud)$p.value)
```

### Pregunta 12

> C√°lcula la matriz correlaciones de Pearson entre las variables num√©ricas. ¬øExiste dependencia LINEAL entre la variable edad y el tiempo de espera? (recuerda: correlaci√≥n de Pearson solo mide asociaci√≥n lineal). Echa un vistazo al paquete `{corrr}`

```{r}
#| code-fold: true

# Opci√≥n 1
mat_cor <-
  datos |> 
  select(where(is.numeric)) |> 
  cor()

# Opci√≥n 2
mat_cor <-
  datos |> 
  select(where(is.numeric)) |> 
  corrr::correlate()

# La correlaci√≥n es de 0.0669 por lo que no parezca exista relaci√≥n
```

### Pregunta 13

>  Calcula en una tabla resumen la correlaci√≥n y el p-valor derivado de un test de correlaciones (`cor.test()`) entre ambas variables

```{r}
#| code-fold: true
cor_summary <-
  datos |> 
  summarise("cor" = cor(edad, tiempo_espera),
            "sig_cor" = cor.test(edad, tiempo_espera)$p.value)
# No parece existir evidencia significativa de dependencia lineal
```

### Pregunta 14

> Repite todo lo anterior con las variables tiempo de espera y grado de satisfacci√≥n

```{r}
#| code-fold: true
mat_cor <- 
  datos |> 
  select(where(is.numeric)) |> 
  corrr::correlate()

cor_summary <-
  datos |> 
  summarise("cor" = cor(grado_satisfaccion, tiempo_espera),
            "sig_cor" = cor.test(grado_satisfaccion, tiempo_espera)$p.value)
# S√≠ parece existir evidencia significativa de dependencia lineal
# concretamente negativa: a m√°s espera, menor satisfacci√≥n
```

