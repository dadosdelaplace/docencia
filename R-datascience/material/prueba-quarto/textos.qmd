---
title: "Tratamiento de textos. Primeras bases de datos"
subtitle: "Cuadernos pr√°cticos de Software II del Grado en Ciencia de Datos Aplicada (curso 2024-2025)"
author: "Javier √Ålvarez Li√©bana"
format:
  html:
    theme: [default, style.scss]
    toc: true
    toc-title: √çndice
    toc-depth: 5
    toc-location: left
    number-sections: true
embed-resources: true
execute: 
  echo: true
---

## Profundizando en textos

Aunque no podamos hacer operaciones aritm√©ticas con ellos si ser√°n importante algunas [**operaciones que podamos realizar con las cadenas de texto**]{.hl-yellow}. Para eso usaremos el paquete `{stringr}` (dentro del mismo ¬´universo de paquetes¬ª de `{lubridate}`)

```{r}
library(stringr)
```

Con dicho paquete vamos a trabajar particularmente con [**cuatro familias de funciones**]{.hl-yellow}

- [**Manipulaci√≥n**]{.hl-purple}

- [**Tratamiento de espacios**]{.hl-purple}

- [**B√∫squeda de patrones**]{.hl-purple}

### Utilidades b√°sicas

#### Longitud

La m√°s obvia es una funci√≥n que, dada una cadena de texto (un string) nos proporcione la [**longitud**]{.hl-yellow}. Para ello podemos usar la funci√≥n `str_length()`

```{r}
str_length("abc")
```

Es importante advertir que cuenta tanto [**n√∫meros como espacios**]{.hl-yellow}, as√≠ como caracteres que **no sean alfanum√©ricos**. 
```{r}
str_length("abc 123 *")
```

Adem√°s si el texto es ausente devuelve ausente (recuerda: `NA` es ausente, `"NA"` es una cadena de texto m√°s) 

```{r}
str_length(NA)
```

&nbsp;

Las [**funciones del paquete est√°n preparadas para ser vectorizadas**]{.hl-yellow} lo que significa que si aplicamos una funci√≥n a un vector de dos cadenas de texto la aplica a ambos de la misma forma.

```{r}
str_length(c("abc", "defghi"))
```

#### Ordenar

Otra muy habitual es [**ordenar cadenas de texto (por orden alfab√©tico)**]{.hl-yellow}. Para ello podemos usar la funci√≥n `str_order()`, distinguiendo `..._sort()` y `..._order()` como con los n√∫meros

```{r}
x <- c("y", "i", "k")
str_order(x)
str_sort(x)
```


### Manipulaci√≥n

#### Extraer subcadenas

* [**Extraer subcadenas**]{.hl-yellow}: dada una cadena de texto, `str_sub(texto, star = ..., end = ...)` nos extrae la subcadena desde la posici√≥n `star` hasta `end` (si es negativo empieza a contar por detr√°s).

```{r}
str_sub("abcd efg", star = 4, end = 6)
str_sub("abcd efg", star = 5)
str_sub("abcd efg", star = 4, end = -2)
```



* [**Extraer subcadenas**]{.hl-yellow}: la funci√≥n `str_sub()` permite aplicarlo a de manera vectorial a m√∫ltiples cadenas de texto, e incluso usarla para asignar valores.

```{r}
x <- c("abcdef", "ghifjk")
str_sub(x, star = 3, end = -2)
str_sub(x, star = -1, end = -1)

# En ambas cadenas, sustituimos por * en la posici√≥n 2
str_sub(x, star = 2, end = 2) <- "*"
```

#### Duplicar cadenas

* [**Duplicar cadenas**]{.hl-yellow}: con `str_dup(..., times = ...)`, dada una cadena de texto (o varias), podemos repetir una cadena `times` veces.

```{r}
str_dup("abc", times = 3)

x <- c("abcdef", "ghifjk")
str_dup(x, times = c(2, 5))
```

#### Concatenar cadenas

* [**Concatenar cadenas**]{.hl-yellow}: con `str_c` podemos concatenar distintas cadenas de texto (con `sep = ...` indicamos el caracter que har√° de separador)

```{r}
str_c("Buenos d√≠as", "Mi nombre es Javier")
str_c("Buenos d√≠as", "Mi nombre es Javier", sep = ". ")
```


#### May√∫sculas y min√∫sculas

* [**May√∫sculas/min√∫sculas**]{.hl-yellow}: con `str_to_...()` podemos convertir textos a may√∫sculas (`..._upper`), a min√∫sculas (`..._lower`) y a t√≠tulo (`..._title`, primera letra de cada palabra en may√∫scula)

```{r}
str_to_upper("me llamo Javi")
str_to_lower("me llamo Javi")
str_to_title("me llamo Javi")
```

#### Reemplazar

* [**Reemplazar**]{.hl-yellow}: `str_replace()` busca un patr√≥n dado en una cadena de texto y, si la encuentra, la sustituye pro otra de reemplazo

```{r}
str_replace(c("javi", "sandra", "carlos"), pattern = "i", replacement = "*")
```

. . .

Con `str_replace_all()` reemplazamos todas las coincidencias (por defecto sino solo se reemplaza la primera)

```{r}
str_replace(c("javi", "sandra", "carlos"), pattern = "a", replacement = "*")
str_replace_all(c("javi", "sandra", "carlos"), pattern = "a", replacement = "*")
```


### Espacios en blanco

#### Rellenar espacios

* [**Rellenar**]{.hl-yellow}: la funci√≥n `str_pad()` rellena una cadena con espacios (al inicio por defecto) para que tenga anchura indicada. Con `side = "both"` como argumento extra nos a√±ade en ambos lados. Con `side = "right"` los a√±ade al final. Con `pad = ...` podemos decidir si queremos rellenar con otro tipo de caracter (espacio por defecto).

```{r}
str_pad("abc", width = 6)
str_pad("abc", 12, side = "both")
str_pad("abc", 6, side = "right", pad = "*")
```

. . .

Si `width` es menor que la longitud de la cadena, no hace nada.

```{r}
str_pad("abc",  width = 2)
```

#### Eliminar espacios

* [**Eliminar espacios**]{.hl-yellow}: con `str_trim()` podemos eliminar espacios en blanco al inicio y al final de la cadena. Si a√±adimos `side = ...` podemos cambiar si queremos que solo los elimine al final o al inicio (por defecto, en ambos). Con `str_squish()` cambiamos cualquier sucesi√≥n de espacios en blanco en medio del texto por uno solo (y elimina al inicio y final)

```{r}
str_trim(" abcde   fghi ")
str_trim(" abcde   ")
str_trim(" abcde   ", side = "left")
str_squish(" abcde   fghi ")
```



### Patrones

#### Detectar. Expresiones regulares.

* [**Detectar**]{.hl-yellow}: con `str_detect()` podemos detectar si una cadena de texto contiene o no una secuencia de caracteres

```{r}
str_detect(c("javi √°lvarez", "javi reyes", "sandra reyes"), pattern = "javi")
str_detect(c("javi √°lvarez", "javi reyes", "sandra reyes"), pattern = "reyes")
str_detect(c("javi √°lvarez", "javi reyes", "sandra reyes"), pattern = "carlos")
```



* [**Expresiones regulares**]{.hl-yellow}: no solo vamos a poder detectar patrones simples sino que podemos hacer uso de las conocidas como **expresiones regulares**, indic√°ndole por ejemplo que queremos localizar todo patr√≥n que sea, al menos una letra

```{r}
str_detect(c("a", "ab", "abc", "abcd"), pattern = "[a-z]")
```

. . .

Si tras los corchetes indicamos `{n}` podemos detectar aquellas cadenas con n letras consecutivas

```{r}
str_detect(c("a", "ab", "abc", "abcd"), pattern = "[a-z]{3}")
```



* [**Expresiones regulares**]{.hl-yellow}: un buen manejo de estas expresiones puede sernos muy √∫til para, por ejemplo, detectar formatos correctos en DNI o n√∫meros de tel√©fono (de Madrid, por ejemplo).

Vamos a considerar que un formato correcto de DNI es aquel seguido por 8 n√∫meros (`[0-9]{8}`) seguido directamente de una letra may√∫scula (`[A-Z]`).

```{r}
str_detect(c("5055A198-W", "50508040W", "5050505W", "50508040-W"),
           pattern = "[0-9]{8}[A-Z]")
```

. . .

Podemos buscar distintos patrones a la vez concaten√°ndolos con una `|`

```{r}
str_detect(c("5055A198-W", "50508040W", "5050505W", "50508040-W"),
           pattern = "[0-9]{8}[A-Z]|[0-9]{8}[-][A-Z]")
```


#### Contar

* [**Contar patrones**]{.hl-yellow}: con `str_count()` podemos contar cuantas veces aparece un mismo patr√≥n

```{r}
str_count(c("abcd defg", "ab defg", "ab cd"), pattern = "[a-z]{4}")
```

#### Localizar posiciones

* [**Localizar posiciones**]{.hl-yellow}: `str_locate()` nos permite localizar la primera posici√≥n en la que se produce un patr√≥n. Con `str_locate_all()` obtenemos todos

```{r}
str_locate(c("abcde abcd", "cba", "*a*"), pattern = "a")
str_locate_all(c("abcde abcd", "cba", "*a*"), pattern = "a")
```


#### Extraer patrones

* [**Extraer patrones**]{.hl-yellow}: con `str_extract()` podemos extraer patrones (con `str_extract_all()` todos ellos) de una cadena de texto.

```{r}
str_extract(c("DNI: 5050W", "DNI: 50558040W, DNI: 50558080-W", "DNI: 50558080-W"),
            pattern = "[0-9]{8}[A-Z]|[0-9]{8}[-][A-Z]")
str_extract_all(c("DNI: 5050W", "DNI: 50558040W, DNI: 50558080-W", "DNI: 50558080-W"),
            pattern = "[0-9]{8}[A-Z]|[0-9]{8}[-][A-Z]")
```

#### Dividir cadenas

* [**Dividir**]{.hl-yellow}: con `str_split()` podemos localizar un patr√≥n y dividir la cadena de texto siempre que aparezca (con `str_split_fixed()` podemos dividir en un n√∫mero concreto de trozos)

```{r}
str_split(c("a-b-c", "ab-c-d-e"), pattern = "-")
str_split_fixed(c("a-b-c", "ab-c-d-e"), pattern = "-", n = 2)
```
. . .

Si usamos `boundary()` como patr√≥n podemos dividir en base a caracteres, frases, palabras, etc.

```{r}
x <- "Esto es una frase. Y esto otra."
str_split(x, boundary("word"))
str_split(x, boundary("sentence"))
```



### üíª Ejercicios

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Define una variable que guarde tu edad (llamada `edad`) y otra con tu nombre (llamada `nombre`)

```{r}
#| code-fold: true
edad <- 33
nombre <- "Javi"
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Comprueba con dicha variable `edad` si NO tiene 60 a√±os o si se llama `"Ornitorrinco"` (debes obtener variables l√≥gicas como resultado)

```{r}
#| code-fold: true
#| eval: false
edad != 60 # distinto de
nombre == "Ornitorrinco" # igual a
```

### [**Ejercicio 3**]{.hl-yellow}

üìù ¬øPor qu√© el c√≥digo inferior da error?

```{r}
#| error: true
edad + nombre
```


### [**Ejercicio 4**]{.hl-yellow}

üìù Define otra variable llamada `hermanos` que responda la pregunta ¬´¬øtienes hermanos?¬ª y otra variable que almacene tu fecha de nacimiento (llamada `fecha_nacimiento`).

```{r}
#| code-fold: true
hermanos <- TRUE

library(lubridate) # sino lo ten√≠as ya cargado
fecha_nacimiento <- as_date("1989-09-10")
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Define otra variable con tus apellidos (llamada `apellidos`) y usa `glue()` para tener, en una sola variable  llamada `nombre_completo`, tu nombre y apellidos separando nombre y apellido por una coma

```{r}
#| code-fold: true
#| eval: false
apellidos <- "√Ålvarez Li√©bana"
glue("{nombre}, {apellidos}")
```

### [**Ejercicio 6**]{.hl-yellow}

üìù De `fecha_nacimiento` extrae el mes.

```{r}
#| code-fold: true
#| eval: false
month(fecha_nacimiento)
```

### [**Ejercicio 7**]{.hl-yellow}

üìù Calcula los d√≠as que han pasado desde la fecha de tu nacimiento hasta hoy (con la fecha de nacimiento definida en el ejercicio 4).

```{r}
#| code-fold: true
#| eval: false
today() - fecha_nacimiento
```

### [**Ejercicio 8**]{.hl-yellow}

üìù Define el vector `x` como la concatenaci√≥n de los 5 primeros n√∫meros impares. Calcula la longitud del vector

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Ejercicio 9**]{.hl-yellow}

üìù Accede al tercer elemento de `x`. Accede al √∫ltimo elemento (sin importar la longitud, un c√≥digo que pueda ejecutarse siempre). Elimina el primer elemento.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Ejercicio 10**]{.hl-yellow}

üìù Obt√©n los elementos de `x` mayores que 4. Calcula el vector `1/x` y gu√°rdalo en una variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Ejercicio 11**]{.hl-yellow}

üìù Crea un vector que represente los nombres de 5 personas, de los cuales uno es desconocido.

```{r}
#| code-fold: true
#| eval: false
nombres <- c("Javi", "Sandra", NA, "Laura", "Carlos")
nombres
```


:::


## Primera base de datos

## üê£ Caso pr√°ctico I: salto de longitud

Para practicar textos y tibbles vamos a usar el dataset `salto_longitud.csv` que tienes guardado en la carpeta de datos, que guarda c√≥mo ha **progresado el r√©cord de salto de longitud masculino**. Dicha tabla ha sido extra√≠da directamente de la wikipedia <https://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression#Low_altitude_record_progression_1965%E2%80%931991>

![](./img/men-long-jump.png)

```{r}
load(file = "./datos/salto_longitud.RData")
```

Aunque m√°s adelante veremos como extraerlo, puedes ver debajo si quieres el c√≥digo que se ha usado para extraer la tabla

```{r}
#| code-fold: true
#| eval: false
library(rvest)
library(tidyverse)
wiki_jump <- 'https://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression'
long_jump <- read_html(wiki_jump)
salto_longitud <- html_table(html_node(long_jump, 'table'))
```



### Pregunta 1

> ¬øCu√°ntos registros hay? ¬øCu√°ntas variables? ¬øDe qu√© tipo es cada una? ¬øCu√°les son sus nombres? ¬øQu√© crees que significan?


```{r}
#| code-fold: true
#| eval: false
nrow(salto_longitud)
ncol(salto_longitud)
names(salto_longitud)

# tenemos 19 r√©cords y 5 variables: la marca (en metros, pies y pulgadas), el viento que hac√≠a, la persona que bati√≥ el record, el lugar y la fecha.
```



### Pregunta 2

> Crea una nueva variable llamada `Mark` (sustituye a la anterior) en la que hayas extra√≠do la marca en metros (y convertida a n√∫mero). Pr√°ctica antes con un valor de juguete, por ejemplo, si tuvi√©semos `x <- "7.61 m (24 ft 11+1/2 in)", ¬øc√≥mo podr√≠amos quedarnos solo con la marca en metros?


```{r}
#| code-fold: true
#| eval: false

# Sabemos que el patr√≥n es 1 n√∫mero, un ., y dos decimales, as√≠ que
# usamos str_extract para extraer ese patr√≥n que le indicamos
# con una expresi√≥n regular.
salto_longitud$Mark <-
  str_extract(salto_longitud$Mark, pattern = "[0-9][.][0-9]{2}")

# Tras ello convertimos a n√∫mero
salto_longitud$Mark <- as.numeric(salto_longitud$Mark)

# importante: ahora en la cabecera debajo de mark pone <dbl>, es un n√∫mero
salto_longitud 
```

### Pregunta 3

> Crea una nueva variable llamada `Wind` (sustituye la original) en la que tengas el viento convertido a n√∫mero. 


```{r}
#| code-fold: true
#| eval: false
salto_longitud$Wind <- as.numeric(salto_longitud$Wind)
salto_longitud
```

> ¬øEn cu√°ntos r√©cords no hab√≠a viento? ¬øEn cu√°ntos no tenemos registros de dicha medida?

```{r}
#| code-fold: true
#| eval: false

# Con viento 0
sum(salto_longitud$Wind == 0, na.rm = TRUE)

# Sin registros
sum(is.na(salto_longitud$Wind))

# importante: ausente y 0 no es lo mismo
```

### Pregunta 4

> Crea una nueva variable llamada `country` que extraiga las siglas de los pa√≠ses de la variable `Athlete`

```{r}
#| code-fold: true
#| eval: false
# Primero extraemos con los par√©ntesis (es m√°s f√°cil detectarlo)
salto_longitud$country <-
  str_extract(salto_longitud$Athlete, pattern = "[(][A-Z]{3}[)]")

# Luego los eliminamos los ( y los ) (de ah√≠ la barra vertical en medio)
# F√≠jate que para que entienda que es un caracter especial (par√©ntesis)
# se lo pasamos como \\( y como \\). Ppasar√≠a lo mismo si queremos detectar,
# por ejemplo, un punto, con \\.
salto_longitud$country <- str_remove_all(salto_longitud$country, "\\(|\\)")
```

> Ordena la tabla por orden alfab√©tico de las siglas

```{r}
#| code-fold: true
#| eval: false
salto_longitud <- salto_longitud[order(salto_longitud$country), ]
```

### Pregunta 5

> 


```{r}
#| code-fold: true
#| eval: false
```

### Pregunta 6

> Reemplaza la variable `Date` por la fecha correcta en formato fecha


```{r}
#| code-fold: true
#| eval: false

# primero eliminamos todos los [?]
salto_longitud$Date <-
  str_remove_all(salto_longitud$Date, pattern = "\\[[0-9]{1}\\]")

# luego atendemos el caso particualr de [note 1]
salto_longitud$Date <-
  str_remove_all(salto_longitud$Date, pattern = "\\[note 1\\]")

# tras depurar convertimos a fecha
salto_longitud$Date <- dmy(salto_longitud$Date)
salto_longitud
```

### Pregunta 7

> ¬øCu√°ntos r√©cords no son de Estados Unidos? ¬øQu√© porcentaje representa respecto al total?

### Pregunta 8

> Para cada r√©cord, calcula los metros de mejora respecto al anterior



## üê£ Caso pr√°ctico II: pinniped dataset

Del paquete `Biostatistics` usaremos el conunto de datos `pinniped`, que guarda los datos de peso de cuerpo y cerebro (desagregado por sexo y mono/poligamia) de 33 especies de mam√≠feros marinos.


```{r}
Biostatistics::pinniped
```

### Pregunta 1

> Comprueba si los datos est√°n en formato tibble. En caso negativo convi√©rtelo.

```{r}
#| eval: false
#| code-fold: true

# chequeamos si es tibble
library(tibble)
is_tibble(Biostatistics::pinniped)

# Convertimos a tibble
pinniped_tb <- as_tibble(Biostatistics::pinniped)
```

### Pregunta 2

> ¬øCu√°ntos registros hay? ¬øCu√°ntas variables? ¬øDe qu√© tipo es cada una? ¬øCu√°les son sus nombres?


```{r}
#| code-fold: true
#| eval: false
nrow(pinniped_tb)
ncol(pinniped_tb)
names(pinniped_tb)
```

### Pregunta 3

> Incorpora una variable nueva llamada `phoca` que sea de tipo l√≥gico y que nos diga si una especie es de la categor√≠a `Phoca` o no.

```{r}
#| code-fold: true
#| eval: false
pinniped_tb$phoca <- pinniped_tb$Species == "Phoca"
```

### Pregunta 4

> ¬øA qu√© sexo le pesa m√°s el cerebro: a las hembras o a los machos?

```{r}
#| code-fold: true
#| eval: false

# ¬øa qui√©n le pesa m√°s el cerebro?
mean(pinniped_tb$Male_brain_g, na.rm = TRUE) >
  mean(pinniped_tb$Female_brain_g, na.rm = TRUE)
```

### Pregunta 5

> ¬øA quienes les pesa m√°s el cuerpo a los mon√≥gamos o a los pol√≠gamos? Recuerda que tienes los pesos divididos por sexos en variables distintas que tendr√°s que juntar de alguna forma

```{r}
#| code-fold: true
#| eval: false

# ¬øa qui√©n le pesa m√°s el cerebro?
mean(c(pinniped_tb$Male_mass_Kg[pinniped_tb$Mate_type == "mono"],
       pinniped_tb$Female_mass_Kg[pinniped_tb$Mate_type == "mono"])) >
  mean(c(pinniped_tb$Male_mass_Kg[pinniped_tb$Mate_type == "poly"],
         pinniped_tb$Female_mass_Kg[pinniped_tb$Mate_type == "poly"]))
```


### Pregunta 6

> Incopora una nueva variable llamada `dif_m_f` que represente la diferencia entre el peso del cerebro entre machos y hembras (machos - hembras) para cada especie.

```{r}
#| code-fold: true
#| eval: false
pinniped_tb$dif_m_f <- pinniped_tb$Male_brain_g - pinniped_tb$Female_brain_g
pinniped_tb
```


