---
title: "SOFTWARE II"
subtitle: "AnÃ¡lisis de datos en R para Ciencia de Datos"
title-slide-attributes:
  data-background-image: img/data-science-2.jpeg
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Grado en Ciencia de Datos Aplicada â€¢ curso 2023-2024"
affiliation: Facultad de Estudios EstadÃ­sticos (UCM)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    chalkboard: true
    multiplex: true
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier Ãlvarez LiÃ©bana</strong>](...) â€¢ Grado en Ciencia de Datos Aplicada (UCM) â€¢ curso 2023-2024"
    slide-number: c/t
execute:
  echo: true
---

# Â¡Bienvenidos a R!

[**Dejad vuestras hojas de cÃ¡lculo y Anacondas a un lado**]{style="color:#444442;"}

---

## Â¡Buenas!

[**Correo**]{.hl-green}: **<javalv09@ucm.es>**. [**Despacho**]{.hl-green}: 722 (3Âª planta). [**TutorÃ­as**]{.hl-green}: lunes (14:30-16:00), martes (12:00-13:00) y viernes (13:00-14:00).

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
-   [**Javier Ãlvarez LiÃ©bana**]{.hl-yellow}, de Carabanchel (Bajo).

-   Licenciado en MatemÃ¡ticas (UCM). [**Doctorado en estadÃ­stica**]{.hl-yellow} (UGR).

-   Encargado de la [**visualizaciÃ³n y anÃ¡lisis de datos covid**]{.hl-yellow} del Principado de Asturias (2021-2022).

-   Miembro de la [**Sociedad EspaÃ±ola de EstadÃ­stica e IO**]{.hl-yellow} y la [**Real Sociedad MatemÃ¡tica EspaÃ±ola**]{.hl-yellow}.
:::
:::
:::

. . .

Actualmente, [**investigador y docente en la Facultad de EstadÃ­stica de la UCM**]{.hl-yellow}. Divulgando por [**Twitter**](https://twitter.com/dadosdelaplace) e [**Instagram**](https://instagram.com/javieralvarezliebana)


---

## Objetivos

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
-   Quitarnos el [**miedo a los errores en programaciÃ³n**]{.hl-yellow} â†’ a programar se aprende programando

-   Entender los [**conceptos bÃ¡sicos de R**]{.hl-yellow} desde cero â†’ aprender a abstraer ideas y algoritmos

-   Utilidad de programar â†’ flujos de trabajo [**reproducibles**, **transparentes**]{.hl-yellow} y mantenibles

-   IntroducciÃ³n al [**anÃ¡lisis y preprocesamiento**]{.hl-yellow} de datos â†’ `{tidyverse}`

-   Adquirir habilidades en la [**visualizaciÃ³n de datos**]{.hl-yellow} â†’ `{ggplot2}`
:::
:::
:::

---

## EvaluaciÃ³n

-   [**Asistencia**]{.hl-yellow}. La asistencia no serÃ¡ obligatoria pero si se [**valorarÃ¡ muy positivamente**]{.hl-purple} la participaciÃ³n en clase (nunca penalizando).

. . .

-   [**EvaluaciÃ³n**]{.hl-yellow}. A lo largo del curso se han planteado [**5 entregas individuales**]{.hl-purple}, asÃ­ como una [**entrega final grupal**]{.hl-purple} (entre 2 y 4 personas) donde se deberÃ¡ presentar el anÃ¡lisis realizado de un caso real.

. . .

-   [**Nota mÃ­nima**]{.hl-yellow}. Para no ir al examen final se [**deberÃ¡ obtener al menos un 4/10**]{.hl-purple} en cada entrega o una [**media ponderada superior al 6/10**]{.hl-purple}. Se deberÃ¡ obtener ademÃ¡s en la [**entrega grupal una nota superior a 6-6.5-7/10**]{.hl-purple} (segÃºn 2-3-4 personas)

. . .

-   [**Examen final**]{.hl-yellow}. Cualquier alumno podrÃ¡ presentarse a un examen final, siendo la valoraciÃ³n del mismo el 100% de su nota (perdiendo la evaluaciÃ³n continua).

---

## PlanificaciÃ³n I

::: column-screen-inset-right
::: {style="font-size:20px"}
|  CLASE | SEMANA | FECHAS | TOPIC | SCRIPTS | EJ. | CASO PRÃCTICO | ENTREGA | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
|     [1](#clase-1-primeros-pasos)      | S1     | 12 sep |                  Primeros pasos en R                   | [ğŸ“](https://github.com/dadosdelaplace/docencia-R-datascience-2324/tree/main/material/scripts)  |                 [ğŸ’»](#tu-turno)                 |                        |         | 
|     [2](#clase-2-primeros-datos)      | S1     | 15 sep |                 Tipos bÃ¡sicos de datos y vectores                | [ğŸ“](https://github.com/dadosdelaplace/docencia-R-datascience-2324/tree/main/material/scripts)  |       [ğŸ’»](#tu-turno-1) [ğŸ’»](#tu-turno-2)       |  [ğŸ£](#caso-prÃ¡ctico)  |         |   
|     [3](#clase-3)      | S2     | 19 sep |                 Primeras bases de datos              | [ğŸ“](https://github.com/dadosdelaplace/docencia-R-datascience-2324/tree/main/material/scripts)  |       [ğŸ’»](#tu-turno-3) [ğŸ’»](#tu-turno-matrices) [ğŸ’»](#tu-turno-tibble)   |  [ğŸ£](#caso-prÃ¡ctico-1)  |         |   
|     [4](#clase-4)      | S2     | 19 sep |      Comunicar y elaborar informes/entregas              | [ğŸ“](https://github.com/dadosdelaplace/docencia-R-datascience-2324/tree/main/material/scripts)  |       |  [ğŸ£](#caso-prÃ¡ctico-3a)  |         | 
|   [5](#entrega-i)   | S3 | 26 sep | Entrega I |  |  [ğŸ’»](#entrega-i)   |  |  ğŸ¯ 5%  | 
|     [6](#clase-6)      | S3     | 29 sep |      Tidydata: intro a tidyverse             | [ğŸ“](https://github.com/dadosdelaplace/docencia-R-datascience-2324/tree/main/material/scripts)  |     [ğŸ’»](#tu-turno-6)  |  [ğŸ£](#caso-prÃ¡ctico-6)  |         |
|   [7](#clase-7-importar)   | S4     | 3 oct |       Importar y exportar archivos  | [ğŸ“]()  |                [ğŸ’»](#tu-turno-7)             |        [ğŸ£](#caso-prÃ¡ctico-7)          |         | 
|   [8](#entrega-ii)   | S4 | 6 oct | Entrega II |  |  [ğŸ’»](#entrega-ii)   |  |  ğŸ¯ 15%  | 
|   [9](#clase-9)   | S5 | 10 oct | Tidyverse: filas |  |  [ğŸ’»](#tu-turno-9a)  [ğŸ’»](#tu-turno-9b)  |  [ğŸ£](#caso-prÃ¡ctico-9)  |  ğŸ¯ | 
|   [10](#clase-10)   | S6 | 17 oct | Tidyverse: filas y columnas |  |  [ğŸ’»](#tu-turno-10)  [ğŸ’»](#tu-turno-10)  |  [ğŸ£](#caso-10)  |  ğŸ¯ | 
|   [11](#clase-11)   | S6 | 17 oct | Tidyverse: filas y columnas |  |  [ğŸ’»](#tu-turno-11)  [ğŸ’»](#tu-turno-11b)  |  [ğŸ£](#caso-11)  |  ğŸ¯ | 
:::
:::

---

## Materiales

* [**Diapositivas**]{.hl-yellow}: las diapositivas que usaremos en el aula a lo largo del curso, estructuradas por clases, estarÃ¡n disponibles y actualizadas en **<https://javieralvarezliebana.es/docencia-R-datascience-2324/diapos>** 

En el menÃº de las diapositivas (abajo a la izquierda) tienes una [**opciÃ³n para descargarlas en pdf**]{.hl-yellow} en `Tools` (consejo: no lo hagas hasta el final del curso ya que irÃ¡n modificÃ¡ndose)
  
&nbsp;

* [**Material**]{.hl-yellow}: [**scripts de cada tema**](https://github.com/dadosdelaplace/docencia-R-datascience-2324/tree/main/material) y materiales extras

* [**ResÃºmenes de paquetes**]{.hl-yellow}: [**chuletas de los paquetes**](https://github.com/dadosdelaplace/docencia-R-datascience-2324/tree/main/fichas%20paquetes) en formato .pdf


# Clase 1: primeros pasos {#clase-1-primeros-pasos}

[**Instalando R y RStudio. Primeros pasos. Scripts y proyectos**]{style="color:#444442;"}

---

## Requisitos

Para el curso los Ãºnicos requisitos serÃ¡n:

1.  [**ConexiÃ³n a internet**]{.hl-yellow} (para la descarga de algunos datos y paquetes).

2.  [**Instalar R**]{.hl-yellow}[: serÃ¡ nuestro lenguaje. La descarga la haremos (gratuitamente) desde <https://cran.r-project.org/>]{.fragment .fade-in}

::: {.fragment .fade-in}
3.  [**Instalar RStudio**]{.hl-yellow} desde <https://posit.co/download/rstudio-desktop/>
:::

::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="420"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="420"}
:::
:::

---

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="400"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="470"}
:::
:::

::: {.fragment .fade-in-then-out}
Programaremos como escribimos (castellano, por ejemplo) â†’ `R` es [**lenguaje**]{.hl-yellow}
:::

::: {.fragment .fade-up}
-   Necesitaremos una [**gramÃ¡tica**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}
-   Y un entorno, por ejemplo un [**Word**]{.hl-yellow} (`RStudio`), para escribirlo
:::
:::

---

## InstalaciÃ³n de R

El lenguaje `R` serÃ¡ nuestra [**gramÃ¡tica y ortografÃ­a**]{.hl-yellow} (nuestras reglas de juego)

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra en <https://cran.r-project.org/> y selecciona tu sistema operativo.

-   [**Paso 2**]{.hl-yellow}: para Mac basta con que hacer click en el **archivo .pkg**, y abrirlo una vez descargado. Para sistemas Windows, debemos clickar en **install R for the first time** y despuÃ©s en **Download R for Windows**. Una vez descargado, abrirlo como cualquier archivo de instalaciÃ³n.

-   [**Paso 3**]{.hl-yellow}: abrir el ejecutable de instalaciÃ³n.
:::

. . .

::: callout-warning
Siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), [**asegÃºrate de tener conexiÃ³n a internet**]{.hl-orange}.
:::

---

## Primera operaciÃ³n

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deberÃ­as ver una **pantalla blanca** similar a esta.

Esa Â«pantalla blancaÂ» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**Idea**]{.hl-yellow}: a una variable llamada `a` le asignaremos el valor `1` (escribiremos el cÃ³digo de abajo en la consola y daremos Â«enterÂ»)

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## Primera operaciÃ³n

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deberÃ­as ver una **pantalla blanca** similar a esta.

Esa Â«pantalla blancaÂ» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Idea**]{.hl-yellow}: definiremos otra variable llamada `b` y le asignaremos el valor `2`

```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

. . .

::: callout-note
## FÃ­jate que...

En `R` usaremos `<-` como una flecha: la variable a la izquierda de dicha flecha le asignamos el valor que hay a la derecha (por ejemplo, `a <- 1`)
:::

---

## Primera operaciÃ³n

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deberÃ­as ver una **pantalla blanca** similar a esta.

Esa Â«pantalla blancaÂ» se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="270"}
:::
:::

[**Idea**]{.hl-yellow}: haremos la suma `a + b` y nos devolverÃ¡ su resultado

```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

---

## InstalaciÃ³n de R Studio

`RStudio` serÃ¡ el [**Word**]{.hl-yellow} que usaremos para escribir (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra la [web oficial de RStudio](https://posit.co/download/rstudio-desktop/) (ahora llamado Posit) y selecciona la descarga gratuita.

-   [**Paso 2**]{.hl-yellow}: selecciona el ejecutable que te aparezca acorde a tu sistema operativo.

-   [**Paso 3**]{.hl-yellow}: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro y dejar que termine la instalaciÃ³n.
:::

---

## OrganizaciÃ³n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo cÃ³digo que antes (la suma de las variables) en ella. La consola serÃ¡ donde **ejecutaremos Ã³rdenes y mostraremos resultados**.

![](img/consola_rstudio.jpg){width="420"}

---

## OrganizaciÃ³n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Environment**]{.hl-yellow}: la pantalla pequeÃ±a (puedes ajustar los mÃ¡rgenes con el ratÃ³n a tu gusto) que tenemos en la parte superior derecha. Nos mostrarÃ¡ las **variables que tenemos definidas**.

![](img/environment.jpg){width="420"}

---

## OrganizaciÃ³n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha no servirÃ¡ para buscar **ayuda de funciones**, ademÃ¡s de para **visualizar grÃ¡ficos**.

![](img/multiusos.jpg){width="420"}

---

## Â¿QuÃ© es R? Â¿Por quÃ© R?

![](img/meme_barco.jpg)

---

## Â¿QuÃ© es R? Â¿Por quÃ© R?

`R` es el [**lenguaje estadÃ­stico por excelencia**]{.hl-yellow}, creado por y para estadÃ­sticos/as, con 5 ventajas fundamentales [**frente a Excel**]{.hl-red}:

::: incremental
-   [**Lenguaje de programaciÃ³n**]{.hl-yellow}: la obviedad [â†’ anÃ¡lisis]{.fragment .fade-in}[**replicables**]{.hl-purple}

-   [**Gratuito**]{.hl-yellow}: la filosofÃ­a de la comunidad de `R` es el compartir cÃ³digo bajo **copyleft** [â†’]{.fragment .fade-in}[**uso Ã©tico de dinero pÃºblico**]{.hl-purple}

-   [**Software libre**]{.hl-yellow}: no solo es gratis sino que permite acceder libremente a cÃ³digo ajeno, incluso al **propio cÃ³digo fuente** [â†’]{.fragment .fade-in}[**flexibilidad y transparencia**]{.hl-purple}

-   [**Lenguaje modular**]{.hl-yellow}: hemos instalado lo mÃ­nimo, pero existen cÃ³digos de otras personas que podemos reusar (casi 20 000 [**paquetes**]{.hl-yellow}) [â†’]{.fragment .fade-in}[**ahorro de tiempo**]{.hl-purple}

-   [**Lenguaje de alto nivel**]{.hl-yellow}: facilita la programaciÃ³n (como Python) [â†’]{.fragment .fade-in}[**menor curva de aprendizaje**]{.hl-purple}
:::

---

## Â¿QuÃ© es R? Â¿Por quÃ© R?

![](img/incel_excel.png)

---

## Â¿Por quÃ© programar?

-   [**Automatizar**]{.hl-yellow} â†’ te permitirÃ¡ automatizar tareas recurrentes.

-   [**Replicabilidad**]{.hl-yellow} â†’ podrÃ¡s replicar tu anÃ¡lisis siempre de la misma manera.

-   [**Flexibilidad**]{.hl-yellow} â†’ podrÃ¡s adaptar el software a tus necesidades.

-   [**Transparencia**]{.hl-yellow} â†’ ser auditado por la comunidad.

![](img/the_general_problem.png)

---

## Idea fundamental: paquetes

Una de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: cÃ³digos que otras personas han implementado para **resolver un problema**

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}
-   [**InstalaciÃ³n**]{.hl-yellow}: descargamos los cÃ³digos de la web (necesitamos internet) â†’ [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)

```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}
-   [**Carga**]{.hl-yellow}: con el paquete descargado, indicamos quÃ© paquetes queremos usar cada vez que abramos `RStudio` â†’ [**traer el libro de la estanterÃ­a**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::
:::
:::

---

## Idea fundamental: paquetes

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
Una vez instalado, hay dos manera de usar un paquete (traerlo de la estanterÃ­a)

::: {.fragment fragment-index="1"}
-   [**Paquete entero**]{.hl-yellow}: con `library()`, usando el nombre del paquete sin comillas, cargamos en la sesiÃ³n [**todo el libro**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}
-   [**Funciones concretas**]{.hl-yellow} usando `paquete::funcion` le Ã­ndicamos que solo queremos una [**pÃ¡gina concreta de ese libro**]{.hl-purple}

```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## Te vas equivocar

Durante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera â†’ [**te vas equivocar**]{.hl-yellow}. No solo serÃ¡ importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.

. . .

-   [**Mensajes de error**]{.hl-red}: precedidos de **Â«Error in...Â»** y serÃ¡n aquellos fallos que [**impidan la ejecuciÃ³n**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Mensajes de warning**]{.hl-orange}: precedidos de **Â«Warning in...Â»** son los (posibles) fallos mÃ¡s delicados ya que son incoherencias que [**no impiden la ejecuciÃ³n**]{.hl-orange}

```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```

---

## Scripts (documentos .R)

::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}
Un [**script**]{.hl-yellow} serÃ¡ el documento en el que programamos, nuestro archivo `.doc` (aquÃ­ con extensiÃ³n `.R`) donde escribiremos las Ã³rdenes. Para **abrir nuestro primero script**, haz click en el menÃº en `File < New File < R Script`.
:::
:::

::: callout-warning
## Cuidado

Es importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habrÃ¡s perdido**]{.hl-orange}.
:::

---

## Ejecutando el primer script

Ahora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros cÃ³digos**]{.hl-yellow}. Â¿CÃ³mo ejecutarlo?

. . .

1.  **Escribimos** el cÃ³digo a ejecutar.

. . .

2.  **Guardamos** el archivo .R haciendo click en `Save current document`.

. . .

3.  El cÃ³digo no se ejecuta salvo que se lo indiquemos. Tenemos tres opciones:

-   [**Copiar y pegar**]{.hl-yellow} en consola.
-   [**Seleccionar lÃ­neas**]{.hl-yellow} y `Ctrl+Enter`
-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el cÃ³digo **completo**.

---

## ğŸ’» Tu turno {#tu-turno}

[**Ejecuta tu primer script**: crea un script de cero, programa lo indicado debajo y ejecÃºtalo (de las 3 maneras posibles)]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Define una variable de nombre `a` y cuyo valor sea -1

```{r}
#| code-fold: true
a <- -1
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ AÃ±ade debajo otra lÃ­nea para definir una variable `b` con el valor 5. Tras ello mÃºltiplica ambas variables

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # sin guardar
multiplicacion <- a * b # guardado
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables.

```{r}
#| eval: false
c <- # deberÃ­as asignarle el valor 3
d <- # deberÃ­as asignarle el valor -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d # sin guardar
division <- c / d # guardado
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Asigna un valor positivo a `x` y calcula su raÃ­z cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la funciÃ³n `abs()`.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Usando la variable `x` ya definida, completa/modifica el cÃ³digo inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.

```{r}
#| eval: false
z <- ? - ? # completa el cÃ³digo
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```
:::

::: callout-note
## Toma nota

Comandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: lÃ­neas de cÃ³digo que hemos Â«encapsuladoÂ» bajo un nombre, y dado unos argumentos de entrada, ejecuta las Ã³rdenes (una especie de atajo).
:::

---

## SÃ© organizado: proyectos

De la misma manera que en el ordenador solemos trabajar de manera [**ordenada por carpetas**]{.hl-yellow}, en `RStudio` podemos hacer lo mismo para trabajar de [**manera eficaz creando proyectos**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
Un [**proyecto serÃ¡ una Â«carpetaÂ»**]{.hl-yellow} dentro de `RStudio`, de manera que nuestro directorio raÃ­z automÃ¡ticamente serÃ¡ la propia carpeta de proyecto (pudiendo pasar de un proyecto a otro con el menu superior derecho).

Podemos crear uno en una carpeta nueva o en una carpeta ya existente.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::

---

## FilosofÃ­a: de la CELDA a la TABLA

Â¿QuÃ© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg){fig-align="middle"}

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenaciÃ³n** de valores del mismo tipo ([**vectores**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenaciÃ³n de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenaciÃ³n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenaciÃ³n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

# Clase 2: primeros datos y vectores {#clase-2-primeros-datos}

[**Â¿QuÃ© tipos de celdas (datos) existen? Concatenando celdas: vectores**]{style="color:#444442;"}

---

## De la CELDA a la TABLA

Â¿QuÃ© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg){fig-align="middle"}

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenaciÃ³n** de valores del mismo tipo ([**vectores**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenaciÃ³n de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenaciÃ³n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenaciÃ³n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

---

## Celdas: tipos de datos

Â¿Existen [**variables mÃ¡s allÃ¡ de los nÃºmeros**]{.hl-yellow}?

. . .

Piensa por ejemplo en los datos guardados de una persona:

::: {.fragment .fade-up}
-   La edad o el peso serÃ¡ un [**nÃºmero**]{.hl-yellow}.

```{r}
edad <- 33
```
:::

::: {.fragment .fade-up}
-   Su nombre serÃ¡ una cadena de [**texto (string o char)**]{.hl-yellow}.

```{r}
nombre <- "javi"
```
:::

::: {.fragment .fade-up}
-   A la pregunta Â«Â¿estÃ¡s matriculado en la Facultad?Â» la respuesta serÃ¡ lo que llamamos una [**variable lÃ³gica**]{.hl-yellow} (`TRUE` si estÃ¡ matriculado o `FALSE` en otro caso).

```{r}
matriculado <- TRUE
```
:::

::: {.fragment .fade-up}
-   Su fecha de nacimiento serÃ¡ precisamente eso, una [**fecha**]{.hl-yellow}.
:::

---

## Variables numÃ©ricas

El dato mÃ¡s sencillo (ya lo hemos usado) serÃ¡n las [**variables numÃ©ricas**]{.hl-yellow}

```{r}
#| eval: false
a <- 5
b <- 2
a + b
```

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

. . .

Para saber el tipo de una variable tenemos la funciÃ³n `class()`

```{r}
class(a)
```

. . .

AdemÃ¡s de los nÃºmeros Â«normalesÂ» tendremos el [**valor infinito**]{.hl-yellow}

```{r}
1/0
```

. . .

Y valores que [**no son nÃºmeros reales**]{.hl-yellow} _not a number_ (indeterminaciones, complejos, etc)

```{r}
0/0
```


---

## Variables numÃ©ricas

Con las variables numÃ©ricas podemos realizar las [**operaciones aritmÃ©ticas**]{.hl-yellow} de una calculadora: sumar (`+`)...

```{r}
a + b
```

. . .

...raÃ­z cuadrada (`sqrt()`)...

```{r}
sqrt(a)
```

. . .

... potencias (`^2`, `^3`)...

```{r}
a^2
```

. . .

...valor absoluto (`abs()`), etc.

```{r}
abs(a)
```


---

## Variables de texto

Imagina que ademÃ¡s de la edad de una persona queremos guardar su nombre: ahora la variable serÃ¡ de tipo `character`

```{r}
nombre <- "Javier"
class(nombre)
```

. . .

Las [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones aritmÃ©ticas**]{.hl-red} (sÃ­ otras operaciones como pegar o localizar patrones).

```{r}
#| error: true
nombre + 1 # error al sumar nÃºmero a texto
```

. . .

::: callout-warning
## Recuerda que...

Las variables de tipo texto (character o string) van [**SIEMPRE entre comillas**]{.hl-orange}: no es lo mismo `TRUE` (valor lÃ³gico, binario) que `"TRUE"` (texto).
:::

---

## Primera funciÃ³n: paste

En `R` llamaremos [**funciÃ³n**]{.hl-yellow} a un trozo de [**cÃ³digo encapsulado**]{.hl-yellow} bajo un nombre, y que depende de unos [**argumentos**]{.hl-yellow} de entrada. Nuestra primera funciÃ³n serÃ¡ `paste()`: dadas dos cadenas de texto nos permite pegarlas.

```{r}
paste("Javier", "Ãlvarez")
```

. . .

FÃ­jate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos aÃ±adir un [**argumento opcional**]{.hl-yellow} para indicarle el separador (en `sep = ...`).

```{r}
paste("Javier", "Ãlvarez", sep = "*")
```

---

## Primera funciÃ³n: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}
Â¿CÃ³mo saber [**quÃ© argumentos necesita una funciÃ³n**]{.hl-yellow}? Escribiendo en consola `? paste` te aparecerÃ¡ una [**ayuda**]{.hl-yellow} en el panel multiusos.

En dicha ayuda podrÃ¡s ver en su cabecera que argumentos ya tiene [**asignados por defecto**]{.hl-yellow} la funciÃ³n
:::
:::

. . .

Existe una funciÃ³n similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).

```{r}
paste0("Javier", "Ãlvarez")
```

--- 

## Funciones: argumentos por defecto

Es muy importante entender el concepto de [**argumento por defecto de una funciÃ³n**]{.hl-yellow} en `R`: es un valor que la funciÃ³n usa pero a veces podemos no ver porque [**ya tiene un valor asignado**]{.hl-yellow}. 

```{r}
# Hacen lo mismo
paste("Javier", "Ãlvarez")
paste("Javier", "Ãlvarez", sep = " ")
```

. . .

::: callout-note
## Toma nota

El operador `=` lo [**reservaremos para asignar argumentos**]{.hl-yellow} dentro de funciones. Para todas las demÃ¡s asignaciones usaremos `<-`
:::

---

## Primer paquete: glue

Una forma mÃ¡s intuitiva de trabajar con textos es usar el paquete `{glue}`: lo primero que haremos serÃ¡ Â«comprar el libroÂ» (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue") # solo la primra vez
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

Con la funciÃ³n `glue()` de dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, Â«la edad es de ... aÃ±osÂ», donde la edad estÃ¡ guardada en una variable.

```{r}
edad <- 33
glue("La edad es de {edad} aÃ±os")
```

. . .

Dentro de las llaves tambiÃ©n podemos [**ejecutar operaciones**]{.hl-yellow}

```{r}
unidades <- "dÃ­as"
glue("La edad es de {edad * 365} {unidades}")
```

---

## Variables lÃ³gicas

Otro tipo fundamental serÃ¡n las [**variables lÃ³gicas o binarias**]{.hl-yellow} (**dos valores**):

-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.
-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.

```{r}
soltero <- TRUE # Â¿Es soltero? --> SÃ
class(soltero)
```

. . .

Dado que internamente estÃ¡n guardados como variables binarias, podemos [**realizar operaciones aritmÃ©ticas**]{.hl-yellow} con ellas

```{r}
2 * TRUE
FALSE - 1
```

---

## Variables lÃ³gicas

Como veremos en breve, las variables lÃ³gicas en realidad puede tomar un tercer valor: `NA` o [**dato ausente**]{.hl-yellow}, representando las siglas de *not available*, y serÃ¡ muy habitual encontrarlo dentro de una base de datos.

```{r}
ausente <- NA
ausente + 1
```


. . .

::: callout-important
## Importante

Las variables lÃ³gicas [**NO son variables de texto**]{.hl-red}: `"TRUE"` es un texto, `TRUE` es un valor lÃ³gico.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Condiciones lÃ³gicas

Los valores lÃ³gicos suelen ser resultado de [**evaluar condiciones lÃ³gicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos [**comprobar**]{.hl-yellow} si una persona se llama Javi.

```{r}
nombre <- "MarÃ­a"
```


. . .

Con el [**operador lÃ³gico**]{.hl-yellow} `==` preguntamos sÃ­ lo que tenemos guardado a la izquierda es igual que lo que tenemos a la derecha: es una [**pregunta**]{.hl-yellow}

```{r}
nombre == "Javi"
```

. . .

Con su opuesto `!=` preguntamos si es distinto.

```{r}
nombre != "Javi"
```

. . .

::: callout-note
## FÃ­jate que...

No es lo mismo `<-` ([**asignaciÃ³n**]{.hl-yellow}) que `==` (estamos [**preguntando**]{.hl-yellow}, es una comparaciÃ³n lÃ³gica).
:::

---

## Condiciones lÃ³gicas

AdemÃ¡s de las comparaciones Â«igual aÂ» frente Â«distintoÂ», tambiÃ©n comparaciones de orden como `<, <=, > o >=`.

**Â¿Tiene la persona menos de 32 aÃ±os?**

```{r}
edad <- 34
edad < 32 # Â¿Es la edad menor de 32 aÃ±os?
```

. . .

**Â¿La edad es mayor o igual que 38 aÃ±os?**

```{r}
edad >= 38
```

. . .

**Â¿El nombre guardado es Javi?**

```{r}
nombre <- "Javi"
nombre == "Javi"
```

---

## Variables de fecha

Un tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.

```{r}
fecha_char <- "2021-04-21"
```

Parece una simple cadena de texto pero [**deberÃ­a representar un instante en el tiempo**]{.hl-yellow}. Â¿QuÃ© deberÃ­a suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?

. . .

```{r}
#| error: true
fecha_char + 1
```


Las fechas [**NO pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha.

. . .

&nbsp;

Para trabajar con fechas usaremos el paquete `{lubridate}`, que deberemos instalar antes de poder usarlo.

```{r}
#| eval: false
install.packages("lubridate")
```

---

## Variables de fecha

Una vez instalado, de todos los paquetes (libros) que tenemos, le indicaremos que nos cargue ese concretamente.

```{r}
library(lubridate) # instala si no lo has hecho

```

. . .

Para [**convertir a tipo fecha**]{.hl-yellow} usaremos la funciÃ³n `as_date()` del paquete `{lubridate}`

&nbsp;

:::: columns
::: {.column width="50%"}

```{r}
#| error: true
# Â¡no es una fecha, es un texto!
fecha_char + 1
class(fecha_char)
```

:::

::: {.column width="50%"}

```{r}
fecha <- as_date("2023-03-28")
fecha + 1
class(fecha)
```

:::

::::

---

## Variables de fecha

En dicho paquete tenemos funciones muy Ãºtiles para [**manejar fechas**]{.hl-yellow}:

-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.

```{r}
today()
```

. . .

-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}

```{r}
now()
```

. . .

-   Con `year()`, `month()` o `day()` podemos [**extraer el aÃ±o, mes y dÃ­a**]{.hl-purple}

```{r}
fecha <- today()
year(fecha)
month(fecha)
```

---

## ResÃºmenes de paquetes

![](img/lubridate.png)

::: callout-note
## Amplia contenido

Tienes un resumen en pdf de los paquetes mÃ¡s importantes en la [**carpeta correspondiente en el campus**]{.hl-green}
:::

---

## ğŸ’» Tu turno {#tu-turno-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Define una variable que guarde tu edad (llamada `edad`) y otra con tu nombre (llamada `nombre`)

```{r}
#| code-fold: true
edad <- 33
nombre <- "Javi"
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Comprueba si NO tienes 60 aÃ±os o si te llamas "Ornitorrinco" (debes obtener variables lÃ³gicas)

```{r}
#| code-fold: true
#| eval: false
edad != 60 # distinto de
nombre == "Ornitorrinco" # igual a
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Define otra variable llamada `hermanos` que responda la pregunta Â«Â¿tienes hermanos?Â» y otra variable que almacene tu fecha de nacimiento (llamada `fecha_nacimiento`).

```{r}
#| code-fold: true
hermanos <- TRUE

library(lubridate) # sino lo tenÃ­as ya cargado
fecha_nacimiento <- as_date("1989-09-10")
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Define otra variable con tus apellidos (llamada `apellidos`) y usa `glue()` para tener, en una sola variable  llamada `nombre_completo`, tu nombre y apellidos separando nombre y apellido por una coma

```{r}
#| code-fold: true
#| eval: false
apellidos <- "Ãlvarez LiÃ©bana"
glue("{nombre}, {apellidos}")
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ De `fecha_nacimiento` extrae el mes.

```{r}
#| code-fold: true
#| eval: false
month(fecha_nacimiento)
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Calcula los dÃ­as que han pasado desde la fecha de tu nacimiento hasta hoy (con la fecha de nacimiento definida en el ejercicio 3).

```{r}
#| code-fold: true
#| eval: false
today() - fecha_nacimiento
```
:::

---

## Vectores: concatenar

Cuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenaciÃ³n**]{.hl-purple} de celdas (valores) del [**mismo tipo**]{.hl-purple} (lo que serÃ­a una columna de una tabla).

. . .

La forma mÃ¡s sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus **elementos entre parÃ©ntesis y separados por comas**

```{r}
edades <- c(32, 27, 60, 61)
edades
```

. . .

::: callout-tip
Un nÃºmero individual `x <- 1` (o bien `x <- c(1)`) es en realidad un **vector de longitud uno** --> todo lo que sepamos [**hacer con un nÃºmero podemos hacerlo con un vector de ellos**]{.hl-green}.
:::

---

## Vectores: concatenar

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}
Como ves ahora en el `environment` tenemos una **colecciÃ³n de elementos** guardada

```{r}
edades
```
:::
:::

. . .



La [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`

```{r}
length(edades)
```

. . .

TambiÃ©n podemos [**concatenar vectores**]{.hl-yellow} entre sÃ­ (los repite uno tras otro)

```{r}
c(edades, edades, 8)
```

---

## Secuencias numÃ©ricas

El vector mÃ¡s famoso serÃ¡ el de tipo numÃ©rico, y en concreto, las conocidas como [**secuencias numÃ©ricas**]{.hl-yellow} (por ejemplo, los dÃ­as del mes), usadas para, entre otras cosas, indexar bucles.

. . .

El comando `seq(inicio, fin)` nos permite crear una [**secuencia numÃ©rica**]{.hl-yellow} desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.

```{r}
seq(1, 31)
```

. . .

FÃ­jate que si hacemos eso con [**caracteres no podremos hacerlo**]{.hl-red} ya que no hay un orden a priori entre textos.

```{r}
#| error: true
"a":"z"
```

---

## Secuencias numÃ©ricas


Un atajo es el comando `1:n`, que nos devuelve lo mismo que `seq(1, n)`

```{r}
1:7
```

Si el elemento inicial es mayor que el final, entenderÃ¡ que la secuencia es [**en orden decreciente**]{.hl-purple}.

```{r}
7:-3
```

. . .

TambiÃ©n podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos con el argumento `by = ...`

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

---

## Secuencias numÃ©ricas


Otras veces nos interesarÃ¡ definir una [**secuencia con una longitud concreta**]{.hl-yellow}

```{r}
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```

. . .

Incluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}

```{r}
rep(0, 7) # vector de 7 ceros
```

. . .


Dado que internamente son guardados como nÃºmeros tambiÃ©n podremos hacer esto con [**fechas**]{.hl-yellow}.

```{r}
seq(as_date("2023-09-01"), as_date("2023-09-10"), by = 1)
```


---

## Vectores de caracteres

Un vector es una **concatenaciÃ³n** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente nÃºmeros. Vamos a crear una frase de ejemplo.

```{r}
frase <- "Me llamo Javi"
frase
length(frase)
```

. . .

En el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas

```{r}
vector <- c("Me", "llamo", "Javi")
vector
length(vector)
```

---

## Vectores de caracteres

Â¿QuÃ© sucederÃ¡ si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

FÃ­jate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}

. . .

```{r}
c(3, 4, TRUE, FALSE)
```

Es importante entender que los valores lÃ³gicos en realidad estÃ¡n [**almacenados internamente como 0/1**]{.hl-yellow}

---

## Operaciones con vectores

Con los vectores numÃ©ricos podemos hacer las mismas [**operaciones aritmÃ©ticas**]{.hl-yellow} que con los nÃºmeros â†’ un [**nÃºmero es un vector**]{.hl-purple} (de longitud uno)

. . .

Â¿QuÃ© sucederÃ¡ si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Cuidado

Salvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}
:::

---

## Operaciones con vectores

Los vectores tambiÃ©n pueden interactuar entre ellos, asÃ­ que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)

```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Dado que la operaciÃ³n (por ejemplo, una suma) se realiza elemento a elemento, Â¿quÃ© sucederÃ¡ si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?

. . .

```{r}
z <- c(1, 3, 5, 7)
x + z
```

Lo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que harÃ¡ serÃ¡ reciclar del vector con menor longitud.

---

## Operaciones con vectores

Una operaciÃ³n muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones lÃ³gicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...

[**Â¿QuÃ© dÃ­as hizo menos de 22 grados?**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

Nos devolverÃ¡ un [**vector lÃ³gico**]{.hl-yellow}, en funciÃ³n de si **cada elemento** cumple o no la condiciÃ³n pedida (de **igual longitud** que el vector preguntado)

. . .

Si tuviÃ©ramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese dÃ­a), la condiciÃ³n evaluada tambiÃ©n serÃ­a `NA`

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Operaciones con vectores

Las [**condiciones lÃ³gicas pueden ser combinadas**]{.hl-yellow} de dos maneras:

-   [**IntersecciÃ³n**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunciÃ³n y**]{.hl-purple} con `&`) para devolver un `TRUE`

```{r}
x < 30 & x > 15
```

-   [**UniÃ³n**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunciÃ³n o**]{.hl-purple} con `|`)

```{r}
x < 30 | x > 15
```

. . .

Con `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen

```{r}
any(x < 30)
all(x < 30)
```

---

## Operaciones con vectores

Otra operaciÃ³n muy habitual es la de [**acceder a elementos**]{.hl-yellow}. La forma mÃ¡s sencilla es usar el operador `[i]` (acceder al elemento i-Ã©simo)

```{r}
edades <- c(20, 30, 33, NA, 61) 
edades[3] # accedemos a la edad de la tercera persona 
```

. . .


Dado que un nÃºmero no es mÃ¡s que un vector de longitud uno, esta operaciÃ³n tambiÃ©n la podemos aplicar usando un [**vector de Ã­ndices a seleccionar**]{.hl-yellow}

```{r}
y <- c("hola", "quÃ©", "tal", "estÃ¡s", "?")
y[c(1:2, 4)] # primer, segundo y cuarto elemento
```

. . .

::: callout-tip
Para acceder al Ãºltimo, sin preocuparnos de cuÃ¡l es, podemos pasarle como Ã­ndice la propia longitud `x[length(x)]`
:::

---

## Operaciones con vectores

Otras veces no querremos seleccionar sino [**eliminar algunos elementos**]{.hl-yellow}. Deberemos repetir la misma operaciÃ³n pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-Ã©simo del vector sino que lo Â«des-seleccionaÂ»

```{r}
y
y[-2]
```


. . .

En muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones lÃ³gicas**]{.hl-yellow}, en funciÃ³n de los valores, asÃ­ que pasaremos como Ã­ndice la propia condiciÃ³n (recuerda, `x < 2` nos devuelve un vector lÃ³gico)

```{r}
edades <- c(15, 21, 30, 17, 45)
nombres <- c("javi", "marÃ­a", "laura", "carla", "luis")
nombres[edades < 18] # nombres de los menores de edad
```

---


## ğŸ’» Tu turno {#tu-turno-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Define el vector `x` como la concatenaciÃ³n de los 5 primeros nÃºmeros impares. Calcula la longitud del vector

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Accede al tercer elemento. Accede al Ãºltimo elemento (sin importar la longitud, un cÃ³digo que pueda ejecutarse siempre). Elimina el primer elemento.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ ObtÃ©n de dicho vector los elementos de `x` mayores que 4. Calcula el vector `1/x` y guÃ¡rdalo en una variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Crea un vector que represente los nombres de 5 personas, de los cuales uno es desconocido.

```{r}
#| code-fold: true
#| eval: false
nombres <- c("Javi", "Sandra", NA, "Laura", "Carlos")
nombres
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Encuentra del vector `x` de ejercicios anteriores los elementos mayores (estrictos) que 1 Y ADEMÃS menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6. Elimina del vector el segundo elemento. Tras eliminarlo determina su suma y su media

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
x[-2]
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Dado el vector del ejercicio anterior, Â¿cuales tienen un dato ausente? Pista: las funciones `is.algo()` comprueban si el elemento es tipo `algo`. Busca en internet como comprobar que un dato es ausente o escribe `is.` en consola y tabula.

```{r}
#| code-fold: true
#| eval: false
is.na(x)
```

:::

---


## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-2}

En el paquete `{datasets}` tenemos diversos conjuntos de datos y uno de ellos es `airquality`. Debajo te he extraÃ­do 3 variables de dicho dataset

```{r}
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

1. Â¿QuÃ© [**representan los datos**]{.hl-yellow}? Â¿CÃ³mo averiguarlo?

```{r}
#| code-fold: true
#| eval: false
? airquality
```

Haciendo uso de `? ...` podemos consultar en el panel de ayuda lo que significa el objeto.

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-2-2}

2. Â¿CuÃ¡ntos [**registros tenemos de mayo**]{.hl-yellow}? Â¿Y de abril? Construye una nueva variable `date` con la [**fecha**]{.hl-yellow} de cada registro (combinando aÃ±o, mes y dÃ­a)

```{r}
#| code-fold: true
# Una forma para registros de mayo
sum(month == 5)
# Otra forma
length(month[month == 5])

# Ã­dem en abril
sum(month == 4)

# variable date
dates <- lubridate::as_date(glue("{1973}-{month}-{day}"))
```

. . .

3. Crea una nueva variable `temp_celsius` con la [**temperatura en ÂºC**]{.hl-yellow}

```{r}
#| code-fold: true
# Temperatura en celsius
temp_celsius <- (temperature - 32) * (5/9)
```

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-2-3}

4. Â¿CuÃ¡l fue la [**media de temperatura**]{.hl-yellow} del mes de agosto? Extrae los dÃ­as en los que la [**temperatura superÃ³ los 30 grados**]{.hl-yellow} y calcula la cantidad de dÃ­as en los que lo hizo.

```{r}
#| code-fold: true
# media en agosto
mean(temperature[month == 8], na.rm = TRUE)
mean(temp_celsius[month == 8], na.rm = TRUE)

# Extremos dÃ­as > 30
dates[temp_celsius > 30]
length(dates[temp_celsius > 30]) # n dÃ­as
sum(temp_celsius > 30) # n dÃ­as (otra forma)
```

---


## Operaciones con vectores

TambiÃ©n podemos hacer uso de [**operaciones estadÃ­sticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**Â¿QuÃ© sucede cuando falta un dato (ausente)?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

Por defecto, si tenemos un dato ausente, la [**operaciÃ³n tambiÃ©n serÃ¡ ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`

```{r}
sum(x, na.rm = TRUE)
```

---

## Operaciones con vectores

Como hemos comentado que los valores lÃ³gicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritmÃ©ticas.


Por ejemplo, si queremos [**averiguar el nÃºmero de elementos que cumplen una condiciÃ³n**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendrÃ¡n asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar dicho vector lÃ³gico para obtener el nÃºmero de elementos que cumplen

```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Operaciones con vectores

Otra operaciÃ³n habitual que puede sernos Ãºtil es la [**suma acumulada**]{.hl-yellow} con `cumsum()` que, dado un vector, nos devuelve un vector a su vez con el primero, el primero mÃ¡s el segundo, el primero mÃ¡s el segundo mÃ¡s el tercero...y asÃ­ sucesivamente.

```{r}
x <- c(1, 5, 2, -1, 8)
cumsum(x)
```

[**Â¿QuÃ© sucede cuando falta un dato (ausente)?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
cumsum(x)
```

En el caso de la suma acumulada lo que sucede es que [**a partir de ese valor, todo lo acumulado posterior serÃ¡ ausente**]{.hl-yellow}.

---

## Operaciones con vectores

Otra operaciÃ³n habitual que puede sernos Ãºtil es la [**diferencia (con retardo)**]{.hl-yellow} con `diff()` que, dado un vector, nos devuelve un vector con el segundo menos el primero, el tercero menos el segundo, el cuarto menos el tercero...y asÃ­ sucesivamente.


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x)
```

. . .

Con el argumento `lag = ` podemos indicar el [**retardo**]{.hl-yellow} de dicha diferencia (por ejemplo, `lag = 3` implica que se resta el cuarto menos el primero, el quinto menos el segundo, etc)


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x, lag = 3)
```

---

## Operaciones con vectores

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La mÃ¡s conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores atÃ­picos o outliers (valores muy grandes o muy pequeÃ±os), la media se perturba con mucha facilidad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Operaciones con vectores

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.


-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Percentiles**]{.hl-yellow}: medidas de posiciÃ³n (nos dividen en partes iguales los datos).

```{r}
quantile(x) # por defecto percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

# Clase 3: primeras bases de datos {#clase-3}

[**Variables de tipo texto. Primeras bases de datos**]{style="color:#444442;"}


---

## Ãšltima operaciÃ³n: ordenar

Por Ãºltimo, una acciÃ³n habitual es saber [**ordenar valores**]{.hl-yellow}:

-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(edades)
sort(edades, decreasing = TRUE)
```

. . .

-   `order()`: devuelve el [**vector de Ã­ndices**]{.hl-yellow} que tendrÃ­amos que usar para tener el vector ordenado

```{r}
order(x)
x[order(x)]
```

---

## ğŸ’» Tu turno {#tu-turno-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Define el vector `x` como la concatenaciÃ³n de los 4 primeros nÃºmeros pares, y calcula su suma.

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(2, 4, 6, 8)
x <- seq(2, 8, by = 2)

sum(x)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ ObtÃ©n los elementos de `x` menores estrictamente que 5. Calcula el nÃºmero de elementos de `x` menores estrictamente que 5.

```{r}
#| code-fold: true
#| eval: false
x[x < 5] 
sum(x < 5)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Calcula el vector `1/x` y obtÃ©n la versiÃ³n ordenada (de menor a mayor) de las dos formas posibles

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Encuentra el mÃ¡ximo y el mÃ­nimo del vector `x`

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 6. Encuentra una forma de averiguar si todos los elementos son o no negativos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, calcula su suma y su media de forma que devuelva un valor numÃ©rico conocido.

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
sum(x, na.rm = TRUE)
mean(x, na.rm = TRUE)
```
:::

---


## Primera base de datos: matrices

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una Â«tablaÂ» que las recopile. La opciÃ³n mÃ¡s inmediata son las [**matrices**]{.hl-yellow}: concatenaciÃ³n de variables del [**mismo tipo e igual longitud**]{.hl-purple}.

. . .

Imagina que tenemos estaturas y pesos de 4 personas. Â¿CÃ³mo [**crear un dataset con las dos variables**]{.hl-yellow}?

-   Con `cbind()` [**concatenamos vectores en forma de columnas**]{.hl-yellow}

```{r}
estaturas <- c(150, 160, 170, 180)
pesos <- c(63, 70, 85, 95)
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

---

## Primer intento: matrices

-   TambiÃ©n podemos [**construir la matriz por filas**]{.hl-yellow} con la funciÃ³n `rbind()` (aunque lo recomendable es tener cada variable en columna e individuo en fila).

```{r}
# Construimos la matriz por filas
rbind(estaturas, pesos)
```

. . .

-   Podemos [**visualizar la matriz**]{.hl-yellow} con la funciÃ³n `View()`.

. . .

-   Podemos [**comprobar las dimensiones**]{.hl-yellow} con `dim()`, `nrow()` y `ncol()`: nuestros datos estÃ¡n tabulados:

```{r}
dim(datos_matriz)
nrow(datos_matriz)
```

---

## Primer intento: matrices

-   TambiÃ©n podemos [**Â«darle vueltaÂ» (matriz transpuesta)**]{.hl-yellow} con `t()`.

```{r}
t(datos_matriz)
```

. . .

-   Dado que ahora tenemos dos dimensiones, para [**acceder a elementos**]{.hl-yellow} deberemos proporcionar el Ã­ndice de la fila y de la columna (si quedan libres implica todos de esa dimensiÃ³n)

```{r}
datos_matriz[2, 1]
datos_matriz[, 2]
```

---

## Primer intento: matrices

-   TambiÃ©n podemos definir una [**matriz a partir de un vector numÃ©rico**]{.hl-yellow}, reorganizando los valores en forma de matriz (sabiendo que los elementos se van [**colocando por columnas**]{.hl-purple}).

```{r}
z <- matrix(1:15, ncol = 5) 
z
```

---

## Primer intento: matrices

Con las matrices sucede como con los vectores: cuando aplicamos una [**operaciÃ³n aritmÃ©tica lo hacemos elemento a elemento**]{.hl-yellow}

```{r}
z/5
```

. . .

Para realizar [**operaciones en un sentido matricial**]{.hl-yellow} deberemos aÃ±adir `%%`, por ejemplo, para multiplicar matrices serÃ¡ `%*%`


```{r}
z %*% t(z)
```


---

## Primer intento: matrices

TambiÃ©n podemos [**realizar operaciones por columnas/filas**]{.hl-yellow} sin recurrir a bucles con la funciÃ³n `apply()`, y le indicaremos como **argumentos**

-   la matriz
-   el sentido de la operaciÃ³n (MARGIN = 1 por filas, MARGIN = 2 por columnas)
-   la funciÃ³n a aplicar

. . .

```{r}
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")
```

. . .

```{r}
# (Cuasi)varianza (var) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "var")
```


---

## ğŸ’» Tu turno (matrices) {#tu-turno-matrices}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo para definir una matriz `x` de ceros de 3 filas y 7 columnas de unos.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ A la matriz anterior, suma un 1 a cada nÃºmero de la matriz y divide el resultado entre 5. Tras ello calcula su transpuesta y obtÃ©n sus dimensiones

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
dim(new_matrix)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Define la matriz `x <- matrix(1:12, nrow = 4)`. ObtÃ©n la primera fila, la tercera columna, y el elemento (4, 1).

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # primera fila
x[, 3] # tercera columna
x[4, 1] # elemento (4, 1)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Con la matriz anterior definida como `x <- matrix(1:12, nrow = 4)`, calcula la media de todos los elementos, la media de cada fila y la media de cada columna. Calcula la suma de de cada fila y de cada columna

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
mean(x) # de todos
apply(x, MARGIN = 1, FUN = "mean") # media por filas
apply(x, MARGIN = 2, FUN = "mean") # media por columnas
apply(x, MARGIN = 1, FUN = "sum") # suma por filas
apply(x, MARGIN = 2, FUN = "sum") # suma por columnas

```
:::

---

## Segundo intento: data.frame

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte

```{r}
#| code-line-numbers: "4-5"
edades <- c(14, 24, NA)
soltero <- c(TRUE, NA, FALSE)
nombres <- c("javi", "laura", "lucÃ­a")
matriz <- cbind(edades, soltero, nombres)
matriz
```

. . .

Al ya no ser nÃºmeros no podemos realizar operaciones aritmÃ©ticas

```{r}
#| error: true
matriz + 1
```

---

## Segundo intento: data.frame

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos lo que se conoce como [**data.frame**]{.hl-yellow}: concatenaciÃ³n de variables de igual longitud pero pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
#| code-line-numbers: "1"
tabla <- data.frame(edades, soltero, nombres)
class(tabla)
tabla
```

---

## Segundo intento: data.frame

Dado que un `data.frame` es ya una Â«base de datosÂ» las variables no son meros vectores matemÃ¡ticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple}

```{r}
library(lubridate)
tabla <- data.frame("edad" = edades, "estado" = soltero, "nombre" = nombres,
             "f_nacimiento" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
tabla
```

---

## Segundo intento: data.frame

[**Â¡TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

![](img/view_tabla.jpg)

---

## Segundo intento: data.frame

Si queremos acceder a sus elementos, podemos como en las matrices (aunque no es recomendable): ahora [**tenemos dos Ã­ndices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera caracterÃ­stica de la segunda persona
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
TambiÃ©n tiene ventajas de una [**Â«baseÂ» de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} (**recomendable** ya que las variables pueden cambiar de posiciÃ³n), poniendo el nombre de la tabla seguido del sÃ­mbolo `$` (con el **tabulador**, nos aparecerÃ¡ un menÃº de columnas a elegir)
:::
:::

---

## Segundo intento: data.frame

-   `names()`: nos muestra los nombres de las variables

```{r}
names(tabla)
```

. . .

-   `dim()`: nos muestra las dimensiones (tambiÃ©n `nrow()` y `ncol()`)

```{r}
dim(tabla)
```

. . .

-   Podemos acceder a las variables por su nombre

```{r}
tabla[c(1, 3), "nombre"]
```

---

## Segundo intento: data.frame

Si tenemos uno ya creado y queremos [**aÃ±adir una columna**]{.hl-yellow} es tan simple como usar la funciÃ³n `data.frame()` que ya hemos visto para concatenar la columna. Vamos aÃ±adir por ejemplo una nueva variable, el nÃºmero de hermanos de cada individuo.

```{r}
# AÃ±adimos una nueva columna con nÂº de hermanos/as
hermanos <- c(0, 2, 3)
tabla <- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

---

## Intento final: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}

La principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```

. . .

Â 

De ahora en adelante usaremos el formato `tibble` (un [**data.frame mejorado**]{.hl-yellow})

```{r}
library(tibble)
tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
       "IMC" = peso / (estatura^2))
```

---

## Intento final: tibble

```{r}
tabla <- tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
                "IMC" = peso / (estatura^2))
tabla
```

Las tablas en formato `tibble` nos permitirÃ¡ una [**gestiÃ³n mÃ¡s Ã¡gil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

-   [**MetainformaciÃ³n**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya automÃ¡ticamente el nÃºmero de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

---

## Intento final: tibble

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
tabla$invent
```

. . .

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de pÃ¡ginas web y documentos sencillos
:::


---

## ğŸ’» Tu turno (tibble) {#tu-turno-tibble}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Carga del paquete `{datasets}` el conjunto de datos `airquality` (variables de la calidad del aire de Nueva York desde mayo hasta septiembre de 1973). Â¿Es el conjunto de datos airquality de tipo tibble? En caso negativo, conviÃ©rtelo a tibble (busca en la documentaciÃ³n del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Una vez convertido a `tibble` obtÃ©n el nombre de las variables y las dimensiones del conjunto de datos. Â¿CuÃ¡ntas variables hay? Â¿CuÃ¡ntos dÃ­as se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Filtra solo los datos del mes de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, ]
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Selecciona aquellos datos que no sean ni de julio ni de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month %in% c(7, 8), ]
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Modifica el siguiente cÃ³digo para quedarte solo con las variable de ozono y temperatura.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[, c("Ozone", "Temp")]
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Selecciona los datos de temperatura y viento de agosto. Traduce a castellano el nombre de las columnas del conjunto filtrado.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, c("Temp", "Wind")]
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```
:::

---

## Resumen hasta ahora

-   Cada [**celda puede ser de un tipo diverso**]{.hl-yellow}: nÃºmeros, texto, fechas, valores lÃ³gicos, etc

. . .

-   Un [**vector es una concatenaciÃ³n de celdas**]{.hl-yellow} (las futuras columnas de nuestras tablas) --\> En `R` por defecto las operaciones se hacen [**elemento a elemento**]{.hl-yellow}

. . .

-   Una [**matriz**]{.hl-yellow} nos permite concatenar [**variables del MISMO tipo y MISMA longitud**]{.hl-yellow} --\> objeto bidimensional (dos Ã­ndices)

. . .

-   Un [**data.frame**]{.hl-yellow} nos permite concatenar [**variables de DISTINTO tipo y MISMA longitud**]{.hl-yellow} --\> usaremos [**tibble**]{.hl-yellow} como una opciÃ³n mejorada de base de datos

---


## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-3a}

Del paquete `Biostatistics` usaremos el conunto de datos `pinniped`

```{r}
#| eval: false
Biostatistics::pinniped
```


1. Â¿QuÃ© [**representan**]{.hl-yellow} los datos? Â¿QuÃ© [**tipo de dato**]{.hl-yellow} es? En caso de que no lo sea, convierte la base de datos a un `tibble` (renombra con `pinniped_tb`)

```{r}
#| code-fold: true
#| eval: false
? Biostatistics::pinniped
```

```{r}
#| code-fold: true
class(Biostatistics::pinniped) # no es un tibble
pinniped_tb <- as_tibble(Biostatistics::pinniped)
```

. . .

2. Â¿CuÃ¡ntos registros hay? Â¿Y variables? Â¿De quÃ© tipo es cada una?


```{r}
#| code-fold: true
nrow(pinniped_tb)
ncol(pinniped_tb)
```


---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-3a-2}


3. Incorpora una [**variable extra llamada phoca**]{.hl-yellow} que sea de tipo lÃ³gico y que nos diga si una especie es de la categorÃ­a `Phoca` o no.

```{r}
#| code-fold: true
pinniped_tb$phoca <- pinniped_tb$Species == "Phoca"
```

. . .

4. Â¿A quÃ© sexo le [**pesa mÃ¡s el cerebro**]{.hl-yellow}: a las hembras o a los machos? Â¿A quienes les [**pesa mÃ¡s el cuerpo**]{.hl-yellow}: a los monÃ³gamos o a los polÃ­gamos?

```{r}
#| code-fold: true
# Â¿a quiÃ©n le pesa mÃ¡s el cerebro?
mean(pinniped_tb$Male_brain_g, na.rm = TRUE) >
  mean(pinniped_tb$Female_brain_g, na.rm = TRUE)

# Â¿a quiÃ©n le pesa mÃ¡s el cerebro?
mean(c(pinniped_tb$Male_mass_Kg[pinniped_tb$Mate_type == "mono"],
       pinniped_tb$Female_mass_Kg[pinniped_tb$Mate_type == "mono"])) >
  mean(c(pinniped_tb$Male_mass_Kg[pinniped_tb$Mate_type == "poly"],
         pinniped_tb$Female_mass_Kg[pinniped_tb$Mate_type == "poly"]))
```

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-3a-3}


5. Incopora una nueva variable que represente la [**diferencia entre el peso del cerebro entre machos y hembras**]{.hl-yellow} (machos - hembras) para cada especie.

```{r}
#| code-fold: true
pinniped_tb$dif_m_f <- pinniped_tb$Male_brain_g - pinniped_tb$Female_brain_g
pinniped_tb
```



# Clase 4: comunicar {#clase-4}

[**Comunicar resultados: rmd y Quarto**]{style="color:#444442;"}

---

## Comunicar: rmd y Quarto

Una de las [**principales fortalezas**]{.hl-yellow} de `R` es la [**facilidad para generar informes, libros, webs, apuntes y hasta diapositivas**]{.hl-yellow} (este mismo material por ejemplo). Para ello [**instalaremos**]{.hl-purple} antes

::: columns
::: {.column width="40%"}
-   el paquete `{rmarkdown}` (para generar archivos `.rmd`)

```{r}
#| eval: false
install.packages("rmarkdown")
```

-   instalar [**Quarto**](https://quarto.org/docs/get-started/) (el Â«nuevoÂ» `.rmd` ahora como `.qmd`)
:::

::: {.column width="60%"}
![](img/quarto.png)
:::
:::

---

## Comunicar: rmd y Quarto

Hasta ahora solo hemos programado en scripts (archivos `.R`) dentro de proyectos, pero en muchas ocasiones [**no trabajaremos solos**]{.hl-yellow} y necesitaremos [**comunicar los resultados**]{.hl-yellow} en diferentes formatos:

-   apuntes (para nosotros mismos)
-   diapositivas
-   web
-   informes

. . .
 
Para todo ello usaremos [**Quarto (nuevo rmarkdown)**]{.hl-yellow}


---

## Comunicar: rmd y Quarto

Los archivos de extensiÃ³n `.qmd` (o `.rmd`) nos permitirÃ¡n fÃ¡cilmente combinar:

-   [**Markdown**]{.hl-yellow}: [**lenguaje tipado**]{.hl-purple} que nos permite crear contenido simple (tipo wordpress, con texto, **negritas**, _cursivas_, etc) con un diseÃ±o legible.

. . .

-   [**MatemÃ¡ticas (latex)**]{.hl-yellow}: lenguaje para escribir notaciÃ³n matemÃ¡tica como $x^2$ o $\sqrt{y}$ o $\int_{a}^{b} f(x) dx$

. . .

-   [**CÃ³digo y salidas**]{.hl-yellow}: podremos no solo mostrar el paso final sino el cÃ³digo que has ido realizando (no solo en `R`), con [**cajitas de cÃ³digo llamadas chunks**]{.hl-purple}.

. . .

-   ImÃ¡genes, [**grÃ¡ficas**]{.hl-yellow}, tablas, estilos (css, js), etc.

---

## Comunicar: rmd y Quarto

La principal ventaja de realizar este tipo de material en Quarto/Rmarkdown es que, al hacerlo desde `RStudio`, puedes generar un [**informe o una presentaciÃ³n sin salirte del entorno de programaciÃ³n**]{.hl-yellow} en el que estÃ¡s trabajando

De esta forma podrÃ¡s analizar los datos, resumirlos y a la vez comunicarlos con la misma herramienta.

. . .

Recientemente el equipo de `RStudio` desarrollÃ³ [**Quarto**]{.hl-yellow}, una versiÃ³n mejorada de Rmarkdown (archivos `.qmd`), con un formato un poco mÃ¡s estÃ©tico y simple. Tienes toda la documentaciÃ³n y ejemplos en [**https://quarto.org/**](https://quarto.org/)

---

## Nuestro primer informe

::: columns
::: {.column width="55%"}
![](img/quarto-create.png)
:::

::: {.column width="45%"}
Vamos a crear el [**primer fichero rmarkdown con Quarto**]{.hl-yellow} con extensiÃ³n `.qmd`. Para ello solo necesitaremos hacer click en

`File << New File << Quarto Document`
:::
:::

---

## Nuestro primer informe

:::: columns
::: {.column width="45%"}
![](img/quarto-format.png)
:::

::: {.column width="55%"}
Tras hacerlo nos aparecerÃ¡n varias [**opciones de formatos de salida**]{.hl-yellow}:

-   archivo `.pdf`
-   archivo `.html` ([**recomendable**]{.hl-yellow}): documento dinÃ¡mico, permite la interacciÃ³n con el usuario, como una Â«pÃ¡gina webÂ».
-   archivo `.doc` (nada recomendable)
:::
::::

. . .

De momento dejaremos marcado el [**formato HTML que viene por defecto**]{.hl-yellow}, y escribiremos el [**tÃ­tulo**]{.hl-yellow} de nuestro documento. Tras ello tendremos nuestro [**archivo .qmd**]{.hl-yellow} (ya no es un script .R como los que hemos abierto hasta ahora).

---

## Nuestro primer informe

:::: columns
::: {.column width="60%"}
![](img/quarto-example.png)
:::

::: {.column width="40%"}

DeberÃ­as tener algo similar a la captura de la imagen con [**dos modos de ediciÃ³n**]{.hl-yellow}: `Source` (con cÃ³digo, la opciÃ³n recomendada hasta que lo domines) y `Visual` (mÃ¡s parecido a un blog)

:::
::::

Para [**ejecutar TODO el documento**]{.hl-yellow} debes clickar `Render on Save` y darle a guardar.

## Cabecera de un qmd

![](img/quarto-prueba-html.png)

DeberÃ­as haber obtenido una [**salida en html similar a esta**]{.hl-yellow} (y se te ha generado en tu ordenador un [**archivo html**]{.hl-yellow})

---

## Nuestro primer informe

:::: columns
::: {.column width="50%"}
![](img/quarto-example.png)

:::

::: {.column width="50%"}

Un fichero `.qmd` se [**divide bÃ¡sicamente en tres partes**]{.hl-yellow}:

* [**Cabecera**]{.hl-yellow}: la parte que tienes al inicio entre `---`.

* [**Texto**]{.hl-yellow}: que podremos formatear y mejorar con negritas (escrito como **negritas**, con doble astÃ©risco al inicio y final), cursivas (_cursivas_, con barra baja al inicio y final) o destacar nombres de funciones o variables de R. Puedes aÃ±adir ecuaciones como $x^2$ (he escrito `$x^2$`, entre dÃ³lares).

* [**CÃ³digo R**]{.hl-yellow}

:::
::::

---

## Cabecera de un qmd

La [**cabecera estÃ¡n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento:

:::: columns
::: {.column width="30%"}
![](img/quarto-cabecera.png)
:::

::: {.column width="70%"}

* `title` y `subtitle`: el tÃ­tulo/subtÃ­tulo del documento
* `author`: autor del mismo
* `date`: fecha
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes algÃºn archivo de estilos
  * `toc`: si quieres Ã­ndice o no
  * `toc-location`: posiciÃ³n del Ã­ndice
  * `toc-title`: tÃ­tulo del Ã­ndice
  * `toc-depth`: profundidad del Ã­ndice
* `editor`: si estÃ¡s en modo visual o source.

:::
::::

---

## Texto de un qmd

Respecto a la escritura solo hay una [**cosa importante**]{.hl-yellow}: salvo que indiquemos lo contrario, [**TODO lo que vamos a escribir es texto (normal)**]{.hl-yellow}. No cÃ³digo R.

:::: columns
::: {.column width="35%"}
![](img/quarto-prueba-qmd2.png){width=350}
![](img/quarto-prueba-html2.png){width=320}
:::

::: {.column width="65%"}
Vamos a empezar escribiendo una secciÃ³n al inicio (`# Intro` y detrÃ¡s por ej. la frase

> Este material ha sido diseÃ±ado por el profesor Javier Ãlvarez LiÃ©bana, docente en la Universidad Complutense de Madrid

AdemÃ¡s al `Running Code` le aÃ±adiremos una almohadilla `#`: las [**almohadillas FUERA DE CHUNKS**]{.hl-yellow} nos servirÃ¡n para crear [**epÃ­grafes (secciones)**]{.hl-yellow} en el documento


:::
::::


---

## Ãndice de un qmd

:::: columns
::: {.column width="40%"}
![](img/quarto-indice-qmd-2.png){width=370}
![](img/quarto-indice-html2.png){width=370}
:::

::: {.column width="60%"}
Para que el [**Ã­ndice capture dichas secciones**]{.hl-yellow} modificaremos la cabecera del archivo como se observa en la imagen (puedes cambiar la localizaciÃ³n del Ã­ndice y el tÃ­tulo si quieres para probar).

:::
::::

---

## Texto en un qmd

Vamos a [**personalizar un poco el texto**]{.hl-yellow} haciendo lo siguiente:


:::: columns
::: {.column width="50%"}
![](img/quarto-texto-mejorado-qmd.png){width=370}
![](img/quarto-texto-mejorado-html.png){width=370}
:::

::: {.column width="50%"}
* Vamos a aÃ±adir [**negrita al nombre**]{.hl-yellow} (poniendo ** al inicio y al final).

* Vamos aÃ±adir [**cursiva**]{.hl-yellow} a la palabra material (poniendo _ al inicio y al final).

* Vamos aÃ±adir un [**enlace**]{.hl-yellow} <https://www.ucm.es>, asociÃ¡ndolo al nombre de la Universidad. Para ello el tÃ­tulo lo ponemos entre corchetes y justo detrÃ¡s el enlace entre parÃ©ntesis `[Â«Universidad Complutense de MadridÂ»](https://www.ucm.es)`

:::
::::

---

## CÃ³digo en un qmd

Para [**aÃ±adir cÃ³digo R**]{.hl-yellow} debemos crear nuestras [**cajas de cÃ³digo llamadas chunks**]{.hl-yellow}: altos en el camino en nuestro texto markdown donde podremos incluir cÃ³digo de casi cualquier lenguaje (y sus salidas).

&nbsp;

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-qmd.png){width=470}
:::

::: {.column width="50%"}

Para incluir uno deberÃ¡ de ir [**encabezado**]{.hl-yellow} de la siguiente forma tienes un atajo `Command + Option + I` (Mac) o `Ctrl + Shift + I` (Windows)
:::

::::

---

## CÃ³digo en un qmd

Dentro de dicha cajita (que tiene ahora otro color en el documento) [**escribiremos cÃ³digo R**]{.hl-yellow} como lo venÃ­amos haciendo hasta ahora en los scripts.

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-1-qmd.png){width=410}
![](img/quarto-chunk-1-html.png){width=410}
:::

::: {.column width="50%"}

 Vamos por ejemplo a definir dos variables y su suma de la siguiente manera, escribiendo dicho cÃ³digo en nuestro `.qmd` (dentro de ese chunk)

```{r}
# CÃ³digo R
x <- 1
y <- 2
x + y
```

:::

::::


---

## Etiquetando chunks


:::: columns
::: {.column width="50%"}
![](img/quarto-tag-chunks-qmd.png){width=400}
![](img/quarto-tag-chunks-html.png){width=400}
:::

::: {.column width="50%"}
Los chunks pueden tener un [**nombre o etiqueta**]{.hl-yellow}, de forma que podamos referenciarlos de nuevo para no repetir cÃ³digo.
:::
::::


---

## Ejecutando chunks

:::: columns
::: {.column width="40%"}
![](img/quarto-inline-qmd.png){width=400}
![](img/quarto-inline-html.png){width=380}
:::

::: {.column width="60%"}
En cada chunk aparecen [**dos botones**]{.hl-yellow}:

* botÃ³n de [**play**]{.hl-yellow}: activa la [**ejecuciÃ³n y salida de ese chunk particular**]{.hl-yellow} (lo puedes visualizar dentro de tu propio `RStudio`)

* botÃ³n de [**rebobinar**]{.hl-yellow}: activa la [**ejecuciÃ³n y salida de todos los chunk hasta ese**]{.hl-yellow} (sin llegar a Ã©l)

&nbsp;

AdemÃ¡s podemos [**incluir cÃ³digo R dentro de la lÃ­nea de texto**]{.hl-yellow} (en lugar de mostrar el texto x ejecuta el cÃ³digo R mostrando la variable).
:::
::::



---

## PersonalizaciÃ³n de chunks

Los [**chunks podemos personalizarlos**]{.hl-yellow} con opciones al inicio del chunk precedido de `#|`:

* `#| echo: false`: [**ejecuta cÃ³digo**]{.hl-green} y se [**muestra resultado**]{.hl-green} pero [**no visualiza cÃ³digo**]{.hl-red} en la salida.

* `#| include: false`: [**ejecuta cÃ³digo**]{.hl-green} pero [**no muestra resultado**]{.hl-red} y [**no visualiza cÃ³digo**]{.hl-red} en la salida.

* `#| eval: false`: [**no ejecuta cÃ³digo**]{.hl-red}, [**no muestra resultado**]{.hl-red} pero [**sÃ­ visualiza cÃ³digo**]{.hl-green} en la salida.

* `#| message: false`: [**ejecuta cÃ³digo**]{.hl-green} pero [**no muestra mensajes de salida**]{.hl-red}.

* `#| warning: false`: [**ejecuta cÃ³digo**]{.hl-green} pero [**no muestra mensajes de warning**]{.hl-red}.

* `#| error: true`: [**ejecuta cÃ³digo**]{.hl-green} y [**permite que haya errores**]{.hl-green} mostrando el mensaje de error en la salida.


![](img/quarto-options-chunk.png){width=380}

Estas opciones podemos aplicarlas chunk a chunk o fijar los parÃ¡metros de forma global con `knitr::opts_chunk$set()` al inicio del documento (dentro de un chunk).

---

## Organizando qmd

AdemÃ¡s de texto y cÃ³digo podemos introducir lo siguiente:

* [**Ecuaciones**]{.hl-yellow}: puedes aÃ±adir ademÃ¡s ecuaciones como $x^2$ (he escrito `$x^2$`, la ecuaciÃ³n entre dÃ³lares).

* [**Listas**]{.hl-yellow}: puedes itemizar elementos poniendo `*`

`* Paso 1: ...`

`* Paso 2: ...`

* [**Cross-references**]{.hl-yellow}: puedes etiquetar partes del documento (la etiqueta se construye con `{#nombre-seccion}`) y llamarlas luego con `[SecciÃ³n](@nombre-seccion)`

---

## GrÃ¡ficas/imÃ¡genes en qmd

:::: columns
::: {.column width="50%"}
![](img/quarto-fig-qmd.png){width=340}
![](img/quarto-fig-html.png){width=390}
:::

::: {.column width="50%"}
Por Ãºltimo, tambiÃ©n podemos [**aÃ±adir pies de grÃ¡ficas o imÃ¡genes**]{.hl-yellow} aÃ±adiendo `#| fig-cap: "..."`
:::
::::

. . .

:::: columns
::: {.column width="65%"}
FÃ­jate que el [**caption estÃ¡ en el margen**]{.hl-yellow} (por ejemplo). Puedes cambiarlo introduciendo [**ajustes en la cabecera**]{.hl-yellow} (todo lo relativo a figuras empieza por `fig-`, y puedes ver las opciones tabulando). Tienes mÃ¡s informaciÃ³n en **<https://quarto.org/>**
:::

::: {.column width="35%"}
![](img/quarto-cabecera-desplegable.png){width=400}
:::
::::

---

## AÃ±adir estilos

:::: columns
::: {.column width="50%"}
![](img/quarto-estilos-qmd.png){width=400}
![](img/quarto-estilos-html.png){width=400}
:::

::: {.column width="50%"}
Por Ãºltimo puedes aÃ±adir un [**tema personalizado**]{.hl-yellow} incluyendo un [**archivo de estilos**]{.hl-yellow} (archivo en formato `.scss` o `.css`). Te he dejado uno en <https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material>.

::: callout-important
## Importante

El archivo de estilos debe estar en la misma carpeta que el archivo `.qmd`
:::
:::
::::

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-3a}

Elabora informes `.qmd` tal que


* Crea un archivo por cada uno de los [**casos prÃ¡cticos de los anteriores temas**]{.hl-yellow}, uno por tema

. . .

* En cada uno de ellos haz [**una secciÃ³n por ejercicio**]{.hl-yellow}

. . .

* [**Detalla todos los pasos**]{.hl-yellow} que consideres mezclando texto, cÃ³digo y salidas

. . .

* Si aparecen medidas estadÃ­sticas como la media, [**prueba a meter fÃ³rmulas**]{.hl-yellow} con `$$` (busca informaciÃ³n de cÃ³mo introducir ecuaciones en latex)

. . .

* Para avanzados: investiga las opciones del paquete `{DT}` (con la funciÃ³n `datatable()`) que nos permite [**introducir dentro de los `.qmd` los datos en formato de tabla dinÃ¡mica**]{.hl-yellow}, permitiendo ordenar y filtrar.



# Clase 5: entrega I {#entrega-i}

[**Primera entrega individual en clase**]{style="color:#444442;"}

---

## Entrega I (26/09/2023)

Se actualizarÃ¡ al inicio de la clase correspondiente.

::: callout-important

## Importante

Esta [**entrega ponderarÃ¡ un 5% en la nota final**]{.hl-green}

PodrÃ¡s [**usar todo el material del curso e internet**]{.hl-yellow} salvo cualquier aplicaciÃ³n de mensajerÃ­a o sistema de comunicaciÃ³n: en caso de tener alguna abierta a lo largo de la entrega, aunque no se estÃ© usando, deberÃ¡s [**abandonar la entrega y contarÃ¡ como un 0**]{.hl-red}.

ContarÃ¡s con aproximadamente 90 minutos, pero [**deberÃ¡s realizar la entrega**]{.hl-yellow}, como tarde, a las [**14:40**]{.hl-yellow}. SerÃ¡ [**obligatorio subir tanto el `.qmd` como el `.html`**]{.hl-yellow}: una entrega que no haya podido ser renderizada (es decir, con errores graves) serÃ¡ [**penalizada contando solo un 65% de la nota obtenida**]{.hl-red} (si la entrega es perfecta, la nota mÃ¡xima serÃ¡ un 6.5 sino se adjunta el `.html` generado).

Te recomiendo practicar bastante y preguntar dudas en clase y/o tutorÃ­a ya que [**irÃ¡s justo de tiempo**]{.hl-yellow}, asÃ­ que necesitas fluidez en los ejercicios.

Si usas un [**pc de la biblioteca**]{.hl-yellow} asegÃºrate de tomarlo con suficiente antelaciÃ³n para [**instalar todas las librerÃ­as necesarias antes de empezar**]{.hl-yellow} para no perder tiempo.

:::


# Clase 6: tidydata {#clase-6}

[**Nuestra base de datos: tibble. Tidydata: un multiverso de datos limpios**]{style="color:#444442;"}

---

## Previously, in Breaking Bad...

Nuestro [**formato final de base de datos**]{.hl-yellow} serÃ¡ el objeto de tipo `tibble`, un `data.frame` mejorado

```{r}
library(tibble)
tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
```

-   [**MetainformaciÃ³n**]{.hl-yellow}: en la cabecera nos dice ya automÃ¡ticamente el nÃºmero de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

. . .

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

. . .

-   [**Por filas**]{.hl-yellow}: permite crear por filas con `tribble()`

---

## Previously, in Breaking Bad...

Para definir un `tibble()` nosotro mismos tenemos dos opciones:

* [**Concatenando vectores**]{.hl-yellow} que ya tengamos definidos, haciendo uso de la funciÃ³n `tibble()` del paquete `{tibble}` (ya incluido en `{tidyverse}`)

```{r}
estatura <- c(1.7, 1.8, 1.6)
peso <- c(80, 75, 70)
IMC <-  peso / (estatura^2)
tibble("estatura" = estatura, "peso" = peso,
       "IMC" = IMC)
```

---

## Previously, in Breaking Bad...

* [**Directamente en tibble**]{.hl-yellow} proporcionando manualmente valores y nombres de variables

```{r}
tibble("estatura" = c(1.7, 1.8, 1.6),
       "peso" = c(80, 75, 70),
       "IMC" = peso / (estatura^2))
```

---


## R base vs Tidyverse

Si conoces algÃºn otro lenguaje de programaciÃ³n (o tienes gente cercana que programa) te extraÃ±arÃ¡ que aÃºn no hayamos hablado de conceptos habituales como

-   [**Bucles for**]{.hl-yellow}: repetir un cÃ³digo un nÃºmero fijo de iteraciones.

-   [**Bucles while**]{.hl-yellow}: repetir un cÃ³digo hasta que se cumpla una condiciÃ³n

-   [**Estructuras if-else**]{.hl-yellow}: estructuras de control para decidir por donde camina el cÃ³digo en funciÃ³n del valor de las variables.

. . .

Y aunque conocer dichas estructuras puede sernos en algÃºn momento interesante, en la [**mayorÃ­a de ocasiones vamos a poder evitarlas**]{.hl-red} (en especial los bucles)

---

## Â¿QuÃ© es tidyverse?

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

`{tidyverse}` es un [**Â«universoÂ» de paquetes**]{.hl-yellow} para garanatizar un flujo de trabajo (de inicio a fin) eficiente, coherente y lexicogrÃ¡ficamente sencillo de entender, basado en la idea de que [**nuestros datos estÃ¡n limpios y ordenados (tidy)**]{.hl-purple}

---

## Â¿QuÃ© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: optimizando data.frame
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: gramÃ¡tica para depurar
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualizaciÃ³n de datos
-   `{tidymodels}`: modelizaciÃ³n/predicciÃ³n
:::
:::

TambiÃ©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.

---

## Â¿QuÃ© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: gramÃ¡tica para depurar
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualizaciÃ³n de datos
-   `{tidymodels}`: modelizaciÃ³n/predicciÃ³n
:::
:::

TambiÃ©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.

---

## FilosofÃ­a base: tidy data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

El [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducido por **Hadley Wickham** (el Dios al que rezo) de [**estandarizar**]{.hl-yellow} el formato los datos para

::: incremental
-   [**sistematizar**]{.hl-green} la depuraciÃ³n
-   hacer mÃ¡s [**sencillo**]{.hl-green} su manipulaciÃ³n.
-   cÃ³digo [**legible**]{.hl-green}
:::

---

## Reglas del tidy data

Lo primero por tanto serÃ¡ entender quÃ© son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos estÃ¡n estandarizados.

::: columns
::: {.column width="50%"}
::: {.fragment .fade-in}
1.  Cada [**variable**]{.hl-yellow} en una [**Ãºnica columna**]{.hl-purple}
:::

::: {.fragment .fade-in}
2.  Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}
:::

::: {.fragment .fade-in}
3.  Cada [**celda**]{.hl-yellow} con un [**Ãºnico valor**]{.hl-purple}
:::

::: {.fragment .fade-in}
4.  Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5.  Si queremos cruzar [**mÃºltiples tablas**]{.hl-yellow} debemos tener una [**columna comÃºn**]{.hl-purple}
:::
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
:::

---

## TuberÃ­a (pipe)

En `{tidyverse}` serÃ¡ clave el [**operador pipe (tuberÃ­a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): serÃ¡ una [**tuberÃ­a que recorre los datos**]{.hl-yellow} y los transforma.

. . .

::: columns
::: {.column width="50%"}
En R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, serÃ­a

```{r}
#| eval: false
third(second(first(datos)))
```
:::

::: {.column width="50%"}
En `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones

```{r}
#| eval: false
datos |> first() |> second() |> third()
```
:::
:::

Â 

. . .

::: callout-caution
## Apunte importante

Desde la versiÃ³n 4.1.0 de `R` disponemos de `|>`, un pipe **nativo** disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que dependÃ­a del paquete `{magrittr}` (bastante problemÃ¡tico).
:::

---

## TuberÃ­a (pipe)

La principal ventaja es que el [**cÃ³digo sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas cÃ³digo.

Â 

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::

::: {.column width="50%"}
<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
:::

---

## Datos SUCIOS: messy data

Â¿Pero quÃ© aspecto tienen los [**datos no tidy**]{.hl-yellow}? Vamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).

Â 

```{r}
library(tidyr)
table4a
```

Â 

[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="40%"}
```{r}
table4a
```
:::

::: {.column width="60%"}
â Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) â†’ las columnas `1999` y `2000` en realidad deberÃ­an ser en sÃ­ [**valores de una variable**]{.hl-yellow} y no nombres de columnas.
:::
:::

. . .

Incluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el aÃ±o y otra que guarde el valor de la variable de interÃ©s en cada uno de esos aÃ±os. Y lo haremos con la funciÃ³n `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="50%"}
```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
               values_to = "cases")
```
:::

::: {.column width="50%"}
![](img/table4a.jpg)
:::
:::

Â 

-   `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}
-   `names_to`: nombre de la nueva variable a la quemandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).
-   `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table2`

Â 

```{r}
table2
```

Â 

[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_wider()

::: columns
::: {.column width="60%"}
```{r}
#| echo: false
table2
```
:::

::: {.column width="40%"}
â Cada [**observaciÃ³n estÃ¡ dividido en dos filas**]{.hl-red} â†’ los [**registros con el mismo aÃ±o deberÃ­an ser el mismo**]{.hl-yellow}
:::
:::

. . .

Lo que haremos serÃ¡ lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table3`


```{r}
table3
```


[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Separar: separate()

::: columns
::: {.column width="60%"}
```{r}
table3
```
:::

::: {.column width="40%"}
â Cada [**celda contiene varios valores**]{.hl-red}
:::
:::

. . .

Lo que haremos serÃ¡ hacer uso de la funciÃ³n `separate()` para mandar [**separar cada valor**]{.hl-yellow} a una columna diferente.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

---

## Separar: separate()

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

FÃ­jate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deberÃ­an ser variables numÃ©ricas. Para ello podemos aÃ±adir el argumento opcional `convert = TRUE`

. . .

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

---

## Datos SUCIOS: messy data

Veamos el Ãºltimo ejemplo con la tabla `table5`


```{r}
table5
```


[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Unir unite()

::: columns
::: {.column width="50%"}
```{r}
table5
```
:::

::: {.column width="50%"}
â Tenemos [**mismos valores divididos en dos columnas**]{.hl-red}
:::
:::

. . .

Usaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y aÃ±o en una misma columna

```{r}
table5 |> unite(col = year_completo, century, year, sep = "")
```

---

## ğŸ’» Tu turno {#tu-turno-6}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. Â¿Es tidydata? En caso negativo, Â¿quÃ© falla? Â¿CÃ³mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Echa un vistazo a la tabla `relig_income` del paquete `{tidyr}`. Â¿Es tidydata? En caso negativo, Â¿quÃ© falla? Â¿CÃ³mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused",
               names_to = "income",
               values_to = "people")
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. Â¿Es tidydata? En caso negativo, Â¿quÃ© falla? Â¿CÃ³mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```

:::

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-6}

En el paquete `{tidyr}` contamos con el dataset `who` (dataset de la OrganizaciÃ³n Mundial de la Salud)

```{r}
#| eval: false
library(tidyr)
who
```


1. Â¿QuÃ© [**significan los datos**]{.hl-yellow}? Â¿CuÃ¡ntas [**variables y observaciones**]{.hl-yellow} tenemos?

. . .


2. Â¿CuÃ¡ntos [**tipos de variables**]{.hl-yellow} tenemos?


. . .


3. Â¿Todas las variables son necesarias? [**Elimina la informaciÃ³n redundante**]{.hl-yellow}.

. . .

4. [**Convierte a tidydata**]{.hl-yellow} la base de datos realizando todas las opciones que consideres (consejo: usa papel y boli para bocetar como deberÃ­a quedar la base de datos).




# Clase 7: importar y exportar {#clase-7-importar}

[**Repasando tidydata. Importar/exportar datos en R**]{style="color:#444442;"}

---


## ğŸ£ Caso prÃ¡ctico (anterior)

En el paquete `{tidyr}` contamos con el dataset `who` (dataset de la OrganizaciÃ³n Mundial de la Salud)

```{r}
#| eval: false
library(tidyr)
who
```


1. Â¿QuÃ© [**significan los datos**]{.hl-yellow}? Â¿CuÃ¡ntas [**variables y observaciones**]{.hl-yellow} tenemos?

. . .


2. Â¿CuÃ¡ntos [**tipos de variables**]{.hl-yellow} tenemos?


. . .


3. Â¿Todas las variables son necesarias? [**Elimina la informaciÃ³n redundante**]{.hl-yellow}.

. . .

4. [**Convierte a tidydata**]{.hl-yellow} la base de datos realizando todas las opciones que consideres (consejo: usa papel y boli para bocetar como deberÃ­a quedar la base de datos).


---

## Un poco mÃ¡s de tidydata...

Del paquete `{tidyr}` usaremos el dataset `world_bank_pop`, que almacena la poblaciÃ³n de cada paÃ­s y cada aÃ±o, segÃºn el Banco Mundial. [**Convierte a tidydata**]{.hl-yellow}


```{r}
#| code-fold: true
world_bank_pop |> 
  pivot_longer(cols = "2000":"2017",
               names_to = "year",
               values_to = "pop",
               values_drop_na = TRUE)
```


---


## Importar/exportar datos

Hasta ahora solo hemos usado datos cargados ya en paquetes pero muchas veces [**necesitaremos importar datos de manera externa**]{.hl-yellow}. Una de las principales [**fortalezas**]{.hl-yellow} de `R` es que podemos importar datos de manera muy sencilla en distintos formatos:


* [**Formatos nativos de R**]{.hl-yellow}: formatos `.rda`, `.RData` y `.rds`

. . .

* [**Datos rectangulares (tabulados)**]{.hl-yellow}: formatos `.csv` y `.tsv`

. . .

* [**Datos sin tabular**]{.hl-yellow}: formato `.txt`

. . .

* [**Datos en excel**]{.hl-yellow}: formatos `.xls` y `.xlsx`

. . .

* [**Datos desde SAS/Stata/SPSS**]{.hl-yellow}: formatos `.sas7bdat`, `.sav` y `.dat`

. . .

* [**Datos desde API**]{.hl-yellow}: Google Drive, aemet, catastro, twitter, spotify, etc


---

## Formatos nativos de R

Los [**ficheros mÃ¡s simples**]{.hl-yellow} para importar en `R` (y que suele ocupar menos espacio en disco) son sus propias [**extensiones nativas**]{.hl-yellow}: archivos con formatos `.RData`, `.rda` y `.rds`.

. . .

Para cargar los dos primeros simplemente necesitamos [**usar la funciÃ³n nativa**]{.hl-yellow} `load()` indicÃ¡ndole la ruta del archivo.

* Archivo `.RData`: vamos a importar un dataset con las distintas caracterÃ­sticas de los [**viajeros del Titanic**]{.hl-purple}, incluyendo quiÃ©n sobreviviÃ³ y quiÃ©n muriÃ³.


```{r}
#| eval: false
load("./datos/titanic.RData")
as_tibble(titanic)
```

```{r}
#| echo: false
library(tidyverse)
load("./datos/titanic.RData")
as_tibble(titanic) |> slice(1:5)
```


---

## Formatos nativos de R


* Archivo `.rda`: vamos a importar un dataset con [**datos de cÃ¡ncer de pecho**]{.hl-purple} de [**Royston and Altman (2013)**](https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/1471-2288-13-33), incluyendo 2982 pacientes y sus caracterÃ­sticas


```{r}
#| eval: false
load("./datos/rotterdam_breast_cancer.rda")
as_tibble(rotterdam)
```

```{r}
#| echo: false
library(tidyverse)
load("./datos/rotterdam_breast_cancer.rda")
as_tibble(rotterdam) |> slice(1:7)
```


---

## Formatos nativos de R

* Archivo `.rds`: para este tipo debemos usar `readRDS()`, y necesitamos incorporar un [**argumento `file`**]{.hl-yellow} con la ruta. En este caso vamos a importar [**datos de cÃ¡ncer de pulmÃ³n**]{.hl-purple} del North Central Cancer Treatment Group.

```{r}
#| eval: false
lung_cancer <-
  readRDS(file = "./datos/NCCTG_lung_cancer.rds") |> as_tibble()
```

```{r}
#| echo: false
lung_cancer <-
  readRDS(survival::cancer, file = "./datos/NCCTG_lung_cancer.rds") |> 
  as_tibble()
lung_cancer |> slice(1:5)
```

::: callout-important

## Importante

Las [**rutas**]{.hl-yellow} deben ir siempre [**sin espacios, ni eÃ±es, ni tildes**]{.hl-yellow}. Y fÃ­jate que los archivos cargados con `load()` se cargan automÃ¡ticamente en el environment (con el nombre guardado originalmente, sin necesidad de asignarlo a nada), pero las funciones `read()` solo se carga de manera local (sino se guarda, no existe a futuro)

:::

---

## Datos rectangulares: readr

El paquete `{readr}` dentro del entorno `{tidyverse}` contiene distintas funciones Ãºtiles para la [**carga de datos rectangulares (sin formatear)**]{.hl-yellow}.

:::: columns
::: {.column width="50%"}

* `read_csv()`: archivos `.csv` cuyo [**separador sea la coma**]{.hl-purple}
* `read_csv2()`: [**punto y coma**]{.hl-purple}
* `read_tsv()`: [**tabulador**]{.hl-purple}.
* `read_table()`: [**espacio**]{.hl-purple}.
* `read_delim()`: funciÃ³n genÃ©rica para [**archivos delimitados por caracteres**]{.hl-purple}.


:::

::: {.column width="50%"}

![](img/data-import-readr.png)
:::
::::

Todos necesitan como **argumento la ruta del archivo** amÃ©n de **otros opcionales** (saltar o no cabecera, decimales, etc). Ver mÃ¡s en <https://readr.tidyverse.org/>

---

## Datos tabulados (.csv, .tsv)

La principal ventaja de `{readr}` es que [**automatiza el formateo**]{.hl-yellow} para pasar de un archivo plano (sin formato) a un tibble (en filas y columnas, con formato).

. . .

* Archivo `.csv`: con `read_csv()` cargaremos archivos [**separados por coma**]{.hl-purple}, pasando como [**argumento la ruta**]{.hl-yellow} en `file = ...`. Vamos a importar el dataset `chickens.csv` (sobre pollos de dibujos animados, why not). Si te fijas en la salida nos proporciona el tipo de variables.

```{r}
library(readr)
chickens <- read_csv(file = "./datos/chickens.csv")
chickens
```

---

## Datos tabulados (.csv, .tsv)


El [**formato de las variables**]{.hl-yellow} normalmente lo harÃ¡ `read_csv()` de forma [**automÃ¡tica**]{.hl-yellow}, y podemos consultarlo con `spec()`

```{r}
spec(chickens)
```

---

## Datos tabulados (.csv, .tsv)

Aunque lo haga normalmente bien de forma automÃ¡tica podemos [**especificar el formato explÃ­citamente**]{.hl-yellow} en `col_types = list()` (en formato lista, con `col_xxx()` para cada tipo de variable, por ejemplo una la pondremos como cualitativa o factor). 


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_types = list(col_character(), col_factor(), col_double(), col_character()))
chickens
```

---


## Datos tabulados (.csv, .tsv)

Incluso podemos indicar que [**variables que queremos seleccionar**]{.hl-yellow} (sin ocupar memoria), indicÃ¡ndoselo en `col_select = ...`


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_select = c(chicken, sex, eggs_laid))
chickens
```


---


## Datos sin tabular (.txt)


Vamos a usar de nuevo `read_csv()` con el archivo `massey-rating.txt`.

```{r}
datos_txt <- read_csv(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```

. . .

Si te fijas nos interpreta todo como una sola columna: [**no tiene comas el archivo y no sabe por donde separar**]{.hl-yellow}

. . .


Â¿QuÃ© sucede cuando el [**separador no es el correcto**]{.hl-red}?

---

## Datos sin tabular (.txt)

Para ello tenemos

* `read_csv2()` cuando el [**separador sea el punto y coma**]{.hl-yellow}, `read_tsv()` cuando el [**sea un tabulador**]{.hl-yellow} y `read_table()` cuando el [**sea un espacio**]{.hl-yellow}

* `read_delim()` en general

```{r}
datos_txt <- read_table(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```


---

## Datos en excel (.xls, .xlsx)

Otro de los paquetes fundamentales de importaciÃ³n serÃ¡ el paquete  `{readxl}` para [**importar datos desde una Excel**]{.hl-yellow}. Tres funciones serÃ¡n claves:

* `read_xls()` especÃ­fica para `.xls`, `read_xlsx()` especÃ­fica para `.xlsx`
* `read_excel()`: para ambas

. . .

Vamos a importar `deaths.xlsx` con registros de fallecimientos de famosos

```{r}
#| eval: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths |> slice(1:8)
```

---

## Datos en excel (.xls, .xlsx)


```{r}
#| eval: false
deaths
```

```{r}
#| echo: false
deaths |> slice(1:8)
```

Algo por [**desgracia muy habitual**]{.hl-yellow} es que haya [**algÃºn tipo de comentario o texto al inicio**]{.hl-red} del archivo, teniendo que [**saltarnos dichas filas**]{.hl-yellow}.

---

## Datos en excel (.xls, .xlsx)

Podemos [**saltarnos dichas filas**]{.hl-yellow} directamente en la carga con `skip = ...` (indicando el nÃºmero de filas que nos saltamos)

```{r}
#| eval: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths |> slice(1:5)
```

---

## Datos en excel (.xls, .xlsx)

AdemÃ¡s con `col_names = ...` podemos renombrar ya las columnas en la importaciÃ³n (si [**proporcionamos nombres asume la 1Âª lÃ­nea ya como un dato**]{.hl-yellow})

```{r}
#| eval: false
#| code-line-numbers: "3"
deaths <-
  read_xlsx(path = "./datos/deaths.xlsx",
            skip = 5,
            col_names = c("name", "profession", "age", "kids", "birth", "death"))
deaths
```

```{r}
#| echo: false
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 5,
                    col_names = c("name", "profession", "age", "kids", "birth", "death"))
deaths |> slice(1:7)
```
        
---

## Datos en excel (.xls, .xlsx)


En ocasiones las [**fechas de Excel estÃ¡n mal formateadas**]{.hl-red} (sorpresa): podemos hacer uso de `convertToDate()` del paquete `{openxlsx}` para convertirlo


```{r}
#| eval: false
library(openxlsx)
deaths$death <- convertToDate(deaths$death)
deaths
```
   
```{r}
#| echo: false
library(openxlsx)
deaths$death <- convertToDate(deaths$death)
deaths |> slice(1:7)
```

---

## Datos en excel (.xls, .xlsx)

TambiÃ©n podemos [**cargar un Excel con varias hojas**]{.hl-yellow}: para [**indicarle la hoja**]{.hl-yellow} (bien por su nombre bien por su nÃºmero) usaremos el argumento `sheet = ...`

```{r}
#| eval: false
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars
```


```{r}
#| echo: false
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars |> slice(1:5)
```


. . .
 
Incluso podemos indicar el [**rango de celdas**]{.hl-yellow} a cargar con `range = ...`

```{r}
iris <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "iris", range = "C1:E4")
iris
```



---

## Desde SAS/STATA/SPSS

El paquete `{haven}` dentro de la Ã³rbita tidyverse nos permitirÃ¡ [**importar archivos de los 3 software de pago mÃ¡s importantes**]{.hl-yellow}: SAS, SPSS y Stata

```{r}
library(haven)

# SAS
iris_sas <- read_sas(data_file = "./datos/iris.sas7bdat")

# SPSS
iris_spss <- read_sav(file = "./datos/iris.sav")

# Stata
iris_stata <- read_dta(file = "./datos/iris.dta")
```

---

## Exportar

De la misma manera que podemos importar tambiÃ©n podemos [**exportar**]{.hl-yellow}

* exportado en `.RData` (opciÃ³n recomendada para variables guardadas en `R`). Recuerda que esta extensiÃ³n [**solo se podrÃ¡ usar en `R`**]{.hl-yellow}. Para ello nos basta con usar `save(objeto, file = ruta)`

```{r}
tabla <- tibble("a" = 1:4, "b" = 1:4)
save(tabla, file = "./datos/tabla_prueba.RData")
rm(tabla) # eliminar
load("./datos/tabla_prueba.RData")
tabla
```

---


## Exportar

De la misma manera que podemos importar tambiÃ©n podemos [**exportar**]{.hl-yellow}

* exportado en `.RDS` (opciÃ³n recomendada para variables guardadas en `R`). Recuerda que esta extensiÃ³n [**solo se podrÃ¡ usar en `R`**]{.hl-yellow}. Para ello nos basta con usar `saveRDS(objeto, file = ruta)`

```{r}
saveRDS(tabla, file = "tabla.RDS") 
```

---

## Exportar

De la misma manera que podemos importar tambiÃ©n podemos [**exportar**]{.hl-yellow}

* exportado en `.csv`. Para ello nos basta con usar `write_csv(objeto, file = ruta)`

```{r}
write_csv(tabla, file = "./datos/tabla_prueba.csv")
read_csv(file = "./datos/tabla_prueba.csv")
```

---

## Exportar

De la misma manera que podemos importar tambiÃ©n podemos [**exportar**]{.hl-yellow}

* exportado en `.xlsx`. Para ello nos basta con usar `write.xlsx(objeto, file = ruta)` del paquete `{openxlsx}`

```{r}
library(openxlsx)
write.xlsx(tabla, file = "./datos/tabla_prueba.xlsx")
```

---

## Desde web

Una de las principales ventajas de `R` es que podemos hacer uso de todas las funciones anteriores de [**importar pero directamente desde una web**]{.hl-yellow}, sin necesidad de realizar la descarga manual: en lugar de pasarle la ruta local le indicaremos el [**enlace**]{.hl-yellow}. Por ejemplo, vamos a descargar los datos de covid del ISCIII (<https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>)


```{r}
#| eval: false
covid_datos <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
covid_datos
```

```{r}
#| echo: false
covid_datos <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv", n_max = 700)
covid_datos
```

---

## Desde google drive

Otra opciÃ³n disponible (sobre todo si trabajamos con otras personas que trabajan) es [**importar desde una hoja de cÃ¡lculo Google Drive**]{.hl-yellow}, haciendo uso de `read_sheet()` del paquete `{googlesheets4}`

La primera vez te pedirÃ¡ un permiso de tidyverse para interactuar con vuestro drive

```{r}
#| eval: false
library(googlesheets4)
google_sheet <-
  read_sheet("https://docs.google.com/spreadsheets/d/1n_UTbD93-oDJR2r-rsMNff5ro147NL_ZN_vYIA2eJ3Q/edit?usp=sharing")
google_sheet
```

---

## Desde API (owid)

Una opciÃ³n tambiÃ©n muy interesante es la [**carga de datos desde una API**]{.hl-yellow}: un intermediario entre una app o proveedor datos y nuestro `R`. Por ejemplo, vamos a cargar la librerÃ­a `{owidR}`, que nos permite la descarga de datos de la web <https://ourworldindata.org/>. La funciÃ³n `owid_covid()` nos carga sin darnos cuenta mÃ¡s de 300 000 registros con mÃ¡s de 50 variables de 238 paÃ­ses

```{r}
#| eval: false
library(owidR)
owid_covid()
```

```{r}
#| echo: false
#| eval: false
library(owidR)
owid_covid() |> slice(1:5)
```

---

## Desde API (owid)

Este paquete tiene la funciÃ³n `owid_search()` para buscar datasets por palabras clave, por ejemplo, `emissions`, dÃ¡ndonos un dataset con el tÃ­tulo de la base de datos y su id para luego usarla.

```{r}
#| eval: false
as_tibble(owid_search("emissions"))
```

```{r}
#| echo: false
#| eval: false
as_tibble(owid_search("emissions")) |> slice(1:4)
```

. . .

Vamos a pedirle por ejemplo las [**emisiones de la oecd**]{.hl-yellow}

```{r}
#| eval: false
owid("emissions-of-air-pollutants-oecd")
```

```{r}
#| echo: false
#| eval: false
owid("emissions-of-air-pollutants-oecd") |> slice(1:5)
```

---

## Desde API (aemet)

En muchas ocasiones para conectar con la API tendremos antes que [**registrarnos y obtener una clave**]{.hl-yellow}, es el caso del paquete `{climaemet}` para acceder a datos meteorolÃ³gicos (<https://opendata.aemet.es/centrodedescargas/inicio>)


Una vez que tenemos la clave de la API la registramos en nuestro RStudio para poder usarla a futuro


```{r}
library(climaemet)

# Definir la clave
apikey <- "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqYXZhbHYwOUB1Y20uZXMiLCJqdGkiOiI4YTU1ODUxMS01MTE3LTQ4MTYtYmM4OS1hYmVkNDhiODBkYzkiLCJpc3MiOiJBRU1FVCIsImlhdCI6MTY2NjQ2OTcxNSwidXNlcklkIjoiOGE1NTg1MTEtNTExNy00ODE2LWJjODktYWJlZDQ4YjgwZGM5Iiwicm9sZSI6IiJ9.HEMR77lZy2ASjmOxJa8ppx2J8Za1IViurMX3p1reVBU"

aemet_api_key(apikey, install = TRUE, overwrite = TRUE)
```

--- 

## Desde API (aemet)


Con dicho paquete podemos hacer una [**bÃºsqueda de estaciones**]{.hl-yellow} para conocer tanto su cÃ³digo postal como su cÃ³digo identificador dentro de la red AEMET 

```{r}
stations <- aemet_stations()
stations
```

---

## Desde API (aemet)

Por ejemplo, la estaciÃ³n del aeropuerto de El Prat, Barcelona, es el cÃ³digo `"0076"`

```{r}
aemet_last_obs("0076")
```

---

## Desde API (catastro)

TambiÃ©n puedes conectar con la [**API del catrastro**]{.hl-yellow} y buscar por ejemplo por coordenadas

```{r}
#| eval: false
library(CatastRo)
catr_ovc_get_rccoor(lat = 38.61965, lon = -3.45624, srs = "4230")
```

---

## Desde Spotify

Incluso podemos hacer un uso mÃ¡s complejo de las API y bajarnos [**datos de sitios como Twitter o Spotify**]{.hl-yellow} (ver documentaciÃ³n en <https://www.rcharlie.com/spotifyr/>)

```{r}
library(spotifyr)
Sys.setenv(SPOTIFY_CLIENT_ID = "79753b0500d34faaaef8673cc36bcf47")
Sys.setenv(SPOTIFY_CLIENT_SECRET = 'ca2955d430064ce5ba6a158a02a19772')
access_token <- get_spotify_access_token()
```

```{r}
rosalia <- get_artist_audio_features("RosalÃ­a")
as_tibble(rosalia)
```


---


## Desde chess.com

Incluso puedes bajarte [**datos de ajedrez**]{.hl-yellow} de plataformas como <https://chess.com> (y analizarlas)

```{r}
# devtools::install_github("JaseZiv/chessR")
library(chessR)
library(chess)
chess_data <- get_raw_chessdotcom(usernames = "DadosDeLaplace", year_month = c(202301:202303))
tibble::as_tibble(chess_data)
```

---


## ğŸ’» Tu turno {#tu-turno-7}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ El dataset `who` que hemos usado en ejercicios anteriores, expÃ³rtalo a un formato nativo de `R` en la carpeta `datos` del proyecto

```{r}
#| code-fold: true
#| eval: false
library(tidyr)
save(who, file = "./datos/who.RData")
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Carga el dataset `who` pero desde la carpeta de datos (importa el archivo creado en el ejercicio anterior)

```{r}
#| code-fold: true
#| eval: false
load("./datos/who.RData")
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Repite lo mismo (exportar e importar) en 4 formatos: `.csv`, `.xlsx`, `.sav` (spss) y `.dta` (stata)

```{r}
#| code-fold: true
#| eval: false

# csv
library(readr)
write_csv(who, file = "./datos/who.csv")
who_data <- read_csv(file = "./datos/who.csv")

# excel
library(openxlsx)
write.xlsx(who, file = "./datos/who.xlsx")
who_data <- read_xlsx(path = "./datos/who.xlsx")

# sas y stata
library(haven)
write_sav(who, path = "./datos/who.sav")
who_data <- read_spss(path = "./datos/who.sav")

write_dta(who, path = "./datos/who.dta")
who_data <- read_dta(path = "./datos/who.dta")
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Repite la carga del `who.csv` pero solo selecciona ya en la carga las 4 primeras columnas

```{r}
#| code-fold: true
#| eval: false
who_select <-
  read_csv(file = "./datos/who.csv",
           col_select = c("country", "iso2", "iso3", "year"))
```


:::

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-7}


En la carpeta de datos tienes el dataset `breast-cancer-wisconsin-data.csv`. Crea un archivo `.qmd` y personalÃ­zalo incluyendo lo siguiente:

1. Importa el archivo csv a un `tibble`. Â¿Es tidydata? Â¿CuÃ¡ntos pacientes y variables tenemos?

. . .

2. El dataset representa datos de cÃ¡ncer de pecho (`id` identificador, `diagnosis` el diagnÃ³stico maligno/benigno y el resto propiedades del tumor). Usando SOLO LO APRENDIDO, Â¿quÃ© % tenÃ­an un tumor maligno y quÃ© % uno benigno?

. . .

3. Â¿CuÃ¡l de los dos tipos de tumores tienen, de media, un radio mÃ¡s elevado? 

. . .

4. Busca la ayuda de la funciÃ³n `t.test()`. Dicha funciÃ³n nos permite contrastar si la media de dos distribuciones son o no iguales. Â¿Podemos rechazar la hipÃ³tesis nula de que la media del radio sea la misma, bajo una significancia de $\alpha = 0.05$?



# Clase 8: entrega II {#entrega-ii}

[**Segunda entrega individual en clase**]{style="color:#444442;"}

---

## Entrega II (06/10/2023)

Se actualizarÃ¡ al inicio de la clase correspondiente.

::: callout-important

## Importante

Esta [**entrega ponderarÃ¡ un 15% en la nota final**]{.hl-green}

PodrÃ¡s [**usar todo el material del curso e internet**]{.hl-yellow} salvo cualquier aplicaciÃ³n de mensajerÃ­a o sistema de comunicaciÃ³n: en caso de tener alguna abierta a lo largo de la entrega, aunque no se estÃ© usando, deberÃ¡s [**abandonar la entrega y contarÃ¡ como un 0**]{.hl-red}.

ContarÃ¡s con aproximadamente 110 minutos, pero [**deberÃ¡s realizar la entrega**]{.hl-yellow}, como tarde, a las [**12:55**]{.hl-yellow}. SerÃ¡ [**obligatorio subir tanto el `.qmd` como el `.html`**]{.hl-yellow}: una entrega que no haya podido ser renderizada (es decir, con errores graves) serÃ¡ [**penalizada contando solo un 65% de la nota obtenida**]{.hl-red} (si la entrega es perfecta, la nota mÃ¡xima serÃ¡ un 6.5 sino se adjunta el `.html` generado).

Te recomiendo practicar bastante y preguntar dudas en clase y/o tutorÃ­a ya que [**irÃ¡s justo de tiempo**]{.hl-yellow}, asÃ­ que necesitas fluidez en los ejercicios.

Si usas un [**pc de la biblioteca**]{.hl-yellow} asegÃºrate de tomarlo con suficiente antelaciÃ³n para [**instalar todas las librerÃ­as necesarias antes de empezar**]{.hl-yellow} para no perder tiempo.

:::


# Clase 9: tidyverse (filas) {#clase-9}

[**Operaciones con filas**]{style="color:#444442;"}

---


## Â¿QuÃ© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: [**gramÃ¡tica para depurar**]{.hl-yellow}
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualizaciÃ³n de datos
-   `{tidymodels}`: modelizaciÃ³n/predicciÃ³n
:::
:::

TambiÃ©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.


---

## Preprocesamiento: dplyr

Dentro de `{tidyverse}` usaremos el paquete `{dplyr}` para el [**preprocesamiento y depuraciÃ³n**]{.hl-yellow} de datos de datos.

::: columns
::: {.column width="60%"}
![](img/dplyr.png){width=450}
:::

::: {.column width="40%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::
:::

La idea es que el [**cÃ³digo sea legible**]{.hl-yellow}, como si fuese una lista de instrucciones que al leerla nos diga de manera muy evidente lo que estÃ¡ haciendo.

---

## HipÃ³tesis: tidydata

::: columns
::: {.column width="50%"}
Toda la depuraciÃ³n que vamos a realizar es sobre la [**hipÃ³tesis de que nuestros datos estÃ¡n en tidydata**]{.hl-yellow}
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
::::

Recuerda que en `{tidyverse}` serÃ¡ clave el [**operador pipe (tuberÃ­a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): serÃ¡ una [**tuberÃ­a que recorre los datos**]{.hl-yellow} y los transforma.

. . .

Vamos a practicar con el dataset `starwars` del paquete cargado `{dplyr}`

```{r}
#| eval: false
library(tidyverse)
starwars
```

---


## Muestreo

:::: columns
::: {.column width="60%"}

Una de las operaciones mÃ¡s comunes es lo que se conoce en estadÃ­stica como [**muestreo**]{.hl-yellow}: una [**selecciÃ³n o filtrado de registros**]{.hl-yellow} (una submuestra)

:::

::: {.column width="40%"}

![](img/muestreo.jpeg){width=500}
:::
::::

. . .


* [**No aleatorio (por cuotas)**]{.hl-purple}: en base a condiciones lÃ³gicas sobre los registros (`filter()`)

. . .

* [**No aleatorio (intencional/discreccional)**]{.hl-purple}: en base a posiciÃ³n (`slice()`)

. . .

* [**Aleatorio simple**]{.hl-purple} (`slice_sample()`)

. . .

* [**Aleatorio estratificado**]{.hl-purple} (`group_by()` + `slice_sample()`)


---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

El mÃ¡s simple es cuando [**filtramos registros**]{.hl-yellow} en base a alguna condiciÃ³n lÃ³gica: con `filter()` se seleccionarÃ¡n solo individuos que cumplan ciertas condiciones (muestreo no aleatorio por condiciones)


::: incremental
-   `==`, `!=`: [**igual**]{.hl-purple} o [**distinto**]{.hl-yellow} que (`|> filter(variable == "a")`)
-   `>`, `<`: [**mayor**]{.hl-purple} o [**menor**]{.hl-yellow} que (`|> filter(variable < 3)`)
-   `>=`, `<=`: [**mayor o igual**]{.hl-yellow} o [**menor o igual**]{.hl-purple} que (`|> filter(variable >= 5)`)
-   `%in%`: valores [**pertenencen**]{.hl-yellow} a un listado de opciones (`|> filter(variable %in% c("azul", "verde"))`)
-   `between(variable, val1, val2)`: si los valores (continuos) [**caen dentro de un rango**]{.hl-yellow} de valores (`|> filter(between(variable, 160, 180))`)
:::

---

## Filtrar filas: filter()

Dichas [**condiciones lÃ³gicas**]{.hl-yellow} las podemos [**combinar**]{.hl-yellow} de diferentes maneras (y, o, o excluyente)

![](img/tablas_verdad.png)

. . .


::: callout-tip
## Importante

Recuerda que dentro de `filter()` debe ir siempre algo que devuelva un [**vector de valores lÃ³gicos**]{.hl-green}.
:::

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para... [**filtrar**]{.hl-yellow} los personajes de [**ojos marrones**]{.hl-purple}?

. . .

[**Â¿QuÃ© tipo de variable es?**]{.hl-yellow} --> La variable `eye_color` es cualitativa asÃ­ que estÃ¡ representada por textos

. . .

```{r}
#| echo: false
#| include: false
library(tidyverse)
```

```{r}
starwars |>
  filter(eye_color == "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para... [**filtrar**]{.hl-yellow} los personajes que [**no tienen ojos marrones**]{.hl-purple}?

. . .


```{r}
starwars |>
  filter(eye_color != "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para ... [**filtrar**]{.hl-yellow} los personajes que [**tengan los ojos marrones o azules**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color %in% c("blue", "brown"))
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

FÃ­jate que `%in%` es equivalente a concatenar varios `==` con una conjunciÃ³n o (`|`)

```{r}
starwars |>
  filter(eye_color == "blue" | eye_color == "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para ... [**filtrar**]{.hl-yellow} los personajes que [**midan entre 120 y 160 cm**]{.hl-purple}?

. . .

[**Â¿QuÃ© tipo de variable es?**]{.hl-yellow} --> La variable `height` es cuantitativa continua asÃ­ que deberemos filtrar por rangos de valores (intervalos) --> usaremos `between()`

. . .

```{r}
starwars |>
  filter(between(height, 120, 160))
```


---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color == "brown" & species != "Human")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos, o que tengan mÃ¡s de 60 aÃ±os**]{.hl-purple}? PiÃ©nsalo bien: los [**parÃ©ntesis son importantes**]{.hl-yellow}: no es lo mismo $(a+b)*c$ que $a+(b*c)$

. . .

```{r}
starwars |>
  filter((eye_color == "brown" & species != "Human") | birth_year > 60)
```

---

## Eliminar ausentes: drop_na()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  retirar_ausentes(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(var1, var2, ...)
```
:::
:::

Hay un filtro especial para una de las operaciones mÃ¡s habituales en depuraciÃ³n: [**retirar los ausentes**]{.hl-yellow}. Para ello podemos usar dentro de un filtro `is.na()`, que nos devuelve `TRUE/FALSE` en funciÃ³n de si es ausente, o bien ...

. . .

Usar `drop_na()`: si no indicamos variable, elimina registros con ausente en cualquier variable. MÃ¡s adelante veremos como [**imputar esos ausentes**]{.hl-yellow} 

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(mass, height)
```

```{r}
#| echo: false
starwars |>
  drop_na(mass, height, sex) |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na()
```

```{r}
#| echo: false
starwars |>
  drop_na() |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::
:::

---

## ğŸ’» Tu turno {#tu-turno-9a}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Selecciona del conjunto de starwars solo los personajes que sean androides o cuyo valor en `species` sea desconocido

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Droid" | is.na(species))
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Selecciona del conjunto de starwars solo los personajes cuyo peso estÃ© entre 65 y 90 kg.

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(between(mass, 65, 90))
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Tras limpiar de ausentes en todas las variables, selecciona del conjunto de starwars solo los personajes que sean humanos y que vengan de Tatooine

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na() |> 
  filter(species == "Human" & homeworld == "Tatooine")
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Selecciona del conjunto original de starwars los personajes no humanos, `male` en el sexo y que midan entre 120 y 170 cm, o los personajes con ojos marrones o rojos.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter((species != "Human" & sex == "male" &
            between(height, 120, 170)) |
           eye_color %in% c("brown", "red"))
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Busca informaciÃ³n en la ayuda de la funciÃ³n `str_detect()` del paquete `{stringr}` (cargado en `{tidyverse}`). Consejo: prueba antes las funciones que vayas a usar con algÃºn vector de prueba para poder comprobar su funcionamiento. Tras saber lo que hace, filtra solo aquellos personajes con apellido `Skywalker`

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(str_detect(name, "Skywalker"))
```
:::

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice(posiciones)
```
:::
:::

A veces nos puede interesar realizar un [**muestreo no aleatorio discreccional**]{.hl-yellow}, o lo que es lo mismo, [**filtrar por posiciÃ³n**]{.hl-yellow}: con `slice(posiciones)` podremos seleccionar filas concretas pasando como argumento un [**vector de Ã­ndices**]{.hl-yellow}

. . .

::: columns
::: {.column width="50%"}
```{r}
#| eval: false

# fila 1
starwars |>
  slice(1)
```

```{r}
#| echo: false
starwars |> slice(1) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false

# filas de la 7 a la 9
starwars |>
  slice(7:9)
```

```{r}
#| echo: false
starwars |> slice(7:9) |> select(name:hair_color)
```
:::
:::

. . .

```{r}
#| eval: false

# filas 2, 7, 10 y 31
starwars |>
  slice(c(2, 7, 10, 31))
```

```{r}
#| echo: false
starwars |>
  slice(c(2, 7, 10, 31)) |> select(name:sex)
```

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(posiciones)
```
:::
:::

Disponemos de opciones por defecto:

* con `slice_head(n = ...)` y `slice_tail(n = ...)` podemos obtener la [**cabecera y cola**]{.hl-yellow} de la tabla

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_head(n = 2)
```

```{r}
#| echo: false
starwars |> slice_head(n = 2) |> select(name:hair_color)
```
:::

::: {.column width="\"50%"}
```{r}
#| eval: false
starwars |> slice_tail(n = 2)
```

```{r}
#| echo: false
starwars |> slice_tail(n = 2) |> select(name:hair_color)
```
:::
:::

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(posiciones)
```
:::
:::

Disponemos de opciones por defecto:

* con `slice_max()` y `slice_min()` obtenemos la [**filas con menor/mayor valor de una variable**]{.hl-yellow} (si empate, todas salvo que `with_ties = FALSE`) que indicamos en `order_by = ...`

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_min(mass, n = 2)
```

```{r}
#| echo: false
starwars |> slice_min(n = 2, order_by = mass) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_max(height, n = 2)
```

```{r}
#| echo: false
starwars |> slice_max(n = 2, order_by = height) |> select(name:hair_color)
```
:::
:::

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

El conocido como [**muestreo aleatorio simple**]{.hl-yellow} se basa en [**seleccionar individuos aleatoriamente**]{.hl-yellow}, de forma que cada uno tenga ciertas [**probabilidades**]{.hl-yellow} de ser seleccionado. Con `slice_sample(n = ...)` podemos extraer n registros aleatoriamente (a priori equiprobables).

```{r}
starwars |> slice_sample(n = 2)
```

. . .

::: callout-important
## Importante...

[**Â«AleatorioÂ» no implica equiprobable**]{.hl-yellow}: es igual de aleatorio un dado normal que uno trucado. No hay cosas Â«mÃ¡s aleatoriasÂ» que otras, simplemente tienen subyacente distintas leyes de probabilidad.

:::

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

TambiÃ©n podremos indicarle la [**proporciÃ³n de datos a samplear**]{.hl-yellow} (en lugar del nÃºmero) y si queremos que sea [**con reemplazamiento (que se puedan repetir)**]{.hl-yellow}.

```{r}
# 5% de registros aleatorios con reemplazamiento
starwars |> 
  slice_sample(prop = 0.05, replace = TRUE)

```


---


## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

Como decÃ­amos, Â«aleatorioÂ» no es igual que Â«equiprobableÂ», asÃ­ que podemos pasarle un [**vector de probabilidades**]{.hl-yellow}. Por ejemplo, vamos a forzar que sea muy improbable sacar una fila que no sean las dos primeras

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

. . .

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

---

## ParÃ©ntesis: sample()

La funciÃ³n `slice_sample()` es simplemente una integraciÃ³n de `{tidyverse}` de la funciÃ³n bÃ¡sica de `R` conocida como `sample()` que nos permite [**muestrear elementos**]{.hl-yellow}

. . .

Por ejemplo, vamos a [**muestrear 10 tiradas de un dado**]{.hl-yellow}, indicÃ¡ndole

- [**soporte**]{.hl-purple} de nuestra variable aleatorio (valores permitidos en `x`)
- [**tamaÃ±o**]{.hl-purple} muestral (`size`)
- [**reemplazamiento**]{.hl-purple} (si `TRUE` entonces pueden salir repetidas, como en el caso del dado)

```{r}
sample(x = 1:6, size = 10, replace = TRUE)
```

---

## ParÃ©ntesis: sample()

La opciÃ³n anterior lo que genera son sucesos de una variable aleatoria [**equiprobable**]{.hl-yellow} pero al igual que antes, podemos asignarle un vector de probabilidades o [**funciÃ³n de masa**]{.hl-yellow} concreta con el argumento  `prob = ...`

```{r}
sample(x = 1:6, size = 50, replace = TRUE,
       prob = c(0.5, 0.2, 0.1, 0.1, 0.05, 0.05))
```

---


## ParÃ©ntesis: sample()

**Â¿CÃ³mo harÃ­as el siguiente enunciado?**

&nbsp;

Supongamos que en una ciudad se han estudiado episodios de gripe estacional. Sean las variables aleatorias $X_m$ y $X_p$ tal que $X_m=1$ si la madre tiene gripe, $X_m=0$ si la madre no tiene gripe, $X_p=1$ si el padre tiene gripe y $X_p=0$ si el padre no tiene gripe. El modelo teÃ³rico asociado a este tipo de epidemias indica que la distribuciÃ³n conjunta viene dada por $P(X_m = 1, X_p=1)=0.02$, $P(X_m = 1, X_p=0)=0.08$, $P(X_m = 1, X_p=0)=0.1$ y $P(X_m = 0, X_p=0)=0.8$

**Genera una muestra** de tamaÃ±o $n = 1000$ (soporte `"10"`, `"01"`, `"00"` y `"11"`) haciendo uso de `runif()` y haciendo uso de `sample()`

---

## ğŸ’» Tu turno {#tu-turno-9b}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Selecciona solo los personajes que sean humanos y de ojos marrones, para despuÃ©s ordernarlos en altura descendente y peso ascendente.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(eye_color == "brown" & species == "Human") |> 
  arrange(height, desc(mass))
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Extrae 3 registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(n = 3)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Extrae el 10% de los registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(prop = 0.1)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Extrae aleatoriamente 10 personajes pero de forma que la probabilidad de que salga cada uno sea proporcional a su peso (mÃ¡s pesados, mÃ¡s probable)

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass) |> 
  slice_sample(n = 10, weight_by = mass)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Selecciona los 3 personajes mÃ¡s mayores.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_max(birth_year, n = 3)
```


:::


# Clase 10: tidyverse (filas y columnas) {#clase-10-tidyverse-columnas}

[**Operaciones con columnas**]{style="color:#444442;"}

---


## Reordenar filas: arrange()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> ordenar(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(var1, var2, ...)
```
:::
:::

TambiÃ©n podemos [**ordenar filas**]{.hl-yellow} en funciÃ³n de alguna variable con `arrange()`

```{r}
#| eval: false
starwars |> arrange(mass)
```

```{r}
#| echo: false
starwars |> arrange(mass) |> select(name:eye_color) |> slice(1:5) 
```

. . .

Por [**defecto de menor a mayor**]{.hl-yellow} pero podemos [**invertir el orden**]{.hl-purple} con `desc()`

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(desc(height))
```

```{r}
#| echo: false
starwars |> arrange(desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(mass, desc(height))
```

```{r}
#| echo: false
starwars |> arrange(mass, desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::
:::

---

## Eliminar duplicados: distinct()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> sin_duplicados(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> distinct(var1, var2, ...)
```
:::
:::

Muchas veces necesitaremos asegurarnos que no hay duplicados en alguna variable (DNI) y podemos [**eliminar filas duplicadas**]{.hl-yellow} con `distinct()`.

```{r}
starwars |> distinct(sex)
```

. . .

Para mantener todas las columnas de la tabla usaremos `.keep_all = TRUE`.

```{r}
#| eval: false
starwars |> distinct(sex, .keep_all = TRUE)
```

```{r}
#| echo: false
starwars |> distinct(sex, .keep_all = TRUE) |> slice(1:3)
```

---

## AÃ±adir filas: bind_rows()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> encuadernar_filas(tibble2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> bind_rows(tibble2)
```
:::
:::

Por Ãºltimo, podemos [**concatenar nuevas filas**]{.hl-yellow} con `bind_rows()` con [**las nuevas observaciones en tabla**]{.hl-red} (si no cuadran columnas rellena con ausentes)

```{r}
datos <-
  tibble("nombre" = c("javi", "laura"), "edad" = c(33, 50))
datos
```

. . .

```{r}
datos |> bind_rows(tibble("nombre" = c("carlos", NA), "cp" = c(28045, 28019)))
```

---

## ğŸ’» Tu turno {#tu-turno-10a}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Para saber que valores Ãºnicos hay en el color de pelo, elimina duplicados de la variable `hair_color`, eliminando antes los ausentes de dicha variable.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(hair_color) |> 
  distinct(hair_color)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ De los personajes que son humanos y miden mÃ¡s de 160 cm, elimina duplicados en color de ojos, elimina ausentes en peso, selecciona los 3 mÃ¡s altos, y orden de mayor a menor peso. Devuelve la tabla.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Human" & height > 160) |> 
  distinct(eye_color, .keep_all = TRUE) |> 
  drop_na(mass) |> 
  slice_max(height, n = 3) |> 
  arrange(desc(mass))
```
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "2"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "2"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "3"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "3"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "4"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "4"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "5"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "5"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen

La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "6"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "6"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::


--- 

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-10}

Vamos a usar el dataset `biopsy` que podemos encontrar en el agregador de datasets <https://vincentarelbundock.github.io/Rdatasets/index.html>. El [**dataset contiene datos de 699 pacientes a lo que se les realizÃ³ una biopsia de pecho**]{.hl-yellow}, obteniendo 11 variables (una que hace de id y 10 escalas medidas de 1 a 10)

Puedes ver la documentaciÃ³n en <https://vincentarelbundock.github.io/Rdatasets/doc/MASS/biopsy.html>

. . .

1. Crea de cero un [**informe en Quarto**]{.hl-yellow} donde hagas los ejercicios posteriores (usa un archivo de estilos para que quede estÃ©tico)

. . .

2. [**Importa el `.csv` desde la propia web**]{.hl-yellow} (a travÃ©s del enlace del archivo)

. . .

3. HabrÃ¡s visto que hay 12 columnas en realidad importadas (la primera nos sobra ya que es solo un contador de filas). Vuelve a cargarlo [**seleccionando en la carga**]{.hl-yellow} solo desde `ID` hasta `class`

---

## ğŸ£ Caso prÃ¡ctico

4. La variable `ID` en realidad es un identificador (una cualitativa). Repite la carga [**especificando los tipos de datos**]{.hl-yellow}: cualitativa o factor para ID y class, nÃºmeros para el resto de variables)

. . .

5. La variable `ID` deberÃ­a ser identificador de cada registro: [**elimina duplicados**]{.hl-yellow} por dicha variable del dataset anterior.

. . .

6. Del dataset anterior [**filtra**]{.hl-yellow} solo los pacientes con tumor maligno y la variable `V9` con valor 4 o inferior, [**eliminando ademÃ¡s cualquier registro que contenga ausente**]{.hl-yellow} en cualquiera de la variables.

. . .

7. Del dataset anterior obtÃ©n una [**muestra del 20% de los datos**]{.hl-yellow} (cada registro puede ser elegido con la misma probabilidad), y [**Ã³rdenalos**]{.hl-yellow} por de mayor a menor por la variable `V1` y, en caso de empate, de menor a mayor por la variable `V2`

---



## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

La opciÃ³n mÃ¡s sencilla para [**seleccionar variables por nombre**]{.hl-yellow} es `select()`, dando como argumentos los nombres de columnas [**sin comillas**]{.hl-purple}.

```{r}
starwars |> select(name, hair_color)
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

La funciÃ³n `select()` nos permite seleccionar varias variables a la vez, incluso [**concatenando sus nombres como si fuesen Ã­ndices numÃ©ricos**]{.hl-yellow}

```{r}
#| eval: false
starwars |> select(name:eye_color) 
```

```{r}
#| echo: false
starwars |> select(name:eye_color) |> slice(1:4)
```

. . .

Y podemos [**deseleccionar columnas**]{.hl-yellow} con `-` delante

```{r}
#| eval: false
starwars |>  select(-mass, -(eye_color:starships))
```

```{r}
#| echo: false
starwars |> select(-mass, -(eye_color:starships)) |> slice(1:4)
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Tenemos ademÃ¡s [**palabras reservadas**]{.hl-yellow}: `everything()` [**todas las variables**]{.hl-purple}...

```{r}
#| eval: false
starwars |> select(mass, homeworld, everything())
```

```{r}
#| echo: false
starwars |> select(mass, homeworld, everything()) |> slice(1:4)
```

. . .

...y `last_col()` para referirnos a [**la Ãºltima columna**]{.hl-purple}.

```{r}
#| eval: false
starwars |> select(name:mass, homeworld, last_col())
```

```{r}
#| echo: false
starwars |> select(name:mass, homeworld, last_col()) |> slice(1:4)
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

TambiÃ©n podemos jugar con [**patrones**]{.hl-yellow} en el nombre, aquellas que [**comiencen por un prefijo**]{.hl-purple} (`starts_with()`), [**terminen con un sufijo**]{.hl-purple} (`ends_with()`), [**contengan un texto**]{.hl-purple} (`contains()`) o cumplan una [**expresiÃ³n regular**]{.hl-purple} (`matches()`).

```{r}
# variables cuyo nombre acaba en "color" y contengan sexo o gÃ©nero
starwars |> select(ends_with("color"), matches("sex|gender"))
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Incluso podemos [**seleccionar por rango numÃ©rico**]{.hl-yellow} si tenemos variables con un prefijo y nÃºmeros.

```{r}
datos <-
  tibble("semana1" = c(115, 141, 232), "semana2" = c(7, NA, 17),
         "semana3" = c(95, 162, NA), "semana4" = c(11, 19, 15),
         "semana5" = c(NA, 262, 190), "semana6" = c(21, 15, 23))
```

. . .

Con `num_range()` podemos seleccionar con un prefijo y una secuencia numÃ©rica.

```{r}
datos |> select(num_range("semana", 1:4))
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Por Ãºltimo, podemos seleccionar columnas por [**tipo de dato**]{.hl-yellow} haciendo uso de `where()` y dentro una funciÃ³n que devuelva un valor lÃ³gico de tipo de dato.

```{r}
# Solo columnas numÃ©ricas o de texto
starwars |> select(where(is.numeric) | where(is.character))
```


# Clase 11: tidyverse (columnas) {#clase-11-tidyverse-mutate}

[**Columnas. Crear y/o modificar variables. Recodificar variables**]{style="color:#444442;"}


## Mover columnas: relocate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  recolocar(var1, despues_de = var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  relocate(var1, .after = var2)
```
:::
:::

Para facilitar la [**recolocaciÃ³n de variables**]{.hl-yellow} tenemos una funciÃ³n para ello, `relocate()`, indicÃ¡ndole en `.after` o `.before` [**detrÃ¡s**]{.hl-purple} o [**delante**]{.hl-purple} de quÃ© columnas queremos moverlas.

```{r}
starwars |> relocate(species, .before = name)
```

---

## Renombrar: rename()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> renombrar(nuevo = antiguo)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> rename(nuevo = antiguo)
```
:::
:::

A veces tambiÃ©n podemos querer [**modificar la Â«metainformaciÃ³nÂ»**]{.hl-yellow} de los datos, [**renombrando columnas**]{.hl-yellow}. Para ello usaremos de `rename()` poniendo [**primero el nombre nuevo**]{.hl-purple} y luego el [**antiguo**]{.hl-purple}.

```{r}
starwars |> rename(nombre = name, altura = height, peso = mass)
```

---

## Extraer columnas: pull()


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> retirar(var)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> pull(var)
```
:::
:::


Si observas la salida de los `select()` [**sigue siendo una tabla tibble**]{.hl-yellow}, ya que nos preserva la naturaleza de nuestros datos.

```{r}
starwars |> select(name)
```

---


## Extraer columnas: pull()


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> retirar(var)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> pull(var)
```
:::
:::


A veces no querremos dicha estructura sino [**extraer literalmente la columna en un vector**]{.hl-yellow}, algo que podemos hacer con `pull()`

```{r}
starwars |> pull(name)
```


---


## ğŸ’» Tu turno {#tu-turno-10b}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Filtra el conjunto de personajes y quÃ©date solo con aquellos que en la variable `height` no tengan un dato ausente. Con los datos obtenidos del filtro anterior, selecciona solo las variables name, height, asÃ­ como todas aquellas variables que CONTENGAN la palabra color en su nombre.

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detrÃ¡s de la variable de nombres.

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio anterior, comprueba cuÃ¡ntas modalidades Ãºnicas hay en la variable de color de pelo (sin usar `unique()`).

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Del conjunto de datos originales, elimina las columnas de tipo lista, y tras ello elimina duplicados en la variable `eye_color`. Tras eliminar duplicados extrae dicha columna en un vector.


:::

---

## ğŸ£ Caso prÃ¡ctico {#caso-prÃ¡ctico-10b}

Del conjunto de datos original de starwars, con [**solo los personajes cuya altura es conocida**]{.hl-yellow}, [**extrae en un vector dicha variable**]{.hl-purple}.

Tras dicha extracciÃ³n, usa el vector para realizar un [**muestreo estratificado (por sexo) del 50% de los datos**]{.hl-yellow}, de manera que (para cada sexo) la [**probabilidad de cada personaje**]{.hl-yellow} de ser elegido sea [**inversamente proporcional a su altura**]{.hl-yellow} (mÃ¡s bajitos, mÃ¡s opciones)

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

En muchas ocasiones querremos [**modificar o crear variables**]{.hl-yellow} con `mutate()`. 


. . . 

Vamos a crear por ejemplo una nueva variable `height_m` con la altura en metros.

```{r}
starwars |> mutate(height_m = height / 100)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

AdemÃ¡s con los argumentos opcionales podemos [**recolocar la columna modificada**]{.hl-yellow}

```{r}
starwars |> 
  mutate(height_m = height / 100,
         IMC = mass / (height_m^2), .before = name)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

::: callout-important
## Importante...

Cuando aplicamos `mutate()`, debemos de acordarnos que las [**operaciones se realizan de manera vectorial**]{.hl-yellow}, elemento a elemento, por lo que la funciÃ³n que usemos dentro debe devolver un vector de igual longitud. En caso contrario, [**devolverÃ¡ una constante**]{.hl-red}
:::

. . .

```{r}
starwars |> 
  mutate(constante = mean(mass, na.rm = TRUE), .before = name)
```

---

## Recategorizar: if_else()

TambiÃ©n podemos combinar `mutate()` con la expresiÃ³n de control `if_else()` para [**recategorizar la variable**]{.hl-yellow}: si [**se cumple una condiciÃ³n**]{.hl-purple}, hace una cosa, en caso contrario otra.

```{r}
starwars |> 
  mutate(human = if_else(species == "Human", "Human", "Not Human"),
         .after = name) |> 
  select(name:mass)
```

---

## Recategorizar: case_when()

Para [**recategorizaciones mÃ¡s complejas**]{.hl-yellow} tenemos `case_when()`, por ejemplo, para crear una categorÃ­a de los personajes en funciÃ³n de su altura.

```{r}
starwars |> 
  drop_na(height) |> 
  mutate(altura = case_when(height < 120 ~ "enanos",
                            height < 160 ~ "bajito",
                            height < 180 ~ "normal",
                            height < 200 ~ "alto",
                            TRUE ~ "gigante"), .before = name)
```

---

## ğŸ’» Tu turno {#tu-turno-11}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Selecciona solo las variables nombre, altura y asÃ­ como todas aquellas variables relacionadas con el color, a la vez que te quedas solo con aquellos que no tengan ausente en la altura.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(name, height, contains("color")) |> 
  drop_na(height)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(name, height, contains("color")) |> 
  drop_na(height) |> 
  rename(nombre = name, altura = height,
         color_pelo = eye_color, color_piel = skin_color,
         color_pelo = hair_color)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detrÃ¡s de la variable de nombres.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  select(name, height, contains("color")) |> 
  drop_na(height) |> 
  rename(nombre = name, altura = height,
         color_pelo = eye_color, color_piel = skin_color,
         color_pelo = hair_color) |> 
  relocate(color_pelo, .after = nombre)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Con los datos originales, comprueba cuÃ¡ntas modalidades Ãºnicas hay en la variable de color de pelo.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  distinct(hair_color) |> 
  nrow()
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Del dataset original, selecciona solo las variables numÃ©ricas y de tipo texto. Tras ello define una nueva variable llamada `under_18` que nos recategorice la variable de edad: `TRUE` si es menor de edad y `FALSE` en caso contrario

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(where(is.numeric) | where(is.character)) |> 
  mutate(under_18 = birth_year < 18)
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Del dataset original, crea una nueva columna llamada `auburn` (cobrizo/caoba) que nos diga TRUE si el color de pelo contiene dicha palabra y FALSE en caso contrario (reminder `str_detect()`).

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(auburn = str_detect(hair_color, "auburn"))
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Del dataset original, incluye una columna que calcule el IMC. Tras ello, crea una nueva variable que valga `NA` si no es humano, `delgadez` por debajo de 18, `normal` entre 18 y 30, `sobrepeso` por encima de 30.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(IMC = mass / ((height/100)^2),
         IMC_recat = case_when(species != "Human" ~ NA,
                               IMC < 18 ~ "delgadez",
                               IMC < 30 ~ "normal",
                               TRUE ~ "sobrepeso"),
         .after = name)
```

:::

---


## ğŸ£ Caso prÃ¡ctico 11 {#caso-11}


Haciendo uso de todo lo aprendido, vamos a proceder a [**crear una tabla con datos de bebÃ©s**]{.hl-yellow} de tamaÃ±o `n = 20` en donde [**simulemos el sexo de los bebÃ©s y su peso**]{.hl-yellow}

. . .

1. Crea un `tibble` con dos columnas, una llamada `id_bebe` y otra llamada `sexo`. En el primer caso debe ir de 1 a 20. En el segundo caso, simula su sexo de manera que haya un 0.5 de probabilidad de `chico` y 0.5 de `chica`.

. . .

2. Conocido el sexo, crea una tercera columna llamada `peso` en la que simules dicho valor. Supondremos que para los chicos el peso sigue una distribuciÃ³n $N(\mu = 3.266kg, \sigma = 0.514)$ y que para las chicas sigue una distribuciÃ³n $N(\mu = 3.155kg, \sigma = 0.495)$.



# Clase 12: tidyverse (resÃºmenes) {#clase-12-summarise}

[**Summarise y group_by(). Contar y resumir: estadÃ­sticas desagregadas por factores/grupos.**]{style="color:#444442;"}

---


## Contar: count()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
:::

Hasta ahora solo hemos transformado o consultado los datos pero no hemos generado estadÃ­sticas. Empecemos por lo sencillo: [**Â¿cÃ³mo contar (frecuencias)?**]{.hl-yellow}

. . .

Cuando lo usamos en solitario `count()` nos devolverÃ¡ simplemente el nÃºmero de registros , pero cuando lo usamos con variables `count()` calcula lo que se conoce como [**frecuencias**]{.hl-yellow}: [**nÃºmero de elementos de cada modalidad**]{.hl-purple}.

```{r}
starwars |> count(sex)
```

---

## Contar: count()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
:::

AdemÃ¡s si pasamos varias variables nos calcula lo que se conoce como una [**tabla de contigencia**]{.hl-yellow}. Con `sort = TRUE` nos devolverÃ¡ el [**conteo ordenado**]{.hl-purple} (mÃ¡s frecuentes primero).

```{r}
starwars |> count(sex, gender, sort = TRUE)
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Una de las [**funciones mÃ¡s potentes**]{.hl-yellow} a combinar con las acciones vistas es `group_by()`, que nos permitirÃ¡ [**agrupar nuestros registros**]{.hl-yellow} previamente

```{r}
starwars |> 
  group_by(sex) |>
  count() |>
  ungroup()
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Cuando apliquemos `group_by()` es importante entender que [**NO MODIFICA los datos**]{.hl-yellow}, sino que nos crea una [**variable de grupo**]{.hl-yellow} (subtablas por cada grupo) que modificarÃ¡ las acciones futuras: las [**operaciones se aplicarÃ¡n a cada subtabla por separado**]{.hl-purple}

. . .

Por ejemplo, imaginemos que queremos extraer el personaje mÃ¡s alto con `slice_max()`.

```{r}
starwars |> slice_max(height)
```


---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Â¿Y si queremos [**extraer el personaje mÃ¡s alto pero...de cada uno de los sexos**]{.hl-yellow}?

. . .

```{r}
starwars |>
  group_by(sex) |> 
  slice_max(height) |> 
  ungroup()
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

::: columns
::: {.column width="50%"}
![](img/tidydatatutor_1.jpg)
:::

::: {.column width="50%"}
![](img/tidydatatutor_2.jpg)
:::
:::

La web <https://tidydatatutor.com/> permite visualizar las operaciones de `{tidyverse}` (con el pipe antiguo)

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |>
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |>
  ungroup()
```
:::
:::

::: callout-important
## Importante

Recuerda siempre [**hacer ungroup**]{.hl-red} para eliminar la variable de grupo creada
:::

. . .

En la nueva versiÃ³n de `{dplyr}` ahora se [**permite incluir la variable de grupo**]{.hl-yellow} en la llamada a muchas funciones con el argumento `by = ...` o `.by = ...`

```{r}
#| eval: false
starwars |> slice_max(height, by = sex)
```

```{r}
#| echo: false
starwars |> slice_max(height, by = sex) |> select(name:eye_color)
```

---

## Fila-a-fila: rowwise()

Una opciÃ³n muy Ãºtil usada antes de una operaciÃ³n tambiÃ©n es `rowwise()`: toda [**operaciÃ³n que venga despuÃ©s se aplicarÃ¡ en cada fila por separado**]{.hl-yellow}. Por ejemplo, vamos a definir un conjunto dummy de notas.

```{r}
notas <- tibble("mates" = c(7.5, 8, 9.1, 3),
                "lengua" = c(8, 6, 6.5, 9.2))
```

. . .

Si aplicamos la media directamente el valor serÃ¡ idÃ©ntico ya que nos ha hecho la media global, pero nos gustarÃ­a sacar una [**media por registro**]{.hl-yellow}. Para eso usaremos `rowwise()`

```{r}
notas |> 
  rowwise() |> 
  mutate(media_curso = mean(c(mates, lengua)))
```

---

## Resumir: summarise()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
:::

Por Ãºltimo tenemos `summarise()`, que nos permitirÃ¡ sacar resÃºmenes estadÃ­sticos. Por ejemplo, vamos a [**calcular la media de las alturas**]{.hl-yellow}.

```{r}
starwars |> 
  drop_na(height) |> 
  summarise(media_altura = mean(height))
```

. . .

::: callout-warning
## Cuidado

FÃ­jate que `mutate()` devuelve [**tantas filas como registros originales**]{.hl-yellow}, mientras que con `summarise()` calcula un [**nuevo dataset de resumen**]{.hl-purple}, solo incluyendo aquello que estÃ© indicado.
:::

---

## Resumir: summarise()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
:::

Si ademÃ¡s esto lo [**combinamos con la agrupaciÃ³n**]{.hl-yellow} de `group_by()` o `.by = ...`, en pocas lÃ­neas de cÃ³digo puedes obtener [**estadÃ­sticas desagreagadas**]{.hl-purple}

```{r}
starwars |> 
  drop_na(sex, height, mass) |> 
  summarise(media_altura = mean(height),
            media_peso = mean(mass),
            .by = sex)
```

---

## Resumir: reframe()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> reframe()
```
:::
:::

En el nuevo `{dplyr}` han incluido `reframe()` para evitar problemas de `summarise()` cuando [**devolvemos mÃ¡s de un valor por variable**]{.hl-yellow}.

::: columns
::: {.column width="50%"}
```{r}
#| warning: true
starwars |>
  drop_na(mass) |>
  summarise(quantile(mass))
```
:::

::: {.column width="50%"}
```{r}
starwars |>
  drop_na(mass) |>
  reframe(quantile(mass))
```
:::
:::

---

## Selectores: across()

Un truco es [**hacer uso de selectores**]{.hl-yellow} `across()` y `where()`. El primero nos permite [**actuar sobre varias columnas por nombre**]{.hl-purple} (con `mutate()` o `summarise()`)

```{r}
starwars |> summarise(medias = across(height:mass, mean, na.rm = TRUE), .by = sex)
```

. . .

El segundo, `where()`, nos permite hacer lo mismo pero [**seleccionando por tipo**]{.hl-yellow}.

```{r}
starwars |> 
  summarise(across(where(is.numeric), mean, na.rm = TRUE), .by = c(sex, gender))
```

---

## ğŸ’» Tu turno {#tu-turno-11b}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Calcula cuÃ¡ntos personajes hay de cada especie, ordenados de mÃ¡s a menor frecuencia.

```{r}
#| code-fold: true
#| eval: false
starwars |> count(species, sort = TRUE)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Tras eliminar ausentes en las variables de peso y estatura, aÃ±ade una nueva variable que nos calcule el IMC de cada personaje, y determina el IMC medio de nuestros personajes desagregada por sexo

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass, height) |> 
  mutate(IMC = mass / ((height/100)^2)) |> 
  summarise(IMC_medio = mean(IMC), .by = sex)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ ObtÃ©n el personaje mÃ¡s joven por cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  slice_min(birth_year, by = sex)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ ObtÃ©n la edad del personaje mÃ¡s joven y mÃ¡s viejo de cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(birth_year) |>
  summarise(min(birth_year), max(birth_year), .by = sex)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Determina la cantidad de personajes en cada dÃ©cada (echa un vistazo a `round()`, primero sin desagregar y luego desagregado por sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  count(birth_decade = round(birth_year, -1))
```
:::

---

## ğŸ£ Caso prÃ¡ctico 12 {#caso-12}

Vamos antes a hacer un [**repaso de lo aprendido**]{.hl-yellow} en `{tidyverse}`

1. Carga la tabla billboard del paquete `{tidyr}`.

```{r}
#| code-fold: true
#| eval: false
billboard
```

2. Antes de nada, selecciona solo las [**primeras 52 semanas**]{.hl-yellow}. Tras ello convierte el dataset a [**tidydata**]{.hl-yellow} con los formatos y tipos adecuados para cada variable

. . .

3. Extrae la [**lista de artistas distintos**]{.hl-yellow} que aparecen en la tabla, incluyendo [**cuÃ¡ntas veces**]{.hl-yellow} aparece cada uno.

. . .

4. Determina [**cuÃ¡ntas canciones tiene cada artistal**]{.hl-yellow}

---

## ğŸ£ Caso prÃ¡ctico 12

5. Determina las [**5 canciones que mÃ¡s semanas**]{.hl-yellow} aparecen en la lista de Ã©xitos. 

. . .

6. Determina [**para cada artista la canciÃ³n que mÃ¡s semanas**]{.hl-yellow} aparece en la lista de Ã©xitos. 

. . .

7. Determina el [**artista con mÃ¡s canciones**]{.hl-yellow} en la lista

. . .

8. Calcula la [**posiciÃ³n mÃ¡s alta**]{.hl-yellow} en la que ha estado cada canciÃ³n. Calcula la posiciÃ³n mÃ¡s alta en la que ha estado un artista

---

## ğŸ£ Caso prÃ¡ctico 12


9. ObtÃ©n una [**tabla resumen**]{.hl-yellow} con el ranking medio de cada artista (contando solo el ranking mÃ¡s alto alcanzado por sus canciones), asÃ­ como el nÃºmero de canciones (distintas) que ha colocado en el top 100.

. . .

10. Realiza un muestreo aleatorio estratificado, extrayendo el 50% de los datos pero manteniendo la proporciÃ³n de datos entre los distintos cuatrimestres.


# Clase 13: funciones {#clase-13-funciones}

[**Â¿QuÃ© es una funciÃ³n? Â¿CÃ³mo se definen? Variables locales vs globales. Uso con mutate.**]{style="color:#444442;"}

---


## Creando funciones

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, ademÃ¡s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**.

Â¿CÃ³mo [**crear nuestra propia funciÃ³n**]{.hl-purple}? Veamos su **esquema bÃ¡sico**:

. . .

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraÃ±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

. . .

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

. . .

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
}
```

---

## Creando funciones

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, ademÃ¡s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**.

Â¿CÃ³mo [**crear nuestra propia funciÃ³n**]{.hl-purple}? Veamos su **esquema bÃ¡sico**:


* [**Cuerpo**]{.hl-yellow} de la funciÃ³n dentro de `{ }`.

. . .

* Finalizamos la funciÃ³n con los [**argumentos de salida**]{.hl-yellow} con `return()`.


```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # CÃ³digo que queramos ejecutar
  cÃ³digo
  
  # Salida
  return(var_salida)
}
```


---

## Creando funciones

* `arg1, arg2, ...`: serÃ¡n los [**argumentos de entrada**]{.hl-yellow}, los argumentos que toma la funciÃ³n para ejecutar el cÃ³digo que tiene dentro

* `cÃ³digo`: lÃ­neas de cÃ³digo que queramos que [**ejecute la funciÃ³n**]{.hl-yellow}. 

* `return(var_salida)`: se introducirÃ¡n los [**argumentos de salida**]{.hl-yellow}.


```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # CÃ³digo que queramos ejecutar
  cÃ³digo
  
  # Salida
  return(var_salida)
}
```

::: callout-important
## Importante

Todas las variables que definamos dentro de la funciÃ³n son [**variables locales: solo existirÃ¡n dentro de la funciÃ³n**]{.hl-yellow} salvo que especifiquemos lo contrario.

:::

---

## Creando funciones

Veamos un ejemplo muy simple de funciÃ³n para [**calcular el Ã¡rea de un rectÃ¡ngulo**]{.hl-yellow}.

. . .

Dado que el Ã¡rea de un rectÃ¡ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serÃ¡n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} serÃ¡ justo su **Ã¡rea** ($lado_1 * lado_2$).

. . .

```{r}
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  return(area)
  
}
```

---

## Creando funciones


TambiÃ©n podemos hacer una definiciÃ³n directa, **sin almacenar variables por el camino**.

```{r}
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  return(lado_1 * lado_2)
  
}
```


[**Â¿CÃ³mo aplicar la funciÃ³n?**]{.hl-yellow}

```{r}
calcular_area(5, 3) # Ã¡rea de un rectÃ¡ngulo 5 x 3 
calcular_area(1, 5) # Ã¡rea de un rectÃ¡ngulo 1 x 5
```

---

## Argumentos por defecto

Imagina ahora que nos damos cuenta que el 90% de las veces usamos dicha funciÃ³n para [**calcular por defecto el Ã¡rea de un cuadrado**]{.hl-yellow} (es decir, solo necesitamos un lado). Para ello, podemos definir [**argumentos por defecto**]{.hl-yellow} en la funciÃ³n: tomarÃ¡n dicho valor salvo que le asignemos otro.

Â¿Por quÃ© no asignar `lado_2 = lado_1` por defecto, para ahorrar lÃ­neas de cÃ³digo y tiempo?

. . .

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

---

## Argumentos por defecto


```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```


Ahora [**por defecto**]{.hl-yellow} el segundo lado serÃ¡ igual al primero (si se lo aÃ±adimos usarÃ¡ ambos).


```{r}
calcular_area(lado_1 = 5) # cuadrado
calcular_area(lado_1 = 5, lado_2 = 7) # rectÃ¡ngulo
```

---
 
## Salida mÃºltiple

Compliquemos un poco la funciÃ³n y aÃ±adamos en la salida los valores de cada lado, etiquetados como `lado_1` y `lado_2`, [**empaquetando la salida en una lista**]{.hl-yellow}.

```{r}
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

---

## IntroducciÃ³n a listas

Veamos un pequeÃ±o resumen de los datos que ya conocemos:

* [**vectores**]{.hl-yellow}: colecciÃ³n de elementos de igual tipo. Pueden ser nÃºmeros, caracteres o valores lÃ³gicos, entre otros.

* [**matrices**]{.hl-yellow}: colecciÃ³n BIDIMENSIONAL de elementos de igual tipo e igual longitud.

* [**data.frame / tibble**]{.hl-yellow}: colecciÃ³n BIDIMENSIONAL de elementos de igual longitud pero de cualquier tipo.

. . .

Las [**listas**]{.hl-yellow} serÃ¡n [**colecciones de variables de diferente tipo y diferente longitud**]{.hl-purple}, con estructuras totalmente heterÃ³geneas (incluso una lista puede tener dentro a su vez otra lista).

---

## IntroducciÃ³n a listas


Vamos a crear [**nuestra primera lista**]{.hl-yellow} con `list()` con tres elementos: el nombre de nuestros padres/madres, nuestro lugar de nacimiento y edades de nuestros hermanos.

```{r}
variable_1 <- c("Paloma", "Gregorio")
variable_2 <- "Madrid"
variable_3 <- c(25, 30, 26)

lista <- list("progenitores" = variable_1, "lugar_nacimiento" = variable_2,
              "edades_hermanos" = variable_3)
lista
```

---

## IntroducciÃ³n a listas

```{r}
length(lista)
```

Si observas el objeto que hemos definido como lista, su [**longitud**]{.hl-yellow} del es de 3 ya que tenemos **guardados tres elementos**: un vector de caracteres (de longitud 2), un caracter (vector de longitud 1), y un vector de nÃºmeros (de longitud 3)

. . .

Tenemos guardados elementos de [**distinto tipo**]{.hl-yellow} (algo que ya podÃ­amos hacer) pero, ademÃ¡s, de **longitudes dispares**.

```{r}
dim(lista) # devolverÃ¡ NULL al no tener dos dimensiones
class(lista) # de tipo lista
```

---

## IntroducciÃ³n a listas

Si los juntÃ¡semos con un `tibble()`, al tener distinta longitud, obtendrÃ­amos un [**error**]{.hl-red}.

```{r}
#| error: true
library(tibble)
tibble("progenitores" = variable_1,
       "lugar_nacimiento" = variable_2,
       "edades_hermanos" = variable_3)
```

---


## IntroducciÃ³n a listas

* [**Acceder por Ã­ndice**]{.hl-yellow}: con el operador `[[i]]` accedemos al **elemento i-Ã©simo** de la lista.

```{r}
lista[[1]]
```

. . .

* [**Acceder por nombre**]{.hl-yellow}: con el operador `$nombre_elemento` accedemos por su nombre.

```{r}
lista$progenitores
```

. . .

En contraposiciÃ³n, el [**corchete simple**]{.hl-yellow} nos permite acceder a [**varios elementos**]{.hl-yellow} a la vez

```{r}
# Varios elementos
lista[1:2]
```

---

## Salida mÃºltiple

Antes nos daba igual el orden de los argumentos pero ahora el [**orden de los argumentos de entrada importa**]{.hl-yellow}, ya que en la salida incluimos `lado_1` y `lado_2`. 

. . .

::: callout-note
## RecomendaciÃ³n

Es altamente recomendable hacer la llamada a la funciÃ³n [**indicando explÃ­citamente los argumentos**]{.hl-yellow} para mejorar la **legibilidad e interpretabilidad**.

```{r}
# Equivalente a calcular_area(5, 3)
calcular_area(lado_1 = 5, lado_2 = 3)
```

:::

---

## Funciones: generando conocimiento

Parece una tonterÃ­a lo que hemos hecho pero hemos cruzado una frontera importante: hemos pasado de [**consumir conocimiento**]{.hl-yellow} (cÃ³digo de otros paquetes, elaborado por otros/as), a [**generar conocimiento**]{.hl-purple}, creando nuestras propias funciones.

---

## Variables locales vs globales

Un aspecto importante sobre el que reflexionar con las funciones: Â¿quÃ© sucede si [**nombramos a una variable dentro**]{.hl-yellow} de una funciÃ³n a la que se nos ha **olvidado asignar** un valor dentro de la misma?

. . .

Debemos ser cautos al usar funciones en `R`, ya que debido a la [**Â«regla lexicogrÃ¡ficaÂ»**]{.hl-yellow}, si una variable no se define dentro de la funciÃ³n, `R` [**buscarÃ¡ dicha variable en el entorno**]{.hl-purple} de variables.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  print(x) # No devuelve nada, solo realiza la acciÃ³n 
}
funcion_ejemplo()
```

---

## Variables locales vs globales

Si una variable  [**ya estÃ¡ definida fuera de la funciÃ³n (entorno global)**]{.hl-yellow}, y ademÃ¡s es usada dentro de cambiando su valor, el valor [**solo cambia dentro**]{.hl-yellow} pero [**no en el entorno global**]{.hl-red}.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  x <- 2
  print(x) # lo que vale dentro
}
```

```{r}
# lo que vale dentro
funcion_ejemplo() #<<
# lo que vale fuera
print(x) #<<
```

---

## Variables locales vs globales


Si queremos que ademÃ¡s de cambiar localmente lo haga [**globalmente**]{.hl-yellow} deberemos usar la [**doble asignaciÃ³n**]{.hl-yellow} (`<<-`).

```{r}
x <- 1
y <- 2
funcion_ejemplo <- function() {
  
  # no cambia globalmente, solo localmente
  x <- 3 
  # cambia globalmente
  y <<- 0 #<<
  
  print(x)
  print(y)
}

funcion_ejemplo() # lo que vale dentro
x # lo que vale fuera
y # lo que vale fuera
```

---


## ğŸ’» Tu turno {#tu-turno-9}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para definir una funciÃ³n llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.

```{r}
#| eval: false
nombre <- function(x, y) {
  suma <- # cÃ³digo a ejecutar
  return()
}
# Aplicamos la funciÃ³n
suma(3, 7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_suma <- function(x, y) {
  suma <- x + y
  return(suma)
}
funcion_suma(3, 7)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para definir una funciÃ³n llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado

```{r}
#| eval: false
nombre <- function(x, y) {
  producto <- # cÃ³digo de la multiplicaciÃ³n
  return()
}
producto(3)
producto(3, -7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_producto <- function(x, y = x) {
  producto <- x * y
  return(producto)
}
funcion_producto(3)
funcion_producto(3, -7)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Define una funciÃ³n llamada `igualdad_nombres` que, dados dos nombres, nos diga si son iguales o no. Hazlo considerando importantes las mayÃºsculas, y sin que importen las mayÃºsculas. Echa un vistazo al paquete `{stringr}`.

```{r}
#| code-fold: true
#| eval: false
# Distinguiendo mayÃºsculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "LucÃ­a")

# Sin importar mayÃºsculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(toupper(persona_1) == toupper(persona_2))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "LucÃ­a")
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Crea una funciÃ³n llamada `calculo_IMC` que, dados dos argumentos (peso y estatura en metros) y un nombre, devuelva una lista con el IMC y el nombre.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura) {
  
  return(list("nombre" = nombre, "IMC" = peso/(estatura^2)))
}
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Repite el ejercicio anterior pero con otro argumento opcional que se llame unidades (por defecto, `unidades = "metros"`). Desarrolla la funciÃ³n de forma que haga lo correcto si `unidades = "metros"` y si `unidades = "centÃ­metros"`.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  
  return(list("nombre" = nombre,
              "IMC" = peso/(if_else(unidades == "metros", estatura, estatura/100)^2)))
}
```

 
### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Crea un tibble ficticio de 7 personas, con tres variables (inventa nombre, y simula peso, estatura en centÃ­metros), y aplica la funciÃ³n definida de forma que obtengamos una cuarta columna con su IMC.

```{r}
#| code-fold: true
#| eval: false
datos <-
  tibble("nombres" = c("javi", "sandra", "laura",
                       "ana", "carlos", "leo", NA),
         "peso" = rnorm(n = 7, mean = 70, sd = 1),
         "estatura" = rnorm(n = 7, mean = 168, sd = 5))

datos |> 
  mutate(IMC = calculo_IMC(nombres, peso, estatura, unidades = "centÃ­metros")$IMC)
```


:::


---

## ğŸ£ Caso prÃ¡ctico 13: funciones {#caso13}

Define una funciÃ³n llamada `conversor_temperatura` que, dada una temperatura en Fahrenheit, Celsius o Kelvin, la convierta a cualquiera de las otras (piensa que argumentos necesita el usuario). Aplica la funciÃ³n a la columna `Temp` del conjunto `airquality`, e incorpÃ³rala al fichero en una nueva columna `Temp_Celsius`.

# Clase 14: concurso

---

## Concurso


[**INSTRUCCIONES**]{.hl-yellow}

* Los equipos (entre [**3 y 6 personas**]{.hl-purple}) deberÃ¡n competir resolviendo una serie de ejercicios. El primer equipo que lo resuelva correctamente se llevarÃ¡ [**0.95 puntos**]{.hl-purple}, el segundo [**0.7 puntos**]{.hl-purple}, el tercero [**0.5 puntos**]{.hl-purple} y el cuarto [**0.4 puntos**]{.hl-purple}.

* Para que un Ã­tem estÃ© resuelto correctamente se deberÃ¡ aportar una [**soluciÃ³n correcta al mismo**]{.hl-purple} y, ademÃ¡s, un [**miembro del equipo me lo tendrÃ¡ que explicar**]{.hl-purple} (elegido por mÃ­). Dicho portavoz rotatorio podrÃ¡ ser sometido a otras preguntas para confirmar que lo ha entendido.


* Cada Ã­tem tendrÃ¡ un [**tiempo mÃ¡x entre 6 y 12 min**]{.hl-purple}. Si transcurre dicho tiempo, o bien ya hay 4 equipos que lo han resuelto, se pasarÃ¡ al siguiente.

* Los 3 equipos que acumulen mÃ¡s puntos [**recibirÃ¡n puntos extra para la nota final del curso**]{.hl-purple}: 0.2 para los terceros, 0.4 los segundos y 0.6 los primeros. AdemÃ¡s los [**2 primeros equipos**]{.hl-purple} recibirÃ¡n otro premio extra.

---

## Concurso

[**IMPORTANTE**]{.hl-yellow}

Si la respuesta es incorrecta (o el portavoz no cumple) se restarÃ¡ 0.25 puntos en el primer intento, 0.15 puntos para el resto de intentos.

---

## Ejercicio 1

Crea una proyecto que tenga el archivo de datos <https://drive.google.com/file/d/1pyW18ffjOBG3DznyrafEQUeukgPfEP7B/view?usp=sharing> y un archivo .qmd donde vayas a realizar los ejercicios. Como primer ejercicio debes carga los datos (con los tipos correctos, echa un vistazo al mensaje que muestra tras cargarlos).

&nbsp;

[**Tiempo mÃ¡ximo: 8 minutos**]{.hl-yellow}

---

## Ejercicio 2

Convierte a tidy data de manera apropiada

&nbsp;

[**Tiempo mÃ¡ximo: 6 minutos**]{.hl-yellow}

---

## Ejercicio 3

En estadÃ­stica  **informaciÃ³n = varianza**, asÃ­ que las **columnas con valores constantes no nos van a aportar nada**. Comprueba cuales son y elimÃ­nalas

&nbsp;

[**Tiempo mÃ¡ximo: 7 minutos**]{.hl-yellow}


---


## Ejercicio 4

Suponiendo que cada elecciÃ³n haya sido realizada el dÃ­a 1 de cada mes, incluye una nueva columna llamada `fecha` (como primera columna) y elimina mes y aÃ±o

&nbsp;

[**Tiempo mÃ¡ximo: 8 minutos**]{.hl-yellow}


---

## Ejercicio 5

Incluye una nueva columna al inicio que sea un cÃ³digo Ãºnico por cada municipio, y Ãºsalo para eliminar duplicados para cada municipio, elecciÃ³n y partido

&nbsp;

[**Tiempo mÃ¡ximo: 8 minutos**]{.hl-yellow}

---

## Ejercicio 6


Tenemos muchÃ­simos partidos que se presentan a las elecciones. Solo nos intereserÃ¡n los partidos :

* PSOE (opciones: PARTIDO SOCIALISTA OBRERO ESPAÃ‘OL, PARTIT DELS SOCIALISTES DE CATALUNYA)

* PP (opciones: PARTIDO POPULAR, PARTIDO POPULAR/PARTIT POPULAR, PARTIT POPULAR/PARTIDO POPULAR)

* UP (opciones: UNIDAS PODEMOS, UNIDOS PODEMOS, PODEMOS, EN COMÃš PODEM-GUANYEM EL CANVI)

* VOX


Todo lo que no sea alguno de los anteriores partidos deberÃ¡ ser codificado como `"OTROS"`. Tras la recodificaciÃ³n, recuerda sumar los votos  (por ejemplo, votos al PSC y PSOE deberÃ­an estar sumados juntos bajo las siglas del PSOE). Consejo: crea una variable de siglas.

&nbsp;


[**Tiempo mÃ¡ximo: 14 minutos**]{.hl-yellow}


---

## Ejercicio 7

Incopora como nueva variable el porcentaje de votos de cada partido (en cada cita electoral, en cada municipio). El porcentaje se calcula como votos del partido entre votos vÃ¡lidos (votos vÃ¡lidos = votos a partidos + blancos)

&nbsp;


[**Tiempo mÃ¡ximo: 10 minutos**]{.hl-yellow}

---

## Ejercicio 8

Incorpora como nueva variable el porcentaje de participaciÃ³n (en cada cita electoral, en cada municipio), calculado como votos emitidos entre censo. Votos emitidos es calculada como votos a partidos + blancos + nulos


&nbsp;


[**Tiempo mÃ¡ximo: 10 minutos**]{.hl-yellow}

---

## Ejercicio 9

Filtra solo las Ãºltimas elecciones. Tras ello responde a la pregunta, Â¿cuÃ¡ntos municipios hay de mÃ¡s de 50 000 habitantes de censo? Del filtro anterior, filtra los municipios de mÃ¡s de 5000 habitantes de censo y guarda el nuevo dataset.

A partir de aquÃ­ solo usaremos los datos de las Ãºltimas elecciones.

&nbsp;


[**Tiempo mÃ¡ximo: 10 minutos**]{.hl-yellow}

---



## Ejercicio 10

Selecciona los dos partidos ganadores en cada municipio


&nbsp;


[**Tiempo mÃ¡ximo: 7 minutos**]{.hl-yellow}

---

## Ejercicio 11

ObtÃ©n el municipio mÃ¡s poblado (con mÃ¡s censo) de cada provincia

&nbsp;


[**Tiempo mÃ¡ximo: 7 minutos**]{.hl-yellow}

---

## Ejercicio 12

Calcula el total de votos de cada partido por provincia. Haz lo mismo por comunidad autonÃ³noma. Haz lo mismo para el total de EspaÃ±a

&nbsp;


[**Tiempo mÃ¡ximo: 9 minutos**]{.hl-yellow}


---

## Ejercicio 13

Â¿QuiÃ©n ganÃ³ en las 10 ciudades mÃ¡s pobladas de EspaÃ±a?

&nbsp;


[**Tiempo mÃ¡ximo: 7 minutos**]{.hl-yellow}

---

## Ejercicio 14


Â¿Influye lo rural? Â¿Es cierto el mantra de que Vox gana en las zonas con menos poblaciÃ³n? Piensa alguna manera de buscar la relaciÃ³n entre ambas cosas.

&nbsp;


[**Tiempo mÃ¡ximo: 15 minutos**]{.hl-yellow}



# Clase 15: entrega III {#entrega-iii}

[**Tercera entrega individual en clase**]{style="color:#444442;"}

---

## Entrega III (31/10/2023)

Se actualizarÃ¡ al inicio de la clase correspondiente.

::: callout-important

## Importante

Esta [**entrega ponderarÃ¡ un 20% en la nota final**]{.hl-green}

PodrÃ¡s [**usar todo el material del curso e internet**]{.hl-yellow} salvo cualquier aplicaciÃ³n de mensajerÃ­a o sistema de comunicaciÃ³n: en caso de tener alguna abierta a lo largo de la entrega, aunque no se estÃ© usando, deberÃ¡s [**abandonar la entrega y contarÃ¡ como un 0**]{.hl-red}.

ContarÃ¡s con aproximadamente 120 minutos, pero [**deberÃ¡s realizar la entrega**]{.hl-yellow}, como tarde, a las [**15:00**]{.hl-yellow}. SerÃ¡ [**obligatorio subir tanto el `.qmd` como el `.html`**]{.hl-yellow}: una entrega que no haya podido ser renderizada (es decir, con errores graves) serÃ¡ [**penalizada contando solo un 65% de la nota obtenida**]{.hl-red} (si la entrega es perfecta, la nota mÃ¡xima serÃ¡ un 6.5 sino se adjunta el `.html` generado).

Te recomiendo practicar bastante y preguntar dudas en clase y/o tutorÃ­a ya que [**irÃ¡s justo de tiempo**]{.hl-yellow}, asÃ­ que necesitas fluidez en los ejercicios.

Si usas un [**pc de la biblioteca**]{.hl-yellow} asegÃºrate de tomarlo con suficiente antelaciÃ³n para [**instalar todas las librerÃ­as necesarias antes de empezar**]{.hl-yellow} para no perder tiempo.

:::

# Clase 16: resoluciÃ³n entrega III. Inicio dataviz {#clase-16}

[**ResoluciÃ³n de la tercera entrega. Inicio a dataviz **]{style="color:#444442;"}

---

## Ejercicio 1

> Carga el **archivo de datos electorales** del Ministerio del Interior, que recopila datos de citas electorales al Congreso de los Diputados de EspaÃ±a desde 2008 hasta la actualidad. Tras la carga, convierte las variables que creas que es necesaria la conversiÃ³n.

. . .

Cargamos y convertimos las lÃ³gicas a nÃºmeros.

```{r}
#| eval: false
library(tidyverse)
datos_brutos <-
  read_csv(file = "../entregas/ENTREGA 3/datos_elecciones_brutos.csv") |> 
  mutate(across(where(is.logical), as.numeric))
datos_brutos
```

---

## Ejercicio 2

> Convierte el archivo a tidydata de manera adecuada, sin NA ni informaciÃ³n redundante que no aporte.

. . .

Pivotamos a lo largo todas las columnas de partidos, eliminando los NA, y eliminamos variables sin variabilidad

```{r}
#| eval: false
datos_tidy <-
  datos_brutos |> 
  pivot_longer(cols = -("tipo_eleccion":"votos_candidaturas"),
               names_to = "partidos", values_to = "votos", values_drop_na = TRUE) 
datos_tidy |> summarise(across(everything(), n_distinct))

datos_tidy <-
  datos_tidy |>
  select(-tipo_eleccion, -vuelta, -codigo_distrito_electoral)
```

---


## Ejercicio 3

> Construye una variable fecha suponiendo que fuesen el dÃ­a de cada mes. Â¿CuÃ¡les eran los 30 municipios de EspaÃ±a con mÃ¡s censo en las Ãºltimas elecciones guardadas en el archivo? ObtÃ©n los nombres del segundo archivo `cod_mun.csv` (con cÃ³digo, no de manera manual)

. . .

Creamos la variable fecha y un cÃ³digo Ãºnico de cada municipio (que debe incluir la ccaa y la provincia ya que hay un municipio 1 en cada provincia)

```{r}
#| eval: false
library(lubridate)
library(glue)
datos_tidy <-
  datos_tidy |> 
  mutate(fecha = ymd(glue("{anno}{mes}01")),
         id_mun = glue("{codigo_ccaa}-{codigo_provincia}-{codigo_municipio}"))
datos_tidy 
```

---

## Ejercicio 3

> Construye una variable fecha suponiendo que fuesen el dÃ­a de cada mes. Â¿CuÃ¡les eran los 30 municipios de EspaÃ±a con mÃ¡s censo en las Ãºltimas elecciones guardadas en el archivo? ObtÃ©n los nombres del segundo archivo `cod_mun.csv` (con cÃ³digo, no de manera manual)

. . .

Hago lo que me dicen para obtener los 30 cÃ³digos en un vector

```{r}
#| eval: false
id_mun_filter <- 
  datos_tidy |>
  slice_max(fecha, n = 1) |> 
  distinct(id_mun, fecha, .keep_all = TRUE) |> 
  slice_max(censo, n = 30) |> 
  pull(id_mun)
```

---

## Ejercicio 3

> Construye una variable fecha suponiendo que fuesen el dÃ­a de cada mes. Â¿CuÃ¡les eran los 30 municipios de EspaÃ±a con mÃ¡s censo en las Ãºltimas elecciones guardadas en el archivo? ObtÃ©n los nombres del segundo archivo `cod_mun.csv` (con cÃ³digo, no de manera manual)

. . .
  
  
Uso ese vector para filtrar en `cod_mun.csv` 

```{r}
#| eval: false
cod_mun_data <- read_csv(file = "../entregas/ENTREGA 3/cod_mun.csv")
cod_mun_data |>
  filter(cod_mun %in% id_mun_filter)
```


---

## Ejercicio 4

> Crea una variable de siglas de manera que agrupe (a lo mejor con detectar palabras clave sirve...)

. . .

```{r}
#| eval: false
datos_tidy <-
  datos_tidy |>
  mutate(siglas =
           case_when(str_detect(partidos, "PARTIDO SOCIALISTA OBRERO|PARTIT DELS SOCIALISTES DE CATALUNYA|PARTIDO DOS SOCIALISTAS DE GALICIA") ~ "PSOE",
                     str_detect(partidos, "PARTIDO POPULAR") ~ "PP",
                     str_detect(partidos, "CIUDADANOS|CIUTADANS") ~ "CS",
                      str_detect(partidos, "PODEMOS|UNIDAS PODEMOS|UNIDOS PODEMOS|EN COMÃš PODEM") ~ "UP",
                     str_detect(partidos, "BLOQUE NACIONALISTA GALEGO") ~ "BNG",
                     str_detect(partidos, "VOX") ~ "VOX",
                     str_detect(partidos, "ESQUERRA REPUBLICANA DE CATALUNYA") ~ "ERC",
                     str_detect(partidos, "PARTIDO NACIONALISTA VASCO") ~ "PNV",
                     str_detect(partidos, "EUSKAL HERRIA BILDU") ~ "EH-BILDU",
                     TRUE ~ "OTROS"))
```

---

## Ejercicio 5

> Tras crear la variable de siglas, suma los votos por siglas tras la recodificaciÃ³n anterior (ejemplo, los votos de PSOE deberÃ­an ir juntos).

. . .

PodrÃ­amos hacer un summarise pero mantener el resto de columnas hacemos un mutate con la suma, agrupando por fecha, municipio y siglas, y luego eliminamos duplicaods por dichas variables (ya que todo lo que es PSOE saldrÃ¡ repetido)

```{r}
#| eval: false
datos_tidy <-
  datos_tidy |> 
  mutate(votos = sum(votos), .by = c(fecha, id_mun, siglas)) |> 
  distinct(fecha, id_mun, siglas, .keep_all = TRUE)
datos_tidy 
```

---

## Ejercicio 6

> Usando la agrupaciÃ³n por siglas anterior, Â¿cuÃ¡les fueron los 5 partidos con mÃ¡s votos totales en cada una de las elecciones? Tras obtenerlo exporta el resultado a un archivo `mas_votados.csv`

. . .

Primero calculamos los votos totales por partido (siglas) y fecha, sin importar municipio, luego extraemos para cada fecha los 5 con mÃ¡s votos

```{r}
#| eval: false
resumen <-
  datos_tidy |> 
  summarise(votos_totales = sum(votos), .by = c(fecha, siglas)) |> 
  slice_max(votos_totales, n = 5, by = fecha)
write_csv(resumen, file = "../entregas/ENTREGA 3/resumen.csv")
```

---

## Ejercicio 7

> Crea una funciÃ³n propia que, dados dos vectores `partidos` y `votos`, proporcione como output las siglas del partido mÃ¡s votado.

. . .

La forma mÃ¡s sencilla para el siguiente ejercicio es definir un tibble y hacer slice_max, sacando solo la variable de las siglas.

```{r}
#| eval: false
mas_votado <- function(partidos, votos) {
  
  datos <- tibble(partidos, votos) 
  siglas <-
    datos |>
    slice_max(n = 1, votos, with_ties = FALSE) |> 
    pull(partidos)
  
  return(siglas)
}
```

---

## Ejercicio 8

> Modifica la funciÃ³n anterior de manera que, dados dos vectores `partidos` y `votos`, nos proporcione como output las siglas del partido que ocupÃ³ la posiciÃ³n `n`, calculando por defecto el mÃ¡s votado.

. . .

Le pedimos los n primeros y de esos el mÃ¡s pequeÃ±o (es decir, posiciÃ³n n-Ã©sima)

```{r}
#| eval: false
n_votado <- function(partidos, votos, n = 1) {
  
  datos <- tibble(partidos, votos) 
  siglas <-
    datos |>
    slice_max(n = n, votos, with_ties = FALSE) |> 
    slice_min(n = 1, votos, with_ties = FALSE) |> 
    pull(partidos)
  
  return(siglas)
}
```

---

## Ejercicio 9

> Aplica la funciÃ³n anterior a la tabla y crea dos columnas nuevas: `ganador` y `segundo`. Tras ello, y tomando solo los datos de las Ãºltimas elecciones, Â¿quiÃ©n fue mÃ¡s veces el segundo partido cuando ganÃ³ el PP? Â¿Y cuÃ¡ndo ganÃ³ el PSOE? Â¿Y cuÃ¡ndo ganÃ³ UP? Â¿Y cuÃ¡ndo ganÃ³ VOX? Comenta las diferencias

. . .

Filtramos y aplicamos la funciÃ³n por fecha y municipio.

```{r}
#| eval: false
datos_tidy <-
  datos_tidy |> 
  filter(fecha == max(fecha)) |> 
  mutate(ganador = n_votado(siglas, votos),
         segundo = n_votado(siglas, votos, n = 2),
         .by = c(fecha, id_mun))

datos_tidy |>
  filter(ganador == "PP") |> 
  count(segundo, sort = TRUE)

datos_tidy |>
  filter(ganador == "PSOE") |> 
  count(segundo, sort = TRUE)
```

---

## Ejercicio 10

> Tomando solo los datos de las Ãºltimas elecciones, Â¿quÃ© partido gano en cada comuniad autÃ³noma y cuÃ¡l quedÃ³ segundo? Â¿Y para cada provincia?

```{r}
#| eval: false
datos_tidy |> 
  filter(fecha == max(fecha)) |> 
  summarise(votos_ccaa = sum(votos), .by = c(fecha, codigo_ccaa, siglas)) |> 
  slice_max(n = 2, votos_ccaa, by = codigo_ccaa)

datos_tidy |> 
  filter(fecha == max(fecha)) |> 
  summarise(votos_prov = sum(votos), .by = c(fecha, codigo_provincia, siglas)) |> 
  slice_max(n = 2, votos_prov, by = codigo_provincia)
```

---

## Dataviz: historia


La apariciÃ³n de grÃ¡ficos estadÃ­sticos es [**relativamente reciente en la ciencia**]{.hl-yellow} ya que hasta la Edad Media la Ãºnica visualizaciÃ³n estaba en los [**mapas**]{.hl-yellow}. [^1] Las propias palabras _chart_ y _cartography_ derivan del mismo origen latino, _charta_, aunque el primer uso de coordenadas viene de los egipcios. [^2] [^3]

. . .

:::: columns
::: {.column width="55%"}

No es hasta la Edad Media, cuando la [**navegaciÃ³n y la astronomÃ­a**]{.hl-yellow} empezaban a tomar relevancia, cuando aparece la primera grÃ¡fica (no propiamente estadÃ­stica), del **movimiento cÃ­clico de los planetas** (siglos X y XI)

:::

::: {.column width="45%"}
![](img/dataviz_historico_1.png){width="370"}
:::
::::
 

[^1]: [Â«GramÃ¡tica de las grÃ¡ficas: pistas para mejorar las representaciones de datosÂ» de JoaquÃ­n Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)

[^2]: [Â«Presentation GraphicsÂ» de Leland Wilkinson. International Encyclopedia of the Social & Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

[^3]: [Â«Quantitative Graphics in Statistics: A Brief HistoryÂ» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)]


---

## NavegaciÃ³n y astronomÃ­a


Con una motivaciÃ³n similar, en torno a 1360 el matemÃ¡tico **Nicole Oresme** diseÃ±Ã³ el [**primer grÃ¡fico de barras**]{.hl-yellow} (pero no estadÃ­stico), con la idea de visualizar a la vez dos **magnitudes fÃ­sicas teÃ³ricas**. [^4]


![](img/dataviz_historico_2.jpeg){width="300"}


[^4]: [Â«The First (Known) Statistical Graph: Michael Florent van Langren and the 'Secret' of LongitudeÂ» de M. Friendly y P. M. Valero-Mora. The American Statistician (2010)](https://www.researchgate.net/publication/227369016_The_First_Known_Statistical_Graph_Michael_Florent_van_Langren_and_the_Secret_of_Longitude)

 
---

## Primer grÃ¡fico estadÃ­stico

La mayorÃ­a de expertos, como Tufte [^5] [^6], consideran este grÃ¡fico casi longitudinal como la [**primera visualizaciÃ³n de datos**]{.hl-yellow} de la historia, hecha por **Van Langren** en 1644, representando la [**distancia entre Toledo y Roma**]{.hl-yellow}.


```{r}
#| echo: false
knitr::include_graphics("./img/longitud_dataviz.jpg")
``` 

```{r}
#| echo: false
knitr::include_graphics("./img/dataviz_historico_3.jpeg")
``` 


[^5]: [Â«Visual explanations: images and quantities, evidence and narrativeÂ» de E. Tufte](https://archive.org/details/visualexplanatio00tuft)

[^6]: [Â«PowerPoint is evilÂ» de E. Tufte](https://www.wired.com/2003/09/ppt2/)

---

## Â¿QuÃ© es una dataviz?


Â¿Es una grÃ¡fica estadÃ­stica? Â¿Por quÃ© sÃ­ o por quÃ© no?


![](img/cuadro_dataviz.jpg)


. . .

No hay [**ninguna INFORMACIÃ“N**]{.hl-red} representada


---

## Â¿QuÃ© es una dataviz?


Â¿Es una grÃ¡fica estadÃ­stica? Â¿Por quÃ© sÃ­ o por quÃ© no?

![](img/horoscopo_dataviz.jpg)

. . .

No hay [**ningÃºn PROCESO DE MEDIDA**]{.hl-red} representado, no cuantifica nada (real).


---

## Â¿QuÃ© es una dataviz?

Â¿Es una grÃ¡fica estadÃ­stica? Â¿Por quÃ© sÃ­ o por quÃ© no?

![](img/celsius_dataviz.jpg)

. . .

No hay [**ningÃºn DATO**]{.hl-red} representado en Ã©l, es una magnitud fÃ­sica teÃ³rica, no un dato (medido empÃ­ricamente o simulado).


---

## Â¿QuÃ© es una dataviz?

Esas mismas preguntas se hizo **JoaquÃ­n Sevilla** [^1], proporcionando [**3 requisitos**]{.hl-yellow}:

. . .

1. Que se base en el esquema de composiciÃ³n de [**eje mÃ©trico**]{.hl-yellow} (proceso de medida): debe [**medir algo**]{.hl-yellow}.

. . .

2. Debe incluir [**informaciÃ³n estadÃ­stica (datos)**]{.hl-yellow}

. . .
 
3. La  [**relaciÃ³n de representatividad**]{.hl-yellow} debe ser [**reversible**]{.hl-purple}: los datos deberÃ­an poder Â«recuperarseÂ» a partir de la grÃ¡fica .



[^1]: [Â«GramÃ¡tica de las grÃ¡ficas: pistas para mejorar las representaciones de datosÂ» de JoaquÃ­n Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)

---

## AboliciÃ³n de tartas

Hay muchas formas de hacer una grÃ¡fica estadÃ­stica, y no suele pasar por un [**grÃ¡fico de tartas**]{.hl-yellow} ya que tienen un grave [**problema de reversibilidad**]{.hl-red}:

. . .

:::: columns
::: {.column width="50%"}
* Si hay **muchas variables**: salvo que tengas transportador de Ã¡ngulos...

* Si hay **pocas variables**: Â¿aporta algo distinto (y/o mejor) que una tabla?

:::

::: {.column width="50%"}
![](img/sectores_muchas_categoriÌas.png)
:::
::::

---

## AboliciÃ³n de tartas


El principal problema de un diagrama de sectores es que la posible informaciÃ³n estÃ¡ [**contenida en los Ã¡ngulos**]{.hl-yellow}, pero nuestra interpretaciÃ³n la realizamos a travÃ©s de la [**comparaciÃ³n de Ã¡reas**]{.hl-yellow} (nuestros ojos no miden bien Ã¡ngulos), las cuales dependen no solo del Ã¡ngulo sino del radio.

&nbsp;

Algo similar sucede con los mal llamados [**grÃ¡ficos tridimensionales**]{.hl-yellow} (son bidimensionales con perspectiva en realidad): los valores mÃ¡s cercanos aparecen sobredimensionados, siendo prÃ¡cticamente imposible la reversibilidad por la [**distorsiÃ³n**]{.hl-yellow}.


---

## Vizfails

::: columns
::: {.column width="55%"}
![](img/persona_dataviz.jpg)
:::

::: {.column width="45%"}
* La figura elegida (persona caminando) sin relaciÃ³n con lo visualizado: [**mala metÃ¡fora**]{.hl-red}.

* Los [**sectores seÃ±alados sin relaciÃ³n con el Ã­tem**]{.hl-red} a representar, lo que dificulta su interpretaciÃ³n.

* Los [**colores sin codificar**]{.hl-red}: no dan informaciÃ³n de ningÃºn tipo.

* Las [**formas irregulares impiden la comparaciÃ³n**]{.hl-red} de las Ã¡reas (amÃ©n de que la suma total supera el 100%).

* **Sin fuente**

:::
::::


---

## Vizfails

![](img/viz_fail_covid.jpg)

---

## Vizfails

![](img/viz_fail_uk.jpg)

---

## La importancia del CONTEXTO

Una **buena idea** puede estar mal ejecutada: la forma de llevarla a cabo es importante

![](img/semaforos.jpg)

---

## Dataviz: historia

En el siglo XVII hubo un boom de la estadÃ­stica al empezar a aplicarse en [**demografÃ­a**]{.hl-yellow}. Uno de los autores mÃ¡s importantes fue [**J. Graunt**]{.hl-purple}, autor de Â«Natural and Political Observations Made upon the Bills of MortalityÂ» (1662), estimando la poblaciÃ³n de Londres con las [**primeras tablas de natalidad y mortalidad**]{.hl-yellow}.

. . .

::: columns
::: {.column width="50%"}

Son precisamente las tablas de Graunt las que usÃ³ [**Christiaan Huygens**]{.hl-yellow} para generar la [**primera grÃ¡fica de densidad**]{.hl-yellow} de una distribuciÃ³n continua (esperanza de vida vs edad).

:::

::: {.column width="50%"}

```{r echo = FALSE,  out.width = "100%", fig.align = "center", fig.cap = "Primera funciÃ³n de densidad, extraÃ­da de https://omeka.lehigh.edu/exhibits/show/data_visualization/vital_statistics/huygen"}
knitr::include_graphics("./img/primera_densidad.jpg")
``` 

:::
::::

---

## GrÃ¡ficos de Playfair

La figura que cambiÃ³ el dataviz fue, sin lugar a dudas, el economista y polÃ­tico [**William Playfair (1759-1823)**]{.hl-yellow}, publicando en 1786 el **Â«Atlas polÃ­tico y comercialÂ»** [^11] [^12] con 44 grÃ¡ficas (43 series temporales y el diagrama de barras mÃ¡s famoso de la historia).

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "70%", fig.align = "center", fig.cap = "ExtraÃ­das de Funkhouser y Walker (1935)"}
knitr::include_graphics("./img/playfair_1.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "25%", fig.align = "center", fig.cap = "ExtraÃ­das de Funkhouser y Walker (1935)"}
knitr::include_graphics("./img/playfair_2.jpg")
``` 

:::
::::

[^10]: [Â«Atlas polÃ­tico y comercialÂ» de William Playfair (1786)](https://www.amazon.es/Playfairs-Commercial-Political-Statistical-Breviary/dp/0521855543)

[^11]: [Â«Playfair and his chartsÂ» de H. Gray Funkhouser and  Helen M. Walker (1935)](https://www.jstor.org/stable/45366440)

---


## GrÃ¡ficos de Playfair

Playfair no solo fue el primero en usar el dataviz para entender (y no solo describir): fue el primero en usar [**conceptos modernos**]{.hl-yellow} como _grid_, tema o color

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "ExtraÃ­da de https://friendly.github.io/HistDataVis"}
knitr::include_graphics("./img/playfair_3.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "ExtraÃ­da de la wikipedia."}
knitr::include_graphics("./img/playfair_4.png")
``` 

:::
::::

---

## GrÃ¡ficos de Playfair

Playfair es ademÃ¡s el autor del [**grÃ¡fico de barras mÃ¡s famoso**]{.hl-yellow} (no fue el primero pero sÃ­ quien lo hizo _mainstream_).

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "GrÃ¡ficas de Playfair de importaciones (barras grises) y exportaciones (negras) de Escocia en 1781, extraÃ­das de la wikipedia."}
knitr::include_graphics("./img/playfair_5.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "90%", fig.align = "center", fig.cap = "Primer diagrama de barras (P. Buache y G. de Lâ€™Isle), visualizando los niveles del Sena (1732 - 1766), extraÃ­da de https://friendly.github.io/HistDataVis"}
knitr::include_graphics("./img/playfair_6.jpg")
``` 
:::
::::

---

## GrÃ¡ficos de Playfair


Playfair ademÃ¡s fue el primero en [**combinar grÃ¡ficos en la misma visualizaciÃ³n**]{.hl-yellow} [^12] [^13]

::: columns
::: {.column width="50%"}

```{r echo = FALSE, out.width = "85%", fig.align = "center", fig.cap = "Visualiza 3 series temporales: precios (barras) del trigo, salarios (lÃ­nea) y time-line con reinados, extraÃ­da de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/playfair_7.jpg")
``` 

:::

::: {.column width="50%"}

```{r echo = FALSE, out.width = "85%", fig.align = "center", fig.cap = "Time-line histÃ³rico, extraÃ­da de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/playfair_8.png")
``` 

:::
::::

[^12]: [Â«A Letter on Our Agricultural Distresses, Their Causes and RemediesÂ» de W. Playfair (1821)](http://onlinebooks.library.upenn.edu/webbin/book/lookupid?key=ha009726110)

[^13]: [Â«An Inquiry Into the Permanent Causes of the Decline and Fall of Powerful and Wealthy NationsÂ» de William Playfair (1821)](https://www.amazon.com/Permanent-Powerful-Nations-Prosperity-Prolonged/dp/140691830X)

---

## Mapas de Minard

Otro pionero en [**combinar visualizaciones**]{.hl-yellow} fue Minard, autor del famoso Â«Carte figurative des pertes successives en hommes de l'ArmÃ©e FranÃ§aise dans la campagne de Russie 1812-1813Â», segÃºn Tufte [**Â«el mejor grÃ¡fico estadÃ­stico jamÃ¡s dibujadoÂ»**]{.hl-yellow}, publicado en 1869 sobre la desastrosa campaÃ±a rusa de NapoleÃ³n en 1812 (3 variables en un grÃ¡fico bidimensional)

```{r echo = FALSE, out.width = "60%", fig.align = "center", fig.cap = "ExtraÃ­da de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/minard_2.png")
```

---

## Primer scatter plot

SegÃºn J. Sevilla, se considera al astrÃ³nomo britÃ¡nico **John Frederick William Herschel** el autor del [**primer diagrama de dispersiÃ³n o scatterplot**]{.hl-yellow} en 1833, visualizando el movimiento de la estrella doble Virginis (tiempo en el eje horizontal, posiciÃ³n angular en el eje vertical)


```{r echo = FALSE, out.width = "35%", fig.align = "center", fig.cap = "ExtraÃ­do de https://friendly.github.io/HistDataVis."}
knitr::include_graphics("./img/herschel.jpg")
``` 

---

## Primera pirÃ¡mide poblacional

La [**primera pirÃ¡mide de poblaciÃ³n**]{.hl-yellow} (doble histograma de poblaciÃ³n), fue publicada por **Francis Amasa Walker**, superintendente del censo de EE.UU., en 1874.

```{r echo = FALSE, out.width = "45%", fig.align = "center", fig.cap = "ExtraÃ­da de https://www.depauw.edu/learn/dew/wpaper/workingpapers/DePauw2016-02-Barreto-DemographyEconomics.pdf"}
knitr::include_graphics("./img/walker_piramide.jpg")
``` 

---

## Florence Nigthingale

::: columns
::: {.column width="65%"}


* El 21 de octubre de 1854 [**Florence Nigthingale**]{.hl-yellow} fue enviada para mejorar las **condiciones sanitarias** de los soldados britÃ¡nicos en la guerra de Crimea. 

* A su regreso demostrÃ³ que los [**soldados fallecÃ­an por las condiciones sanitarias**]{.hl-yellow}. Nigthingale es la creadora del famoso [**diagrama de rosa**]{.hl-yellow}, visualizando tres variables a la vez y su estacionalidad.

* El 8 de febrero de 1955, The Times la describiÃ³ como la **Â«Ã¡ngel guardiÃ¡nÂ» de los hospitales**, y acabÃ³ siendo conocida como [**Â«The Lady with the LampÂ»**]{.hl-yellow} tras un poema de H. W. Longfellow (1857).

* AÃ±os despuÃ©s se convirtiÃ³ en la [**primera mujer en la Royal Statistical Society**]{.hl-yellow}.

:::

::: {.column width="35%"}

```{r echo = FALSE, out.width = "95%", fig.align = "center"}
knitr::include_graphics("./img/the_lady_with_the_lamp.png")
``` 

:::
::::

---

## Diagrama de rosa

Florence Nigthingale es la creadora del famoso [**diagrama de rosa**]{.hl-yellow}, permitiendo pintar [**tres variables a la vez y su estacionalidad**]{.hl-yellow}: **tiempo** (cada **gajo** es un mes), **nÂº de muertes** (**Ã¡rea** del gajo) y **causa** de la muerte (**color** del gajo: azules enfermedades infecciosas, rojas por heridas, negras otras causas).


```{r echo = FALSE, out.width = "75%", fig.align = "center"}
knitr::include_graphics("./img/rosa_nightingale.jpg")
``` 

---


## Recursos de dataviz


ğŸ“š [Â«The Functional Art: an introduction to information graphics and visualizationÂ» de Alberto Cairo](https://www.amazon.es/Functional-Art-Voices-That-Matter/dp/0321834739)


ğŸ“š [Â«GramÃ¡tica de las grÃ¡ficas: pistas para mejorar las representaciones de datosÂ» de JoaquÃ­n Sevilla](https://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)


ğŸ“š [Â«A Brief History of VisualizationÂ» de Friendly et al. (2008)](https://www.researchgate.net/publication/226400313_A_Brief_History_of_Data_Visualization)

ğŸ“š [Â«Quantitative Graphics in Statistics: A Brief HistoryÂ» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)]

ğŸ“š [Â«Presentation GraphicsÂ» de Leland Wilkinson. International Encyclopedia of the Social & Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

ğŸ“š [Â«The Grammar of GraphicsÂ» de Leland Wilkinson](https://www.amazon.es/Grammar-Graphics-Statistics-Computing/dp/0387245448)


ğŸ“š [Â«The Minard System: The Graphical Works of Charles-Joseph MinardÂ» de Sandra Rendgen](https://www.amazon.es/gp/product/1616896337/ref=sw_img_1?smid=A1AT7YVPFBWXBL&psc=1)

ğŸ“š [Â«The Visual Display of Quantitative InformationÂ» de E. W. Tufte](https://www.amazon.es/Visual-Display-Quantitative-Information/dp/0961392142)

---

## Dataviz en R: ggplot2

:::: columns
::: {.column width="50%"}

El paquete `{ggplot2}` se basa en la idea de Wilkinson en [**Â«Grammar of graphicsÂ»**]{.hl-yellow}: dotar a los grÃ¡ficos de una gramÃ¡tica propia. Una de las principales fortalezas de `R` es la [**visualizaciÃ³n**]{.hl-yellow} con `{ggplot2}`.

```{r}
library(ggplot2)
```

La [**visualizaciÃ³n de datos**]{.hl-yellow} deberÃ­a ser una parte fundamental de todo anÃ¡lisis de datos. No es solo una cuestiÃ³n estÃ©tica.
:::

::: {.column width="50%"}
![](img/telling_dataviz.jpg){width="400"}
:::
::::

---

## Dataviz en R: ggplot2

La filosofÃ­a detrÃ¡s de `{ggplot2}` es entender los [**grÃ¡ficos como parte del flujo**]{.hl-yellow} de trabajo, dotÃ¡ndoles de una [**gramÃ¡tica**]{.hl-yellow}. El objetivo es empezar con un lienzo en blanco e ir [**aÃ±adiendo capas a tu grÃ¡fico**]{.hl-yellow}. La ventaja de `{ggplot2}` es poder [**mapear atributos estÃ©ticos**]{.hl-purple} (color, forma, tamaÃ±o) de objetos geomÃ©tricos (puntos, barras, lÃ­neas) en funciÃ³n de los datos.

&nbsp;


La **documentaciÃ³n** del paquete puedes consultarla en <https://ggplot2-book.org/introduction.html> 

![](img/grammar_ggplot2.jpg)


---

## Dataviz en R: ggplot2

![](img/tarta_ggplot2.png)

---

## Dataviz en R: ggplot2

:::: columns
::: {.column width="40%"}
![](img/tarta_recortada_ggplot2.jpg)
:::

::: {.column width="60%"}
Un grÃ¡fico se podrÃ¡ componer de [**capas**]{.hl-yellow}

* [**Datos (data)**]{.hl-purple}
* [**Mapeado (aesthetics)**]{.hl-purple} de elementos estÃ©ticos: ejes, color, forma, etc (en funciÃ³n de los datos)
* [**GeometrÃ­a (geom)**]{.hl-purple}: puntos, lÃ­neas, barras, polÃ­gonos, etc.
* [**Componer grÃ¡ficas (facet)**]{.hl-purple}
* [**Transformaciones (stat)**]{.hl-purple}: ordenar, resumir, etc.
* [**Coordenadas (coord)**]{.hl-purple}: coordenadas cartesianas, polares, grids, etc.
* [**Temas (theme)**]{.hl-purple}: fuente, tamaÃ±o de letra, subtÃ­tulos, captions, leyenda, ejes, etc.

:::
::::

---

## Primer intento: scatter plot

Veamos un **primer intento** para entender la filosofÃ­a ggplot. Imagina que queremos dibujar un [**scatter plot**]{.hl-yellow} (diagrama de dispersiÃ³n de puntos). Para ello vamos a usar el conjunto de datos `gapminder`, del paquete homÃ³nimo: un fichero con **datos de esperanzas de vida, poblaciones y renta per cÃ¡pita** de distintos paÃ­ses en distintos momentos temporales.

```{r}
library(gapminder)
gapminder
```

---

## Primer intento: scatter plot

El fichero consta de 1704 registros y 6 variables: `country`, `continent`, `year`, `lifeExp` (esperanza de vida), `pop` (poblaciÃ³n)  y `gdpPercap` (renta per cÃ¡pita).

```{r}
glimpse(gapminder)
```

Para empezar con algo sencillo [**filtraremos solo los datos de 1997**]{.hl-yellow}

```{r}
gapminder_1997 <-
  gapminder |>
  filter(year == 1997) |> 
  drop_na(gdpPercap, lifeExp, pop)
```

---

## Ingredientes: (x, y)


Â¿QuÃ© [**elementos necesitamos**]{.hl-yellow} para realizar un diagrama de puntos? Para [**iniciar el lienzo**]{.hl-pÃ¹rple} necesitamos una base de datos y dos variables a representar.

. . .

:::: columns
::: {.column width="45%"}

* [**Datos (data)**]{.hl-yellow}: conjunto `gapminder_1997`.

* [**Mapeado**]{.hl-yellow}: indicar dentro de `aes()` (aesthetics) las variables en cada coordenada. Todo [**dentro de aes() serÃ¡ mapeado de los datos**]{.hl-purple}

```{r}
#| eval: false
ggplot(data = gapminder_1997,
       aes(x = gdpPercap, y = pop))
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop))
```

:::
::::

---


## Primera geometrÃ­a: geom_point()

:::: columns
::: {.column width="45%"}

* [**GeometrÃ­a (geom)**]{.hl-yellow}: optaremos por **puntos** usando `geom_point()`.

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop)) +
  geom_point()
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(x = gdpPercap, y = pop)) +
  geom_point()
```

:::
::::

---

## Rol de los ejes: (x, y)


:::: columns
::: {.column width="45%"}

Vamos a profundizar en ese mapeado: Â¿cÃ³mo [**cambiar el rol**]{.hl-yellow} de los ejes (poblaciÃ³n en el eje X y renta per cÃ¡pita en el eje Y)? 

* **Eje X**: poblaciÃ³n (variable `pop`)
* **Eje Y**: renta per cÃ¡pita (variable `gdpPercap`)


```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = pop)) +
  geom_point() 
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop)) +
  geom_point() 
```
:::
::::

---

## Rol de los ejes: (x, y)


:::: columns
::: {.column width="45%"}

Â¿Y un scatter plot con **esperanza de vida** en eje X frente a **renta per cÃ¡pita**?


* **Eje X**: esperanza de vida (variable `lifeExp`)
* **Eje Y**: renta per cÃ¡pita (variable `gdpPercap`)


```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point()
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point()
```

:::
::::

---

## Color, size, shape: fijos

Dentro de `geom_point()` tenemos varios argumentos a usar:


* `na.rm = ...`: si queremos que nos quite ausentes.

* `color = ...`: color (si tiene dimensiÃ³n, color del contorno)

* `fill = ...`: color del relleno.

. . .

:::: columns
::: {.column width="45%"}

Empezaremos por un [**color fijo**]{.hl-yellow}, por ejemplo `"red"` (existen otros como `"blue"`, `"black"`, `"yellow"`, etc)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red")
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red")
```

:::
::::


# Clase 17: entrega III bis {#entrega-iii-bis}

[**Tercera entrega individual en clase**]{style="color:#444442;"}

---

# Clase 18: introducciÃ³n a ggplot {#ggplot1}

[**Dataviz con ggplot**]{style="color:#444442;"}

---


## Color, size, shape: fijos

:::: columns
::: {.column width="45%"}

* `size = ...`: tamaÃ±o  de la geometrÃ­a (en este caso el [**tamaÃ±o de los puntos**]{.hl-yellow}), cuanto mayor sea el nÃºmero, mayor serÃ¡ el tamaÃ±o de la geometrÃ­a.

  
```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7) 
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7)
```

:::
::::

---

## Color, size, shape: fijos


:::: columns
::: {.column width="45%"}

* `alpha = ...`: grado de opacidad del color (1 totalmente opaco, 0 totalmente transparente)

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7,
             alpha = 0.4)
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7, alpha = 0.4)
```

:::
::::

---

## Color, size, shape: fijos


:::: columns
::: {.column width="45%"}

* `shape = ...`: forma de la geometrÃ­a, en este caso del Â«puntoÂ» (ver todas las opciones en `vignette("ggplot2-specs")`)


```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red",
             fill = "black",
             size = 7,
             alpha = 0.4,
             shape = 23)
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", fill = "black",
             size = 7, alpha = 0.4, shape = 23)
```

:::
::::

---

## Color, size, shape: fijos


:::: columns
::: {.column width="45%"}

* `stroke = ...`: tamaÃ±o del contorno

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", size = 7,
             alpha = 0.4, stroke = 3)
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "red", alpha = 0.4,
             size = 7, stroke = 3)
```

:::
::::


---

## Color, size, shape: fijos


:::: columns
::: {.column width="45%"}

Los colores tambiÃ©n podemos asignÃ¡rselos por su **cÃ³digo hexadecimal**, consultando en <https://htmlcolorcodes.com/es/>, eligiendo el color que queramos. El cÃ³digo hexadecimal siempre comenzarÃ¡ con `#`


```{r}
#| eval: false
# Color en hexadecimal
# https://htmlcolorcodes.com/es/
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "#A02B85",
             alpha = 0.4, size = 7) 
```


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "#A02B85", alpha = 0.4, size = 7)
```

:::
::::

  
---

## Mapeado estÃ©tico: aes()


Hasta ahora los **atributos estÃ©ticos** se los hemos pasado fijos y [**constantes**]{.hl-yellow}.  Pero la verdadera potencia y versatilidad de `ggplot` es que podemos [**mapear los atributos estÃ©ticos en funciÃ³n de los datos**]{.hl-yellow} en `aes()` para que dependan de variables de los datos.

. . .

:::: columns
::: {.column width="45%"}

Por ejemplo, vamos a asignar un [**color a cada dato en funciÃ³n de su continente**]{.hl-yellow} con `aes(color = continent)`

```{r}
#| eval: false
# TamaÃ±o fijo
# Color por continentes
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent)) +
  geom_point(size = 7)
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(size = 5)
```

:::
::::

---

## Mapeado estÃ©tico: aes()


:::: columns
::: {.column width="50%"}
  
Podemos combinarlo con lo que hemos hecho anteriormente:

* [**color**]{.hl-yellow} en funciÃ³n del [**continente**]{.hl-purple}.

* [**tamaÃ±o**]{.hl-yellow} en funciÃ³n de la [**poblaciÃ³n**]{.hl-purple}.

* [**transparencia**]{.hl-yellow} la fijamos [**constante**]{.hl-purple} del 50%.

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7)
```

A este scatter plot particular se le conoce **BUBBLE CHART**

:::

::: {.column width="50%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7)
```

:::
::::

---

## VisualizaciÃ³n multivariante
  
Reflexionemos sobre el grÃ¡fico anterior:

* **color** en funciÃ³n del **continente**.
* **tamaÃ±o** en funciÃ³n de la **poblaciÃ³n**
* **transparencia** fija del 50%

&nbsp;

Usando los datos hemos conseguido dibujar en un [**grÃ¡fico bidimensional 4 variables** ]{.hl-yellow}: `lifeExp` y `gdpPercap` en los ejes , `continent` como color y `pop` como tamaÃ±o de la geometrÃ­a, con muy pocas lÃ­neas de cÃ³digo.

---

## Etiquetas sencillas: labs()

Podemos [**personalizar de manera sencilla**]{.hl-yellow}  haciendo uso de la capa `labs()`:

:::: columns
::: {.column width="43%"}

* `title, subtitle`:  tÃ­tulo/subtÃ­tulo
* `caption`: pie de grÃ¡fica
* `x, y`: nombres de los ejes
* `size, color, fill, ...`: nombre en la leyenda de las variables que codifiquen los distintos atributos


:::

::: {.column width="57%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  labs(x = "Esperanza de vida",
       y = "Renta per cÃ¡pita",
       title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana",
       color = "continente",
       size = "poblaciÃ³n")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita",
       title = "Primer ggplot", subtitle = "Datos de gapminder",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente", size = "poblaciÃ³n")
```


---

## Eliminar de la leyenda

Podemos eliminar variables de la leyenda con `guides(atributo = "none")`

:::: columns

::: {.column width="45%"}

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, 
           x = lifeExp,
           color = continent, 
           size = pop)) +
  geom_point(alpha = 0.7) +
  guides(size = "none") +
  labs(x = "Esperanza de vida",
       y = "Renta per cÃ¡pita",
       title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana",
       color = "continente")
```

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  guides(size = "none") +
  labs(x = "Esperanza de vida",
       y = "Renta per cÃ¡pita",
       title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana",
       color = "continente")
```

:::
::::

---

## Escalas (scale): ejes

Una de las capas mÃ¡s importantes es la [**capa de escalas**]{.hl-yellow}: dentro de `aes()` solo le indicamos que variable mapeamos pero no sus ajustes.

. . .


:::: columns

::: {.column width="47%"}

Vamos a configurar el eje x para tener marcas cada 10 unidades (`scale_x_continuous()`)


:::

::: {.column width="53%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita",
       title = "Primer ggplot", caption = "J. Ãlvarez LiÃ©bana",
       color = "continente")
```

---

## Escalas (scale): colores

La misma idea la podemos aplicar a otro atrÃ­buto como los [**colores**]{.hl-yellow} con `scale_color_...()` y `scale_fill_...()`: hemos indicado que mapeÃ© dicho atributo por continente pero...Â¿quÃ© colores usar?

. . .

:::: columns

::: {.column width="50%"}

Con `scale_color_manual()` podemos indicar manualmente una [**paleta**]{.hl-yellow} (puedes buscar en <https://htmlcolorcodes.com/>)


         
:::

::: {.column width="50%"}

```{r}
#| echo: false
pal <- c("#A02B85", "#2DE86B", "#4FB2CA", "#E8DA2D", "#E84C2D")
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = pal) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita",
       title = "Primer ggplot", caption = "J. Ãlvarez LiÃ©bana",
       color = "continente")
```

:::
::::
      
```{r}
#| eval: false
pal <- c("#A02B85", "#2DE86B", "#4FB2CA", "#E8DA2D", "#E84C2D")
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = pal) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

---

## Escalas (scale): colores


Otra opciÃ³n es elegir alguna de las [**paletas de colores diseÃ±adas**]{.hl-yellow} en el paquete `{ggthemes}`:

:::: columns

::: {.column width="40%"}

* `scale_color_economist()`: paleta de colores basada en los colores de **The Economist**.

:::

::: {.column width="60%"}

```{r}
#| echo: false
library(ggthemes)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_economist() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_economist() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```


---

## Escalas (scale): colores

Otra opciÃ³n es elegir alguna de las [**paletas de colores diseÃ±adas**]{.hl-yellow} en el paquete `{ggthemes}`:

:::: columns

::: {.column width="40%"}


* `scale_color_colorblind()`: paleta de colores basada en los colores de  [**daltÃ³nicos/as**]{.hl-yellow}.

:::

::: {.column width="60%"}

```{r}
#| echo: false
library(ggthemes)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```


:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```



---

## Escalas (scale): colores


Incluso cargar [**paletas de colores diseÃ±adas en base a pelÃ­culas o arte**]{.hl-yellow}


:::: columns

::: {.column width="44%"}

* [**pelÃ­culas**]{.hl-yellow}: paquete `{harrypotter}` (repositorio de Github `aljrico/harrypotter`) usando `scale_color_hp_d()`.


```{r echo = FALSE,  out.width = "20%", fig.align = "center", fig.cap = "Paleta basada en la casa Ravenclaw"}
knitr::include_graphics("https://raw.githubusercontent.com/aljrico/harrypotter/master/readme_raw_files/palettes/ravenclaw.png")
``` 

:::

::: {.column width="55%"}

```{r}
#| echo: false
library(harrypotter)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_hp_d(option = "ravenclaw")+
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```



:::

::::

```{r}
#| eval: false
devtools::install_github(repo = "aljrico/harrypotter") 
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  harrypotter::scale_color_hp_d(option = "ravenclaw")+
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```


---

## Escalas (scale): colores

Incluso cargar [**paletas de colores diseÃ±adas en base a pelÃ­culas o arte**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* [**cuadros**]{.hl-yellow}: paquete `{MetBrewer}` (repositorio de Github `BlakeRMills/MetBrewer`) usando `scale_colour_manual(values = met.brewer(...))`.

:::


::: {.column width="55%"}

```{r}
#| echo: false
library(MetBrewer)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = met.brewer("Monet")) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

:::
::::

```{r}
#| eval: false
devtools::install_github(repo = "BlakeRMills/MetBrewer") 
library(MetBrewer)

ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = met.brewer("Monet")) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```


---


## Escalas (scale): colores

Incluso cargar [**paletas de colores diseÃ±adas en base a pelÃ­culas o arte**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* [**discos**]{.hl-yellow}: paquete `{peRReo}` (repositorio de Github `jbgb13/peRReo`) usando `scale_colour_manual(values = latin_palette())`.

:::

::: {.column width="55%"}

```{r}
#| echo: false
library(peRReo)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = latin_palette("rosalia")) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

:::
::::

```{r}
#| eval: false
devtools::install_github(repo = "jbgb13/peRReo") 
library(peRReo)

ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  scale_color_manual(values = latin_palette("rosalia")) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

---

## Escalas : otros atributos

Lo mismo que hemos hecho para los ejes o colores podemos hacer para el [**resto de atrÃ­butos estÃ©ticos**]{.hl-yellow}

:::: columns

::: {.column width="40%"}


Por ejemplo, vamos a indicarle que mapeÃ© el tamaÃ±o en funciÃ³n de poblaciÃ³n pero indicÃ¡ndole el [**rango de valores**]{.hl-yellow} (continuo en este caso) entre los que moverse con `scale_size_continuous()`

:::


::: {.column width="60%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  scale_size_continuous(range = c(3, 17)) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  scale_size_continuous(range = c(3, 15)) +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente")
```

:::
::::

---


## Tema (bÃ¡sico)

Por Ãºltimo en este primer grÃ¡fico, vamos personalizar el tema con alguna de las capas `theme_...()`


:::: columns

::: {.column width="45%"}

Por ejemplo, vamos a usar `theme_minimal()` para tener un tema "austero" y minimalista (aprenderemos a definir cada detalle de nuestro tema).

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(breaks = seq(35, 85, by = 10)) +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```


# Clase 19: profundizando en ggplot {#clase-19}

[**VisualizaciÃ³n de datos**]{style="color:#444442;"}


---

## Resumen de capas

Vamos a hacer un pequeÃ±o resumen de lo que llevamos aprendido hasta ahora respecto a `{ggplot2}`

. . .

* [**Capa de datos**]{.hl-yellow}: normalmente un grÃ¡fico en `{ggplot2}` empieza con `ggplot(datos)`.

. . .

* [**Mapeo de atributos estÃ©ticos**]{.hl-yellow}: todo lo que queramos que se [**codifique en funciÃ³n de los datos**]{.hl-purple} debe ir dentro de `aes()`

. . .

* [**Capa geomÃ©trica**]{.hl-yellow}: para decidir si queremos un scatter plot, un diagrama de barras, un histograma, etc

. . .

* [**Capas de escalas**]{.hl-yellow}: para decidir los ajustes personalizados de atributos estÃ©ticos (escala del alpha o size, paleta de colores, etc)

. . . 

* [**Tema**]{.hl-yellow}: tema para personalizar el grÃ¡fico (y etiquetas)

---

## Capa de escalas

Vamos a profundizar un poco dentro de nuestro scatter plot en  [**escalas**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* Â¿CÃ³mo [**fijar lÃ­mites en los ejes**]{.hl-purple}? En `scale_x_continuous()` y `scale_y_continuous()`, ademÃ¡s de "saltos" podemos indicar lÃ­mites con `limits = ...`

:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(limits = c(50, 70),
                     breaks = seq(50, 70, by = 5)) +
  scale_y_continuous(limits = c(1000, 18000),
                      breaks = seq(0, 18000, by = 1000)) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(limits = c(50, 70), breaks = seq(50, 70, by = 5)) +
  scale_y_continuous(limits = c(1000, 18000), breaks = seq(0, 18000, by = 1000)) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---

## Capa de escalas


:::: columns

::: {.column width="45%"}

* Â¿CÃ³mo [**etiquetar las unidades de los ejes**]{.hl-purple}? Haciendo uso del paquete `{scales}` podemos aÃ±adir [**prefijos/sufijos**]{.hl-yellow} con `labels = label_number(...)`


:::

::: {.column width="55%"}

```{r}
#| echo: false
library(scales)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(limits = c(50, 70), breaks = seq(50, 70, by = 5),
                     labels = label_number(suffix = " aÃ±os")) +
  scale_y_continuous(limits = c(1000, 18000), breaks = seq(0, 18000, by = 1000),
                     labels = label_number(suffix = " $")) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
library(scales)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_x_continuous(limits = c(50, 70), breaks = seq(50, 70, by = 5),
                     labels = label_number(suffix = " aÃ±os")) +
  scale_y_continuous(limits = c(1000, 18000), breaks = seq(0, 18000, by = 1000),
                     labels = label_number(suffix = " $")) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---

## Capa de escalas

Vamos a profundizar un poco dentro de nuestro scatter plot en  [**escalas**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* Â¿CÃ³mo [**cambiar los ajustes de tamaÃ±o, alpha, etc**]{.hl-purple}? Igual que tenemos `scale_x_...()` o `scale_color_...()`, tenemos tambiÃ©n `scale_size_...()` y `scale_alpha_...()`


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(aes(alpha = pop)) +
  scale_size(range = c(4, 12)) +
  scale_alpha(range = c(0.1, 0.95)) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none", alpha = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(aes(alpha = pop)) +
  scale_size(range = c(4, 12)) +
  scale_alpha(range = c(0.1, 0.5)) +
  ggthemes::scale_color_colorblind() +
  guides(size = "none", alpha = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---

## Capa de escalas

Vamos a profundizar un poco dentro de nuestro scatter plot en  [**escalas**]{.hl-yellow}

:::: columns

::: {.column width="45%"}

* Â¿CÃ³mo [**cambiar la escala (relaciÃ³n) lineal entre los ejes**]{.hl-purple}? Con `scale_x_sqrt()` o `scale_x_log10()` podemos cambiar la escala de los ejes.


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_y_log10() +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_y_log10() +
  ggthemes::scale_color_colorblind() +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```


---

## scale_color: paleta Brewer

Una de las capas de escalas mÃ¡s importantes son las [**capas de color**]{.hl-yellow}. Ya vimos como definir paletas manuales, Â¿pero quÃ© [**opciones hay para escalas continuas de colores**]{.hl-purple}?

. . .

Existen unas [**paletas de colores conocidas como ColorBrewer**]{.hl-yellow} pudiendo definirse de manera **secuencial**, **divergente** o de manera **cualitativa** (ver info en <https://colorbrewer2.org>)

```{r}
RColorBrewer::brewer.pal.info
```

---

## scale_color: paleta Brewer

Con `RColorBrewer::brewer.pal()` podemos obtener el vector de n colores para una paleta dada

```{r}
RColorBrewer::brewer.pal(n = 5, name = "RdYlBu")
```

. . .

Con `RColorBrewer::display.brewer.pal()` podemos **visualizar los colores** de dicha paleta

```{r}
RColorBrewer::display.brewer.pal(n = 5, name = "RdYlBu")
```

---


## scale_color: paleta Brewer


:::: columns

::: {.column width="45%"}

Para incluirlo podemos usar `scale_colour_brewer()` o bien `scale_color_distiller()` si queremos crear una **escala continua** (interpolando entre los colores)


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.7, size = 3) +
  scale_x_log10() +
  scale_color_distiller(palette = "RdYlBu") +
  guides(size = "none") +
  labs(x = "PoblaciÃ³n", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "esperanza de vida") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.7, size = 3) +
  scale_x_log10() +
  scale_color_distiller(palette = "RdYlBu") +
  guides(size = "none") +
  labs(x = "PoblaciÃ³n", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "esperanza de vida") +
  theme_minimal()
```


---

## Capa de coordenadas


:::: columns

::: {.column width="45%"}


AdemÃ¡s de escalas tenemos una [**capa de coordenadas**]{.hl-yellow} con `coord_...` para indicar si queremos un sistema cartesiano (y sus lÃ­mites), coordenadas polares (`coord_polar()`), si queremos coordenadas iguales (`coord_equal()`) o invertir su rol (`coord_flip()`)


:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.8, size = 3) +
  scale_x_log10() +
  scale_color_gradient2(low = "#E92745", mid = "#F4ED5B", high = "#56B1F7", midpoint = 60) +
  coord_flip() +
  labs(x = "PoblaciÃ³n", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "esperanza de vida") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.8, size = 3) +
  scale_x_log10() +
  scale_color_gradient2(low = "#E92745", mid = "#F4ED5B", high = "#56B1F7", midpoint = 60) +
  coord_flip() +
  labs(x = "PoblaciÃ³n", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "esperanza de vida") +
  theme_minimal()
```


---

## Capa de stats

Una capa importante es la [**capa de estadÃ­sticas**]{.hl-yellow}

:::: columns

::: {.column width="45%"}


* `stat_smooth()`: visualiza un [**ajuste suavizado**]{.hl-yellow} de los datos (reg. lineal, glm, loess, gam, etc).

Con `stat_smooth(method = "lm", se = FALSE)` una recta de regresiÃ³n (sin intervalos). 

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE, linewidth = 1.5) +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```
:::
::::


```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE, linewidth = 1.5) +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---

## Capa de stats

Una capa importante es la [**capa de estadÃ­sticas**]{.hl-yellow} que nos permite combinar en nuestro grÃ¡fico algunas funcionalidades

:::: columns

::: {.column width="45%"}

FÃ­jate que si usas en la [**primera capa parÃ¡metros estÃ©ticos**]{.hl-yellow} se acaban [**heredando a capas posteriores**]{.hl-purple}, en concreto al ajuste visualizado.

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE, linewidth = 1.5) +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```
:::
::::


```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE, linewidth = 1.5) +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```


---


## Capa de stats


:::: columns

::: {.column width="45%"}

Dentro de `stat_smooth()` podemos especificarle otro [**ajuste polinÃ³mico**]{.hl-yellow} dÃ¡ndole expresiÃ³n en `formula = ...`
:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2) + I(x^3) + I(x^4) + I(x^5),
              color = "firebrick", se = FALSE, linewidth = 1.2) +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```
:::
::::


```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2) + I(x^3) + I(x^4) + I(x^5),
              color = "firebrick", se = FALSE, linewidth = 1.2) +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```


---

## Capa de stats


:::: columns

::: {.column width="45%"}

Con `stat_summary()` podemos incluso aÃ±adir [**estadÃ­sticas por grupos**]{.hl-yellow}, como la media o mediana.

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder, aes(y = gdpPercap, x = year)) +
  geom_point(size = 1.7, alpha = 0.2) +
  stat_summary(fun = "mean", size = 0.4, color = "coral") + 
  stat_summary(fun = "median", size = 0.4, color = "darkcyan") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::


```{r}
#| eval: false
ggplot(gapminder, aes(y = gdpPercap, x = year)) +
  geom_point(size = 1.7, alpha = 0.2) +
  stat_summary(fun = "mean", size = 0.4, color = "coral") + 
  stat_summary(fun = "median", size = 0.4, color = "darkcyan") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```



---

## Capa de stats

:::: columns

::: {.column width="45%"}

FÃ­jate que si no tenemos una variable cuali, la media la hace con `n = 1` (es decir, es el propio punto).
:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder, aes(y = gdpPercap, x = pop)) +
  geom_point(size = 1.7, alpha = 0.2) +
  stat_summary(fun = "mean", size = 0.4, color = "coral") + 
  stat_summary(fun = "median", size = 0.4, color = "darkcyan") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::


```{r}
#| eval: false
ggplot(gapminder, aes(y = gdpPercap, x = pop)) +
  geom_point(size = 1.7, alpha = 0.2) +
  stat_summary(fun = "mean", size = 0.4, color = "coral") + 
  stat_summary(fun = "median", size = 0.4, color = "darkcyan") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```


---

## Componiendo (facet)

TambiÃ©n podemos [**desagregar los grÃ¡ficos (facetar)**]{.hl-yellow} por grupos, equivalente al `group_by()` en tidyverse.


:::: columns

::: {.column width="45%"}

Por ejemplo, vamos a crear un [**grÃ¡fico por continente**]{.hl-yellow}, mostrando todos los grÃ¡ficos a la vez (pero por separado) con `facet_wrap(~continent)`.

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent)+
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent) +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---

## Componiendo (facet)

TambiÃ©n podemos [**desagregar los grÃ¡ficos (facetar)**]{.hl-yellow} por grupos, equivalente al `group_by()` en tidyverse.


:::: columns

::: {.column width="45%"}

Por defecto las escalas en los ejes son compartidas. Si queremos que la [**escala de los ejes**]{.hl-yellow} vaya por libre debemos usar `scales = "free_x"`, `scales = "free_y"` o `scales = "free"`


:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---

## Componiendo (facet)

TambiÃ©n podemos [**desagregar los grÃ¡ficos (facetar)**]{.hl-yellow} por grupos, equivalente al `group_by()` en tidyverse.


:::: columns

::: {.column width="45%"}

Con `nrow = ...` y `ncol = ...` podemos especificar cuantas columnas y filas tenemos en la cuadrÃ­cula de grÃ¡ficas

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent, scales = "free", nrow = 3) +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.75) +
  ggthemes::scale_color_colorblind() +
  facet_wrap(~continent, scales = "free", nrow = 3) +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```



---

## Componiendo (facet)



:::: columns

::: {.column width="45%"}

TambiÃ©n le podemos pasar dos argumentos (variables) para formar un [**grid de grÃ¡ficas**]{.hl-yellow}

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder |> filter(year >= 1962), aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  facet_grid(continent ~ year, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> filter(year >= 1962), aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  facet_grid(continent ~ year, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```


---

## Componiendo (facet)



:::: columns

::: {.column width="45%"}

Aprenderemos distintas personalizaciones del tema pero con `theme(legend.position = ...)` podemos [**decidir la posiciÃ³n de la leyenda**]{.hl-yellow}

:::


::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder |> filter(year >= 1962), aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  facet_grid(continent ~ year, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder |> filter(year >= 1962), aes(y = gdpPercap, x = lifeExp, size = pop, color = continent)) +
  geom_point(alpha = 0.7) +
  ggthemes::scale_color_colorblind() +
  facet_grid(continent ~ year, scales = "free") +
  guides(size = "none") +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

# Clase 20: profundizando en ggplot {#clase-20}

[**VisualizaciÃ³n de datos**]{style="color:#444442;"}

---

hacer resumen construyendo poco a poco

camrecorder

---

mismo grÃ¡fico con distinta geometrÃ­a para continuas

---

## Gradiente de color manual


:::: columns

::: {.column width="45%"}

Tambien podemos crear un [**gradiente de color manual**]{.hl-yellow} son `scale_..._gradient()` para dos colores, `scale_..._gradient2()` para tres colores (bajo, medio y alto) y `scale_..._gradientn()` para n colores



:::

::: {.column width="55%"}

```{r}
#| echo: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.8, size = 3) +
  scale_x_log10() +
  scale_color_gradient2(low = "#E92745", mid = "#F4ED5B", high = "#56B1F7", midpoint = 60) +
  labs(x = "PoblaciÃ³n", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "esperanza de vida") +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(gapminder_1997, aes(y = gdpPercap, x = pop, color = lifeExp)) +
  geom_point(alpha = 0.8, size = 3) +
  scale_x_log10() +
  scale_color_gradient2(low = "#E92745", mid = "#F4ED5B", high = "#56B1F7", midpoint = 60) +
  labs(x = "PoblaciÃ³n", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "esperanza de vida") +
  theme_minimal()
```


---


## geom_text()

:::: columns

::: {.column width="45%"}


Podemos aÃ±adirle [**textos simples**]{.hl-yellow} con `geom_text(label = ...)`, por ejemplo, para aÃ±adir la correlaciÃ³n del ajuste.

:::


::: {.column width="55%"}

```{r}
#| echo: false
cor <- round(cor(gapminder_1997$gdpPercap, gapminder_1997$lifeExp), 3)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE) +
  geom_text(aes(x = 50, y = 20000), label = glue("CorrelaciÃ³n: {cor}"),
            size = 5, color = "darkcyan") +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```
:::
::::


```{r}
#| eval: false
cor <- round(cor(gapminder_1997$gdpPercap, gapminder_1997$lifeExp), 3)
ggplot(gapminder_1997, aes(y = gdpPercap, x = lifeExp)) +
  geom_point(aes(color = continent, size = pop), alpha = 0.8) +
  stat_smooth(method = "lm", se = FALSE) +
  geom_text(aes(x = 50, y = 20000, label = glue("CorrelaciÃ³n: {cor}")),
                size = 5, color = "darkcyan") +
  scale_y_log10() +
  guides(size = "none") +
  ggthemes::scale_color_colorblind() +
  labs(x = "Esperanza de vida", y = "Renta per cÃ¡pita", title = "Primer ggplot",
       caption = "J. Ãlvarez LiÃ©bana", color = "continente") +
  theme_minimal()
```

---

## Variables continuas

Hemos aprendido a realizar uno de los grÃ¡ficos mÃ¡s famosos, un [**diagrama de dispersiÃ³n**]{.hl-yellow}, pero...Â¿quÃ© propiedades deben cumplir las variables?

. . .

Para visualizar dos variables con un [**diagrama de dispersiÃ³n**]{.hl-yellow} es necesario que ambas sean [**variables numÃ©ricas continuas**]{.hl-purple}

. . .

Â¿Se te ocurre algÃºna grÃ¡fico bÃ¡sico para [**variables discretas**]{.hl-yellow}?

---


## Cualis: barras


Â¿Y si tengo [**variables discretas o cualitativas**]{.hl-yellow}?

. . .

Vamos a usar el ya conocido conjunto `starwars` para visualizar en un [**diagrama de barras**]{.hl-yellow}: vamos a representar la [**frecuencia**]{.hl-yellow} de una [**variable cualitativa**]{.hl-yellow} como es `sex`.

```{r}
starwars |>  
  count(sex)
```


---

## Cualis: barras

La ventaja de ggplot es que, al trabajar por [**capas**]{.hl-yellow},  todo lo que hemos aprendido nos sirve: solo tenemos que [**cambiar la geometrÃ­a**]{.hl-purple}.

:::: columns

::: {.column width="40%"}

En este caso para realizar un [**diagrama de barras**]{.hl-yellow} usaremos `geom_bar()` en lugar de `geom_point()`, indicando [**solo la variable de grupo**]{.hl-purple} con `x = sex` (ggplot harÃ¡ solo el recuento)

:::

::: {.column width="60%"}


```{r}
#| echo: false
ggplot(starwars, aes(x = sex)) +
  geom_bar() +
  theme_minimal()
```

:::
::::

```{r}
#| eval: false
ggplot(starwars, aes(x = sex)) +
  geom_bar()
  theme_minimal()
```


---

## Cualis: barras

:::: columns

::: {.column width="40%"}


Podemos aplicar lo aprendido sobre [**colores para codificar**]{.hl-yellow} la informaciÃ³n, en este caso vamos a usar las paletas ya cargadas en `scale_color_colorblind()` del paquete `{ggthemes}`

:::

::: {.column width="60%"}

```{r}
#| echo: false
library(ggthemes)
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(color = sex), alpha = 0.5) + 
  scale_color_colorblind() +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
library(ggthemes)
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(color = sex), alpha = 0.5) + 
  scale_color_colorblind() +
  theme_minimal()
```



---


## Cualis: barras

:::: columns

::: {.column width="40%"}

FÃ­jate que ahora [**solo nos ha coloreado el contorno**]{.hl-red}: en otras geometrÃ­as, como las barras, serÃ¡ importante distinguir entre `color` y `fill`


:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  theme_minimal()
```


---

## Cualis: barras




:::: columns

::: {.column width="40%"}

Podemos [**personalizar el grÃ¡fico**]{.hl-yellow} haciendo uso de las opciones ya vistas, por ejemplo, con escalas en ejes, tÃ­tulos de las variables, leyendas, etc

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  labs(x = "sexo", y = "frecuencia absoluta",
       fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana") +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana") +
  theme_minimal()
```


---


## Cualis: barras




:::: columns

::: {.column width="40%"}

Para cambiar el rol de los ejes, generando un diagrama de [**barras horizontales**]{.hl-yellow}, podemos dejar el grÃ¡fico igual y luego simplemente hacer `coord_flip()`
:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana") +
  theme_minimal()
```

:::

::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana") +
  theme_minimal()
```



---

## ParÃ©ntesis: temas


Vamos a hacer un parÃ©ntesis y aprender a [**personalizar mÃ¡s nuestras grÃ¡ficas**]{.hl-yellow}

:::: columns

::: {.column width="55%"}

* `theme_set(theme_minimal())` fija tema base

* `theme_update(...)` personaliza parÃ¡metros.

Por ejemplo, en `plot.title` vamos a indicarle el [**tamaÃ±o y negrita**]{.hl-yellow} en el tÃ­tulo, dentro de `element_text()`

:::


::: {.column width="45%"}

```{r}
#| echo: false
theme_set(theme_minimal())
theme_update(plot.title = element_text(size = 25, face = "bold"))
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```

:::
::::

```{r}
#| eval: false
theme_set(theme_minimal())
theme_update(plot.title = element_text(size = 25, face = "bold"))
starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente", caption = "J. Ãlvarez LiÃ©bana")
```


---

## ParÃ©ntesis: temas

:::: columns

::: {.column width="40%"}

Podemos hacer lo mismo con otros textos con `plot.subtitle` o `plot.caption`

:::


::: {.column width="60%"}

```{r}
#| echo: false
theme_set(theme_minimal())
theme_update(
  plot.title =
    element_text(size = 25, face = "bold"),
  plot.subtitle = element_text(size = 13),
  plot.caption = element_text(size = 9))

starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```

:::
::::

```{r}
#| eval: false
theme_set(theme_minimal())
theme_update(
  plot.title =
    element_text(size = 25, face = "bold"),
  plot.subtitle = element_text(size = 13),
  plot.caption = element_text(size = 9))
```


---

## ParÃ©ntesis: temas

:::: columns

::: {.column width="50%"}

Vamos incluso a [**elegir fuente o el color**]{.hl-yellow}

* `sysfonts::font_add_google()`: le indicaremos la tipografÃ­a de <https://fonts.google.com/>

* `showtext_auto()` del paquete `{showtext}` nos permite su uso.

:::

::: {.column width="50%"}

```{r}
#| echo: false
library(showtext)
library(sysfonts)
font_add_google(name = "Roboto")
showtext_auto()
theme_set(theme_minimal(base_family = "Roboto")) 

# Configurar tema
theme_update(
  plot.title = element_text(color = "#C34539", face = "bold", size = 33),
  plot.subtitle = element_text(color = "#3E6FCB", face = "bold", size = 21),
  axis.title.x = element_text(size = 19),
  axis.title.y = element_text(size = 19))

starwars |> 
  drop_na(sex) |> 
  ggplot(aes(x = sex)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  scale_y_continuous(breaks = seq(0, 70, by = 10)) +
  coord_flip() +
  labs(x = "sexo", y = "frecuencia absoluta", fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```

:::
::::

```{r}
#| eval: false
library(showtext)
library(sysfonts)
font_add_google(name = "Roboto")
showtext_auto()
theme_set(theme_minimal(base_family = "Roboto")) 

# Configurar tema
theme_update(
  plot.title = element_text(color = "#C34539", face = "bold", size = 33),
  plot.subtitle = element_text(color = "#3E6FCB", face = "bold", size = 21),
  axis.title.x = element_text(size = 19),
  axis.title.y = element_text(size = 19))
```

---

## Cualis: barras apiladas

Â¿PodrÃ­amos visualizar [**dos variables discretas/cualis a la vez**]{.hl-yellow}?

. . .

:::: columns

::: {.column width="40%"}

Podemos incluir una en `x = ...` y otra en `fill = ...`, de manera que [**por defecto nos visualiza barras apiladas**]{.hl-yellow}, por ejemplo, para ver el reparto de sexos entre humanos y no humanos.

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  labs(x = "Â¿Humanos?", y = "frecuencia absoluta", fill = "sexo",  title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```
 
:::
::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5) + 
  scale_fill_colorblind() +
  labs(x = "Â¿Humanos?", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```

---

## Cualis: barras solapas

:::: columns

::: {.column width="40%"}

Con `position = "dodge"` visualizamos las barras sin apilar, solapadas una al lado de otra

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5,
           position = "dodge") + 
  scale_fill_colorblind() +
  labs(x = "Â¿Humanos?", y = "frecuencia absoluta", fill = "sexo",
       title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```
 
:::
::::


```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5, position = "dodge") + 
  scale_fill_colorblind() +
  labs(x = "Â¿Humanos?", y = "frecuencia absoluta", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```

---

## Cualis: barras fill


:::: columns

::: {.column width="40%"}

Con `position = "fill"` visualizamos las barras en forma de [**frecuencia relativa**]{.hl-yellow}, con las barras de la misma altura para facilitar la comparativa.

:::

::: {.column width="60%"}

```{r}
#| echo: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5, position = "fill") + 
  scale_fill_colorblind() +
  labs(x = "Â¿Humanos?", y = "frecuencia relativa", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```
 
:::
::::

```{r}
#| eval: false
starwars |> 
  drop_na(sex) |> 
  mutate(Human = species == "Human") |> 
  ggplot(aes(x = Human)) +
  geom_bar(aes(fill = sex), alpha = 0.5,  position = "fill") + 
  scale_fill_colorblind() +
  labs(x = "Â¿Humanos?", y = "frecuencia relativa", fill = "sexo", title = "Primer diagrama de barras",
       subtitle = "Sexos: femenino, masculino, hemafrodita, ninguno y ausente",
       caption = "J. Ãlvarez LiÃ©bana")
```


# Clase 21: joins y expresiones de control

[**Cruzando datos. Bucles**]{style="color:#444442;"}


## Relacionando datos

Al trabajar con datos [**no siempre tendremos la informaciÃ³n en una sola tabla**]{.hl-yellow} y a veces nos interesarÃ¡ cruzar la informaciÃ³n de distintas fuentes.

. . .

Para ello usaremos un clÃ¡sico de todo lenguaje que maneja datos: los famosos [**join**]{.hl-yellow}, una herramienta que nos va a permitir [**cruzar una o variables tablas**]{.hl-yellow}, haciendo uso de una [**columna identificadora**]{.hl-yellow} de cada una de ellas (por ejemplo, imagina que cruzamos datos de hacienda y de antecedentes penales, haciendo _join_ por la columna `DNI`).

---

## Relacionando datos


```{r}
#| eval: false
tabla_1 |>
  xxx_join(tabla_2, by = id)
```

* `inner_join()`: solo sobreviven los [**registros con id en ambas**]{.hl-yellow} tablas.

* `full_join()`: mantiene [**todos los registros de ambas**]{.hl-yellow} tablas.

* `left_join()`: mantiene [**todos los registros de la primera tabla**]{.hl-yellow}, y busca cuales tienen id tambiÃ©n en la segunda (en caso de [**no tenerlo se rellena con NA**]{.hl-yellow} los campos de la 2Âª tabla).

* `right_join()`: mantiene [**todos los registros de la segunda tabla**]{.hl-yellow}, y busca cuales tienen id tambiÃ©n en la primera.

![](img/sql-joins.jpg)


---

## Relacionando datos

Vamos a probar los distintos joins con un ejemplo sencillo

```{r}
tb_1 <- tibble("key" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```

:::: columns
::: {.column width="50%"}

```{r}
tb_1
```

:::

::: {.column width="50%"}

```{r}
tb_2
```

:::
::::

---

## Left join

Imagina que queremos [**incorporar**]{.hl-yellow} a `tb_1` la [**informaciÃ³n de la tabla_2**]{.hl-yellow}, identificando los registros por la columna key (indicando con `by = "key"` la columna por la que tiene que cruzar): queremos mantener todos los registros de la primera tabla y buscar cuales tienen id (mismo valor en `key`) tambiÃ©n en la segunda tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1  |> 
  left_join(tb_2, by = "key")
```

:::
::: {.column width="50%"}


![](img/left_join.jpg)


:::
::::

---

## Left join

```{r}
tb_1 |> 
  left_join(tb_2, by = "key")
```

FÃ­jate que los [**registros de la primera cuya key no ha encontrado en la segunda**]{.hl-yellow} les ha dado el valor de [**ausente**]{.hl-yellow}.

---

## Right join

El `right_join()` realizarÃ¡ la operaciÃ³n contraria: vamos ahora a [**incorporar**]{.hl-yellow} a `tb_2` la [**informaciÃ³n de la tabla_2**]{.hl-yellow}, identificando los registros por la columna key (indicando con `by = "key"` la columna por la que tiene que cruzar): queremos mantener todos los registros de la segunda y buscar cuales tienen id (mismo valor en `key`) tambiÃ©n en la primera tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

:::

::: {.column width="50%"}

![](img/right_join.jpg)

:::
::::


---

## Right join


```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

FÃ­jate que ahora los [**registros de la segunda cuya key no ha encontrado en la primera**]{.hl-yellow} son los que les ha dado el valor de [**ausente**]{.hl-yellow}.

---


## Claves y sufijos

Las columnas clave que usaremos para el cruce [**no siempre se llamarÃ¡n igual**]{.hl-yellow}.

```{r}
tb_1 <- tibble("key_1" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```

. . .

* `by = c("key_2" = "key_2")`: le indicaremos en quÃ© columna de cada tabla estÃ¡n las claves por las que vamos a cruzar.

:::: columns
::: {.column width="50%"}

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

```{r}
# Right
tb_1  |> 
  right_join(tb_2, by = c("key_1" = "key_2"))
```

:::
::::

---

## Claves y sufijos

AdemÃ¡s podemos [**cruzar por varias columnas a la vez**]{.hl-yellow} (interpretarÃ¡ como igual registro aquel que tenga el conjunto de claves igual), con `by = c("var1_t1" = "var1_t2", "var2_t1" = "var2_t2", ...)`. Modifiquemos el ejemplo anterior

```{r}
tb_1 <- tibble("k_11" = 1:3, "k_12" = c("a", "b", "c"),  "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("k_21" = c(1, 2, 4), "k_22" = c("a", "b", "e"), "val_y" = c("y1", "y2", "y3"))
```

. . .

```{r}
# Left
tb_1 |> 
  left_join(tb_2,
            by = c("k_11" = "k_21", "k_12" = "k_22"))
```


---

## Claves y sufijos

TambiÃ©n podrÃ­a suceder que al cruzar dos tablas, haya [**columnas de valores que se llamen igual**]{.hl-yellow}


```{r}
tb_1 <- tibble("key_1" = 1:3, "val" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val" = c("y1", "y2", "y3"))
```

. . .

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

FÃ­jate que [**por defecto nos aÃ±ade los sufijos**]{.hl-yellow} `.x` y `.y` para indicarnos de que tabla vienen.

---

## Claves y sufijos


Dicho [**sufijo podemos especificÃ¡rselo**]{.hl-yellow} en el argumento opcional `suffix = ...`, que nos permita [**distinguir las variables**]{.hl-yellow} de una tabla y de otra.


```{r}
# Left
tb_1 |>
  left_join(tb_2, by = c("key_1" = "key_2"), suffix = c("_tabla1", "_tabla2"))
```


---

## Full join

Los dos anteriores casos forman lo que se conoce como [**outer joins**]{.hl-yellow}: cruces donde se mantienen observaciones que salgan en al menos una tabla. El tercer outer join es el conocido como `full_join()` que nos [**mantendrÃ¡ las observaciones de ambas**]{.hl-yellow} tablas, [**aÃ±adiendo las filas**]{.hl-yellow} que no casen con la otra tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  full_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

![](img/full_join.jpg)

:::
::::


---

## Inner join

Frente a los outer join estÃ¡ lo que se conoce como [**inner join**]{.hl-yellow}, con `inner_join()`: un cruce en el que solo se mantienen las [**observaciones que salgan en ambas tablas**]{.hl-yellow}, solo mantiene aquellos registros matcheados.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

![](img/inner_join.png)


:::
::::

---

## Inner join

FÃ­jate que en tÃ©rminos de registros, `inner_join` si es conmutativa, **nos da igual el orden de las tablas**: lo Ãºnico que cambia es el orden de las columnas que aÃ±ade.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

:::

::: {.column width="50%"}


```{r}
tb_2 |> 
  inner_join(tb_1, by = c("key_2" = "key_1"))
```

:::
::::

---

## Anti/semi join

Por Ãºltimo tenemos dos herramientas interesantes para [**filtrar (no cruzar) registros**]{.hl-yellow}: `semi_join()` y `anti_join()`. El [**semi join**]{.hl-yellow} nos deja en la [**primera tabla los registros que cuya clave estÃ¡ tambiÃ©n en la segunda**]{.hl-yellow} (como un inner join pero sin aÃ±adir la info de la segunda tabla). Y el segundo, los anti join, hace justo lo contrario (aquellos que no estÃ¡n).


:::: columns
::: {.column width="50%"}

```{r}
# semijoin
tb_1 |> 
  semi_join(tb_2, by = c("key_1" = "key_2"))
```

:::

::: {.column width="50%"}

```{r}
# antijoin
tb_1 |> 
  anti_join(tb_2, by = c("key_1" = "key_2"))
```

:::
::::


---


## ğŸ’» Tu turno {#tu-turno-16}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

Para los ejercicios usaremos las tablas disponibles en el paquete `{nycflights13}` (echa un vistazo antes)

```{r}
library(nycflights13)
```

* [**airlines**]{.hl-yellow}: nombre de aerolÃ­neas (con su abreviatura).
* [**airports**]{.hl-yellow}: datos de aeropuertos (nombres, longitud, latitud, altitud, etc).
* [**flights**]{.hl-yellow}: datos de vuelos.
* [**planes**]{.hl-yellow}: datos de los aviones.
* [**weather**]{.hl-yellow}: datos meteorolÃ³gicos horarios de las estaciones LGA, JFK y EWR.

---

## ğŸ’» Tu turno {#tu-turno-16}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Del paquete `{nycflights13}` cruza la tabla `flights` con `airlines`. Queremos mantener todos los registros de vuelos, aÃ±adiendo la informaciÃ³n de las aerolÃ­neas a la tabla de aviones.

```{r}
#| eval: false
#| code-fold: true
flights_airlines <-
  flights |> 
  left_join(airlines, by = "carrier")
flights_airlines
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ A la tabla obtenida del cruce del apartado anterior, cruza despuÃ©s con los datos de los aviones en `planes`, pero incluyendo solo aquellos vuelos de los que tengamos informaciÃ³n de sus aviones (y viceversa). 


```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum")
flights_airlines_planes
```


### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Repite el ejercicio anterior pero conservando ambas variables `year` (en una es el aÃ±o del vuelo, en la otra es el aÃ±o de construcciÃ³n del aviÃ³n), y distinguiÃ©ndolas entre sÃ­



```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum",
             suffix = c("_flight", "_build_aircraft"))
flights_airlines_planes
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Al cruce obtenido del ejercicio anterior incluye la longitud y latitud de los aeropuertos en `airports`, distinguiendo entre la latitud/longitud del aeropuerto en destino y en origen.

```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes %>%
  left_join(airports %>% select(faa, lat, lon),
            by = c("origin" = "faa")) |> 
  rename(lat_origin = lat, lon_origin = lon) |> 
  left_join(airports %>% select(faa, lat, lon),
            by = c("dest" = "faa")) |> 
  rename(lat_dest = lat, lon_dest = lon)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Filtra de `airports` solo aquellos aeropuertos de los que salgan vuelos. Repite el proceso filtrado solo aquellos a los que lleguen vuelos

```{r}
#| eval: false
#| code-fold: true
airports |> 
  semi_join(flights, by = c("faa" = "origin"))
airports |> 
  semi_join(flights, by = c("faa" = "dest"))
```


### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Â¿De cuÃ¡ntos vuelos no disponemos informaciÃ³n del aviÃ³n? Elimina antes los vuelos que no tengan identificar (diferente a NA) del aviÃ³n


```{r}
#| eval: false
#| code-fold: true
flights |> 
  drop_na(tailnum) |>
  anti_join(planes, by = "tailnum") |>
  count(tailnum, sort = TRUE) # de mayor a menor ya de paso
```

:::


---

## Estructuras de control

Una [**estructura de control**]{.hl-yellow} se compone de una serie de comandos orientados a  [**decidir el camino**]{.hl-yellow} que tu cÃ³digo debe recorrer

* Si se cumple la condiciÃ³n A, Â¿quÃ© sucede?

* Â¿Y si sucede B?

* Â¿CÃ³mo puedo repetir una misma expresiÃ³n (dependiendo de una variable)?

. . .

Si has programado antes, quizÃ¡s te sea familiar las conocidas como [**estructuras condicionales**]{.hl-yellow} tales como `if (blabla) {...} else {...}`  o [**bucles**]{.hl-yellow} `for/while` (a evitar siempre que podamos).

---

## Estructura If

Una de las estructuras de control mÃ¡s famosas son las conocidas como [**estructuras condicionales**]{.hl-yellow} `if`.

> SI (IF) un conjunto de condiciones se cumple (TRUE), entonces ejecuta lo que haya dentro de las llaves

Por ejemplo, la estructura `if (x == 1) { cÃ³digo A }` lo que harÃ¡ serÃ¡ [**ejecutar el cÃ³digo A entre llaves**]{.hl-yellow} pero [**SOLO SI**]{.hl-purple} la [**condiciÃ³n entre parÃ©ntesis es cierta**]{.hl-purple} (solo si `x` es 1). En cualquier otro caso, no harÃ¡ nada.

. . .

Por ejemplo, definamos un vector de edades de 8 personas

```{r}
edad <- c(14, 17, 24, 56, 31, 20, 87, 73)
edad < 18
```

---

## Estructura If


Nuestra estructura condicional harÃ¡ lo siguiente: [**si existe algÃºn menor de edad, imprimirÃ¡**]{.hl-yellow} por pantalla un mensaje.

```{r}
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```

---

## Estructura If

```{r}
#| eval: false
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```


En caso de que las [**condiciones no sean ciertas**]{.hl-yellow} dentro de `if()` (`FALSE`), no sucede nada


```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
}
```

**No obtenemos ningÃºn mensaje** porque la condiciÃ³n `all(edad >= 18)` no es `TRUE`, asÃ­ que bno ejecuta nada.

---

## Estructura If-else

La estructura `if (condicion) { cÃ³digo A }` puede combinarse con un `else { cÃ³digo B }`: cuando la [**condiciÃ³n no estÃ¡ verificada**]{.hl-yellow}, se [**ejecutarÃ¡ el cÃ³digo alternativo B**]{.hl-yellow} dentro de `else { }`, permitiÃ©ndonos decidir que sucede cuando se cumple y cuando no.
. . .

Por ejemplo, `if (x == 1) { cÃ³digo A } else { cÃ³digo B }` ejecutarÃ¡ A si `x` es igual a 1 y B en cualquier otro caso.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else {
  
  print("Existe alguna persona menor de edad")
}
```

---

## Estructura If-else

Esta estructura `if - else` puede ser [**anidada**]{.hl-yellow}: imagina que queremos ejecutar un cÃ³digo si todos son menores; si no sucede, pero todos son mayores de 16, hacer otra cosa; en cualquier otra cosa, otra acciÃ³n.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else if (all(edad >= 16)) {
  
  print("Hay algÃºn menor de edad pero todos con 16 aÃ±os o mÃ¡s")
  
} else { print("Hay alguna persona con menos de 16 aÃ±os") }
```

::: callout-note
## Truco

Puedes **colapsar las estructuras** haciendo click en la flecha a la izquierda que aparece en tu script.

:::


---

## If-else vectorizado


Esta estructura condicional se puede [**vectorizar**]{.hl-yellow} (en una sola lÃ­nea) con `if_else()` (del paquete `{dplyr}`), cuyos argumentos son

* la condiciÃ³n a evaluar
* lo que sucede cuando se cumple
* lo que sucede cuando no
* un argumento opcional para cuando la condiciÃ³n a evaluar es `NA`

Por ejemplo, vamos a etiquetar sin son mayores/menores de edad y un "desconocido" cuando no conocemos la edad

```{r}
library(dplyr)
edad <- c(NA, edad)
if_else(edad >= 18, "mayor", "menor", missing = "desconocido")
```



---

## Bucles

Aunque en la mayorÃ­a de ocasiones se pueden reemplazar por otras estructuras mÃ¡s eficientes y legibles, es importante conocer una de las expresiones de control mÃ¡s famosas: los [**bucles**]{.hl-yellow}.

* `for { }`: permite [**repetir el mismo cÃ³digo**]{.hl-yellow} en un [**nÃºmero prefijado y conocido**]{.hl-purple} de veces.

* `while { }`: permite [**repetir el mismo cÃ³digo**]{.hl-yellow} pero en un [**nÃºmero indeterminado de veces**]{.hl-purple} (hasta que una **condiciÃ³n** deje de cumplirse).

---

## Bucles for

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de Ã³rdenes un nÃºmero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de Ã­ndices.

. . .

Por ejemplo, vamos a definir un vector `x` y vamos a imprimir sus elementos al cuadrado: definireos un Ã­ndice `i` para imprimir, en cada paso, el valor i-Ã©simo `x[i]^2`. Esos Ã­ndices irÃ¡n dentro de `for (indice in conjunto) { code }` (por ejemplo, `i in 1:4`)

```{r}
x <- c(0, -7, 1, 4)
for (i in 1:4) {
  
  print(x[i]^2)
  
}
```

---

## Bucles for

```{r}
#| eval: false
for (i in 1:4) { 
  print(x[i]^2) 
}
```

Dentro del parÃ©ntesis del `for ()` debemos tener una  [**secuencia de Ã­ndices**]{.hl-yellow} (en este caso, nÃºmeros). Si queremos hacer lo mismo pero excluyendo el segundo elemento simplemente definimos el conjunto de valores `c(1, 3, 4)` entre los que `i` puede moverse.

```{r}
for (i in c(1, 3, 4)) {
  
  print(x[i]^2)
  
}
```

---

## Bucles for

Otra forma de usar un bucle es definir de cero un vector: primer inicializamos en ceros `y <- rep(0, 4)` para despuÃ©s modificar cada [**elemento i-Ã©simo**]{.hl-yellow} definidos como `x[i]^2`.

```{r}
y <- rep(0, 4)
for (i in 1:4) {
  
  y[i] <- x[i]^2
  
}
y
```

. . .

Lo anterior es equivalente vectorialmente a

```{r}
y <- x^2
y
```

---

## Evitando bucles


Como ya hemos aprendido con el paquete`{microbenchmark}` podemos chequear como [**los bucles suelen ser muy ineficientes**]{.hl-yellow} (de ahÃ­ que debamos evitarlos en la mayorÃ­a de ocasiones

```{r}
library(microbenchmark)
x <- 1:1000
microbenchmark(y <- x^2, 
               for (i in 1:100) { y[i] <- x[i]^2 },
               times = 500)
```

---
 
## Bucles for


Podemos ver otro ejemplo  [**combinando nÃºmeros y textos**]{.hl-yellow}: definimos un vector de edades y de nombres, e imprimimos el nomber y edad i-Ã©sima.

```{r}
nombres <- c("Javi", "Sandra", "Carlos", "Marcos", "Marta")
edades <- c(33, 27, 18, 43, 29)

for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} aÃ±os")) 
  
}
```

---

## Bucles for


FÃ­jate que [**si no queremos estar pendientes de cuantos valores**]{.hl-yellow} tenemos, podemos hacer uso de `length()` para acceder a la [**Ãºltima posiciÃ³n**]{.hl-yellow} (sea cual sea).

```{r}
for (i in 1:length(nombres)) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} aÃ±os")) 
  
}
```

---

## Bucles for

Aunque normalmente se suelen indexar con vectors numÃ©ricos, los bucles pueden ser [**indexados sobre cualquier estructura vectorial**]{.hl-yellow}

```{r}
library(stringr)
week_days <- c("monday", "tuesday", "wednesday", "thursday",
               "friday", "saturday", "sunday")

for (days in week_days) {
  
  print(str_to_upper(days))
}
```

---

## Bucles for

Vamos a combinar las estructuras condicionales y los bucles: usando el conjunto `swiss` del paquete `{datasets}`, vamos a asignar `NA`  si los valores de fertilidad son mayores de 80.

```{r}
for (i in 1:nrow(swiss)) {
  
  if (swiss$Fertility[i] > 80) { 
    
    swiss$Fertility[i] <- NA
    
  }
}
```

. . .

Esto es exactamente igual a un `if_else()` vectorizado

```{r}
data("swiss")
swiss$Fertility <- if_else(swiss$Fertility > 80, NA, swiss$Fertility)
```


---

## Bucles while

Otra forma de crear un bucle es con la estructura `while { }`, que nos ejecutarÃ¡ un bucle [**un nÃºmero desconocido de veces**]{.hl-yellow}, hasta que una condiciÃ³n [**deje de cumplirse**]{.hl-yellow} (de hecho puede que nunca termine). Por ejemplo, vamos a inializar una variable `ciclos <- 1`, que incrementaremos en cada paso, y no saldremos del bucle hasta que `ciclos > 4`.

```{r}
ciclos <- 1
while(ciclos <= 4) {
  
  print(glue("No todavÃ­a, vamos por el ciclo {ciclos}")) 
  ciclos <- ciclos + 1
  
}
```


---
  
## Bucles while


Â¿QuÃ© sucede cuando la [**condiciÃ³n nunca es FALSE**]{.hl-yellow}? PruÃ©balo tu mismo

```{r}
#| eval: false
while (1 > 0) {
  
  print("Presiona ESC para salir del bucle")
  
}
```

&nbsp;

::: callout-warning
## Cuidado

Un bucle `while { }` puede ser bastante Â«peligrosoÂ» sino controlamos bien cÃ³mo pararlo.

:::

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `break`: permite [**abortar un bucle**]{.hl-yellow} incluso si no se ha llegado a su final

```{r}
for(i in 1:10) {
  if (i == 3) {
    
    break # si i = 3, abortamos bucle
    
  }
  print(i)
}
```

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `next`: [**fuerza un bucle a avanzar a la siguiente iteraciÃ³n**]{.hl-yellow} 

```{r}
for(i in 1:5) {
  if (i == 3) {
    
    next # si i = 3, la obvia y continua al siguiente
    
  }
  print(i)
}
```

---

## Bucles repeat

Aunque no es tan usado como las opciones anteriores, tambiÃ©n contamos con `repeat { }` que ejecuta un [**bucle de manera infinita hasta que se indique abortar**]{.hl-yellow} con un break

```{r}
count <- 0
repeat { 
  
  count <- count + 1
  if (count >= 100) { break }
  
}
count
```


---

## Replicate

Por Ãºltimo, otra forma de [**repetir cÃ³digo un nÃºmero de veces**]{.hl-yellow} es hacer uso de `replicate()`: simplemente permite repetir lo mismo [**n veces**]{.hl-yellow}

```{r}
x <- 1:3
replicate(n = 3, x^2)
```

---

## ğŸ’» Tu turno {#tu-turno-n-1}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para que se imprima un mensaje por pantalla si y solo si todos los datos de `airquality` son con mes distinto a enero

```{r}
#| eval: false
library(datasets)
months <- airquality$Month

if (months == 2) {
  print("No hay datos de enero")
}
```

```{r}
#| code-fold: true
#| eval: false
library(datasets)
months <- airquality$Month

if (all(months != 1)) {
  print("No hay datos de enero")
}
```


### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para guardar en una variable llamada `temp_alta` un `TRUE` si alguno de los registros tiene una temperatura superior a 90 grados Farenheit y `FALSE` en cualquier otro caso
 
```{r}
#| eval: false
temp <- airquality$Temp

if (temp == 100) {
  print("Algunos de los registros tienen temperaturas superiores a 90 grados Farenheit")
}
```

 
```{r}
#| eval: false
#| code-fold: true
# Option 1
temp <- airquality$Temp
temp_alta <- FALSE
if (any(temp > 90)) {
   temp_alta <- TRUE
}

# Option 2
temp_alta <- any(airquality$Temp > 90)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para diseÃ±ar un bucle `for` de 5 iteraciones que solo recorra los primeros 5 impares (y en cada paso del bucle los imprima)

```{r}
#| eval: false
for (i in 1:5) {
  
  print(i)
}
```

```{r}
#| eval: false
#| code-fold: true
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i)
}
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para diseÃ±ar un bucle `while` que empiece con un contador `count <- 1` y pare cuando llegue a 6

```{r}
#| eval: false
count <- 1
while (count == 2) {
  
  print(count)
}
```

```{r}
#| eval: false
#| code-fold: true
count <- 1
while (count < 6) {
  
  print(count)
  count <- count + 1
  
}
```


:::



# El mundo Github

[**Trabajar ordenados, publicar resultados, replicabilidad de lo realizado**]{style="color:#444442;"}

---

## Â¿QuÃ© es Github?

[**GitHub**]{.hl-yellow} es la plataforma colaborativa mÃ¡s conocida basada en el [**sistema de control de versiones Git**]{.hl-yellow}

. . .

-   [**Â¿QuÃ© es Git?**]{.hl-purple} Git es un sistema de [**control de versiones**]{.hl-yellow}: una especie de [**Dropbox**]{.hl-yellow} para facilitar la [**programaciÃ³n colaborativa**]{.hl-yellow} entre un grupo de personas, permitiendo llevar la [**trazabilidad de los cambios**]{.hl-yellow} realizados.

. . .

-   [**Â¿QuÃ© es Github?**]{.hl-purple} Nuestra [**plataforma/interfaz**]{.hl-yellow} para ejecutar el control de versiones: nos servirÃ¡ no solo para trabajar colaborativamente sino para [**hacer transparente**]{.hl-yellow} el proceso de construcciÃ³n de nuestros proyectos de cÃ³digo.

. . .

::: callout-important
## Importante

Desde el 4 de junio de 2018 Github es de Microsoft (ergo el cÃ³digo que subas tambiÃ©n)
:::

---

## VisiÃ³n general

Tras hacernos una cuenta en Github, [**arriba a la derecha**]{.hl-purple} tendremos un cÃ­rculo, y haciendo click en [**Your Profile**]{.hl-purple}, veremos algo similar a esto

::: columns
::: {.column width="55%"}
![](img/github_1.png)
:::

::: {.column width="45%"}
-   [**Edit profile**]{.hl-purple}: nos permite aÃ±adir una [**descripciÃ³n y foto de perfil**]{.hl-yellow}.

-   [**Overview**]{.hl-purple}: en ese panel de cuadrados se [**visualizarÃ¡ nuestra actividad**]{.hl-yellow} a lo largo del tiempo.

-   [**Repositories**]{.hl-purple}: el cÃ³dugo serÃ¡ subido a [**repositorios**]{.hl-yellow}, el equivalente a nuestras carpetas compartidas en Dropbox.
:::
:::

---

## Primer uso: consumidor

Antes de aprender como crear repositorios, Github tambiÃ©n nos servirÃ¡ para

-   [**Acceder a cÃ³digo**]{.hl-purple} ajeno
-   [**Proponer mejoras**]{.hl-purple} a otros usuarios, e incluso proponer [**correcciones de error que detectemos**]{.hl-yellow} de software que usemos

. . .

-   [**Instalar paquetes de R**]{.hl-purple}. En muchas ocasiones los desarrolladores de paquetes suben las actualizaciones a CRAN cada cierto tiempo, y en otras el software no es suficientemente Â«amplioÂ» para poder ser subido como paquete.

El cÃ³digo de paquetes que no tengamos subido en CRAN podremos [**instalarlo como cÃ³digo desde Github**]{.hl-yellow}

---

## Instalar desde Github

Por ejemplo, vamos a instalar un paquete llamado [`{peRReo}`](https://github.com/jbgb13/peRReo), cuya Ãºnica funciÃ³n es darnos [**paletas de colores**]{.hl-yellow} basadas en portadas de [**Ã¡lbumes de mÃºsica urbana**]{.hl-yellow}

::: columns
::: {.column width="50%"}
![](img/perrreo.png)
:::

::: {.column width="50%"}
![](img/rosalia.png){width="360"}
:::
:::

. . .

Para ello antes tendremos que instalar un [**conjunto de paquetes para desarrolladores**]{.hl-yellow} llamado `{devtools}`, que nos permitirÃ¡ la instalaciÃ³n desde Github

```{r}
#| eval: false
install.packages("devtools")
```

---

## Instalar desde Github

Las [**instrucciones de instalaciÃ³n**]{.hl-yellow} suelen venir detalladas en la portada del repositorio

::: columns
::: {.column width="50%"}
![](img/install_perreo.png)
:::

::: {.column width="50%"}
![](img/rosalia.png){width="310"}
:::
:::

. . .

En la mayorÃ­a de casos bastarÃ¡ con la funciÃ³n `install_github()` (del paquete que acabamos de instalar), pasÃ¡ndole como argumento la [**ruta del repositorio**]{.hl-yellow} (sin "github.com/").

```{r}
#| eval: false
devtools::install_github("jbgb13/peRReo")
```

Ya puedes perrear con ggplot ;)

---

## Descargar desde Github

La mayorÃ­a de veces lo que subamos no serÃ¡ un paquete de R como tal sino que [**subiremos un cÃ³digo mÃ¡s o menos organizado**]{.hl-yellow} y comentado. En ese caso podremos [**descargar el repo entero**]{.hl-yellow} haciendo click [**Code**]{.hl-green} y luego Download ZIP.

Por ejemplo, vamos a descargarnos los scripts de dataviz que han subido desde el [Centre d'Estudis d'OpiniÃ³](https://github.com/ceopinio/bop-grafics)

![](img/ceo_github.png)

---

## Ideal

![](img/abogados_simpson.jpeg){width="600"}

[**Â¿Lo ideal en caso de RTVE?**]{.hl-purple} Tener dos tipos de repositorios

-   Una [**colecciÃ³n de repositorios pÃºblicos (producciÃ³n)**]{.hl-yellow} donde hacer transparente el cÃ³digo y los datos ([**ya validados**]{.hl-purple}), coordinado por un nÂº reducido de personas.

-   Una [**colecciÃ³n de repositorios privados (desarrollo)**]{.hl-yellow} donde estÃ© todo el equipo colaborando y donde se haga el [**trabajo del dÃ­a**]{.hl-purple}, con trazabilidad interna.

---

## Nuestro primer repositorio

Vamos a [**crear nuestro primero repositorio**]{.hl-yellow} que servirÃ¡ ademÃ¡s como [**carta de presentaciÃ³n**]{.hl-yellow} de nuestro perfil en Github.

1.  [**Repositories**]{.hl-purple}: hacemos click en las pestaÃ±a de Repositories.

2.  [**New**]{.hl-purple}: hacemos click en el [**botÃ³n verde New**]{.hl-green} para crear un nuevo repositorio

![](img/new_repo.png)

---

## Nuestro primer repositorio

-   [**Repository name**]{.hl-purple}: el [**nombre del repositorio**]{.hl-yellow}. En este caso vamos a crear un repositorio muy concreto: el nombre debe [**coincidir exactamente con tu nombre de usuario**]{.hl-yellow}

-   [**Description**]{.hl-purple}: descripciÃ³n de tu repositorio. En este caso serÃ¡ un repo de presentaciÃ³n.

![](img/repo_init_1.png)

---

## Nuestro primer repositorio

-   [**Public vs private**]{.hl-purple}: con cada repositorio tendremos la opciÃ³n de hacer el repositorio

    -   [**pÃºblico**]{.hl-purple}: todos los usuarios podrÃ¡n ver el cÃ³digo asÃ­ cÃ³mo la trazabilidad de su desarrollo (quÃ© se aÃ±ade y cuÃ¡ndo). Es para mÃ­ la opciÃ³n mÃ¡s recomendable cuando quieres darle [**visibilidad y transparencia**]{.hl-yellow} a tu trabajo
    -   [**privado**]{.hl-purple}: solo tendrÃ¡n acceso al repositorio aquellos usuarios a los que se lo permitas. No se podrÃ¡ visualizar ni instalar nada de Ã©l fuera de Github.

![](img/repo_init_2.png)

En este caso concreto, dado que serÃ¡ un repositorio de presentaciÃ³n, lo [**haremos pÃºblico**]{.hl-yellow}.

---

## Nuestro primer repositorio

-   [**Add a README file**]{.hl-purple}: un README file serÃ¡ el archivo donde incluiremos las [**instrucciones y detalles de uso**]{.hl-yellow} a los demÃ¡s (en el caso de `{peRReo}` era el archivo que contenÃ­a los detalles de instalaciÃ³n)

![](img/repo_init_3.png)

De momento [**ignoraremos los demÃ¡s campos**]{.hl-red} para este primer repositorio.

---

## Nuestro primer repositorio

![](img/repo_init_1.png)

Por defecto Github asume que este repositorio, con el [**mismo nombre que nuestro usuario**]{.hl-yellow} serÃ¡ el repositorio que querremos que se presente de inicio cuando alguien entra en nuestro perfil, y serÃ¡ el repositorio donde \[**incluir en el README.md**\] una presentaciÃ³n de nosotros y un Ã­ndice de tu trabajo (si quieres).

---

## Nuestro primer repositorio

![](img/profile_github_md.png)

FÃ­jate que ahora en nuestra [**portada tenemos dicho README.md**]{.hl-yellow} que podemos personalizar a nuestro gusto haciendo uso de [**html y markdown**]{.hl-yellow}.

AquÃ­ puedes ver [**algunos ejemplos de README.MD**](https://github.com/matiassingers/awesome-readme)

---

## Repo de cÃ³digo

Una vez que tenemos nuestro README de presentaciÃ³n (recuerda que puedes [**personalizar a tu gusto con html y markdown**]{.hl-yellow}) vamos a crear un [**repositorio de cÃ³digo**]{.hl-yellow}.

. . .

Si ya era importante [**trabajar con proyectos**]{.hl-yellow} en `RStudio`, cuando lo combinamos con Github es aÃºn mÃ¡s crucial que creemos un proyecto antes de subir el cÃ³digo, asÃ­ que vamos a crear uno de prueba que se llame `repo-github-1`.

. . .

En dicho proyecto vamos a [**crear un script**]{.hl-yellow} (en mi caso llamado **codigo.R**) en el que deberÃ¡s hacer los siguientes pasos:

---

## Repo de cÃ³digo

1.  [**Carga**]{.hl-yellow} directamente desde la pÃ¡gina del [ISCIII](https://cnecovid.isciii.es/covid19/resources) el archivo llamado `casos_hosp_uci_def_sexo_edad_provres.csv`

```{r}
#| eval: false
#| code-fold: true
# Carga de datos desde ISCIII
datos_covid <- read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
```

. . .

2.  [**Filtra**]{.hl-yellow} datos de Madrid (`"M"`), de 2020 y con sexo conocido (hombre/mujer). Tras ello quÃ©date con las columnas `fecha`, `sexo`, `grupo_edad`, `num_casos` (ese orden). Por Ãºltimo obtÃ©n la suma de casos diarios por fecha y sexo.

```{r}
#| eval: false
#| code-fold: true
# DepuraciÃ³n
datos_madrid <-
  datos_covid |>
  # Filtrado por Madrid y fecha
  filter(provincia_iso == "M" & fecha <= "2020-12-31" & sexo != "NC") |> 
  # SelecciÃ³n de columnas
  select(provincia_iso:fecha, num_casos) |> 
  # Resumen de casos diarios por fecha y sexo
  summarise(num_casos = sum(num_casos), .by = c(fecha, sexo))
  
```

---

## Repo de cÃ³digo

3.  [**Exporta el dataset a un csv**]{.hl-yellow} en una carpeta que se llame `exportado`

```{r}
#| eval: false
#| code-fold: true
# Exportamos datos
write_csv(datos_madrid, file = "./exportado/datos_madrid.csv")
```

. . .

::: columns
::: {.column width="40%"}
4.  Crea una [**grÃ¡fica de lÃ­neas**]{.hl-yellow} que tenga en el eje x fecha, en el eje y casos, con una curva por sexo (grÃ¡ficas separadas).

```{r}
#| eval: false
#| code-fold: true
# GrÃ¡fica
ggplot(datos_madrid) +
  geom_line(aes(x = fecha, y = num_casos, color = sexo),
            alpha = 0.6, linewidth = 0.7) +
  scale_color_manual(values = c("#85519D", "#278862")) +
  facet_wrap(~sexo) +
  theme_minimal() +
  theme(legend.position = "bottom")
```
:::

::: {.column width="60%"}
![](./img/ggplot.png){width="380"}
:::
:::

. . .

5.  Tras ello [**exportamos la grÃ¡fica**]{.hl-yellow}

```{r}
#| eval: false
ggsave(filename = "./exportado/ggplot.png", plot = last_plot(),
       bg = "white", width = 12, height = 8)
```

---

## Repo de cÃ³digo

Â¿CÃ³mo [**subimos el proyecto**]{.hl-yellow}? Vamos de nuevo a [**crear un proyecto de cero**]{.hl-yellow}. Antes no hemos hablado de dos campos importantes:

::: columns
::: {.column width="50%"}
![](./img/repo-1.png){width="460"}
:::

::: {.column width="50%"}
-   `Add .gitignore` nos permitirÃ¡ [**seleccionar el lenguaje**]{.hl-yellow} en el que estarÃ¡ nuestro proyecto para que Github lo entienda al sincronizar (y no actualice cosas que no deba).

-   `Choose a license` nos permitirÃ¡ [**seleccionar la licencia**]{.hl-yellow} que determinarÃ¡ las condiciones en las que otros podrÃ¡n reusar tu cÃ³digo.
:::
:::

---

## Repo de cÃ³digo

::: columns
::: {.column width="50%"}
![](./img/repo-1-1.png)
:::

::: {.column width="50%"}
Si te fijas traer crearlo tenemos solo 3 archivos: el de licencia, el .gitignore y el readme.md (donde deberÃ­amos escribir una guÃ­a de uso de lo que hayamos subido)
:::
:::

Para subir los archivos vamos a clickar en [**Add file \< Upload File**]{.hl-purple} y [**arrastraremos TODOS los archivos**]{.hl-yellow} de la carpeta de nuestro proyecto.

---

## Repo de cÃ³digo

Tras la subida de archivos tendremos un cuadro llamado [**Commit changes**]{.hl-purple}

![](./img/commit-1.png)

Un [**commit**]{.hl-purple} es una [**modificaciÃ³n del repositorio**]{.hl-yellow} con algo que se aÃ±ade/elimine/modifique, y dicho cuadro es recomendable usarlo para [**resumir en quÃ© consiste la modificaciÃ³n**]{.hl-yellow}, de manera que quede trazado el cambio.

---

## Repo de cÃ³digo

Haciendo click en el reloj donde indica el [**nÃºmero de commits**]{.hl-yellow} accedemos al [**histÃ³rico de commits (cambios)**]{.hl-yellow} con hora, dÃ­a, autor, comentarios, etc.

![](./img/commit-reloj.png)

---

## Repo de cÃ³digo

Vamos a realizar un [**cambio en nuestro cÃ³digo**]{.hl-yellow}: en tu cÃ³digo local (local --\> tu ordenador), en lugar de filtrar por Madrid haz el [**filtro por Barcelona**]{.hl-yellow}, guarda el cÃ³digo y sube en el repositorio el nuevo archivo (con el mismo nombre, Github harÃ¡ la sobrescritura)

```{r}
#| eval: false
#| code-line-numbers: "3"
datos_bcn <-
  datos_covid |>
  filter(provincia_iso == "B" & fecha <= "2020-12-31" & sexo != "NC") |> 
  select(fecha, sexo, grupo_edad, num_casos) |> 
  summarise(num_casos = sum(num_casos), .by = c(fecha, sexo))
```

---

## Consulta de commits

![](./img/barcelona_covid.png){width="550"}

::: columns
::: {.column width="40%"}
Si ahora [**consultamos el commit**]{.hl-yellow}, al lado hay un nÃºmero que lo identifica, y clickando en Ã©l nos resume los cambios: no solo [**almacena todas las versiones pasadas**]{.hl-yellow} sino que ademÃ¡s nos [**muestra las diferencias entre los archivos cambiados**]{.hl-yellow}
:::

::: {.column width="60%"}
![](./img/commit_cambio.png)
:::
:::

---

## Trazabilidad de cambios

::: columns
::: {.column width="72%"}
![](./img/commit_split.png) ![](./img/commit_unified.png)
:::

::: {.column width="28%"}
Tenemos [**dos modos de visualizaciÃ³n**]{.hl-yellow} de los cambios: el modo split nos muestra el antiguo y el nuevo, con las inclusiones en verde y lo que ya no estÃ¡ en rojo; y el modo unified nos muestra todo en un mismo documento.
:::
:::

---

## RecuperaciÃ³n de commits

![](./img/browse-repo.png)

Github nos permite incluso [**recuperar una versiÃ³n del pasado**]{.hl-yellow} de nuestro repositorio, haciendo click en el tercer icono del commit.

---

## RecuperaciÃ³n de commits

![](./img/branch-commit.png)

Si te fijas ahora al lado de `1 branch` tenemos un [**menÃº desplegable**]{.hl-yellow} en el que antes ponÃ­a `main` y ahora un nÃºmero identificador del commit. Ya hablaremos de la idea de [**rama (branch)**]{.hl-yellow}

---

## Repo con rmd/qmd

::: columns
::: {.column width="60%"}
Vamos a poner en prÃ¡ctica lo aprendido:

1.  Crea un nuevo repositorio en Github (llamado `repo-github-2`) donde habrÃ¡ alojado con proyecto de R.

2.  Crea un proyecto en `RStudio` que se llame (por ejemplo) `proyecto-qmd`

3.  Una vez dentro del proyecto en `RStudio` haz click en `File < New File < Quarto Document`
:::

::: {.column width="40%"}
![](./img/primer-qmd.png)
:::
:::

DeberÃ¡s tener un documento similar a este: un [**quarto markdown (.qmd)**]{.hl-yellow}, un documento que nos permitirÃ¡ incluir [**markdown + cÃ³digo**]{.hl-yellow} (puede ser `R` o puede ser `Observable`, `D3`, etc).

---

## Repo con rmd/qmd

Este formato es ideal para:

-   [**Trabajar en equipo**]{.hl-yellow} construyendo el borrador de una pieza.
-   Tomar [**apuntes o informes**]{.hl-yellow} para uno mismo.
-   [**Presentar**]{.hl-yellow} tu trabajo a tus compaÃ±eros.

::: columns
::: {.column width="50%"}
![](./img/prueba-qmd-html.png)
:::

::: {.column width="50%"}
Si te fijas ahora nuestro repositorio tiene un archivo con formato `.html`...es decir...

[**Â¡Es una web!**]{.hl-yellow}
:::
:::

---

## Github pages

Â¿CÃ³mo [**convertir nuestro repositorio en una web**]{.hl-yellow}?

![](./img/github-pages.png)

1.  Haz click en `Settings`
2.  Ve al apartado `Pages`
3.  En el subapartado `branch` selecciona la Ãºnica rama que tenemos ahora (`main`)
4.  Selecciona la carpeta donde tengas el `.html` (en web complejas estarÃ¡ como en cualquier web en `docs`, en algo simple estarÃ¡ en la ruta raiz del repositorio)
5.  Haz click en `Save`

---

## Github pages

Si te fijas en la [**parte superior del repositorio**]{.hl-yellow} ahora tenemos un icono naranja, que nos indica que la [**web estÃ¡ en proceso de ser desplegada (deploy)**]{.hl-orange}

![](./img/github-naranja.png)

---

## Github pages

Pasados unos segundos (dependiendo del tamaÃ±o de la web y tu conexiÃ³n a internet) ese [**icono pasarÃ¡ a ser un check verde**]{.hl-green}: habemus web

![](./img/github-verde.png)

El [**link de la web por defecto**]{.hl-yellow} serÃ¡ `{nombre_usuario}.github.io/{nombre_repo}`

---

## Github pages

![](./img/github-pages-deploy.png)

Â¡Un momento! Ahora mismo nuestra web [**no nos estÃ¡ mostrando nuestro .qmd**]{.hl-red}, sino por defecto el [**README.md**]{.hl-yellow}.

. . .

Para que Github entienda que queremos visualizar ese `.html` que hemos generado a partir del `.qmd` vamos en nuestro proyecto local a [**borrar**]{.hl-yellow} todo lo que no sea nuestro archivo `.Rproj` y nuestro archivo `.qmd`, y vamos a [**cambiar el nombre**]{.hl-yellow} a este Ãºltimo llamÃ¡ndolo `index.qmd`, y volvemos a compilarlo para [**generar un index.html**]{.hl-yellow}

---

## Github pages

Vamos a [**subir a Github ese nuevo proyecto**]{.hl-yellow} con el cambio de nombre (llamado `repo-github-3`) para ver luego las diferencias entre uno y otro

![](./img/repo-index-html.png)

---

## Github pages

Si [**repetimos el proceso para hacer una Page**]{.hl-yellow} y esperamos al tick verde...

::: columns
::: {.column width="50%"}
![](./img/index-html-qmd.png)
:::

::: {.column width="50%"}
Si a tu `.qmd` ya le llamas de inicio `index.qmd`, automÃ¡ticamente, al detectar Github un `index.html`, interpreta que ese [**archivo index.html**]{.hl-yellow} es el que define la web (y puedes personalizar aÃ±adiendo un archivo `css` de estilos)

[**Habemus web**]{.hl-green} simplemente clickando en Pages :)
:::
:::

---

## Repo con diapositivas

Vamos a crear el Ãºltimo repositorio que se llamarÃ¡ `repo-diapos`, y crear un proyecto en `RStudio` del mismo nombre (por ejemplo). Una vez creado le daremos a `File < New File < Quarto Presentation`.

::: columns
::: {.column width="45%"}
![](img/quarto-slides.png)
:::

::: {.column width="55%"}
La forma de escribir serÃ¡ igual que un `.qmd` normal solo que ahora [**cada diapositiva la separaremos**]{.hl-yellow} con un `---` (usando archivos de estilos podemos personalizar lo que queramos)

Llama al archivo directamente `index.qmd`, sÃºbelo a Github y con un click en Pages tienes una [**web con tus diapositivas**]{.hl-yellow}
:::
:::

---

## Uso de Gitkraken

La forma mÃ¡s [**sencilla para trabajar de manera colaborativa**]{.hl-yellow} en Github, y tenerlo sincronizado con nuestro local, es hacer uso de [Gitkraken](https://www.gitkraken.com/download)

::: columns
::: {.column width="50%"}
![](img/gitkraken-repo.png)
:::

::: {.column width="50%"}
Una vez dentro clickamos en el icono de la carpeta (`Repo Management`) y si ya tenemos el repositorio en Github seleccionamos `Clone`, indicando donde queremos clonar (en nuestro local) y que [**repositorio de Github queremos clonar**]{.hl-yellow}.
:::
:::

---

## Uso de Gitkraken

::: columns
::: {.column width="50%"}
![](img/view-change.png)
:::

::: {.column width="50%"}
Una vez clonado, la idea es que cada [**cambio que hagamos en local nos aparecerÃ¡ en Gitkraken**]{.hl-yellow} como `View changes`.
:::
:::

---

## Uso de Gitkraken

Cuando tengas suficientes cambios como para [**actualizar el repositorio**]{.hl-yellow} (tampoco tiene sentido actualizar con cada ediciÃ³n), verÃ¡s algo similar a esto con todos los [**commits realizados**]{.hl-yellow}

::: columns
::: {.column width="50%"}
![](img/stage-all-changes.png)
:::

::: {.column width="50%"}
PodrÃ¡s decidir cuÃ¡les de los [**commits locales quieres incluir en remoto**]{.hl-yellow}, bien uno a uno o en `Stage all changes` (para todos)
:::
:::

---

## Uso de Gitkraken

Tras incluir los commits deberÃ¡s incluir un [**tÃ­tulo y descripciÃ³n del commit**]{.hl-yellow}

![](img/titulo-commit.png)

---

## Uso de Gitkraken

Tras hacerlo verÃ¡s que ahora tenemos [**dos iconos separados en una especie de Ã¡rbol**]{.hl-yellow} (Â¿te acuerdas de la `branch` o rama?):

-   [**Ordenador**]{.hl-purple}: la versiÃ³n del repositorio que tienes en tu [**ordenador**]{.hl-yellow}.

-   [**Logo**]{.hl-purple}: la versiÃ³n del repositorio que tienes [**subida en remoto**]{.hl-yellow}

![](img/split-gitkraken.png)

---

## Uso de Gitkraken

Mientras eso suceda solo tendrÃ¡s sincronizado tu ordenador con Gitkraken, pero no con Github. Para ello haremos [**click en Push**]{.hl-yellow} (con `Pull` podrÃ¡s forzar a tener en local lo mismo que en remoto).

![](img/push-gitkraken.png)

---

## Branchs

Como hemos mencionado ya en varias ocasiones, hay un elefante en la habitaciÃ³n que aÃºn no hemos mentado: las [**ramas o branchs**]{.hl-yellow} de un repositorio.

. . .

Imagina que estÃ¡is trabajando varios en un proyecto y teneÃ­s una versiÃ³n que funciona pero que querÃ©is [**modificar en paralelo a partir del estado actual**]{.hl-yellow} del repositorio.

. . .

Las [**ramas**]{.hl-yellow} nos permiten partir de una versiÃ³n comÃºn del repositorio y hacer cambios que [**no afecten a los demÃ¡s**]{.hl-yellow}

---

## Branchs

Para [**crear una rama**]{.hl-yellow} a partir del estado actual de repositorio haremos click en `Branch` y le pondremos un nombre

![](img/branch-button.png)

Una vez creada verÃ¡s [**dos iconos**]{.hl-yellow} y un [**menÃº desplegable**]{.hl-yellow} con las distintas ramas en las que quieres hacer el commit. Imagina que realizas un cambio pero [**no quieres aÃ±adirlo a la rama principal**]{.hl-yellow}: puedes hacer el [**commit en tu rama propia en LOCAL**]{.hl-yellow} (lo harÃ¡s en la rama activa de tu menÃº de branchs).

---

## Branchs

La primera vez te pedirÃ¡ que escribas la [**rama en REMOTO**]{.hl-yellow} con la quieres sincronizar tu rama en local. [**Consejo**]{.hl-green}: ponle el mismo nombre en remoto que en local.

![](img/name-branch.png)

---

## Branchs

FÃ­jate que ahora tenemos el ordenador y el logo en el mismo sitio. Esto no significa que tengas ambas ramas en tu local, solo que [**Gitkraken tiene ambas sincronizadas**]{.hl-yellow}: clickando en cualquiera de ellas, tus archivos en tu ordenador cambiarÃ¡n.

![](img/both-branchs.png)

---

## Pull request

Lo mÃ¡s recomendable es que [**solo se incorpore de una rama secundaria**]{.hl-yellow} a la rama principal aquello que estÃ¡ [**validado por un/a coordinador/a**]{.hl-yellow} del repositorio, asegurÃ¡ndose que todo funciona correctamente.

Cuando queramos incluirlo haremos [**click con botÃ³n derecho**]{.hl-yellow} en el icono de la rama secundaria y seleccionamos `Start a pull request to origin from...`

![](img/pull-request-menu.png)

. . .

Una [**pull request**]{.hl-yellow} serÃ¡ una [**peticiÃ³n al responsable de la rama principal**]{.hl-yellow} para incluir los cambios

---

## Pull request

::: columns
::: {.column width="60%"}
![](img/create-pull-request.png)
:::

::: {.column width="40%"}
En el cuadro que no se abre deberemos escribir:

-   La [**rama**]{.hl-yellow} a la que hacer el `merge` (normalmente la `main`)
-   TÃ­tulo y resumen de los cambios
-   Puedes incluso asignar un [**revisor**]{.hl-yellow} entre los colaboradores del repo.
-   Puedes asignar [**etiquetas**]{.hl-yellow}
:::
:::

---

## Pull request

Mientras no se acepte aparecerÃ¡ un [**icono de rama**]{.hl-yellow} y un +1 en Pull Requests

![](img/pending-branch.png){width="500"}

. . .

Si somos al mantenedor del repositorio, haciendo click en el menÃº nos saldrÃ¡n las ramas que nos quieren hacer hacer `merge`

![](img/menu-pr.png){width="500"}

---

## Pull request

Al hacer click se abrirÃ¡ un [**cuadro de Pull Request**]{.hl-yellow} para decidir si

-   [**Revisar**]{.hl-yellow} los cambios
-   [**Aprobar**]{.hl-yellow} el `merge`
-   [**AÃ±adir comentarios**]{.hl-yellow} al que ha solicitado el `merge` por si queremos solicitar algÃºn cambio [**antes de ser aprobado**]{.hl-yellow}

## ![](img/menu-pr-2.png)

## Pull request

Tras revisar todo y aprobarlo clickaremos en `Confirm merge`, y tras ello podremos decidir si esa rama que era paralela a la principal la queremos [**eliminar**]{.hl-yellow} o dejar visible a todos (consejo: dejar visible para tene [**trazabilidad**]{.hl-yellow} del proyecto de trabajo)

::: columns
::: {.column width="50%"}
![](img/merge-branch.png)
:::

::: {.column width="50%"}
![](img/delete-branch.png)
:::
:::

