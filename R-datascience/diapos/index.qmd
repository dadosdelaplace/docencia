---
title: "SOFTWARE II"
subtitle: "AnÃ¡lisis de datos en R para Ciencia de Datos"
title-slide-attributes:
  data-background-image: img/data-science-2.jpeg
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Grado en Ciencia de Datos Aplicada â€¢ Javier Ãlvarez LiÃ©bana"
affiliation: Facultad de Estudios EstadÃ­sticos (UCM)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier Ãlvarez LiÃ©bana</strong>](...) â€¢ Grado en Ciencia de Datos Aplicada (UCM)"
    slide-number: c/t
execute:
  echo: true
---

::: r-fit-text
[Â¡Bienvenidos a R!]{.flow}
:::

[**Dejad vuestras hojas de cÃ¡lculo, Anacondas y SAS a un lado**]{style="color:#444442;"}

---

## Â¡Buenas!

[**Correo**]{.hl-green}: **<javalv09@ucm.es>**. [**Despacho**]{.hl-green}: 722 (3Âª planta). [**TutorÃ­as (curso 2024-2025)**]{.hl-green}: lunes y martes de 11 a 13.

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
-   [**Javier Ãlvarez LiÃ©bana**]{.hl-yellow}, de Carabanchel. Licenciado en MatemÃ¡ticas (UCM). [**Doctor en estadÃ­stica**]{.hl-yellow} (UGR)

-   Encargado de la [**visualizaciÃ³n y anÃ¡lisis de datos covid**]{.hl-yellow} del Principado de Asturias (2021-2022).

-   Miembro de la [**Sociedad EspaÃ±ola de EstadÃ­stica e IO**]{.hl-yellow} y la [**Real Sociedad MatemÃ¡tica EspaÃ±ola**]{.hl-yellow}.

- Formador de `R` en RTVE y ISCIII (actualmente) y el Ayuntamiento de Madrid (2024).

:::
:::
:::

Actualmente, [**investigador y docente en la Facultad de EstadÃ­stica de la UCM**]{.hl-yellow}, e investigador colaborador del [**Network Science Institute**]{.hl-yellow} de la Northeastern University (Boston). Divulgando por [**Twitter**](https://twitter.com/dadosdelaplace) e [**Instagram**](https://instagram.com/javieralvarezliebana)


---

## Objetivos

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
-   Quitarnos el [**miedo a los errores en programaciÃ³n**]{.hl-yellow} â†’ a programar se aprende programando

-   Entender los [**conceptos bÃ¡sicos de R**]{.hl-yellow} desde cero â†’ aprender a abstraer ideas y algoritmos

-   Utilidad de programar â†’ flujos de trabajo [**reproducibles**, **transparentes**]{.hl-yellow} y mantenibles

-   IntroducciÃ³n al [**anÃ¡lisis y preprocesamiento**]{.hl-yellow} de datos â†’ `{tidyverse}`

-   Adquirir habilidades en la [**visualizaciÃ³n de datos**]{.hl-yellow} â†’ `{ggplot2}`

:::
:::
:::

---

## EvaluaciÃ³n

-   [**Asistencia**]{.hl-yellow}. No serÃ¡ obligatoria pero se [**valorarÃ¡ positivamente**]{.hl-purple} la participaciÃ³n.

. . .

-   [**EvaluaciÃ³n continua**]{.hl-yellow}: se han planteado [**4 entregas individuales (5%-15%-25%-30%)**]{.hl-purple}, asÃ­ como una [**entrega final grupal (25%)**]{.hl-purple} (entre 4 y 7 personas). 

. . .

* [**Examen final**]{.hl-yellow}: solo [**obligatorio en caso de que en la continua individual (sin contar la grupal) no superes el 3.5 sobre 10**]{.hl-purple} de nota media. En caso contrario el dÃ­a de la entrega final grupal (dÃ­a del examen oficial de enero) deberÃ¡s realizar un examen final en lugar de la grupal.

. . .

* [**Nota mÃ¡xima**]{.hl-yellow}: para tener una nota final superior al 9 deberÃ¡s tener al menos un 8.5 de nota media en la evaluaciÃ³n continua individual (sin contar la grupal).

---

## PlanificaciÃ³n entregas

* [**Entrega I (5%)**]{.hl-yellow}: 26 de septiembre (segunda mitad de clase, 60 minutos).

* [**Entrega II (15%)**]{.hl-yellow}: 10 de octubre (120 minutos).

* [**Entrega III (25%)**]{.hl-yellow}: 11 de noviembre (120 minutos).

* [**Entrega IV (30%)**]{.hl-yellow}: aprox 19 de diciembre (120 minutos).

&nbsp;

* [**Entrega grupal (25%)** o examen final]{.hl-yellow}: 20 de enero (10:00-13:30)

&nbsp;

Se podrÃ¡n modificar las fechas por saturaciÃ³n con otras asignaturas siempre y cuando el/la delegado/a lo solicite con **mÃ¡s de 7 dÃ­as de antelaciÃ³n**.



---

## PlanificaciÃ³n {#planificacion}

::: column-screen-inset-right
::: {style="font-size:20px"}
|  CLASE | SEMANA | FECHAS | TOPIC | EJ. | WORKBOOK | ENTREGA | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
| [1](#clase-1) | S1 | 9 sep | Primeros pasos en R | [ğŸ’»](#tu-turno-1) |  |  | 
| [2](#clase-2) | S1 | 12 sep | Tipos bÃ¡sicos de datos y vectores | [ğŸ’»](#tu-turno-2-1) [ğŸ’»](#tu-turno-2-2) |  [ğŸ£](#caso-practico-2) |  |
| [3](#clase-3) | S2 | 16 sep | Textos | [ğŸ’»](#tu-turno-3-1)  |  [ğŸ£](#caso-practico-3-1) |  |
| [4](#clase-4) | S2 | 19 sep | Primeras bases de datos | [ğŸ’»](#tu-turno-3-2) [ğŸ’»](#tu-turno-3-3) |  [ğŸ£](#caso-practico-3-2) |  |
| [5](#clase-5) | S3 | 26 sep | Quarto y entrega I | | [ğŸ£](#caso-practico-4)  | [ğŸ¯ 5%](#clase-5) |
| [6](#clase-6) | S4 | 30 sep | Estructuras de control | [ğŸ’»](#tu-turno-6-1) [ğŸ’»](#tu-turno-6-2)  |  [ğŸ£](#caso-practico-6) |  |
| [7](#clase-7) | S4 | 3 oct | Funciones | [ğŸ’»](#tu-turno-7)  |  [ğŸ£](#caso-practico-7) |  |
| [8](#clase-8) | S5 | 7 oct | Tidy data | [ğŸ’»](#tu-turno-8) |  [ğŸ£](#caso-practico-8) |  |
| [9](#clase-9) | S5 | 10 oct | Entrega II | | | [ğŸ¯ 15%](#clase-9) |
| [10](#clase-10) | S6 | 14 oct | Tidyverse: filas | [ğŸ’»](#tu-turno-10-1) [ğŸ’»](#tu-turno-10-2) | [ğŸ£](#caso-practico-10) |  |
| [11](#clase-11) | S6 | 17 oct | Tidyverse: columnas | [ğŸ’»](#tu-turno-11-1) [ğŸ’»](#tu-turno-11-2) | [ğŸ£](#caso-practico-11-1) [ğŸ£](#caso-practico-11-2)  [ğŸ£](#caso-practico-11-3) |  |
| [12](#clase-12) | S7 | 21 oct | Tidyverse: resÃºmenes | [ğŸ’»](#tu-turno-12-1) |  [ğŸ£](#caso-practico-12-1) [ğŸ£](#caso-practico-12-2)  |  |
| [13](#clase-12) | S7 | 24 oct | Joins. Import/export | [ğŸ’»](#tu-turno-13-1) [ğŸ’»](#tu-turno-13-2) |  [ğŸ£](#caso-practico-13-1) [ğŸ£](#caso-practico-13-2)  |  |
| [14-15](#clase-14) | S8 | 28 oct (2 clases) | Concurso | | |  |
| [16](#clase-16) | S8 | 31 oct | Listas y paquete purrr | | |  |
| [17](#clase-17) | S9 | 4 nov | Inferencia y simulaciÃ³n | | |  |
| [18](#clase-18) | S9 | 7 nov | Repaso | | |  |
| [19](#clase-19) | S10 | 11 nov | Entrega III | | | [ğŸ¯ 25%](#clase-19) |
:::
:::


---

## Materiales

* [**Diapositivas**]{.hl-yellow}: diapositivas en `Quarto` disponibles y actualizadas en **<https://javieralvarezliebana.es/docencia/R-datascience>**. En el menÃº de las diapositivas (abajo a la izquierda) tienes una [**opciÃ³n para descargarlas en pdf**]{.hl-yellow} en `Tools`
  
&nbsp;

* [**Material**]{.hl-yellow}: [**cuadernos de trabajo**](https://javieralvarezliebana.es/docencia/R-datascience/material/) y materiales extras y **resÃºmenes de paquetes**

* [ğŸ—ƒ **Datos**]{.hl-yellow}: datasets que usaremos a lo largo de la asignatura, disponibles en **<https://javieralvarezliebana.es/docencia/R-datascience/material>**

* [ğŸ“š **Recursos de apoyo**]{.hl-yellow}: en inglÃ©s <https://r4ds.had.co.nz/> y en castellano <https://cdr-book.github.io/>, y <https://ivelasq.quarto.pub/intro-to-quarto/> para Quarto.

---

## Datasets

* [ğŸ—ƒ **Datos**]{.hl-yellow}: datasets que usaremos a lo largo de la asignatura, disponibles en **<https://javieralvarezliebana.es/docencia/R-datascience/material>**

&nbsp;

* `airquality` del paquete `{datasets}` (ya instalado por defecto):
medidas diarias (153 observaciones) de la calidad del aire en Nueva York, de mayo a septiembre de 1973. Se midieron **6 variables**: ozono, radiaciÃ³n solar, viento, temperatura, mes y dÃ­a.

* `salto_longitud`: guarda cÃ³mo ha **progresado el rÃ©cord de salto de longitud masculino**. Tabla extraÃ­da de la wikipedia <https://shorturl.at/Wqif1>

* `pinniped` del paquete `{Biostatistics}`: **peso corporal y cerebral** de 33 especies de pinnÃ­pedos (morsas, leones marinos y elefantes marinos) desagregado por sexos y mono/poligamia.

---

## Datasets

* [ğŸ—ƒ **Datos**]{.hl-yellow}: datasets que usaremos a lo largo de la asignatura, disponibles en **<https://javieralvarezliebana.es/docencia/R-datascience/material>**

&nbsp;

* `discursos`: recopila los discursos de navidad de los jefes de Estado en EspaÃ±a (en dictadura y en democracia) desde 1946 hasta 2021

* `relig_income` del paquete `{tidyr}`: recopila los datos de ingresos anuales en funciÃ³n de la religiÃ³n (fuente original <https://www.pewresearch.org/religion/religious-landscape-study/>)

* `who/who2` del paquete `{tidyr}`: datos de la OMS respecto infecciones por tuberculosis, desagregados por tipo de enfermedad, sexo y edad.

* `billboard` del paquete `{tidyr}`: ranking top 100 de canciones segÃºn Billboard (algo parecido a Los 40) para el aÃ±o 2000.


---

## Datasets

* [ğŸ—ƒ **Datos**]{.hl-yellow}: datasets que usaremos a lo largo de la asignatura, disponibles en **<https://javieralvarezliebana.es/docencia/R-datascience/material>**

&nbsp;

* `starwars` del paquete `{dplyr}`: caracterÃ­sticas de 87 personajes de las sagas de Starwars

* `lotr`: conteo de palabras por raza y gÃ©nero de los personajes de El SeÃ±or de los Anillos en cada una de las pelÃ­culas de la trilogÃ­a. ExtraÃ­dos de <https://github.com/jennybc/lotr-tidy/tree/master/data>.


* `futbol`: dataset que captura las estadÃ­sticas de los jugadores de las 5 principales ligas de futbol masculinas, desde 2005 hasta 2019. Los datos se han extraÃ­do directamente haciendo uso del paquete `{worldfootballR}`, que nos permite extraer datos de <https://www.fbref.com>


# Clase 1: [primeros pasos]{.flow} {#clase-1}



[**Instalando R y RStudio. Primeros pasos. Scripts y proyectos**]{style="color:#444442;"}


* [ğŸ’» Ejercicios resueltos](#tu-turno-1)
* [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## Requisitos

Para el curso los Ãºnicos requisitos serÃ¡n:

1.  [**ConexiÃ³n a internet**]{.hl-yellow} (para la descarga de algunos datos y paquetes).

. . .

2.  [**Instalar R**]{.hl-yellow}: serÃ¡ nuestro lenguaje. La descarga la haremos (gratuitamente) desde <https://cran.r-project.org/>

. . .

3.  [**Instalar RStudio**]{.hl-yellow} desde <https://posit.co/download/rstudio-desktop/>


::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="420"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="420"}
:::
:::

---

## R vs RStudio

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="360"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="430"}
:::
:::

::: {.fragment .fade-in-then-out}
Programaremos como escribimos (castellano, por ejemplo) â†’ `R` es [**lenguaje**]{.hl-yellow}
:::

::: {.fragment .fade-up}
-   Necesitaremos una [**gramÃ¡tica, un lenguaje**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}
-   Y un entorno, por ejemplo un [**Word**]{.hl-yellow} (`RStudio`), para escribirlo
:::
:::

---

## InstalaciÃ³n de R

El lenguaje `R` serÃ¡ nuestra [**gramÃ¡tica y ortografÃ­a**]{.hl-yellow} (nuestras reglas de juego)

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra en <https://cran.r-project.org/> y selecciona tu sistema operativo.

-   [**Paso 2**]{.hl-yellow}: para Mac basta con que hacer click en el **archivo .pkg**, y abrirlo una vez descargado. Para sistemas Windows, debemos clickar en **install R for the first time** y despuÃ©s en **Download R for Windows**. Una vez descargado, abrirlo como cualquier archivo de instalaciÃ³n.

-   [**Paso 3**]{.hl-yellow}: abrir el ejecutable de instalaciÃ³n.
:::

. . .

::: callout-warning
Siempre que tengas que descargar algo de CRAN (ya sea el propio R o un paquete), [**asegÃºrate de tener conexiÃ³n a internet**]{.hl-orange}.
:::

---

## Primera operaciÃ³n {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalaciÃ³n, tras abrir `R`, deberÃ­as ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**Primer cÃ³digo**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el cÃ³digo en la consola y daremos Â«enterÂ»). Tras ello haremos la suma `a + b`.

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## Primera operaciÃ³n {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalaciÃ³n, tras abrir `R`, deberÃ­as ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Primer cÃ³digo**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el cÃ³digo en la consola y daremos Â«enterÂ»). Tras ello haremos la suma `a + b`.


```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

---

## Primera operaciÃ³n {auto-animate="true"}

::: columns
::: {.column width="60%"}
Para comprobar la instalaciÃ³n, tras abrir `R`, deberÃ­as ver el `R GUI` (Graphical User Interface) con una **pantalla blanca** similar a esta ([**consola**]{.hl-yellow}).
:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**Primer cÃ³digo**]{.hl-yellow}: a una variable llamada `a` le **asignaremos** el valor `1` (escribiremos el cÃ³digo en la consola y daremos Â«enterÂ»). Tras ello haremos la suma `a + b`.


```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

. . .

::: callout-note
## FÃ­jate que...

En la consola aparece un nÃºmero `[1]`: simplemente es un contador de elementos (como contar filas en un Word)
:::

---

## InstalaciÃ³n de R Studio

`RStudio` serÃ¡ el [**Word**]{.hl-yellow} que usaremos para escribir (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).

::: incremental
-   [**Paso 1**]{.hl-yellow}: entra la [web oficial de RStudio](https://posit.co/download/rstudio-desktop/) (ahora llamado Posit) y selecciona la descarga gratuita.

-   [**Paso 2**]{.hl-yellow}: selecciona el ejecutable que te aparezca acorde a tu sistema operativo.

-   [**Paso 3**]{.hl-yellow}: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro y dejar que termine la instalaciÃ³n.
:::

---

## OrganizaciÃ³n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo cÃ³digo que antes (la suma de las variables) en ella. La consola serÃ¡ donde **ejecutaremos Ã³rdenes y mostraremos resultados**.

![](img/consola_rstudio.jpg){width="420"}

---

## OrganizaciÃ³n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Environment**]{.hl-yellow}: la pantalla pequeÃ±a (puedes ajustar los mÃ¡rgenes con el ratÃ³n a tu gusto) que tenemos en la parte superior derecha. Nos mostrarÃ¡ las **variables que tenemos definidas**.

![](img/environment.jpg){width="420"}

---

## OrganizaciÃ³n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha no servirÃ¡ para buscar **ayuda de funciones**, ademÃ¡s de para **visualizar grÃ¡ficos**.

![](img/multiusos.jpg){width="420"}

---

## Â¿QuÃ© es R? Â¿Por quÃ© R?

![](img/meme_barco.jpg)

---


## Â¿QuÃ© es R? Â¿Por quÃ© R?

![](img/incel_excel.png)

`R` es la evoluciÃ³n del trabajo de los laboratorios Bell con el lenguaje `S`, que fue llevado al mundo del software libre por Ross Ihaka y Robert Gentleman en los aÃ±os 90. La version `R 1.0.0` se publicÃ³ el 29 de febrero de 2000.


---

## Â¿QuÃ© es R? Â¿Por quÃ© R?

`R` es el [**lenguaje estadÃ­stico por excelencia**]{.hl-yellow}, creado por y para estadÃ­sticos/as, con 6 ventajas fundamentales [**frente a Excel, SAS, Stata o SPSS**]{.hl-red}:

. . .

-   [**Lenguaje de programaciÃ³n**]{.hl-yellow}: la obviedad â†’ anÃ¡lisis [**replicables**]{.hl-purple}

. . .

-   [**Gratuito**]{.hl-yellow}: la filosofÃ­a de la comunidad de `R` es el compartir cÃ³digo bajo **copyleft** â†’ **uso Ã©tico de dinero y algoritmos**

. . .

-   [**Software libre**]{.hl-yellow}: no solo es gratis sino que permite acceder libremente a cÃ³digo ajeno, incluso al **propio cÃ³digo fuente** â†’ [**flexibilidad y transparencia**]{.hl-purple} (Free and Open Source Software FOSS)

---

## Â¿QuÃ© es R? Â¿Por quÃ© R?

`R` es el [**lenguaje estadÃ­stico por excelencia**]{.hl-yellow}, creado por y para estadÃ­sticos/as, con 6 ventajas fundamentales [**frente a Excel, SAS, Stata o SPSS**]{.hl-red}:


-   [**Lenguaje modular**]{.hl-yellow}: hemos instalado lo mÃ­nimo, pero existen cÃ³digos de otras personas que podemos reusar (casi 20 000 [**paquetes**]{.hl-yellow}) â†’ [**ahorro de tiempo**]{.hl-purple} e [**innovaciÃ³n inmediata**]{.hl-purple}

. . .

-   [**Lenguaje de alto nivel**]{.hl-yellow}: facilita la programaciÃ³n (como Python) â†’ [**menor curva de aprendizaje**]{.hl-purple}

. . .

- [**Comunidad y empleabilidad**]{.hl-yellow}: junto con Python es el lenguaje mÃ¡s utilizado en el campo de la estadÃ­stica y la ciencia de datos en investigaciÃ³n, docencia, empresas (LÃ­nea Directa, Mapfre, TelefÃ³nica, Orange, Apple, Spotify, Netflix, El PaÃ­s, Civio, HP, etc) y organismos pÃºblicos (ISCIII, CNIC, CNIO, INE, IGN, CIS, CEO, DGT, AEMET, RTVE, etc) 


---

## Â¿Por quÃ© programar?

-   [**Automatizar**]{.hl-yellow} â†’ te permitirÃ¡ automatizar tareas recurrentes.

-   [**Replicabilidad**]{.hl-yellow} â†’ podrÃ¡s replicar tu anÃ¡lisis siempre de la misma manera.

-   [**Flexibilidad**]{.hl-yellow} â†’ podrÃ¡s adaptar el software a tus necesidades.

-   [**Transparencia**]{.hl-yellow} â†’ ser auditado por la comunidad.

![](img/the_general_problem.png)

---

## Idea fundamental: paquetes

Una de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: cÃ³digos que otras personas han implementado para **resolver un problema**

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}
-   [**InstalaciÃ³n**]{.hl-yellow}: descargamos los cÃ³digos de la web (necesitamos internet) â†’ [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)

```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}
-   [**Carga**]{.hl-yellow}: con el paquete descargado, indicamos quÃ© paquetes queremos usar cada vez que abramos `RStudio` â†’ [**traer el libro de la estanterÃ­a**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::
:::
:::

---

## Idea fundamental: paquetes

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
Una vez instalado, hay **dos manera de usar un paquete** (traerlo de la estanterÃ­a)

::: {.fragment fragment-index="1"}
-   [**Paquete entero**]{.hl-yellow}: con `library()`, usando el nombre del paquete sin comillas, cargamos en la sesiÃ³n [**todo el libro**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}
-   [**Funciones concretas**]{.hl-yellow} usando `paquete::funcion` le Ã­ndicamos que solo queremos una [**pÃ¡gina concreta de ese libro**]{.hl-purple}

```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## Te vas equivocar

Durante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera â†’ [**te vas equivocar**]{.hl-yellow}. No solo serÃ¡ importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.

. . .

-   [**Mensajes de error**]{.hl-red}: precedidos de **Â«Error in...Â»** y serÃ¡n aquellos fallos que [**impidan la ejecuciÃ³n**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Mensajes de warning**]{.hl-orange}: precedidos de **Â«Warning in...Â»** son los (posibles) fallos mÃ¡s delicados ya que son incoherencias que [**no impiden la ejecuciÃ³n**]{.hl-orange}

```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```

---

## Scripts (documentos .R)


::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}
Un [**script**]{.hl-yellow} serÃ¡ el documento en el que programamos, nuestro archivo `.doc` (aquÃ­ con extensiÃ³n `.R`) donde escribiremos las Ã³rdenes. Para **abrir nuestro primero script**, haz click en el menÃº en `File < New File < R Script`.

::: callout-warning
## Cuidado

Es importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habrÃ¡s perdido**]{.hl-orange}.
:::

:::
:::



::: callout-warning
## Cuidado

`R` es [**case-sensitive**]{.hl-orange}: es sensible a mayÃºsculas y minÃºsculas por lo que `x` y `X` representa variables distintas.
:::


---

## Ejecutando el primer script

Ahora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros cÃ³digos**]{.hl-yellow}. Â¿CÃ³mo ejecutarlo?

. . .

1.  **Escribimos** el cÃ³digo a ejecutar.

. . .

2.  **Guardamos** el archivo .R haciendo click en `Save current document`.

. . .

3.  El cÃ³digo no se ejecuta salvo que se lo indiquemos. Tenemos **tres opciones de ejecutar un script**:

-   [**Copiar y pegar**]{.hl-yellow} en consola.
-   [**Seleccionar lÃ­neas**]{.hl-yellow} y `Ctrl+Enter`
-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el cÃ³digo **completo**.

---


## SÃ© organizado: proyectos

De la misma manera que en el ordenador solemos trabajar de manera [**ordenada por carpetas**]{.hl-yellow}, en `RStudio` podemos hacer lo mismo para trabajar de [**manera eficaz creando proyectos**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
Un [**proyecto serÃ¡ una Â«carpetaÂ»**]{.hl-yellow} dentro de `RStudio`, de manera que nuestro directorio raÃ­z automÃ¡ticamente serÃ¡ la propia carpeta de proyecto (pudiendo pasar de un proyecto a otro con el menu superior derecho).

Podemos crear uno en una carpeta nueva o en una carpeta ya existente.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::


---

## ğŸ’» Tu turno {#tu-turno-1}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Crea en tu ordenador una carpeta de la asignatura y crea dentro de ella el proyecto de `RStudio`: es ahÃ­ donde vas a guardar todo lo que hagamos a lo largo de este curso.Tras crear el proyecto tendrÃ¡s un archivo `R Project`. A continuaciÃ³n crea en dicha carpeta dos subcarpetas: `datos` (es ahÃ­ donde irÃ¡s guardando los distintos datasets que usaremos) y `scripts` (es ahÃ­ donde irÃ¡s guardando los archivos `.R` de cada clase)

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Dentro del proyecto crea un script `ejercicios-clase1.R` (dentro de la carpeta `scripts`). Una vez creado define en Ã©l una variable de nombre `a` y cuyo valor sea -1. Ejecuta el cÃ³digo de las 3 maneras explicadas.

```{r}
#| code-fold: true
a <- -1
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ AÃ±ade debajo otra lÃ­nea para definir una variable `b` con el valor 5. Tras ello guarda la multiplicaciÃ³n de ambas variables. Ejecuta el cÃ³digo como consideres.

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # sin guardar
multiplicacion <- a * b # guardado
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables y guarda el resultado.

```{r}
#| eval: false
c <- # deberÃ­as asignarle el valor 3
d <- # deberÃ­as asignarle el valor -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d # sin guardar
division <- c / d # guardado
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Asigna un valor positivo a `x` y calcula su raÃ­z cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la funciÃ³n `abs()`.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

::: callout-note
## Toma nota

Comandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: lÃ­neas de cÃ³digo que hemos Â«encapsuladoÂ» bajo un nombre, y dado unos argumentos de entrada, ejecuta las Ã³rdenes (una especie de atajo). En las funciones los [**argumentos irÃ¡n SIEMPRE entre parÃ©ntesis**]{.hl-yellow}
:::


### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Usando la variable `x` ya definida, completa/modifica el cÃ³digo inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.

```{r}
#| eval: false
z <- ? - ? # completa el cÃ³digo
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Define una variable `x` y asÃ­gnale el valor `-1`. Define otra `y` y asÃ­gnale el valor `0`. Tras ello realiza las operaciones a) `x` entre `y`; b) raÃ­z cuadrada de `x`. Â¿QuÃ© obtienes?



```{r}
#| code-fold: true
#| eval: false
x <- -1
y <- 0

x / y
sqrt(x)
```

### [**Ejercicio 8**]{.hl-yellow}

ğŸ“ Escribe el cÃ³digo inferior en tu script. Â¿Por quÃ© crees que no funciona?


```{r}
#| error: true
x <- -1
y <- 0

X + y
```

:::



# Clase 2: [primeros datos y vectores]{.flow} {#clase-2}

[**Â¿QuÃ© tipos de celdas (datos) existen? Concatenando celdas: vectores**]{style="color:#444442;"}

* [ğŸ’» Ejercicios resueltos: tipos de datos](#tu-turno-2-1) 

* [ğŸ’» Ejercicios resueltos: vectores](#tu-turno-2-2) 

* [ğŸ£ Workbook/caso prÃ¡ctico](#caso-prÃ¡ctico-2)

* [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## De la CELDA a la TABLA

Â¿QuÃ© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg)

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenaciÃ³n** de valores del mismo tipo ([**vectores en R**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenaciÃ³n de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenaciÃ³n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenaciÃ³n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

---

## Pero antes...buenas prÃ¡cticas

Antes de seguir, es importante que sepas algo cuÃ¡nto antes: [**empezar en la programaciÃ³n puede ser frustrante**]{.hl-yellow}

. . .

Al igual que cuando aprendes un idioma nuevo, el primer obstÃ¡culo a solventar no es tanto quÃ© decir sino cÃ³mo decirlo de manera correcta. Y en `R` pasa lo mismo, asÃ­ que vamos a [**normalizar nuestra forma de programar**]{.hl-yellow} lo mÃ¡ximo posible para evitar errores futuros.

. . .

* [**Tip 1**]{.hl-green}: [**asignar, evaluar y comparar no es lo mismo**]{.hl-yellow}. Si te has fijado en `R` estamos usando `<-` para asignar valores a variables. Usaremos `=` para evaluar argumentos en funciones y `==` para saber si dos elementos son iguales.

```{r}
#| eval: false
x <- 1 # asignar
x = 1 # evaluar
x == 1 # comparar
```



---

## Pero antes...buenas prÃ¡cticas

* [**Tip 2**]{.hl-green}: programa como escribes. Al igual que cuando redactas en castellano, acostÃºmbrate a incorporar [**espacios y saltos de lÃ­nea**]{.hl-yellow} paranoquedarteciego (es una buena prÃ¡ctica y no un requisito porque `R` no procesa los espacios)

```{r}
#| eval: false
x <- 1 # Ã³ptimo
x<-1 # regu
x<- 1 # peor (decÃ­dete)
```

. . .

* [**Tip 3**]{.hl-green}: no seas caÃ³tico/a, [**estandariza nombres**]{.hl-yellow}. AcostÃºmbrate siempre a nombrar las variables de la misma manera. El Ãºnico requisito es que **debe empezar siempre por una letra** (y sin tildes). La forma mÃ¡s recomendable es la conocida como `snake_case`

```{r}
#| eval: false
variable_en_modo_snake_case
otraFormaMasDificilDeLeer
hay.gente.que.usa.esto
Incluso_Haygente.Caotica_que.NoMereceNuestraATENCION
```

---

## Pero antes...buenas prÃ¡cticas

* [**Tip 4**]{.hl-green}: facilita la lectura y escritura, [**pon lÃ­mites**]{.hl-yellow}. En `Tools < Global Options` puedes personalizar algunas opciones de `RStudio`. En `Code < Display` podemos indicarle en `Show margin` que los scripts nos muestren un margen "imaginario" (no interacciona con el cÃ³digo) para "forzarnos" a realizar un salto de lÃ­nea.

![](img/show_margin.jpg)


---

## Pero antes...buenas prÃ¡cticas

* [**Tip 5**]{.hl-green}: el [**tabulador es tu mejor amigo**]{.hl-yellow}. En `RStudio` tenemos una herramienta maravillosa: si escribes parte del nombre de una variable o funciÃ³n y tabulas, `RStudio` te autocompleta

![](img/tab-autocompletar.png)  


---

## Pero antes...buenas prÃ¡cticas

* [**Tip 6**]{.hl-green}: ni un parÃ©ntesis soltero. Siempre que abras un parÃ©ntesis deberÃ¡s cerrarlo. Para facilitar esta tarea entra en `Tools < Global Options < Code < Display` y activa la opciÃ³n `Rainbow parentheses`

![](img/rainbow-parentheses.jpg)



---

## Pero antes...buenas prÃ¡cticas

* [**Tip 7**]{.hl-green}: fÃ­jate en el lateral izquierdo. No solo podrÃ¡s ver la lÃ­nea de cÃ³digo por la que vas sino que, en caso de estar cometiendo un [**error de sintaxis**]{.hl-red}, el propio `RStudio` te avisarÃ¡.

![](img/rstudio-error-sintaxis.png)

* [**Tip 8**]{.hl-green}: intenta [**trabajar siempre por proyectos**]{.hl-yellow} (para esta clase, crea un script `clase2.R` en el proyecto que creamos en la anterior clase)

&nbsp;

Ver mÃ¡s tips en <https://r4ds.had.co.nz/workflow-basics.html#whats-in-a-name>

---

## Celdas: tipos de datos

Â¿Existen [**variables mÃ¡s allÃ¡ de los nÃºmeros en la ciencia de datos**]{.hl-yellow}? Piensa por ejemplo en los datos que podrÃ­as guardar de una persona:

::: {.fragment .fade-up}
-   La edad o el peso serÃ¡ un [**nÃºmero**]{.hl-yellow}.

```{r}
edad <- 33
```
:::

::: {.fragment .fade-up}
-   Su nombre serÃ¡ una cadena de [**texto (conocida como string o char)**]{.hl-yellow}.

```{r}
nombre <- "javi"
```
:::

::: {.fragment .fade-up}
-   A la pregunta Â«Â¿estÃ¡s matriculado en la Facultad?Â» la respuesta serÃ¡ lo que llamamos una [**variable lÃ³gica**]{.hl-yellow} (`TRUE` si estÃ¡ matriculado o `FALSE` en otro caso).

```{r}
matriculado <- TRUE
```
:::

::: {.fragment .fade-up}
-   Su fecha de nacimiento serÃ¡ precisamente eso, una [**fecha**]{.hl-yellow}.
:::

---

## Variables numÃ©ricas {auto-animate="true"}

El dato mÃ¡s sencillo (ya lo hemos usado) serÃ¡n las [**variables numÃ©ricas**]{.hl-yellow}. Para saber la [**clase de dato en R**]{.hl-yellow}  de una variable tenemos la funciÃ³n `class()`

```{r}
#| eval: false
#| code-line-numbers: "1"
a <- 5
```



---

## Variables numÃ©ricas {auto-animate="true"}

El dato mÃ¡s sencillo (ya lo hemos usado) serÃ¡n las [**variables numÃ©ricas**]{.hl-yellow}. Para saber la [**clase de dato en R**]{.hl-yellow}  de una variable tenemos la funciÃ³n `class()`


```{r}
#| eval: false
#| code-line-numbers: "2"
a <- 5
class(a)
```

. . .

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

Para saber su [**tipologÃ­a (naturaleza o formato)**]{.hl-yellow} variable tenemos `typeof()`

```{r}
typeof(1) # 1 pero almacenado como un valor real (double, con decimales)
typeof(as.integer(1)) # 1 pero almacenado como un entero.
```

::: callout-note
## FÃ­jate que...

En `R` tenemos una colecciÃ³n de funciones que empiezan por `as.x()` y que sirven como [**funciones de conversiÃ³n**]{.hl-yellow}: un dato que era de un tipo, lo convertimos a tipo `x`.
:::

---


## Variables numÃ©ricas


AdemÃ¡s de los nÃºmeros Â«normalesÂ» tendremos el [**valor mÃ¡s/menos infinito**]{.hl-yellow} codificado como `Inf` o `-Inf`

```{r}
1/0
```

```{r}
-1/0
```

. . .

Y valores que [**no son nÃºmeros reales**]{.hl-yellow} _not a number_ (indeterminaciones, complejos, etc) codificado como `NaN`

```{r}
0/0
```

```{r}
sqrt(-2)
```



---

## Variables numÃ©ricas

Con las variables numÃ©ricas podemos realizar las [**operaciones aritmÃ©ticas**]{.hl-yellow} de una calculadora: sumar (`+`)...

```{r}
a + b
```

. . .

...raÃ­z cuadrada (`sqrt()`)...

```{r}
sqrt(a)
```

. . .

... potencias (`^2`, `^3`)...

```{r}
a^2
```

. . .

...valor absoluto (`abs()`), etc.

```{r}
abs(a)
```


---

## Variables de texto

Imagina que ademÃ¡s de la edad de una persona queremos guardar su nombre: ahora la variable serÃ¡ de tipo `character`

```{r}
nombre <- "Javier"
class(nombre)
```

. . .

Las [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones aritmÃ©ticas**]{.hl-red} (sÃ­ otras operaciones como pegar o localizar patrones).

```{r}
#| error: true
nombre + 1 # error al sumar nÃºmero a texto
```

. . .

::: callout-warning
## Recuerda que...

Las variables de tipo texto (character o string) van [**SIEMPRE entre comillas**]{.hl-orange}: no es lo mismo `TRUE` (valor lÃ³gico, binario) que `"TRUE"` (texto).
:::

---

## Primera funciÃ³n: paste

Como hemos comentado `R` llamaremos [**funciÃ³n**]{.hl-yellow} a un trozo de [**cÃ³digo encapsulado**]{.hl-yellow} bajo un nombre, y que depende de unos [**argumentos**]{.hl-yellow} de entrada. Nuestra primera funciÃ³n serÃ¡ `paste()`: dadas dos cadenas de texto nos permite pegarlas.

```{r}
paste("Javier", "Ãlvarez")
```

. . .

FÃ­jate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos aÃ±adir un [**argumento opcional**]{.hl-yellow} para indicarle el separador (en `sep = ...`). 

```{r}
paste("Javier", "Ãlvarez", sep = "*")
```

---

## Primera funciÃ³n: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}
Â¿CÃ³mo saber [**quÃ© argumentos necesita una funciÃ³n**]{.hl-yellow}? Escribiendo en consola `? paste` te aparecerÃ¡ una [**ayuda**]{.hl-yellow} en el panel multiusos.

En dicha ayuda podrÃ¡s ver en su cabecera que argumentos ya tiene [**asignados por defecto**]{.hl-yellow} la funciÃ³n
:::
:::

. . .

Existe una funciÃ³n similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).

```{r}
paste0("Javier", "Ãlvarez")
```

---

## Primera funciÃ³n: paste

Los argumentos (y su detalle) tambiÃ©n pueden ser consultado **tabulando (detras una coma)**.

![](img/tab-functions.png)

--- 

## Funciones: argumentos por defecto

Es muy importante entender el concepto de [**argumento por defecto de una funciÃ³n**]{.hl-yellow} en `R`: es un valor que la funciÃ³n usa pero a veces podemos no ver porque [**ya tiene un valor asignado**]{.hl-yellow}. 

```{r}
# Hacen lo mismo
paste("Javier", "Ãlvarez")
paste("Javier", "Ãlvarez", sep = " ")
```

. . .

::: callout-note
## Toma nota

El operador `=` lo [**reservaremos para asignar argumentos**]{.hl-yellow} dentro de funciones. Para todas las demÃ¡s asignaciones usaremos `<-`
:::

---

## Primer paquete: glue

Una forma mÃ¡s intuitiva de trabajar con textos es usar el paquete `{glue}`: lo primero que haremos serÃ¡ Â«comprar el libroÂ» (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue") # solo la primra vez
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

Con la funciÃ³n `glue()` de dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, Â«la edad es de ... aÃ±osÂ», donde la edad estÃ¡ guardada en una variable.

```{r}
edad <- 33
glue("La edad es de {edad} aÃ±os")
```

. . .

Dentro de las llaves tambiÃ©n podemos [**ejecutar operaciones**]{.hl-yellow}

```{r}
unidades <- "dÃ­as"
glue("La edad es de {edad * 365} {unidades}")
```

---

## Variables lÃ³gicas

Otro tipo fundamental serÃ¡n las [**variables lÃ³gicas o binarias**]{.hl-yellow} (**dos valores**):

-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.
-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.

```{r}
soltero <- TRUE # Â¿Es soltero? --> SÃ
class(soltero)
```

. . .

Dado que internamente estÃ¡n guardados como variables binarias, podemos [**realizar operaciones aritmÃ©ticas**]{.hl-yellow} con ellas

```{r}
2 * TRUE
FALSE - 1
```

---

## Variables lÃ³gicas

Como veremos en breve, las variables lÃ³gicas en realidad puede tomar un tercer valor: `NA` o [**dato ausente**]{.hl-yellow}, representando las siglas de *not available*, y serÃ¡ muy habitual encontrarlo dentro de una base de datos.

```{r}
ausente <- NA
ausente + 1
```


. . .

::: callout-important
## Importante

Las variables lÃ³gicas [**NO son variables de texto**]{.hl-red}: `"TRUE"` es un texto, `TRUE` es un valor lÃ³gico.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Condiciones lÃ³gicas

Los valores lÃ³gicos suelen ser resultado de [**evaluar condiciones lÃ³gicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos [**comprobar**]{.hl-yellow} si una persona se llama Javi.

```{r}
nombre <- "MarÃ­a"
```


. . .

Con el [**operador lÃ³gico**]{.hl-yellow} `==` preguntamos sÃ­ lo que tenemos guardado a la izquierda es [**igual que**]{.hl-purple} lo que tenemos a la derecha: es una [**pregunta**]{.hl-yellow}

```{r}
nombre == "Javi"
```

. . .

Con su opuesto `!=` preguntamos [**si es distinto**]{.hl-purple}.

```{r}
nombre != "Javi"
```

. . .

::: callout-note
## FÃ­jate que...

No es lo mismo `<-` ([**asignaciÃ³n**]{.hl-yellow}) que `==` (estamos [**preguntando**]{.hl-yellow}, es una comparaciÃ³n lÃ³gica).
:::

---

## Condiciones lÃ³gicas

AdemÃ¡s de las comparaciones Â«igual aÂ» frente Â«distintoÂ», tambiÃ©n comparaciones de orden como [**menor que**]{.hl-purple} `<`, [**mayor que**]{.hl-purple} `>`,  `<=` o `>=`.

**Â¿Tiene la persona menos de 32 aÃ±os?**

```{r}
edad <- 34
edad < 32 # Â¿Es la edad menor de 32 aÃ±os?
```

. . .

**Â¿La edad es mayor o igual que 38 aÃ±os?**

```{r}
edad >= 38
```

. . .

**Â¿El nombre guardado es Javi?**

```{r}
nombre <- "Javi"
nombre == "Javi"
```

---

## Variables de fecha

Un tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.

```{r}
fecha_char <- "2021-04-21"
```

Parece una simple cadena de texto pero [**deberÃ­a representar un instante en el tiempo**]{.hl-yellow}. Â¿QuÃ© deberÃ­a suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?

. . .

```{r}
#| error: true
fecha_char + 1
```


Las fechas [**NO pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha.

. . .

&nbsp;

Para trabajar con fechas usaremos el paquete `{lubridate}`, que deberemos instalar antes de poder usarlo.

```{r}
#| eval: false
install.packages("lubridate")
```

---

## Variables de fecha

Una vez instalado, de todos los paquetes (libros) que tenemos, le indicaremos que nos cargue ese concretamente.

```{r}
library(lubridate) # instala si no lo has hecho

```

. . .

Para [**convertir a tipo fecha**]{.hl-yellow} usaremos la funciÃ³n `as_date()` del paquete `{lubridate}` (por defecto en formato `yyyy-mm-dd`)

&nbsp;

:::: columns
::: {.column width="50%"}

```{r}
#| error: true
# Â¡no es una fecha, es un texto!
fecha_char + 1
class(fecha_char)
```

:::

::: {.column width="50%"}

```{r}
fecha <- as_date("2023-03-28")
fecha + 1
class(fecha)
```

:::

::::

---

## Variables de fecha

En `as_date()` el formato de fecha por defecto es `yyyy-mm-dd` asÃ­ si la cadena de texto no se introduce de manera adecuada...

```{r}
as_date("28-03-2023")
```

. . .

Para [**cualquier otro formato debemos especificarlo**]{.hl-yellow} en el argumento opcional `format = ...` tal que `%d` representa dÃ­as, `%m` meses, `%Y` en formato de 4 aÃ±os y `%y` en formato de 2 aÃ±os.

```{r}
as_date("28-03-2023", format = "%d-%m-%Y")
as_date("28-03-23", format = "%d-%m-%y")
as_date("03-28-2023", format = "%m-%d-%Y")
as_date("28/03/2023", format = "%d/%m/%Y")
```


---

## Variables de fecha

En dicho paquete tenemos funciones muy Ãºtiles para [**manejar fechas**]{.hl-yellow}:

-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.

```{r}
today()
```

. . .

-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}

```{r}
now()
```

. . .

-   Con `year()`, `month()` o `day()` podemos [**extraer el aÃ±o, mes y dÃ­a**]{.hl-purple}

```{r}
fecha <- today()
year(fecha)
month(fecha)
```

---

## ResÃºmenes de paquetes

![](img/lubridate.png)

::: callout-note
## Amplia contenido

Tienes un resumen en pdf de los paquetes mÃ¡s importantes en la [**carpeta correspondiente en el campus**]{.hl-green}
:::

---

## ğŸ’» Tu turno {#tu-turno-2-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Define una variable que guarde tu edad (llamada `edad`) y otra con tu nombre (llamada `nombre`)

```{r}
#| code-fold: true
edad <- 33
nombre <- "Javi"
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Comprueba con dicha variable `edad` si NO tiene 60 aÃ±os o si se llama `"Ornitorrinco"` (debes obtener variables lÃ³gicas como resultado)

```{r}
#| code-fold: true
#| eval: false
edad != 60 # distinto de
nombre == "Ornitorrinco" # igual a
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Â¿Por quÃ© el cÃ³digo inferior da error?

```{r}
#| error: true
edad + nombre
```


### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Define otra variable llamada `hermanos` que responda la pregunta Â«Â¿tienes hermanos?Â» y otra variable que almacene tu fecha de nacimiento (llamada `fecha_nacimiento`).

```{r}
#| code-fold: true
hermanos <- TRUE

library(lubridate) # sino lo tenÃ­as ya cargado
fecha_nacimiento <- as_date("1989-09-10")
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Define otra variable con tus apellidos (llamada `apellidos`) y usa `glue()` para tener, en una sola variable  llamada `nombre_completo`, tu nombre y apellidos separando nombre y apellido por una coma

```{r}
#| code-fold: true
#| eval: false
apellidos <- "Ãlvarez LiÃ©bana"
glue("{nombre}, {apellidos}")
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ De `fecha_nacimiento` extrae el mes.

```{r}
#| code-fold: true
#| eval: false
month(fecha_nacimiento)
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Calcula los dÃ­as que han pasado desde la fecha de tu nacimiento hasta hoy (con la fecha de nacimiento definida en el ejercicio 4).

```{r}
#| code-fold: true
#| eval: false
today() - fecha_nacimiento
```
:::

---

## Vectores: concatenar

Cuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenaciÃ³n**]{.hl-purple} de celdas (valores) del [**mismo tipo**]{.hl-purple} (lo que serÃ­a una columna de una tabla).

. . .

La forma mÃ¡s sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus **elementos entre parÃ©ntesis y separados por comas**

```{r}
edades <- c(32, 27, 60, 61)
edades
```

. . .

::: callout-tip
Un nÃºmero individual `x <- 1` (o bien `x <- c(1)`) es en realidad un **vector de longitud uno** --> todo lo que sepamos [**hacer con un nÃºmero podemos hacerlo con un vector de ellos**]{.hl-green}.
:::

---

## Vectores: concatenar

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}
Como ves ahora en el `environment` tenemos una **colecciÃ³n de elementos** guardada

```{r}
edades
```
:::
:::

. . .



La [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`

```{r}
length(edades)
```

. . .

TambiÃ©n podemos [**concatenar vectores**]{.hl-yellow} entre sÃ­ (los repite uno tras otro)

```{r}
c(edades, edades, 8)
```

---

## Secuencias numÃ©ricas

El vector mÃ¡s famoso serÃ¡ el de tipo numÃ©rico, y en concreto, las conocidas como [**secuencias numÃ©ricas**]{.hl-yellow} (por ejemplo, los dÃ­as del mes), usadas para, entre otras cosas, indexar bucles.

. . .

El comando `seq(inicio, fin)` nos permite crear una [**secuencia numÃ©rica**]{.hl-yellow} desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.

```{r}
seq(1, 31)
```

. . .

FÃ­jate que si hacemos eso con [**caracteres no podremos hacerlo**]{.hl-red} ya que no hay un orden a priori entre textos.

```{r}
#| error: true
"a":"z"
```

---

## Secuencias numÃ©ricas


Un atajo es el comando `1:n`, que nos devuelve lo mismo que `seq(1, n)`

```{r}
1:7
```

Si el elemento inicial es mayor que el final, entenderÃ¡ que la secuencia es [**en orden decreciente**]{.hl-purple}.

```{r}
7:-3
```

. . .

TambiÃ©n podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos con el argumento `by = ...`

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

---

## Secuencias numÃ©ricas


Otras veces nos interesarÃ¡ definir una [**secuencia con una longitud concreta**]{.hl-yellow}

```{r}
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```

. . .

Incluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}

```{r}
rep(0, 7) # vector de 7 ceros
```

. . .


Dado que internamente son guardados como nÃºmeros tambiÃ©n podremos hacer esto con [**fechas**]{.hl-yellow}.

```{r}
seq(as_date("2023-09-01"), as_date("2023-09-10"), by = 1)
```


---

## Vectores de caracteres

Un vector es una **concatenaciÃ³n** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente nÃºmeros. Vamos a crear una frase de ejemplo.

```{r}
frase <- "Me llamo Javi"
frase
length(frase)
```

. . .

En el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas

```{r}
vector <- c("Me", "llamo", "Javi")
vector
length(vector)
```

---

## Vectores de caracteres

Â¿QuÃ© sucederÃ¡ si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

FÃ­jate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}

. . .

```{r}
c(3, 4, TRUE, FALSE)
```

Es importante entender que los valores lÃ³gicos en realidad estÃ¡n [**almacenados internamente como 0/1**]{.hl-yellow}

---

## Operaciones con vectores

Con los vectores numÃ©ricos podemos hacer las mismas [**operaciones aritmÃ©ticas**]{.hl-yellow} que con los nÃºmeros â†’ un [**nÃºmero es un vector**]{.hl-purple} (de longitud uno)

. . .

Â¿QuÃ© sucederÃ¡ si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Cuidado

Salvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}
:::

---

## Suma de vectores

Los vectores tambiÃ©n pueden interactuar entre ellos, asÃ­ que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)

```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Dado que la operaciÃ³n (por ejemplo, una suma) se realiza elemento a elemento, Â¿quÃ© sucederÃ¡ si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?

. . .

```{r}
z <- c(1, 3, 5, 7)
x + z
```

Lo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que harÃ¡ serÃ¡ reciclar del vector con menor longitud.

---

## Comparar vectores

Una operaciÃ³n muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones lÃ³gicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...

[**Â¿QuÃ© dÃ­as hizo menos de 22 grados?**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

Nos devolverÃ¡ un [**vector lÃ³gico**]{.hl-yellow}, en funciÃ³n de si **cada elemento** cumple o no la condiciÃ³n pedida (de **igual longitud** que el vector preguntado)

. . .

Si tuviÃ©ramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese dÃ­a), la condiciÃ³n evaluada tambiÃ©n serÃ­a `NA`

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Comparar vectores

Las [**condiciones lÃ³gicas pueden ser combinadas**]{.hl-yellow} de dos maneras:

-   [**IntersecciÃ³n**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunciÃ³n y**]{.hl-purple} con `&`) para devolver un `TRUE`

```{r}
x < 30 & x > 15
```

-   [**UniÃ³n**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunciÃ³n o**]{.hl-purple} con `|`)

```{r}
x < 30 | x > 15
```

. . .

Con `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen

```{r}
any(x < 30)
all(x < 30)
```

---

## Acceder a elementos

Otra operaciÃ³n muy habitual es la de [**acceder a elementos**]{.hl-yellow}. La forma mÃ¡s sencilla es usar el operador `[i]` (acceder al elemento i-Ã©simo)

```{r}
edades <- c(20, 30, 33, NA, 61) 
edades[3] # accedemos a la edad de la tercera persona 
```

. . .


Dado que un nÃºmero no es mÃ¡s que un vector de longitud uno, esta operaciÃ³n tambiÃ©n la podemos aplicar usando un [**vector de Ã­ndices a seleccionar**]{.hl-yellow}

```{r}
y <- c("hola", "quÃ©", "tal", "estÃ¡s", "?")
y[c(1:2, 4)] # primer, segundo y cuarto elemento
```

. . .

::: callout-tip
Para acceder al Ãºltimo, sin preocuparnos de cuÃ¡l es, podemos pasarle como Ã­ndice la propia longitud `x[length(x)]`
:::

---

## Eliminar elementos

Otras veces no querremos seleccionar sino [**eliminar algunos elementos**]{.hl-yellow}. Deberemos repetir la misma operaciÃ³n pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-Ã©simo del vector sino que lo Â«des-seleccionaÂ»

```{r}
y
y[-2]
```


. . .

En muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones lÃ³gicas**]{.hl-yellow}, en funciÃ³n de los valores, asÃ­ que pasaremos como Ã­ndice la propia condiciÃ³n (recuerda, `x < 2` nos devuelve un vector lÃ³gico)

```{r}
edades <- c(15, 21, 30, 17, 45)
nombres <- c("javi", "marÃ­a", "laura", "carla", "luis")
nombres[edades < 18] # nombres de los menores de edad
```

---


## Sumar vectores

TambiÃ©n podemos hacer uso de [**operaciones estadÃ­sticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**Â¿QuÃ© sucede cuando falta un dato (ausente)?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

Por defecto, si tenemos un dato ausente, la [**operaciÃ³n tambiÃ©n serÃ¡ ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`

```{r}
sum(x, na.rm = TRUE)
```

---

## Sumar vectores

Como hemos comentado que los valores lÃ³gicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritmÃ©ticas.


Por ejemplo, si queremos [**averiguar el nÃºmero de elementos que cumplen una condiciÃ³n**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendrÃ¡n asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar dicho vector lÃ³gico para obtener el nÃºmero de elementos que cumplen

```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Suma acumulada

Otra operaciÃ³n habitual que puede sernos Ãºtil es la [**suma acumulada**]{.hl-yellow} con `cumsum()` que, dado un vector, nos devuelve un vector a su vez con el primero, el primero mÃ¡s el segundo, el primero mÃ¡s el segundo mÃ¡s el tercero...y asÃ­ sucesivamente.

```{r}
x <- c(1, 5, 2, -1, 8)
cumsum(x)
```

[**Â¿QuÃ© sucede cuando falta un dato (ausente)?**]{.hl-yellow}


```{r}
x <- c(1, -2, 3, NA, -1)
cumsum(x)
```

En el caso de la suma acumulada lo que sucede es que [**a partir de ese valor, todo lo acumulado posterior serÃ¡ ausente**]{.hl-yellow}.

---

## Diferencia

Otra operaciÃ³n habitual que puede sernos Ãºtil es la [**diferencia (con retardo)**]{.hl-yellow} con `diff()` que, dado un vector, nos devuelve un vector con el segundo menos el primero, el tercero menos el segundo, el cuarto menos el tercero...y asÃ­ sucesivamente.


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x)
```

. . .

Con el argumento `lag = ` podemos indicar el [**retardo**]{.hl-yellow} de dicha diferencia (por ejemplo, `lag = 3` implica que se resta el cuarto menos el primero, el quinto menos el segundo, etc)


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x, lag = 3)
```

---

## Media

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La mÃ¡s conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores atÃ­picos o outliers (valores muy grandes o muy pequeÃ±os), la media se perturba con mucha facilidad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Percentiles

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.


-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Percentiles**]{.hl-yellow}: medidas de posiciÃ³n (nos dividen en partes iguales los datos).

```{r}
quantile(x) # por defecto percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

---


## Ordenar vectores

Por Ãºltimo, una acciÃ³n habitual es saber [**ordenar valores**]{.hl-yellow}:

-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(edades)
sort(edades, decreasing = TRUE)
```

. . .

-   `order()`: devuelve el [**vector de Ã­ndices**]{.hl-yellow} que tendrÃ­amos que usar para tener el vector ordenado

```{r}
order(x)
x[order(x)]
```

---

## ğŸ’» Tu turno {#tu-turno-2-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Define el vector `x` como la concatenaciÃ³n de los 5 primeros nÃºmeros impares. Calcula la longitud del vector

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Accede al tercer elemento de `x`. Accede al Ãºltimo elemento (sin importar la longitud, un cÃ³digo que pueda ejecutarse siempre). Elimina el primer elemento.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ ObtÃ©n los elementos de `x` mayores que 4. Calcula el vector `1/x` y guÃ¡rdalo en una variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Crea un vector que represente los nombres de 5 personas, de los cuales uno es desconocido.

```{r}
#| code-fold: true
#| eval: false
nombres <- c("Javi", "Sandra", NA, "Laura", "Carlos")
nombres
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Encuentra del vector `x` de ejercicios anteriores los elementos mayores (estrictos) que 1 Y ADEMÃS menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`,  Â¿por quÃ© su media no devuelve un nÃºmero sino lo que se muestra en el cÃ³digo inferior?

```{r}
x <- c(1, -5, 8, NA, 10, -3, 9)
mean(x)
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6. 

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
x[-2]
```

### [**Ejercicio 8**]{.hl-yellow}

ğŸ“ Dado el vector `x` del ejercicio anterior, Â¿cuales tienen un dato ausente? Pista: las funciones `is.algo()` comprueban si el elemento es tipo `algo` (tabula)

```{r}
#| code-fold: true
#| eval: false
is.na(x)
```


### [**Ejercicio 9**]{.hl-yellow}

ğŸ“ Define el vector `x` como la concatenaciÃ³n de los 4 primeros nÃºmeros pares. Calcula el nÃºmero de elementos de `x` menores estrictamente que 5.

```{r}
#| code-fold: true
#| eval: false
x[x < 5] 
sum(x < 5)
```


### [**Ejercicio 10**]{.hl-yellow}

ğŸ“ Calcula el vector `1/x` y obtÃ©n la versiÃ³n ordenada (de menor a mayor) de las dos formas posibles

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Ejercicio 11**]{.hl-yellow}

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Ejercicio 12**]{.hl-yellow}

ğŸ“ Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 6. Encuentra una forma de averiguar si todos los elementos son o no negativos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

:::


## ğŸ£ Caso prÃ¡ctico {#caso-practico-2}

En el paquete `{datasets}` (ya instalado por defecto) tenemos diversos conjuntos de datos y uno de ellos es `airquality`. Debajo te he extraÃ­do 3 variables de dicho dataset (fÃ­jate que se hace con `datos$variable`, ese dolar serÃ¡ importante en el futuro).

Los datos capturan [**medidas diarias (n = 153 observaciones) de la calidad del aire**]{.hl-yellow} en Nueva York, de mayo a septiembre de 1973. Se midieron **6 variables**: niveles de ozono, radiaciÃ³n solar, viento, temperatura, mes y dÃ­a.

```{r}
library(datasets)
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/intro-r-base/)


# Clase 3: [textos]{.flow} {#clase-3}

[**Profundizando en variables de tipo texto**]{style="color:#444442;"}

* [ğŸ’» Ejercicios resueltos: variables de texto](#tu-turno-3-1) 

* [ğŸ£ Workbook/caso prÃ¡ctico](#caso-practico-3-1)


* [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## Profundizando en textos

Aunque no podamos hacer operaciones aritmÃ©ticas con ellos si serÃ¡n importante algunas [**operaciones que podamos realizar con las cadenas de texto**]{.hl-yellow}

Para eso usaremos el paquete `{stringr}` (dentro del mismo Â«universo de paquetesÂ» de `{lubridate}`, del que hablaremos mÃ¡s adelante)

```{r}
library(stringr)
```

---

## Profundizando en textos

En dicho paquete vamos a trabajar particularmente con [**cuatro familias de funciones**]{.hl-yellow}

- [**ManipulaciÃ³n**]{.hl-purple}

- [**Tratamiento de espacios**]{.hl-purple}

- [**BÃºsqueda de patrones**]{.hl-purple}

---

## Utilidades bÃ¡sicas

* [**Longitud de un texto**]{.hl-yellow}: para calcular la longitud de una cadena de texto podemos usar `str_length()`

```{r}
str_length("abc")
str_length("abc 123 *")
```

. . .

Como ves **cuenta tanto nÃºmeros como espacios como caracteres que no sean alfanumÃ©ricos**. AdemÃ¡s si el texto es ausente devuelve ausente

```{r}
str_length(NA)
```

. . .

Las [**funciones del paquete estÃ¡n preparadas para ser vectorizadas**]{.hl-yellow} por lo que si aplicamos una funciÃ³n a un vector de dos elementos la aplica a ambos.

```{r}
str_length(c("abc", "defghi"))
```

---

## Utilidades bÃ¡sicas

* [**Ordenar**]{.hl-yellow}: con `str_order()` podemos ordenar cadenas de texto segÃºn su orden alfabÃ©tico (distinguiendo `..._sort()` y `..._order()` como con los nÃºmeros)

```{r}
x <- c("y", "i", "k")
str_order(x)
str_sort(x)
```

---

## ManipulaciÃ³n

* [**Extraer subcadenas**]{.hl-yellow}: dada una cadena de texto, `str_sub(texto, star = ..., end = ...)` nos extrae la subcadena desde la posiciÃ³n `star` hasta `end` (si es negativo empieza a contar por detrÃ¡s).

```{r}
str_sub("abcd efg", star = 4, end = 6)
str_sub("abcd efg", star = 5)
str_sub("abcd efg", star = 4, end = -2)
```

---

## ManipulaciÃ³n

* [**Extraer subcadenas**]{.hl-yellow}: la funciÃ³n `str_sub()` permite aplicarlo a de manera vectorial a mÃºltiples cadenas de texto, e incluso usarla para asignar valores.

```{r}
x <- c("abcdef", "ghifjk")
str_sub(x, star = 3, end = -2)
str_sub(x, star = -1, end = -1)

# En ambas cadenas, sustituimos por * en la posiciÃ³n 2
str_sub(x, star = 2, end = 2) <- "*"
```

---

## ManipulaciÃ³n

* [**Duplicar cadenas**]{.hl-yellow}: con `str_dup(..., times = ...)`, dada una cadena de texto (o varias), podemos repetir una cadena `times` veces.

```{r}
str_dup("abc", times = 3)

x <- c("abcdef", "ghifjk")
str_dup(x, times = c(2, 5))
```

---

## ManipulaciÃ³n

* [**Concatenar cadenas**]{.hl-yellow}: con `str_c` podemos concatenar distintas cadenas de texto (con `sep = ...` indicamos el caracter que harÃ¡ de separador)

```{r}
str_c("Buenos dÃ­as", "Mi nombre es Javier")
str_c("Buenos dÃ­as", "Mi nombre es Javier", sep = ". ")
```


---

## ManipulaciÃ³n

* [**MayÃºsculas/minÃºsculas**]{.hl-yellow}: con `str_to_...()` podemos convertir textos a mayÃºsculas (`..._upper`), a minÃºsculas (`..._lower`) y a tÃ­tulo (`..._title`, primera letra de cada palabra en mayÃºscula)

```{r}
str_to_upper("me llamo Javi")
str_to_lower("me llamo Javi")
str_to_title("me llamo Javi")
```

---

## ManipulaciÃ³n

* [**Reemplazar**]{.hl-yellow}: `str_replace()` busca un patrÃ³n dado en una cadena de texto y, si la encuentra, la sustituye pro otra de reemplazo

```{r}
str_replace(c("javi", "sandra", "carlos"), pattern = "i", replacement = "*")
```

. . .

Con `str_replace_all()` reemplazamos todas las coincidencias (por defecto sino solo se reemplaza la primera)

```{r}
str_replace(c("javi", "sandra", "carlos"), pattern = "a", replacement = "*")
str_replace_all(c("javi", "sandra", "carlos"), pattern = "a", replacement = "*")
```

---


## Espacios en blanco

* [**Rellenar**]{.hl-yellow}: la funciÃ³n `str_pad()` rellena una cadena con espacios (al inicio por defecto) para que tenga anchura indicada. Con `side = "both"` como argumento extra nos aÃ±ade en ambos lados. Con `side = "right"` los aÃ±ade al final. Con `pad = ...` podemos decidir si queremos rellenar con otro tipo de caracter (espacio por defecto).

```{r}
str_pad("abc", width = 6)
str_pad("abc", 12, side = "both")
str_pad("abc", 6, side = "right", pad = "*")
```

. . .

Si `width` es menor que la longitud de la cadena, no hace nada.

```{r}
str_pad("abc",  width = 2)
```

---

## Espacios en blanco

* [**Eliminar espacios**]{.hl-yellow}: con `str_trim()` podemos eliminar espacios en blanco al inicio y al final de la cadena. Si aÃ±adimos `side = ...` podemos cambiar si queremos que solo los elimine al final o al inicio (por defecto, en ambos). Con `str_squish()` cambiamos cualquier sucesiÃ³n de espacios en blanco en medio del texto por uno solo (y elimina al inicio y final)

```{r}
str_trim(" abcde   fghi ")
str_trim(" abcde   ")
str_trim(" abcde   ", side = "left")
str_squish(" abcde   fghi ")
```


---

## Patrones

* [**Detectar**]{.hl-yellow}: con `str_detect()` podemos detectar si una cadena de texto contiene o no una secuencia de caracteres

```{r}
str_detect(c("javi Ã¡lvarez", "javi reyes", "sandra reyes"), pattern = "javi")
str_detect(c("javi Ã¡lvarez", "javi reyes", "sandra reyes"), pattern = "reyes")
str_detect(c("javi Ã¡lvarez", "javi reyes", "sandra reyes"), pattern = "carlos")
```


---

## Patrones

* [**Expresiones regulares**]{.hl-yellow}: no solo vamos a poder detectar patrones simples sino que podemos hacer uso de las conocidas como **expresiones regulares**, indicÃ¡ndole por ejemplo que queremos localizar todo patrÃ³n que sea, al menos una letra

```{r}
str_detect(c("a", "ab", "abc", "abcd"), pattern = "[a-z]")
```

. . .

Si tras los corchetes indicamos `{n}` podemos detectar aquellas cadenas con n letras consecutivas

```{r}
str_detect(c("a", "ab", "abc", "abcd"), pattern = "[a-z]{3}")
```

---

## Patrones

* [**Expresiones regulares**]{.hl-yellow}: un buen manejo de estas expresiones puede sernos muy Ãºtil para, por ejemplo, detectar formatos correctos en DNI o nÃºmeros de telÃ©fono (de Madrid, por ejemplo).

Vamos a considerar que un formato correcto de DNI es aquel seguido por 8 nÃºmeros (`[0-9]{8}`) seguido directamente de una letra mayÃºscula (`[A-Z]`).

```{r}
str_detect(c("5055A198-W", "50508040W", "5050505W", "50508040-W"),
           pattern = "[0-9]{8}[A-Z]")
```

. . .

Podemos buscar distintos patrones a la vez concatenÃ¡ndolos con una `|`

```{r}
str_detect(c("5055A198-W", "50508040W", "5050505W", "50508040-W"),
           pattern = "[0-9]{8}[A-Z]|[0-9]{8}[-][A-Z]")
```


--- 

## Patrones

* [**Contar patrones**]{.hl-yellow}: con `str_count()` podemos contar cuantas veces aparece un mismo patrÃ³n

```{r}
str_count(c("abcd defg", "ab defg", "ab cd"), pattern = "[a-z]{4}")
```

---

## Patrones

* [**Localizar posiciones**]{.hl-yellow}: `str_locate()` nos permite localizar la primera posiciÃ³n en la que se produce un patrÃ³n. Con `str_locate_all()` obtenemos todos

```{r}
str_locate(c("abcde abcd", "cba", "*a*"), pattern = "a")
str_locate_all(c("abcde abcd", "cba", "*a*"), pattern = "a")
```


---

## Patrones

* [**Extraer patrones**]{.hl-yellow}: con `str_extract()` podemos extraer patrones (con `str_extract_all()` todos ellos) de una cadena de texto.

```{r}
str_extract(c("DNI: 5050W", "DNI: 50558040W, DNI: 50558080-W", "DNI: 50558080-W"),
            pattern = "[0-9]{8}[A-Z]|[0-9]{8}[-][A-Z]")
str_extract_all(c("DNI: 5050W", "DNI: 50558040W, DNI: 50558080-W", "DNI: 50558080-W"),
            pattern = "[0-9]{8}[A-Z]|[0-9]{8}[-][A-Z]")
```

---

## Patrones

* [**Dividir**]{.hl-yellow}: con `str_split()` podemos localizar un patrÃ³n y dividir la cadena de texto siempre que aparezca (con `str_split_fixed()` podemos dividir en un nÃºmero concreto de trozos)

```{r}
str_split(c("a-b-c", "ab-c-d-e"), pattern = "-")
str_split_fixed(c("a-b-c", "ab-c-d-e"), pattern = "-", n = 2)
```
. . .

Si usamos `boundary()` como patrÃ³n podemos dividir en base a caracteres, frases, palabras, etc.

```{r}
x <- "Esto es una frase. Y esto otra."
str_split(x, boundary("word"))
str_split(x, boundary("sentence"))
```

---

## ğŸ’» Tu turno (textos) {#tu-turno-3-1}


El dataset serÃ¡ `discursos` (extraÃ­do de <https://github.com/lirondos/discursos-de-navidad>) con los discursos de navidad de los jefes de Estado (1946-2021).

```{r}
load(file = "./datos/discursos.RData")
```

::: panel-tabset

### [**Ej 1**]{.hl-yellow}

ğŸ“ Convierte todos los discurso a minÃºscula (y reemplaza la variable `texto`)

```{r}
#| code-fold: true
#| eval: false

# Convertimos a minÃºscula
discursos$texto <- str_to_lower(discursos$texto)
```


### [**Ej 2**]{.hl-yellow}

ğŸ“ Elimina los: ":", ",", ".", ";", "Â¡", "!", "Â¿" y "?". Tras ello elimina espacios adelante y atrÃ¡s, y en medio si existen solo deja uno  (busca en las diapos y pdf del paquete). Como son **caracteres especiales** debes indicÃ¡rselos con `\\` delante

```{r}
str_detect(c("hola", "hola. adios"), pattern = ".")
str_detect(c("hola", "hola. adios"), pattern = "\\.")
```




```{r}
#| code-fold: true
#| eval: false

# Eliminamos los signos de puntuaciÃ³n
discursos$texto <-
  str_remove_all(discursos$texto, pattern = "\\:|\\,|\\.|\\;|\\Â¡|\\!|\\Â¿|\\?")

# Tras ello eliminamos espacios adelante, atrÃ¡s y en medio solo dejamos uno
discursos$texto <- str_squish(discursos$texto)
```

### [**Ej 3**]{.hl-yellow}

ğŸ“ Crea una nueva variable `long` con la longitud de cada discurso

```{r}
#| code-fold: true
#| eval: false

# Eliminamos los signos de puntuaciÃ³n
discursos$long <- str_length(discursos$texto)
```



### [**Ej 4**]{.hl-yellow}

ğŸ“ Determina los 5 aÃ±os con mayor longitud

```{r}
#| code-fold: true
#| eval: false

# 5 aÃ±os con mayor longitud (usamos order para obtener Ã­ndices)
discursos$year[order(discursos$long, decreasing = TRUE)[1:5]]
```

### [**Ej 5**]{.hl-yellow}

ğŸ“ Incorpora una nueva variable llamada `spain` que calcule el nÃºmero de veces que se dice "espaÃ±oles", "espaÃ±olas" o "espaÃ±a" en el discurso. Determina los 5 aÃ±os dÃ³nde menos se menten dichas palabras

```{r}
#| code-fold: true
#| eval: false

# Contamos
discursos$spain <- str_count(discursos$texto, pattern = "espaÃ±oles|espaÃ±olas|espaÃ±a")

# AÃ±os con menos menciones
discursos$year[order(discursos$spain)[1:5]]
```

### [**Ej 6**]{.hl-yellow}

ğŸ“ De los 76 aÃ±os calcula el nÃºmero de discursos en los que las palabras "mujer" o "mujeres" se nombren mÃ¡s que las palabras "hombre" u "hombres"

```{r}
#| code-fold: true
#| eval: false

sum(str_count(discursos$texto, pattern = "mujer|mujeres") >
      str_count(discursos$texto, pattern = "hombre|hombres"))
```

:::


---

## ğŸ£ Caso prÃ¡ctico I: textos {#caso-practico-3-1}

Para practicar textos y tibbles vamos a usar el dataset `salto_longitud` que tienes guardado en la carpeta de datos, que guarda cÃ³mo ha **progresado el rÃ©cord de salto de longitud masculino**. Dicha tabla ha sido extraÃ­da directamente de la wikipedia <https://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression#Low_altitude_record_progression_1965%E2%80%931991>

```{r}
load(file = "./datos/salto_longitud.RData")
```

Aunque mÃ¡s adelante veremos como extraerlo, puedes ver debajo si quieres el cÃ³digo que se ha usado para extraer la tabla

```{r}
#| code-fold: true
#| eval: false
library(rvest)
library(tidyverse)
wiki_jump <- 'https://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression'
long_jump <- read_html(wiki_jump)
salto_longitud <- html_table(html_node(long_jump, 'table'))
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/textos-primeras-bbdd/)



# Clase 4: [primeras tablas]{.flow} {#clase-4}

[**Primeras bases de datos**]{style="color:#444442;"}

* [ğŸ’» Ejercicios resueltos: matrices](#tu-turno-3-2) 

* [ğŸ’» Ejercicios resueltos: data.frame y tibble](#tu-turno-3-3) 

* [ğŸ£ Workbook/caso prÃ¡ctico](#caso-practico-3-2)

* [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## Primera base de datos

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una Â«tablaÂ» que las recopile. La opciÃ³n mÃ¡s inmediata son las [**matrices**]{.hl-yellow}: concatenaciÃ³n de variables del [**mismo tipo e igual longitud**]{.hl-purple}.

Imagina que tenemos estaturas y pesos de 4 personas. Â¿CÃ³mo [**crear un dataset con las dos variables**]{.hl-yellow}?

. . .


La opciÃ³n mÃ¡s habitual es usando `cbind()`: [**concatenamos (bind) vectores en forma de columnas (c)**]{.hl-yellow}

```{r}
#| code-line-numbers: "3"
estaturas <- c(150, 160, 170, 180)
pesos <- c(63, 70, 85, 95)
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

---

## Primer intento: matrices

TambiÃ©n podemos [**construir la matriz por filas**]{.hl-yellow} con la funciÃ³n `rbind()` (concatenar - bind - por filas  - rows), aunque lo [**recomendable es tener cada variable en columna**]{.hl-green} e individuo en fila como luego veremos.

```{r}
rbind(estaturas, pesos) # Construimos la matriz por filas
```

. . .

- Podemos [**Â«visualizarÂ» la matriz**]{.hl-yellow} con `View(matriz)`.

. . .

-   Podemos [**comprobar las dimensiones**]{.hl-yellow} con `dim()`, `nrow()` y `ncol()`: las matrices son un tipo de **datos tabulados** (organizados en filas y columnas)

```{r}
dim(datos_matriz)
nrow(datos_matriz)
ncol(datos_matriz)
```

---

## Primer intento: matrices

TambiÃ©n podemos [**Â«darle vueltaÂ» (matriz transpuesta)**]{.hl-yellow} con `t()`.

```{r}
t(datos_matriz)
```

. . .

Dado que ahora tenemos dos dimensiones en nuestros datos, para [**acceder a elementos con `[]`**]{.hl-yellow} deberemos proporcionar **dos Ã­ndices separados por comas**: Ã­ndice de la fila y de la columna 

```{r}
datos_matriz[2, 1] # segunda fila, primera columna
datos_matriz[1, 2] # primera fila, segunda columna 
```

---

## Primer intento: matrices

En algunas casos querremos obtener los [**datos totales de un individuo**]{.hl-yellow} (una fila concreta pero todas las columnas) o los valores de [**toda una variable**]{.hl-yellow} para todos los individuos (una columna concreta pero todas las filas). Para ello dejaremos [**sin rellenar uno de los Ã­ndices**]{.hl-yellow}

```{r}
datos_matriz[2, ] # segundo individuo
datos_matriz[, 1] # primera variable
```

. . .

Mucho de lo aprendido con vectores podemos hacerlo con matrices, asÃ­ podemos por ejemplo acceder a varias filas y/o columnas haciendo uso de las [**secuencias de enteros 1:n**]{.hl-yellow}

```{r}
datos_matriz[c(1, 3), 1] # primera variable para el primer y tercer individuo
```


---

## Primer intento: matrices

TambiÃ©n podemos definir una [**matriz a partir de un vector numÃ©rico**]{.hl-yellow}, reorganizando los valores en forma de matriz (sabiendo que los elementos se van [**colocando por columnas**]{.hl-purple}).

```{r}
z <- matrix(1:9, ncol = 3) 
z
```

. . .

Incluso podemos [**definir una matriz de valores constantes**]{.hl-yellow}, por ejemplo de ceros (para luego rellenar)

```{r}
matrix(0, nrow = 2, ncol = 3)
```


---

## Operaciones con matrices

Con las matrices sucede como con los vectores: cuando aplicamos una [**operaciÃ³n aritmÃ©tica lo hacemos elemento a elemento**]{.hl-yellow}

```{r}
z/5
```

. . .

Para realizar [**operaciones en un sentido matricial**]{.hl-yellow} deberemos aÃ±adir `%%`, por ejemplo, para multiplicar matrices serÃ¡ `%*%`


```{r}
z * t(z)
z %*% t(z)
```


---

## Operaciones con matrices

TambiÃ©n podemos [**realizar operaciones por columnas/filas**]{.hl-yellow} sin recurrir a bucles con la funciÃ³n `apply()`, y le indicaremos como **argumentos**

-   la matriz
-   el sentido de la operaciÃ³n (`MARGIN = 1` por filas, `MARGIN = 2` por columnas)
-   la funciÃ³n a aplicar
- argumentos extra que necesite la funciÃ³n

. . .

Por ejemplo, para aplicar una media a cada variable, serÃ¡ `mean` aplicada con `MARGIN = 2` (misma funciÃ³n para cada columna)

```{r}
# Media (mean) por columnas (MARGIN = 2)
apply(datos_matriz, MARGIN = 2, FUN = "mean")
```



---

## ğŸ’» Tu turno (matrices) {#tu-turno-3-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para definir una matriz `x` de unos, de 3 filas y 7 columnas.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ A la matriz anterior, suma un 1 a cada nÃºmero de la matriz y divide el resultado entre 5. Tras ello calcula su transpuesta

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Â¿Por quÃ© el cÃ³digo inferior nos devuelve dicho mensaje de aviso?

```{r}
#| warning: TRUE
matrix(1:15, nrow = 4)
```



### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Define la matriz `x <- matrix(1:12, nrow = 4)`. Tras ello obtÃ©n los datos del primer individuo, los datos de la tercera variable, y el elemento `(4, 1)`.

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # primera fila
x[, 3] # tercera columna
x[4, 1] # elemento (4, 1)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Define una matriz de 2 variables y 3 individuos tal que cada variable capture la estatura y la edad 3 personas, de manera que la edad de la segunda persona sea desconocida (ausente). Tras ello calcula la media de cada variable (Â¡nos debe de volver un nÃºmero!)

```{r}
#| code-fold: true
#| eval: false
datos <- cbind("edad" = c(20, NA, 25), "estatura" = c(160, 165, 170))
apply(datos, MARGIN = 2, FUN = "mean", na.rm = TRUE) # media por columnas

```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Â¿Por quÃ© devuelve error el cÃ³digo inferior? Â¿QuÃ© estÃ¡ mal?

```{r}
#| error: true
matriz <- cbind("edad" = c(15, 20, 25), "nombres" = c("javi", "sandra", "carlos"))
matriz
matriz + 1
```



:::

---

## Segundo intento: data.frame

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte (fÃ­jate en el cÃ³digo inferior: las edades y los `TRUE/FALSE` los ha convertido a texto)

```{r}
#| code-line-numbers: "4-5"
edades <- c(14, 24, NA)
soltero <- c(TRUE, NA, FALSE)
nombres <- c("javi", "laura", "lucÃ­a")
matriz <- cbind(edades, soltero, nombres)
matriz
```

. . .

De hecho al no ser nÃºmeros ya no podemos realizar operaciones aritmÃ©ticas

```{r}
#| error: true
matriz + 1
```

---

## Segundo intento: data.frame

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos en `R` lo que se conoce como [**data.frame**]{.hl-yellow}: concatenaciÃ³n de variables de igual longitud pero que pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
tabla <- data.frame(edades, soltero, nombres)
class(tabla)
tabla
```

---

## Segundo intento: data.frame

Dado que un `data.frame` es ya un intento de Â«base de datosÂ» las variables no son meros vectores matemÃ¡ticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple} que describan su significado

```{r}
library(lubridate)
tabla <-
  data.frame("edad" = edades, "estado" = soltero, "nombre" = nombres,
             "f_nacimiento" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
tabla
```

---

## Segundo intento: data.frame

[**Â¡TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} (estrictamente no podemos hablar de base de datos pero de momento como lo si fuesen). Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

![](img/view_tabla.jpg)

---

## Acceso a variables

Si queremos acceder a sus elementos, al ser de nuevo **datos tabulados**, podemos acceder como en las matrices ([**no recomendable**]{.hl-red}): de nuevo [**tenemos dos Ã­ndices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera caracterÃ­stica de la segunda persona
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
Pero tambiÃ©n tiene las ventajas de una [**Â«baseÂ» de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} ([**lo recomendable**]{.hl-green} ya que las variables pueden cambiar de posiciÃ³n y ahora sÃ­ tienen un significado), poniendo el nombre de la tabla seguido del sÃ­mbolo `$` (con el **tabulador**, nos aparecerÃ¡ un menÃº de columnas a elegir)
:::
:::

---

## Funciones de consulta

-   `names()`: nos muestra los nombres de las variables

```{r}
names(tabla)
```

. . .

-   `dim()`: nos muestra las dimensiones (tambiÃ©n `nrow()` y `ncol()`)

```{r}
dim(tabla)
```

. . .

-   Podemos acceder a las variables por su nombre

```{r}
tabla[c(1, 3), "nombre"]
tabla$nombre[c(1, 3)]
```

---

## AÃ±adir variable

Si tenemos uno ya creado y queremos [**aÃ±adir una columna**]{.hl-yellow} es tan simple como usar la funciÃ³n `data.frame()` que ya hemos visto para concatenar la columna. Vamos aÃ±adir por ejemplo una nueva variable, el nÃºmero de hermanos de cada individuo.

```{r}
# AÃ±adimos una nueva columna con nÂº de hermanos/as
hermanos <- c(0, 2, 3)
tabla <- data.frame(tabla, "n_hermanos" = hermanos)
tabla
```

---

## Intento final: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}. La principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```

. . .


En adelante usaremos el formato `tibble` ([**data.frame mejorado**]{.hl-yellow}) del paquete `{tibble}`

```{r}
library(tibble)
datos_tb <- 
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
class(datos_tb)
datos_tb
```

---

## Intento final: tibble

```{r}
datos_tb <-
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
datos_tb
```

Las tablas en formato `tibble` nos permitirÃ¡ una [**gestiÃ³n mÃ¡s Ã¡gil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

-   [**MetainformaciÃ³n**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya automÃ¡ticamente el nÃºmero de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

---

## Intento final: tibble

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
datos_tb$invent
```

. . .

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de pÃ¡ginas web y documentos sencillos
:::


---


## Recapitulando

-   Cada [**celda puede ser de un tipo diverso**]{.hl-yellow}: nÃºmeros, texto, fechas, valores lÃ³gicos, etc

. . .

-   Un [**vector es una concatenaciÃ³n de celdas**]{.hl-yellow} (las futuras columnas de nuestras tablas) --> En `R` por defecto las operaciones se hacen [**elemento a elemento**]{.hl-yellow}

. . .

-   Una [**matriz**]{.hl-yellow} nos permite concatenar [**variables del MISMO tipo y MISMA longitud**]{.hl-yellow} --> datos tabulados

. . .

-   Un [**data.frame**]{.hl-yellow} nos permite concatenar [**variables de DISTINTO tipo y MISMA longitud**]{.hl-yellow} --> usaremos [**tibble**]{.hl-yellow} como una opciÃ³n mejorada de base de datos

---

## ğŸ’» Tu turno (tb/df) {#tu-turno-3-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Carga del paquete `{datasets}` el conjunto de datos `airquality` (variables de la calidad del aire de Nueva York desde mayo hasta septiembre de 1973). Â¿Es el conjunto de datos airquality de tipo tibble? En caso negativo, conviÃ©rtelo a tibble (busca en la documentaciÃ³n del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Una vez convertido a `tibble` obtÃ©n el nombre de las variables y las dimensiones del conjunto de datos. Â¿CuÃ¡ntas variables hay? Â¿CuÃ¡ntos dÃ­as se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```


### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Cambia el cÃ³digo inferior para filtrar solo los datos de la quinta observaciÃ³n

```{r}
#| eval: false
airquality_tb[Month == 8, ]
```

```{r}
#| code-fold: true
#| eval: false
airquality_tb[5, ]
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Cambia el cÃ³digo inferior para filtrar solo los datos del mes de agosto.


```{r}
#| eval: false
airquality_tb[Month == 8, ]
```

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, ]
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Selecciona aquellos datos que no sean ni de julio ni de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month != 7 & airquality_tb$Month != 8, ]

# otra opciÃ³n
airquality_tb[!(airquality_tb$Month %in% c(7, 8)), ]
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Modifica el siguiente cÃ³digo para quedarte solo con las variable de ozono y temperatura (sin importar quÃ© posiciÃ³n ocupen)

```{r}
#| eval: false
airquality_tb[, 3]
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Selecciona los datos de temperatura y viento de agosto. 

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, c("Temp", "Wind")]
```

### [**Ejercicio 8**]{.hl-yellow}

ğŸ“ Traduce a castellano el nombre de las variables.


```{r}
#| code-fold: true
#| eval: false
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```

:::




---

## ğŸ£ Caso prÃ¡ctico II: tibble {#caso-practico-3-2}

Del paquete `{Biostatistics}` usaremos el conunto de datos `pinniped`, que guarda los **datos de peso de cuerpo y cerebro** (desagregado por sexo y mono/poligamia) de 33 especies de mamÃ­feros marinos.


```{r}
Biostatistics::pinniped
```


Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/textos-primeras-bbdd/)



# Clase 5: [entrega y Quarto]{.flow} {#clase-5}


[**Comunicar: elaborar apuntes, diapositivas, etc**]{style="color:#444442;"}

* [ğŸ£ Workbook/caso prÃ¡ctico](#caso-practico-4)

* [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## Comunicar: rmd y Quarto

Una de las [**principales fortalezas**]{.hl-yellow} de `R` es la [**facilidad para generar informes, libros, webs, apuntes y hasta diapositivas**]{.hl-yellow} (este mismo material por ejemplo). Para ello [**instalaremos**]{.hl-purple} antes

::: columns
::: {.column width="40%"}
-   el paquete `{rmarkdown}` (para generar archivos `.rmd`)

```{r}
#| eval: false
install.packages("rmarkdown")
```

- instalar [**Quarto**](https://quarto.org/docs/get-started/) (si ya conocÃ­as `R`, el Â«nuevoÂ» `.rmd` ahora como `.qmd`)
:::

::: {.column width="60%"}
![](img/quarto.png)
:::
:::

---

## Comunicar: rmd y Quarto

Hasta ahora solo hemos programado en scripts (archivos `.R`) dentro de proyectos, pero en muchas ocasiones [**no trabajaremos solos**]{.hl-yellow} y necesitaremos [**comunicar los resultados**]{.hl-yellow} en diferentes formatos:

- apuntes (para nosotros mismos)
- diapositivas
- web
- informes


Para todo ello usaremos [**Quarto**]{.hl-yellow} (ver mÃ¡s en <https://ivelasq.quarto.pub/intro-to-quarto/>)


---

## Comunicar: rmd y Quarto

Los archivos de extensiÃ³n `.qmd` (o `.rmd` antes) nos permitirÃ¡n fÃ¡cilmente combinar:

-   [**Markdown**]{.hl-yellow}: [**lenguaje tipado**]{.hl-purple} que nos permite crear contenido simple (tipo wordpress, con texto, **negritas**, _cursivas_, etc) con un diseÃ±o legible.

. . .

-   [**MatemÃ¡ticas (latex)**]{.hl-yellow}: lenguaje para escribir notaciÃ³n matemÃ¡tica como $x^2$ o $\sqrt{y}$ o $\int_{a}^{b} f(x) dx$

. . .

-   [**CÃ³digo y salidas**]{.hl-yellow}: podremos no solo mostrar el paso final sino el cÃ³digo que has ido realizando (en `R`, `Python`, `C++`, `Julia`, ...), con [**cajitas de cÃ³digo llamadas CHUNKS**]{.hl-purple}.

. . .

-   ImÃ¡genes, [**grÃ¡ficas**]{.hl-yellow}, tablas, estilos (css, js), etc.

---

## Comunicar: rmd y Quarto

La principal ventaja de realizar este tipo de material en Quarto/Rmarkdown es que, al hacerlo desde `RStudio`, puedes generar un [**informe o una presentaciÃ³n sin salirte del entorno de programaciÃ³n**]{.hl-yellow} en el que estÃ¡s trabajando

De esta forma podrÃ¡s analizar los datos, resumirlos y a la vez comunicarlos con la misma herramienta.

. . .

Recientemente el equipo de `RStudio` desarrollÃ³ [**Quarto**]{.hl-yellow}, una versiÃ³n mejorada de Rmarkdown (archivos `.qmd`), con un formato un poco mÃ¡s estÃ©tico y simple. Tienes toda la documentaciÃ³n y ejemplos en [**https://quarto.org/**](https://quarto.org/)

---

## Usos de Quarto

::: panel-tabset
### Webs

![](./img/website.png){height="350"}

### Libros

![](./img/book.png){height="350"}

### Blogs

![](./img/blog.png){height="350"}

### Presentaciones

![](./img/presentation.png){height="350"}

### Revistas

![](https://user-images.githubusercontent.com/163582/42351114-e5deaa1c-8078-11e8-90de-2aff57bba255.png){height="350"}
:::

ImÃ¡genes obtenidas de <https://ivelasq.quarto.pub/intro-to-quarto/#/working-with-the-rstudio-visual-editor>

---

## Nuestro primer informe

::: columns
::: {.column width="55%"}
![](img/quarto-create.png)
:::

::: {.column width="45%"}
Vamos a crear el [**primer fichero rmarkdown con Quarto**]{.hl-yellow} con extensiÃ³n `.qmd`. Para ello solo necesitaremos hacer click en

`File << New File << Quarto Document`
:::
:::

---

## Nuestro primer informe

:::: columns
::: {.column width="45%"}
![](img/quarto-format.png)
:::

::: {.column width="55%"}
Tras hacerlo nos aparecerÃ¡n varias [**opciones de formatos de salida**]{.hl-yellow}:

-   archivo `.pdf`
-   archivo `.html` ([**recomendable**]{.hl-yellow}): documento dinÃ¡mico, permite la interacciÃ³n con el usuario, como una Â«pÃ¡gina webÂ».
-   archivo `.doc` (nada recomendable)
:::
::::

. . .

De momento dejaremos marcado el [**formato HTML que viene por defecto**]{.hl-yellow}, y escribiremos el [**tÃ­tulo**]{.hl-yellow} de nuestro documento. Tras ello tendremos nuestro [**archivo .qmd**]{.hl-yellow} (ya no es un script .R como los que hemos abierto hasta ahora).

---

## Nuestro primer informe

:::: columns
::: {.column width="60%"}
![](img/quarto-example.png)
:::

::: {.column width="40%"}

DeberÃ­as tener algo similar a la captura de la imagen con [**dos modos de ediciÃ³n**]{.hl-yellow}: `Source` (con cÃ³digo, la opciÃ³n recomendada hasta que lo domines) y `Visual` (mÃ¡s parecido a un blog)

:::
::::

Para [**ejecutar TODO el documento**]{.hl-yellow} debes clickar `Render on Save` y darle a guardar.

---

## Salida de Quarto

![](img/quarto-prueba-html.png)

DeberÃ­as haber obtenido una [**salida en html similar a esta**]{.hl-yellow} (y se te ha generado en tu ordenador un [**archivo html**]{.hl-yellow})

---

## Editor: source vs visual

Como se indicaba, tienes dos formas de trabajar: con cÃ³digo puro y algo parecido a un Notion (blog)

![](./img/rstudio-source-visual.png)

Imagen obtenida de <https://ivelasq.quarto.pub/intro-to-quarto/#/working-with-the-rstudio-visual-editor>

---

## Nuestro primer informe

:::: columns
::: {.column width="50%"}
![](img/quarto-example.png)

:::

::: {.column width="50%"}

Un fichero `.qmd` se [**divide bÃ¡sicamente en tres partes**]{.hl-yellow}:

* [**Cabecera**]{.hl-yellow}: la parte que tienes al inicio entre `---`.

* [**Texto**]{.hl-yellow}: que podremos formatear y mejorar con negritas (escrito como **negritas**, con doble astÃ©risco al inicio y final), cursivas (_cursivas_, con barra baja al inicio y final) o destacar nombres de funciones o variables de R. Puedes aÃ±adir ecuaciones como $x^2$ (he escrito `$x^2$`, entre dÃ³lares).

* [**CÃ³digo R**]{.hl-yellow}

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera estÃ¡n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el tÃ­tulo/subtÃ­tulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes algÃºn archivo de estilos
  * `toc`: si quieres Ã­ndice o no
  * `toc-location`: posiciÃ³n del Ã­ndice
  * `toc-title`: tÃ­tulo del Ã­ndice
* `editor`: si estÃ¡s en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
format:
  html:
editor: visual
---
```

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera estÃ¡n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el tÃ­tulo/subtÃ­tulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes algÃºn archivo de estilos
  * `toc`: si quieres Ã­ndice o no
  * `toc-location`: posiciÃ³n del Ã­ndice
  * `toc-title`: tÃ­tulo del Ã­ndice
* `editor`: si estÃ¡s en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier Ã¡lvarez liÃ©bana"
format:
  html:
editor: visual
---
```

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera estÃ¡n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el tÃ­tulo/subtÃ­tulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes algÃºn archivo de estilos
  * `toc`: si quieres Ã­ndice o no
  * `toc-location`: posiciÃ³n del Ã­ndice
  * `toc-title`: tÃ­tulo del Ã­ndice
* `editor`: si estÃ¡s en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier Ã¡lvarez liÃ©bana"
format:
  html:
    style: style.css
    toc: true
editor: visual
---
```

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera estÃ¡n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el tÃ­tulo/subtÃ­tulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes algÃºn archivo de estilos
  * `toc`: si quieres Ã­ndice o no
  * `toc-location`: posiciÃ³n del Ã­ndice
  * `toc-title`: tÃ­tulo del Ã­ndice
* `editor`: si estÃ¡s en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier Ã¡lvarez liÃ©bana"
format:
  html:
    style: style.css
    toc: true
    toc-location: left
editor: visual
---
```

:::
::::

---

## Cabecera de un qmd {auto-animate="true"}

La [**cabecera estÃ¡n en formato YAML**]{.hl-yellow} y contiene los [**metadatos**]{.hl-yellow} del documento

:::: columns
::: {.column width="60%"}

* `title` y `subtitle`: el tÃ­tulo/subtÃ­tulo del documento
* `author`: autor del mismo
* `format`: formato de salida (podremos personalizar)
  * `theme`: si tienes algÃºn archivo de estilos
  * `toc`: si quieres Ã­ndice o no
  * `toc-location`: posiciÃ³n del Ã­ndice
  * `toc-title`: tÃ­tulo del Ã­ndice
* `editor`: si estÃ¡s en modo visual o source.

:::

::: {.column width="40%"}

``` yaml
---
title: "prueba"
author: "javier Ã¡lvarez liÃ©bana"
format:
  html:
    style: style.css
    toc: true
    toc-location: left
    toc-title: Ãndice
editor: visual
---
```

:::
::::


---

## Texto de un qmd

Respecto a la escritura solo hay una [**cosa importante**]{.hl-yellow}: salvo que indiquemos lo contrario, [**TODO lo que vamos a escribir es texto (normal)**]{.hl-yellow}. No cÃ³digo R.

:::: columns
::: {.column width="35%"}
![](img/quarto-prueba-qmd2.png){width=350}
![](img/quarto-prueba-html2.png){width=320}
:::

::: {.column width="65%"}
Vamos a empezar escribiendo una secciÃ³n al inicio (`# Intro` y detrÃ¡s por ej. la frase

> Este material ha sido diseÃ±ado por el profesor Javier Ãlvarez LiÃ©bana, docente en la Universidad Complutense de Madrid

AdemÃ¡s al `Running Code` le aÃ±adiremos una almohadilla `#`: las [**almohadillas FUERA DE CHUNKS**]{.hl-yellow} nos servirÃ¡n para crear [**epÃ­grafes (secciones)**]{.hl-yellow} en el documento


:::
::::


---

## Ãndice de un qmd

:::: columns
::: {.column width="40%"}
![](img/quarto-indice-qmd-2.png){width=370}
![](img/quarto-indice-html2.png){width=370}
:::

::: {.column width="60%"}
Para que el [**Ã­ndice capture dichas secciones**]{.hl-yellow} modificaremos la cabecera del archivo como se observa en la imagen (puedes cambiar la localizaciÃ³n del Ã­ndice y el tÃ­tulo si quieres para probar).

:::
::::

---

## Texto en un qmd

Vamos a [**personalizar un poco el texto**]{.hl-yellow} haciendo lo siguiente:


:::: columns
::: {.column width="50%"}
![](img/quarto-texto-mejorado-qmd.png){width=370}
![](img/quarto-texto-mejorado-html.png){width=370}
:::

::: {.column width="50%"}
* Vamos a aÃ±adir [**negrita al nombre**]{.hl-yellow} (poniendo ** al inicio y al final).

* Vamos aÃ±adir [**cursiva**]{.hl-yellow} a la palabra material (poniendo _ al inicio y al final).

* Vamos aÃ±adir un [**enlace**]{.hl-yellow} <https://www.ucm.es>, asociÃ¡ndolo al nombre de la Universidad. Para ello el tÃ­tulo lo ponemos entre corchetes y justo detrÃ¡s el enlace entre parÃ©ntesis `[Â«Universidad Complutense de MadridÂ»](https://www.ucm.es)`

:::
::::

---

## CÃ³digo en un qmd

Para [**aÃ±adir cÃ³digo R**]{.hl-yellow} debemos crear nuestras [**cajas de cÃ³digo llamadas chunks**]{.hl-yellow}: altos en el camino en nuestro texto markdown donde podremos incluir cÃ³digo de casi cualquier lenguaje (y sus salidas).

&nbsp;

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-qmd.png){width=470}
:::

::: {.column width="50%"}

Para incluir uno deberÃ¡ de ir [**encabezado**]{.hl-yellow} de la siguiente forma tienes un atajo `Command + Option + I` (Mac) o `Ctrl + Shift + I` (Windows)
:::

::::

---

## CÃ³digo en un qmd

Dentro de dicha cajita (que tiene ahora otro color en el documento) [**escribiremos cÃ³digo R**]{.hl-yellow} como lo venÃ­amos haciendo hasta ahora en los scripts.

:::: columns
::: {.column width="50%"}
![](img/quarto-chunk-1-qmd.png){width=410}
![](img/quarto-chunk-1-html.png){width=410}
:::

::: {.column width="50%"}

 Vamos por ejemplo a definir dos variables y su suma de la siguiente manera, escribiendo dicho cÃ³digo en nuestro `.qmd` (dentro de ese chunk)

```{r}
# CÃ³digo R
x <- 1
y <- 2
x + y
```

:::

::::


---

## Etiquetando chunks


:::: columns
::: {.column width="50%"}
![](img/quarto-tag-chunks-qmd.png){width=400}
![](img/quarto-tag-chunks-html.png){width=400}
:::

::: {.column width="50%"}
Los chunks pueden tener un [**nombre o etiqueta**]{.hl-yellow}, de forma que podamos referenciarlos de nuevo para no repetir cÃ³digo.
:::
::::


---

## Ejecutando chunks

:::: columns
::: {.column width="40%"}
![](img/quarto-inline-qmd.png){width=400}
![](img/quarto-inline-html.png){width=380}
:::

::: {.column width="60%"}
En cada chunk aparecen [**dos botones**]{.hl-yellow}:

* botÃ³n de [**play**]{.hl-yellow}: activa la [**ejecuciÃ³n y salida de ese chunk particular**]{.hl-yellow} (lo puedes visualizar dentro de tu propio `RStudio`)

* botÃ³n de [**rebobinar**]{.hl-yellow}: activa la [**ejecuciÃ³n y salida de todos los chunk hasta ese**]{.hl-yellow} (sin llegar a Ã©l)

&nbsp;

AdemÃ¡s podemos [**incluir cÃ³digo R dentro de la lÃ­nea de texto**]{.hl-yellow} (en lugar de mostrar el texto x ejecuta el cÃ³digo R mostrando la variable).
:::
::::



---

## PersonalizaciÃ³n de chunks

Los [**chunks podemos personalizarlos**]{.hl-yellow} con opciones al inicio del chunk precedido de `#|`:

* `#| echo: false`: [**ejecuta cÃ³digo**]{.hl-green} y se [**muestra resultado**]{.hl-green} pero [**no visualiza cÃ³digo**]{.hl-red} en la salida.

* `#| include: false`: [**ejecuta cÃ³digo**]{.hl-green} pero [**no muestra resultado**]{.hl-red} y [**no visualiza cÃ³digo**]{.hl-red} en la salida.

* `#| eval: false`: [**no ejecuta cÃ³digo**]{.hl-red}, [**no muestra resultado**]{.hl-red} pero [**sÃ­ visualiza cÃ³digo**]{.hl-green} en la salida.

* `#| message: false`: [**ejecuta cÃ³digo**]{.hl-green} pero [**no muestra mensajes de salida**]{.hl-red}.

* `#| warning: false`: [**ejecuta cÃ³digo**]{.hl-green} pero [**no muestra mensajes de warning**]{.hl-red}.

* `#| error: true`: [**ejecuta cÃ³digo**]{.hl-green} y [**permite que haya errores**]{.hl-green} mostrando el mensaje de error en la salida.


![](img/quarto-options-chunk.png){width=380}

Estas opciones podemos aplicarlas chunk a chunk o fijar los parÃ¡metros de forma global con `knitr::opts_chunk$set()` al inicio del documento (dentro de un chunk).

---

## Personalizando chunks

Si queremos que aplique la **opciÃ³n a todos los chunks por defecto** debemos incluirlo al final de la cabecera, como [**opciones de ejecuciÃ³n**]{.hl-yellow}

``` yaml
---
title: "Â¡Hola!"
format: html
editor: visual
execute:
  echo: false
---
```

---

## Organizando qmd

AdemÃ¡s de texto y cÃ³digo podemos introducir lo siguiente:

* [**Ecuaciones**]{.hl-yellow}: puedes aÃ±adir ademÃ¡s ecuaciones como $x^2$ (he escrito `$x^2$`, la ecuaciÃ³n entre dÃ³lares).

* [**Listas**]{.hl-yellow}: puedes itemizar elementos poniendo `*`

`* Paso 1: ...`

`* Paso 2: ...`

* [**Cross-references**]{.hl-yellow}: puedes etiquetar partes del documento (la etiqueta se construye con `{#nombre-seccion}`) y llamarlas luego con `[SecciÃ³n](@nombre-seccion)`

---

## GrÃ¡ficas/imÃ¡genes en qmd

:::: columns
::: {.column width="50%"}
![](img/quarto-fig-qmd.png){width=340}
![](img/quarto-fig-html.png){width=390}
:::

::: {.column width="50%"}
Por Ãºltimo, tambiÃ©n podemos [**aÃ±adir pies de grÃ¡ficas o imÃ¡genes**]{.hl-yellow} aÃ±adiendo `#| fig-cap: "..."`
:::
::::

. . .

:::: columns
::: {.column width="65%"}
FÃ­jate que el [**caption estÃ¡ en el margen**]{.hl-yellow} (por ejemplo). Puedes cambiarlo introduciendo [**ajustes en la cabecera**]{.hl-yellow} (todo lo relativo a figuras empieza por `fig-`, y puedes ver las opciones tabulando). Tienes mÃ¡s informaciÃ³n en **<https://quarto.org/>**
:::

::: {.column width="35%"}
![](img/quarto-cabecera-desplegable.png){width=400}
:::
::::

---

## AÃ±adir estilos

:::: columns
::: {.column width="50%"}
![](img/quarto-estilos-qmd.png){width=400}
![](img/quarto-estilos-html.png){width=400}
:::

::: {.column width="50%"}
Por Ãºltimo puedes aÃ±adir un [**tema personalizado**]{.hl-yellow} incluyendo un [**archivo de estilos**]{.hl-yellow} (archivo en formato `.scss` o `.css`). Te he dejado uno en <https://github.com/dadosdelaplace/docencia-R-master-bio-2324/tree/main/material>.

::: callout-important
## Importante

El archivo de estilos debe estar en la misma carpeta que el archivo `.qmd`
:::
:::
::::

---

## AÃ±adir estilos

TambiÃ©n puedes hacerlo de manera sencilla [**aÃ±adiendo a los textos un poco de HTML**]{.hl-yellow}. Por ejemplo, para personalizar el color de un texto va entre corchetes y justo tras el texto, entre llaves, las opciones de estilo

``` html
Esta palabra es [roja]{style="color:red;"} ...
```

``` html
... y esta [verde y en negrita]{style="color:green; font-weight: bold;"}
```

. . .

Esta palabra es [roja]{style="color:red;"} ...

... y esta [verde y en negrita]{style="color:green; font-weight: bold;"}

---

## Revealjs

Puedes aÃ±adir algunas Â«animacionesÂ» usando lo que se conoce como Revealjs (javascript), especifcÃ¡ndolo en la cabecera y usando [**bloques**]{.hl-yellow} de dicho lenguaje delimitados por `:::` al inicio y final, y la palabra de la Â«herramientaÂ» a usar. Por ejemplo `{.incremental}` hace una transiciÃ³n de los elementos.

``` yaml
format:
  revealjs
```
&nbsp;

``` revealjs
::: {.incremental}
- Me
- llamo
- Javi
:::
```


::: {.incremental}
- Me
- llamo
- Javi
:::

---

## Bloques de llamada

TambiÃ©n puedes usar los [**bloques de llamada**]{.hl-yellow} que por defecto son `note`, `tip`, `warning`, `caution` e `important` (aunque los puedes crear y personalizar). Para ello basta con usar `:::{.callout-tipo}` y el tipo que quieras

``` html
:::{.callout-tip}

Note that there are five types of callouts, including: 
`note`, `tip`, `warning`, `caution`, and `important`.

:::
```

. . .

:::{.callout-tip}

Recuerda que los 5 tipos son `note`, `tip`, `warning`, `caution` e `important`.

:::

. . .

:::{.callout-caution}

Ãšsalos con cabeza, a veces mucho recursos estÃ©tico puede marear.

:::

---

## MÃºltiples columnas

Con `:::: columns` podemos definir una disposiciÃ³n de [**mÃºltiples columnas**]{.hl-yellow} donde cada una viene definida por `::: {.column width="65%"} cosa :::`, indicando al lado del porcentaje cuanto quieres que ocupe cada columna (Â¡cuidado, no dejar espacios!)

``` html
:::: columns
::: {.column width="65%"}
AsÃ­ se define un vector
:::
::: {.column width="35%"}
x <- c(1, 2, 3)
x
:::
::::
```
&nbsp;

. . .

:::: columns
::: {.column width="65%"}
AsÃ­ se define un vector
:::

::: {.column width="35%"}
```{r}
x <- c(1, 2, 3)
x
```
:::
::::


---

## PestaÃ±as

Con `::: panel-tabset :::` podemos tambiÃ©n definir un panel de pestaÃ±as

``` html
### Ejercicios

Resuelve los siguientes ejercicios
::: panel-tabset

#### Ejercicio 1

Define un vector x con los primeros 3 nÃºmeros naturales

#### Ejercicio 2

Haz la suma del vector anterior
:::
```

. . .

### Ejercicios

Resuelve los siguientes ejercicios

::: panel-tabset

#### Ejercicio 1

Define un vector x con los primeros 3 nÃºmeros naturales

#### Ejercicio 2

Haz la suma del vector anterior

:::

---

## CÃ³digo ajeno a R

AdemÃ¡s `{reticulate}` nos permite crear chunks de `python` dentro de un Quarto en `R` (ver <https://quarto.org/docs/computations/python.html> para crear jupyter notebooks directamente desde Quarto)

```{r}
#| echo: false
#| eval: false
library(reticulate)
```

```{r}
#| eval: false
# install.packages("reticulate")
library(reticulate)

install_python("3.9.12") # Instalar python en PC sino lo tienes

# Instalar paquetes de Python
reticulate::py_install("numpy")
reticulate::py_install("matplotlib")
```

:::: columns
::: {.column width="60%"}

```{python}
#| eval: false
import numpy as np
import matplotlib.pyplot as plt
r = np.arange(0, 2, 0.05)
theta = 2 * np.pi * r
fig, ax = plt.subplots(
  subplot_kw = {'projection': 'polar'} 
)
ax.plot(theta, r)
plt.show()
```

:::

::: {.column width="40%"}

```{python}
#| echo: false
#| eval: false
import numpy as np
import matplotlib.pyplot as plt
r = np.arange(0, 2, 0.05)
theta = 2 * np.pi * r
fig, ax = plt.subplots(
  subplot_kw = {'projection': 'polar'} 
)
ax.plot(theta, r)
plt.show()
```

:::
::::

---


## ğŸ£ Caso prÃ¡ctico: simulacro  {#caso-practico-4}

1. Crea un documento `.qmd` en el que al menos la cabecera contenga
  - TÃ­tulo, autor y formato (html)
  - Ãndice con tÃ­tulo y situado a la derecha
  
2. Tras ello vuelve a [ejercicios del tema 3](#tu-turno-3-3) y estructura un documento donde cada ejercicio sea una subsecciÃ³n. En cada subsecciÃ³n pon el enunciado.

4. Debajo de cada enunciado pon el chunk con el cÃ³digo correspondiente, asÃ­ como comentarios de texto de la salida (con negritas y cursivas)

5. AÃ±ade un Ãºltimo chunk en el que, dado un vector `x <- 1:5`, calcules su media, e incluye con `$ $` la fÃ³rmula de la media aritmÃ©tica e incrusta ademÃ¡s una foto de la fÃ³rmula que encuentres por google.

6. Renderiza el documento para obtener el html


---

## Ejemplo de entrega

Vamos a realizar un pequeÃ±o simulacro antes de la entrega usando el dataset `starwars` del paquete `{dplyr}`

![](https://sm.ign.com/t/ign_latam/screenshot/default/baby-yoda-nombre_3x56.1280.jpg)

---

## Ejemplo de entrega

```{r}
library(dplyr)
starwars
```

En Ã©l tenemos **diferentes variables de los personajes de Star Wars**, con caracterÃ­sticas de su pelo, piel, altura, nombre, etc.


---

## Ejemplo de entrega

> Crea un documento `.qmd` con nombre, tÃ­tulo, formato e Ã­ndice. Cada ejercicio posterior serÃ¡ una subsecciÃ³n del documento. Ejecuta los chunks que consideres y comenta las salidas para responder a cada pregunta

. . .

> Ejercicio 1. Â¿CuÃ¡ntos personajes hay guardados en la base de datos? Â¿CuÃ¡ntas caracterÃ­sticas se han medido de cada uno?

. . .

> Ejercicio 2. Extrae en dos variables distintas `nombres` y `edades` las variables correspondientes de la tabla. Â¿De quÃ© tipo es la variable nombre? Â¿Y la variable birth_year?

. . .

> Ejercicio 3. ObtÃ©n el vector de nombres de los personajes ordenados de mayores a jÃ³venes.


---

## Ejemplo de entrega

> Ejercicio 4. Busca ayuda de la funciÃ³n unique(). Ãšsala para saber que modalidades tiene la variable cualitativa correspondiente al color de ojos. Â¿CuÃ¡ntos distintos hay?

. . .

> Ejercicio 5. Â¿Existe ALGÃšN valor ausente en la variable de color ojos? 

. . .

> Ejercicio 6.  Calcula la media y desviaciÃ³n tÃ­pica de las variables de estatura y peso (cuidado con los ausentes). Define un nuevo tibble con esas dos variables e incorpora una tercera variable que se llame â€œIMCâ€ que calcule el Ã­ndice de masa corporal. Incorpora con `$ $` la fÃ³rmula usada para el IMC.

---

## Entrega I (5%)

El dÃ­a de la entrega tendrÃ¡s subido una [**plantilla de entrega**]{.hl-yellow} en formato `.qmd` en el campus.

* **Descomprime la carpeta** (Â¡importante! si no descomprimes, aunque puedas editar el `.qmd`, no podrÃ¡s generar el `.html`)

* **Edita la cabecera** con tu nombre y DNI

* DeberÃ¡s **rellenar cada chunk** con el cÃ³digo que consideres (en algunos te he dejado pistas) y **cambiar** de `#| eval: false` a `#| eval: true` (si los quitas directamente, por defecto ya es true)

* DeberÃ¡s de **comentar** con texto normal lo que consideres para responder a las preguntas.

* SerÃ¡ [**OBLIGATORIO**]{.hl-yellow} subir el archivo `.html` generado (solo se corregirÃ¡ dicho archivo) asÃ­ que ve renderizando segÃºn rellenas el documento, no lo dejes para el final.


# Clase 6: [estructuras control]{.flow} {#clase-6}

[**Estructuras condicionales y bucles**]{style="color:#444442;"}

* [ğŸ’» Ejercicios resueltos: estructuras condicionales](#tu-turno-6-1) 

* [ğŸ’» Ejercicios resueltos: bucles](#tu-turno-6-2) 

* [ğŸ£ Workbook/caso prÃ¡ctico](#caso-practico-6)

* [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## Estructuras de control

Una [**estructura de control**]{.hl-yellow} se compone de una serie de comandos orientados a  [**decidir el camino**]{.hl-yellow} que tu cÃ³digo debe recorrer

* Si se cumple la condiciÃ³n A, Â¿quÃ© sucede?

* Â¿Y si sucede B?

* Â¿CÃ³mo puedo repetir una misma expresiÃ³n (dependiendo de una variable)?

. . .

Si has programado antes, quizÃ¡s te sea familiar las conocidas como [**estructuras condicionales**]{.hl-yellow} tales como `if (blabla) {...} else {...}`  o [**bucles**]{.hl-yellow} `for/while` (a evitar siempre que podamos).

---

## Estructura If

Una de las estructuras de control mÃ¡s famosas son las conocidas como [**estructuras condicionales**]{.hl-yellow} `if`.

> SI (IF) un conjunto de condiciones se cumple (TRUE), entonces ejecuta lo que haya dentro de las llaves

Por ejemplo, la estructura `if (x == 1) { cÃ³digo A }` lo que harÃ¡ serÃ¡ [**ejecutar el cÃ³digo A entre llaves**]{.hl-yellow} pero [**SOLO SI**]{.hl-purple} la [**condiciÃ³n entre parÃ©ntesis es cierta**]{.hl-purple} (solo si `x` es 1). En cualquier otro caso, no harÃ¡ nada.

. . .

Por ejemplo, definamos un vector de edades de 8 personas

```{r}
edad <- c(14, 17, 24, 56, 31, 20, 87, 73)
edad < 18
```

---

## Estructura If


Nuestra estructura condicional harÃ¡ lo siguiente: [**si existe algÃºn menor de edad, imprimirÃ¡**]{.hl-yellow} por pantalla un mensaje.

```{r}
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```

---

## Estructura If

```{r}
#| eval: false
if (any(edad < 18)) { 
  
  print("Existe alguna persona menor de edad")
  
}
```


En caso de que las [**condiciones no sean ciertas**]{.hl-yellow} dentro de `if()` (`FALSE`), no sucede nada


```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
}
```

**No obtenemos ningÃºn mensaje** porque la condiciÃ³n `all(edad >= 18)` no es `TRUE`, asÃ­ que no ejecuta nada.

---

## Estructura If-else

La estructura `if (condicion) { cÃ³digo A }` puede combinarse con un `else { cÃ³digo B }`: cuando la [**condiciÃ³n no estÃ¡ verificada**]{.hl-yellow}, se [**ejecutarÃ¡ el cÃ³digo alternativo B**]{.hl-yellow} dentro de `else { }`, permitiÃ©ndonos decidir que sucede cuando se cumple y cuando no.

. . .

Por ejemplo, `if (x == 1) { cÃ³digo A } else { cÃ³digo B }` ejecutarÃ¡ A si `x` es igual a 1 y B en cualquier otro caso.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else {
  
  print("Existe alguna persona menor de edad")
}
```

---

## Estructura If-else

Esta estructura `if - else` puede ser [**anidada**]{.hl-yellow}: imagina que queremos ejecutar un cÃ³digo si todos son menores; si no sucede, pero todos son mayores de 16, hacer otra cosa; en cualquier otra cosa, otra acciÃ³n.

```{r}
if (all(edad >= 18)) { 
  
  print("Todos son mayores de edad")
  
} else if (all(edad >= 16)) {
  
  print("Hay algÃºn menor de edad pero todos con 16 aÃ±os o mÃ¡s")
  
} else { print("Hay alguna persona con menos de 16 aÃ±os") }
```

::: callout-note
## Truco

Puedes **colapsar las estructuras** haciendo click en la flecha a la izquierda que aparece en tu script.

:::


---

## If-else vectorizado



Esta estructura condicional se puede [**vectorizar**]{.hl-yellow} (en una sola lÃ­nea) con `if_else()` (del paquete `{dplyr}`), cuyos argumentos son

* la condiciÃ³n a evaluar
* lo que sucede cuando se cumple y cuando no
* un argumento opcional para cuando la condiciÃ³n a evaluar es `NA`

Vamos a etiquetar sin son mayores/menores y un "desconocido" cuando no conocemos

```{r}
library(dplyr)
edad <- c(NA, edad)
if_else(edad >= 18, "mayor", "menor", missing = "desconocido")
```

En `R` base existe `ifelse()`: no deja especificar que hacer con los ausentes pero permite especificar distintos tipos de datos en `TRUE` y en `FALSE`.

---

## ğŸ’» Tu turno {#tu-turno-6-1}


[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Â¿CuÃ¡l es la salida del siguiente cÃ³digo?

```{r}
#| eval: false
if_else(sqrt(9) < 2, sqrt(9), 0)
```

```{r}
#| eval: false
#| code-fold: true

La salida es 0 ya que sqrt(9) es igual 3, y dado que no es menor que 2, devuelve el segundo argumento que es 0
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Â¿CuÃ¡l es la salida del siguiente cÃ³digo?

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true

La salida es el vector c(0, NA, NA, 1) ya que sqrt(1) sÃ­ es menor que 2, sqrt(9) no lo es, y tanto en el caso de sqrt(NA) (raÃ­z de ausente) como sqrt(-1) (devuelve NaN, not a number), su raÃ­z cuadrada no puede verificarse si es menor que 2 o no, asÃ­ que la salida es NA.
```


### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para que, cuando no se pueda verificar si la raÃ­z cuadrada de un nÃºmero es menor que 2, devuelva -1

```{r}
#| eval: false
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1)
```

```{r}
#| eval: false
#| code-fold: true
x <- c(1, NA, -1, 9)
if_else(sqrt(x) < 2, 0, 1, missing = -1)
```


### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Â¿CuÃ¡l es son los valores de `x` e `y` del cÃ³digo inferior para `z <- 1`, `z <- -1` y `z <- -5`?

```{r}
#| eval: false
z <- -1
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
En primero caso x = 1 e y = -1. En el segundo caso x = 1 e y = 1. En el tercer caso -2.5 y 5
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Â¿QuÃ© pasarÃ­a si ejecutamos el siguiente cÃ³digo? Spoiler: da error. Â¿Por quÃ©? Â¿CÃ³mo solucionarlo?

```{r}
#| eval: false
z <- c(-1, 1, 5)
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| eval: false
#| code-fold: true
Da error ya que en los `if (condiciÃ³n) { } else { }` "clÃ¡sicos" necesitamos que
la condiciÃ³n tenga longitud uno (un solo valor TRU/FALSE)
```

```{r}
#| eval: false
#| code-fold: true
# para arreglarlo podemos hacer un if_else vectorial
z <- c(-1, 1, -5)
library(dplyr)
x <- if_else(z > 0, z^3, if_else(abs(z) < 2, z^4, z/2))
y <- if_else(z > 0, -sqrt(z), if_else(abs(z) < 2, sqrt(-z), abs(z)))
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Â¿QuÃ© sucederÃ¡ si ejecutamos el cÃ³digo inferior?

```{r}
#| eval: false
z <- "a"
if (z > 0) {
  
  x <- z^3
  y <- -sqrt(z)
  
} else if (abs(z) < 2) {
  
  x <- z^4
  y <- sqrt(-z)
  
} else {
  
  x <- z/2
  y <- abs(z)
  
}
```

```{r}
#| code-fold: true
#| eval: false

# darÃ¡ error ya que no es un argumento numÃ©rico
Error in z^3 : non-numeric argument to binary operator
```


### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Del paquete `{lubridate}`, la funciÃ³n `hour()` nos devuelve la hora de una fecha dada, y la funciÃ³n `now()` nos devuelve fecha y hora del momento actual. Con ambas funciones haz que se imprima por pantalla (`cat()`) "buenas noches" solo a partir de las 21 horas.

```{r}
#| code-fold: true
#| eval: false

# Cargamos librerÃ­a
library(lubridate)

# Fecha-hora actual
fecha_actual <- now()

# Estructura if
if (hour(fecha_actual) > 21) {
  
  cat("Buenas noches") # print/cat dos formas de imprimir por pantalla
}
```


:::

---

## Bucles

Aunque en la mayorÃ­a de ocasiones se pueden reemplazar por otras estructuras mÃ¡s eficientes y legibles, es importante conocer una de las expresiones de control mÃ¡s famosas: los [**bucles**]{.hl-yellow}.

* `for { }`: permite [**repetir el mismo cÃ³digo**]{.hl-yellow} en un [**nÃºmero prefijado y conocido**]{.hl-purple} de veces.

* `while { }`: permite [**repetir el mismo cÃ³digo**]{.hl-yellow} pero en un [**nÃºmero indeterminado de veces**]{.hl-purple} (hasta que una **condiciÃ³n** deje de cumplirse).

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de Ã³rdenes un nÃºmero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de Ã­ndices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacÃ­a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los parÃ©ntesis indicaremos un Ã­ndice y unos valores a recorrer, dentro de las llaves el cÃ³digo a ejecutar en cada iteraciÃ³n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()
```

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de Ã³rdenes un nÃºmero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de Ã­ndices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacÃ­a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los parÃ©ntesis indicaremos un Ã­ndice y unos valores a recorrer, dentro de las llaves el cÃ³digo a ejecutar en cada iteraciÃ³n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  
}
```

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de Ã³rdenes un nÃºmero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de Ã­ndices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vacÃ­a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los parÃ©ntesis indicaremos un Ã­ndice y unos valores a recorrer, dentro de las llaves el cÃ³digo a ejecutar en cada iteraciÃ³n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
```

---

## Bucles for

FÃ­jate que debido a que `R` funciona de manera [**vectorial por defecto**]{.hl-yellow}, el bucle es lo mismo que hacer `x + 1` directamente.

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
y

y2 <- x + 1
y2
```

---

## Bucles for

Otra opciÃ³n habitual es indicar los Ã­ndices de manera Â«automÃ¡ticaÂ»: desde el primero `1` hasta el Ãºltimo (que corresponde con la longitud de x `length(x)`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:length(x)) {
  y[i] <- x[i] + 1
}
y

```


---

## Bucles for

AsÃ­ la [**estructura general de un bucle for**]{.hl-yellow} serÃ¡ siempre la siguiente

```{r}
#| eval: false
for (Ã­ndice in conjunto) { 
  cÃ³digo (dependiente de i)
}
```

[**SIEMPRE**]{.hl-green} sabemos cuÃ¡ntas iteraciones tenemos (tantas como elementos haya en el conjunto a indexar)

---

## Evitando bucles


Como ya hemos aprendido con el paquete`{microbenchmark}` podemos chequear como [**los bucles suelen ser muy ineficientes**]{.hl-yellow} (de ahÃ­ que debamos evitarlos en la mayorÃ­a de ocasiones

```{r}
library(microbenchmark)
x <- 1:1000
microbenchmark(y <- x^2, 
               for (i in 1:100) { y[i] <- x[i]^2 },
               times = 500)
```

---
 
## Bucles for


Podemos ver otro ejemplo de bucle  [**combinando nÃºmeros y textos**]{.hl-yellow}: definimos un vector de edades y de nombres, e imprimimos el nombre y edad i-Ã©sima.

```{r}
nombres <- c("Javi", "Sandra", "Carlos", "Marcos", "Marta")
edades <- c(33, 27, 18, 43, 29)

for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} aÃ±os")) 
  
}
```


---

## Bucles for

Aunque normalmente se suelen indexar con vectors numÃ©ricos, los bucles pueden ser [**indexados sobre cualquier estructura vectorial**]{.hl-yellow}, da igual de que tipo sea el conjunto

```{r}
library(stringr)
week_days <- c("monday", "tuesday", "wednesday", "thursday",
               "friday", "saturday", "sunday")

for (days in week_days) {
  
  print(str_to_upper(days))
}
```

---

## Bucles y condicionales

Vamos a **combinar las estructuras condicionales y los bucles**: usando el conjunto `swiss` del paquete `{datasets}`, vamos a asignar `NA`  si los valores de fertilidad son mayores de 80.

```{r}
for (i in 1:nrow(swiss)) {
  
  if (swiss$Fertility[i] > 80) { 
    
    swiss$Fertility[i] <- NA
    
  }
}
```

. . .

Esto es exactamente igual a un `if_else()` vectorizado

```{r}
data("swiss")
swiss$Fertility <- if_else(swiss$Fertility > 80, NA, swiss$Fertility)
```


---

## Bucles while

Otra forma de crear un bucle es con la estructura `while { }`, que nos ejecutarÃ¡ un bucle [**un nÃºmero desconocido de veces**]{.hl-yellow}, hasta que una condiciÃ³n [**deje de cumplirse**]{.hl-yellow} (de hecho puede que nunca termine). Por ejemplo, vamos a inializar una variable `ciclos <- 1`, que incrementaremos en cada paso, y no saldremos del bucle hasta que `ciclos > 4`.

```{r}
ciclos <- 1
while(ciclos <= 4) {
  
  print(glue("No todavÃ­a, vamos por el ciclo {ciclos}")) 
  ciclos <- ciclos + 1
  
}
```

---

## Bucles while

Un bucle `while` serÃ¡ siempre como sigue

```{r}
#| eval: false
while(condiciÃ³n) {
  
  cÃ³digo a hacer mientras la condiciÃ³n sea TRUE
  # normalmente aquÃ­ se actualiza alguna variable
  
}
```

---
  
## Bucles while

Â¿QuÃ© sucede cuando la [**condiciÃ³n nunca es FALSE**]{.hl-yellow}? PruÃ©balo tu mismo

```{r}
#| eval: false
while (1 > 0) {
  
  print("Presiona ESC para salir del bucle")
  
}
```

&nbsp;

::: callout-warning
## Cuidado

Un bucle `while { }` puede ser bastante Â«peligrosoÂ» sino controlamos bien cÃ³mo pararlo.

:::

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `break`: permite [**abortar un bucle**]{.hl-yellow} incluso si no se ha llegado a su final

```{r}
for(i in 1:10) {
  if (i == 3) {
    
    break # si i = 3, abortamos bucle
    
  }
  print(i)
}
```

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `next`: [**fuerza un bucle a avanzar a la siguiente iteraciÃ³n**]{.hl-yellow} 

```{r}
for(i in 1:5) {
  if (i == 3) {
    
    next # si i = 3, la obvia y continua al siguiente
    
  }
  print(i)
}
```

---

## Bucles repeat

Aunque no es tan usado como las opciones anteriores, tambiÃ©n contamos con `repeat { }` que ejecuta un [**bucle de manera infinita hasta que se indique abortar**]{.hl-yellow} con un break

```{r}
count <- 0
repeat { 
  
  count <- count + 1
  if (count >= 100) { break }
  
}
count
```


---

## Replicate

Aunque no es formalmente un bucle, otra forma de [**repetir cÃ³digo un nÃºmero de veces**]{.hl-yellow} es hacer uso de `replicate()`: simplemente permite repetir lo mismo [**n veces**]{.hl-yellow}

```{r}
x <- 1:3
replicate(n = 3, x^2)
```

---

## Replicate

La funciÃ³n `replicate()` se suele usar para [**generar distintas repeticiones de elementos aleatorios**]{.hl-yellow}. Por ejemplo, imaginemos que queremos generar 3 muestras de distribuciones normales, en la que cada muestra tendrÃ¡ 7 elementos. Para generar una se usa `rnorm(n = 7)` (r de resample, norm de normal, y si no se dice nada es media 0 y desv 1).

```{r}
replicate(n = 3, rnorm(n = 7))
```

---


## ğŸ’» Tu turno {#tu-turno-6-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para que se imprima un mensaje por pantalla si y solo si todos los datos de `airquality` son con mes distinto a enero

```{r}
#| eval: false
library(datasets)
months <- airquality$Month

if (months == 2) {
  print("No hay datos de enero")
}
```

```{r}
#| code-fold: true
#| eval: false
library(datasets)
months <- airquality$Month

if (all(months != 1)) {
  print("No hay datos de enero")
}
```


### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para guardar en una variable llamada `temp_alta` un `TRUE` si alguno de los registros tiene una temperatura superior a 90 grados Farenheit y `FALSE` en cualquier otro caso
 
```{r}
#| eval: false
temp <- airquality$Temp

if (temp == 100) {
  print("Algunos de los registros tienen temperaturas superiores a 90 grados Farenheit")
}
```

 
```{r}
#| eval: false
#| code-fold: true
# Option 1
temp <- airquality$Temp
temp_alta <- FALSE
if (any(temp > 90)) {
   temp_alta <- TRUE
}

# Option 2
temp_alta <- any(airquality$Temp > 90)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para diseÃ±ar un bucle `for` de 5 iteraciones que solo recorra los primeros 5 impares (y en cada paso del bucle los imprima)

```{r}
#| eval: false
for (i in 1:5) {
  
  print(i)
}
```

```{r}
#| eval: false
#| code-fold: true
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i)
}
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para diseÃ±ar un bucle `while` que empiece con un contador `count <- 1` y pare cuando llegue a 6

```{r}
#| eval: false
count <- 1
while (count == 2) {
  
  print(count)
}
```

```{r}
#| eval: false
#| code-fold: true
count <- 1
while (count < 6) {
  
  print(count)
  count <- count + 1
  
}
```


:::

---

## ğŸ£ Caso prÃ¡ctico {#caso-practico-6}


Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/control-bucles-if-else/) donde tendrÃ¡s que diseÃ±ar algunos estudios de simulaciÃ³n haciendo uso de **bucles y estructuras condicionales**



# Clase 7: [funciones]{.flow} {#clase-7}

[**Â¿QuÃ© es una funciÃ³n? Â¿CÃ³mo se definen? Variables locales vs globales**]{style="color:#444442;"}

* [ğŸ’» Ejercicios resueltos: funciones](#tu-turno-7) 

* [ğŸ£ Workbook/caso prÃ¡ctico](#caso-practico-7)

* [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, ademÃ¡s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. Â¿CÃ³mo [**crear nuestra propia funciÃ³n**]{.hl-purple}? Veamos su **esquema bÃ¡sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraÃ±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funciÃ³n dentro de `{ }`.

* Finalizamos la funciÃ³n con los [**argumentos de salida**]{.hl-yellow} con `return()`.



```{r}
#| eval: false
name_fun <- function() {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, ademÃ¡s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. Â¿CÃ³mo [**crear nuestra propia funciÃ³n**]{.hl-purple}? Veamos su **esquema bÃ¡sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraÃ±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funciÃ³n dentro de `{ }`.

* Finalizamos la funciÃ³n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, ademÃ¡s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. Â¿CÃ³mo [**crear nuestra propia funciÃ³n**]{.hl-purple}? Veamos su **esquema bÃ¡sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraÃ±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funciÃ³n dentro de `{ }`.

* Finalizamos la funciÃ³n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  cÃ³digo a ejecutar
  
}
```

---


## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, ademÃ¡s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. Â¿CÃ³mo [**crear nuestra propia funciÃ³n**]{.hl-purple}? Veamos su **esquema bÃ¡sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extraÃ±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funciÃ³n dentro de `{ }`.

* Finalizamos la funciÃ³n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  cÃ³digo a ejecutar
  
  return(var_salida)
  
}
```


---

## Creando funciones

* `arg1, arg2, ...`: serÃ¡n los [**argumentos de entrada**]{.hl-yellow}, los argumentos que toma la funciÃ³n para ejecutar el cÃ³digo que tiene dentro

* `cÃ³digo`: lÃ­neas de cÃ³digo que queramos que [**ejecute la funciÃ³n**]{.hl-yellow}. 

* `return(var_salida)`: se introducirÃ¡n los [**argumentos de salida**]{.hl-yellow}.


```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # CÃ³digo que queramos ejecutar
  cÃ³digo
  
  # Salida
  return(var_salida)
  
}
```

::: callout-important
## Importante

Todas las variables que definamos dentro de la funciÃ³n son [**variables LOCALES: solo existirÃ¡n dentro de la funciÃ³n**]{.hl-yellow} salvo que especifiquemos lo contrario.

:::

---

## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funciÃ³n para [**calcular el Ã¡rea de un rectÃ¡ngulo**]{.hl-yellow}.

Dado que el Ã¡rea de un rectÃ¡ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serÃ¡n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} serÃ¡ justo su **Ã¡rea** ($lado_1 * lado_2$).

```{r}
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
}
```

---


## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funciÃ³n para [**calcular el Ã¡rea de un rectÃ¡ngulo**]{.hl-yellow}.

Dado que el Ã¡rea de un rectÃ¡ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serÃ¡n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} serÃ¡ justo su **Ã¡rea** ($lado_1 * lado_2$).

```{r}
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  
}
```

---


## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funciÃ³n para [**calcular el Ã¡rea de un rectÃ¡ngulo**]{.hl-yellow}.

Dado que el Ã¡rea de un rectÃ¡ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos serÃ¡n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} serÃ¡ justo su **Ã¡rea** ($lado_1 * lado_2$).

```{r}
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  return(area)
  
}
```

---

## Uso de funciones

TambiÃ©n podemos hacer una definiciÃ³n directa de las variables **sin almacenar por el camino**.

```{r}
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  return(lado_1 * lado_2)
  
}
```

. . .

[**Â¿CÃ³mo aplicar la funciÃ³n?**]{.hl-yellow}

```{r}
calcular_area(5, 3) # Ã¡rea de un rectÃ¡ngulo 5 x 3 
calcular_area(1, 5) # Ã¡rea de un rectÃ¡ngulo 1 x 5
```

---

## Uso de funciones

::: callout-tip

Aunque no sea necesario, es [**recomendable hacer explÃ­cita la llamada de los argumentos**]{.hl-green}, especificando en el cÃ³digo quÃ© valor es para cada argumento para que no dependa de su orden, haciendo el cÃ³digo mÃ¡s legible
:::


```{r}
calcular_area(lado_1 = 5, lado_2 = 3) # Ã¡rea de un rectÃ¡ngulo 5 x 3 
calcular_area(lado_2 = 3, lado_1 = 5) # Ã¡rea de un rectÃ¡ngulo 5 x 3 
```

---

## Argumentos por defecto

Imagina ahora que nos damos cuenta que el 90% de las veces usamos dicha funciÃ³n para [**calcular por defecto el Ã¡rea de un cuadrado**]{.hl-yellow} (es decir, solo necesitamos un lado). Para ello, podemos definir [**argumentos por defecto**]{.hl-yellow} en la funciÃ³n: tomarÃ¡n dicho valor salvo que le asignemos otro.

Â¿Por quÃ© no asignar `lado_2 = lado_1` **por defecto**, para ahorrar lÃ­neas de cÃ³digo y tiempo?

. . .

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

---

## Argumentos por defecto


```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```


Ahora [**por defecto**]{.hl-yellow} el segundo lado serÃ¡ igual al primero (si se lo aÃ±adimos usarÃ¡ ambos).


```{r}
calcular_area(lado_1 = 5) # cuadrado
calcular_area(lado_1 = 5, lado_2 = 7) # rectÃ¡ngulo
```

---
 

## Salida mÃºltiple

Compliquemos un poco la funciÃ³n y aÃ±adamos en la salida los valores de cada lado, etiquetados como `lado_1` y `lado_2`, [**empaquetando la salida en una vector**]{.hl-yellow}.

```{r}
#| code-line-numbers: "7-8"
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

---

## Salida mÃºltiple

Podemos complicar un poco mÃ¡s la salida aÃ±adiendo una cuarta variable que nos diga, en funciÃ³n de los argumentos, [**si rectÃ¡ngulo o cuadrado**]{.hl-yellow}, teniendo que aÃ±adir en la salida una variable que de tipo caracter (o lÃ³gica).

```{r}
#| code-line-numbers: "7-9"
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rectÃ¡ngulo")))
  
}
calcular_area(5, 3)
```

. . .

[**Problema**]{.hl-red}: al intentar juntar nÃºmeros y texto, lo convierte todo a nÃºmeros. PodrÃ­amos guardarlo todo en un `tibble()` como hemos aprendido o en un objeto conocido en `R` como [**listas**]{.hl-yellow}

---

## IntroducciÃ³n a listas

Veamos un pequeÃ±o resumen de los datos que ya conocemos:

* [**vectores**]{.hl-yellow}: colecciÃ³n de elementos de igual tipo. Pueden ser nÃºmeros, caracteres o valores lÃ³gicos, entre otros.

* [**matrices**]{.hl-yellow}: colecciÃ³n BIDIMENSIONAL de elementos de igual tipo e igual longitud.

* [**data.frame / tibble**]{.hl-yellow}: colecciÃ³n BIDIMENSIONAL de elementos de igual longitud pero de cualquier tipo.

. . .

Las [**listas**]{.hl-yellow} serÃ¡n [**colecciones de variables de diferente tipo y diferente longitud**]{.hl-purple}, con estructuras totalmente heterÃ³geneas (incluso una lista puede tener dentro a su vez otra lista).

---

## IntroducciÃ³n a listas


Vamos a crear [**nuestra primera lista**]{.hl-yellow} con `list()` con tres elementos: el nombre de nuestros padres/madres, nuestro lugar de nacimiento y edades de nuestros hermanos.

```{r}
var_1 <- c("Paloma", "Gregorio")
var_2 <- "Madrid"
var_3 <- c(25, 30, 26)

lista <- list("progenitores" = var_1, "lugar_nac" = var_2, "edad_hermanos" = var_3)
lista
```



---

## IntroducciÃ³n a listas

```{r}
length(lista)
```

Si observas el objeto que hemos definido como lista, su [**longitud**]{.hl-yellow} del es de 3 ya que tenemos **guardados tres elementos**: un vector de caracteres (de longitud 2), un caracter (vector de longitud 1), y un vector de nÃºmeros (de longitud 3)

. . .

Tenemos guardados elementos de [**distinto tipo**]{.hl-yellow} (algo que ya podÃ­amos hacer) pero, ademÃ¡s, de **longitudes dispares**.

```{r}
dim(lista) # devolverÃ¡ NULL al no tener dos dimensiones
class(lista) # de tipo lista
```

---

## IntroducciÃ³n a listas

Si los juntÃ¡semos con un `tibble()`, al tener distinta longitud, obtendrÃ­amos un [**error**]{.hl-red}.

```{r}
#| error: true
library(tibble)
tibble("progenitores" = var_1, "lugar_nac" = va_2, "edad_hermanos" = var_3)
```

---


## IntroducciÃ³n a listas

* [**Acceder por Ã­ndice**]{.hl-yellow}: con el operador `[[i]]` accedemos al **elemento i-Ã©simo** de la lista.

```{r}
lista[[1]]
```

. . .

* [**Acceder por nombre**]{.hl-yellow}: con `$nombre_elemento` accedemos por su nombre.

```{r}
lista$progenitores
```

. . .

En contraposiciÃ³n, el [**corchete simple**]{.hl-yellow} nos permite acceder a [**varios elementos**]{.hl-yellow} a la vez

```{r}
# Varios elementos
lista[1:2]
```

---

## Salida mÃºltiple: listas

```{r}
#| code-line-numbers: "7-9"
# DefiniciÃ³n del nombre de funciÃ³n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funciÃ³n
  area <- lado_1 * lado_2
  
  # Resultado
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rectÃ¡ngulo")))
  
}
calcular_area(5, 3)
```

---

## Orden de los argumentos

Antes nos daba igual el orden de los argumentos pero ahora el [**orden de los argumentos de entrada importa**]{.hl-yellow}, ya que en la salida incluimos `lado_1` y `lado_2`. 

. . .

::: callout-note
## RecomendaciÃ³n

Como se comentaba, altamente recomendable hacer la llamada a la funciÃ³n [**indicando explÃ­citamente los argumentos**]{.hl-yellow} para mejorar **legibilidad e interpretabilidad**.

```{r}
# Equivalente a calcular_area(5, 3)
calcular_area(lado_1 = 5, lado_2 = 3)
```

:::

---

## Funciones: generando conocimiento

Parece una tonterÃ­a lo que hemos hecho pero hemos cruzado una frontera importante: hemos pasado de [**consumir conocimiento**]{.hl-yellow} (cÃ³digo de otros paquetes, elaborado por otros/as), a [**generar conocimiento**]{.hl-purple}, creando nuestras propias funciones.

. . .

Las funciones van a ser claves en tu dÃ­a a dÃ­a ya que te permitirÃ¡ automatizar cÃ³digo que vas a repetir una y otra vez: empaquetando ese cÃ³digo bajo un alias (nombre de la funciÃ³n) vas a [**poder usarlo una y otra vez sin necesidad de programarlo (por lo que hacer el doble de trabajo no implicarÃ¡ trabajar el doble)**]{.hl-yellow}

---

## Variables locales vs globales

Un aspecto importante sobre el que reflexionar con las funciones: Â¿quÃ© sucede si [**nombramos a una variable dentro**]{.hl-yellow} de una funciÃ³n a la que se nos ha **olvidado asignar** un valor dentro de la misma?

. . .

Debemos ser cautos al usar funciones en `R`, ya que debido a la [**Â«regla lexicogrÃ¡ficaÂ»**]{.hl-yellow}, si una variable no se define dentro de la funciÃ³n, `R` [**buscarÃ¡ dicha variable en el entorno**]{.hl-purple} de variables.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  print(x) # No devuelve nada, solo realiza la acciÃ³n 
}
funcion_ejemplo()
```

---

## Variables locales vs globales

Si una variable  [**ya estÃ¡ definida fuera de la funciÃ³n (entorno global)**]{.hl-yellow}, y ademÃ¡s es usada dentro de cambiando su valor, el valor [**solo cambia dentro**]{.hl-yellow} pero [**no en el entorno global**]{.hl-red}.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  x <- 2
  print(x) # lo que vale dentro
}
```

```{r}
# lo que vale dentro
funcion_ejemplo() #<<
# lo que vale fuera
print(x) #<<
```

---

## Variables locales vs globales


Si queremos que ademÃ¡s de cambiar localmente lo haga [**globalmente**]{.hl-yellow} deberemos usar la [**doble asignaciÃ³n**]{.hl-yellow} (`<<-`).

```{r}
x <- 1
y <- 2
funcion_ejemplo <- function() {
  
  # no cambia globalmente, solo localmente
  x <- 3 
  # cambia globalmente
  y <<- 0 #<<
  
  print(x)
  print(y)
}

funcion_ejemplo() # lo que vale dentro
x # lo que vale fuera
y # lo que vale fuera
```

---


## ğŸ’» Tu turno {#tu-turno-7}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ej 1**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para definir una funciÃ³n llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.

```{r}
#| eval: false
nombre <- function(x, y) {
  suma <- # cÃ³digo a ejecutar
  return()
}
# Aplicamos la funciÃ³n
suma(3, 7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_suma <- function(x, y) {
  suma <- x + y
  return(suma)
}
funcion_suma(3, 7)
```

### [**Ej 2**]{.hl-yellow}

ğŸ“ Modifica el cÃ³digo inferior para definir una funciÃ³n llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado

```{r}
#| eval: false
nombre <- function(x, y) {
  producto <- # cÃ³digo de la multiplicaciÃ³n
  return()
}
producto(3)
producto(3, -7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_producto <- function(x, y = x) {
  producto <- x * y
  return(producto)
}
funcion_producto(3)
funcion_producto(3, -7)
```

### [**Ej 3**]{.hl-yellow}

ğŸ“ Define una funciÃ³n llamada `igualdad_nombres` que, dados dos nombres, nos diga si son iguales o no. Hazlo considerando importantes las mayÃºsculas, y sin que importen las mayÃºsculas. Usa el paquete `{stringr}`.

```{r}
#| code-fold: true
#| eval: false
# Distinguiendo mayÃºsculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "LucÃ­a")

# Sin importar mayÃºsculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(str_to_upper(persona_1) == str_to_upper(persona_2))
  # otra opciÃ³n
  return(str_equal(persona_1, persona_2, ignore_case = TRUE))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "LucÃ­a")
```

### [**Ej 4**]{.hl-yellow}

ğŸ“ Crea una funciÃ³n llamada `calculo_IMC` que, dados dos argumentos (peso y estatura en metros) y un nombre, devuelva una lista con el IMC ($peso/(estatura_m^2)$) y el nombre.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura) {
  
  return(list("nombre" = nombre, "IMC" = peso/(estatura^2)))
}
```

### [**Ej 5**]{.hl-yellow}

ğŸ“ Repite el ejercicio anterior pero con otro argumento opcional que se llame unidades (por defecto, `unidades = "metros"`). Desarrolla la funciÃ³n de forma que haga lo correcto si `unidades = "metros"` y si `unidades = "centÃ­metros"`.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura, unidades = "metros") {
  
  return(list("nombre" = nombre,
              "IMC" = peso/(if_else(unidades == "metros", estatura, estatura/100)^2)))
}
```

 
### [**Ej 6**]{.hl-yellow}

ğŸ“ Crea un tibble ficticio de 7 personas, con tres variables (inventa nombre, y simula peso, estatura en centÃ­metros), y aplica la funciÃ³n definida de forma que obtengamos una cuarta columna con su IMC.

```{r}
#| code-fold: true
#| eval: false
datos <-
  tibble("nombres" = c("javi", "sandra", "laura",
                       "ana", "carlos", "leo", NA),
         "peso" = rnorm(n = 7, mean = 70, sd = 1),
         "estatura" = rnorm(n = 7, mean = 168, sd = 5))

datos |> 
  mutate(IMC = calculo_IMC(nombres, peso, estatura, unidades = "centÃ­metros")$IMC)
```


### [**Ej 7**]{.hl-yellow}

ğŸ“ Crea una funciÃ³n llamada `atajo` que tenga dos argumentos numÃ©ricos `x` e `y`. Si ambos son iguales, debes devolver `"iguales"` y hacer que la funciÃ³n acaba automÃ¡ticamente (piensa cuÃ¡ndo una funciÃ³n sale). OJO: `x` e `y` podrÃ­an ser vectores. Si son distintos (de igual de longitud) calcula la proporciÃ³n de elementos  diferentes. Si son distintos (por ser distinta longitud), devuelve los elementos que no sean comunes.

```{r}
#| code-fold: true
#| eval: false
atajo <- function(x, y) {
  
  if (all(x == y) & length(x) == length(y)) { return("iguales") }
  else {
   
    if (length(x) == length(y)) {
      
      n_diff <- sum(x != y) / length(x)
      return(n_diff)
      
    } else {
      
      diff_elem <- unique(c(setdiff(x, y), setdiff(y, x)))
      return(diff_elem)
    }
    
  }
}
```


:::


---

## ğŸ£ Caso prÃ¡ctico {#caso-practico-7}

Para practicar con funciones vamos a crear un completo **conversor de temperaturas** que, dada una temperatura en Fahrenheit, Celsius o Kelvin, la convierta a cualquiera de las otras

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/funciones-en-r/) hasta construirlo.



# Clase 8: [tidydata]{.flow} {#clase-8}

[**Nuestra base de datos: tibble. Tidydata: un multiverso de datos limpios**]{style="color:#444442;"}

* [ğŸ’» Ejercicios resueltos: tidy data](#tu-turno-8) 

* [ğŸ£ Workbook/caso prÃ¡ctico](#caso-practico-8)

* [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## Previously, in Breaking Bad...

Nuestro [**formato final de base de datos**]{.hl-yellow} serÃ¡ el objeto de tipo `tibble`, un `data.frame` mejorado

```{r}
library(tibble)
tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70), "IMC" = peso / (estatura^2))
```

-   [**MetainformaciÃ³n**]{.hl-yellow}: en la cabecera nos dice ya automÃ¡ticamente el nÃºmero de filas y columnas, y el tipo de cada variable

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning


-   [**Por filas**]{.hl-yellow}: permite crear por filas con `tribble()`

---

## Previously, in Breaking Bad...

Para definir un `tibble()` nosotro mismos tenemos dos opciones:

* [**Concatenando vectores**]{.hl-yellow} que ya tengamos definidos, haciendo uso de la funciÃ³n `tibble()` del paquete `{tibble}` (ya incluido en `{tidyverse}`)

```{r}
estatura <- c(1.7, 1.8, 1.6)
peso <- c(80, 75, 70)
IMC <-  peso / (estatura^2)
tibble("estatura" = estatura, "peso" = peso,
       "IMC" = IMC)
```

---

## Previously, in Breaking Bad...

* [**Directamente en tibble**]{.hl-yellow} proporcionando manualmente valores y nombres de variables

```{r}
tibble("estatura" = c(1.7, 1.8, 1.6),
       "peso" = c(80, 75, 70),
       "IMC" = peso / (estatura^2))
```

---

## R base vs Tidyverse

Hasta ahora todo lo que hemos hecho en `R` lo hemos realizado en el paradigma de programaciÃ³n conocido como [**R base**]{.hl-yellow}. Y es que cuando `R` naciÃ³ como lenguaje, muchos de los que programaban en Ã©l imitaron formas y metodologÃ­as heredadas de otros lenguajes, basado en el uso de

-   Bucles [**for**]{.hl-yellow}

-   Bucles [**while**]{.hl-yellow}

-   Estructuras [**if-else**]{.hl-yellow}


Y aunque conocer dichas estructuras puede sernos en algunos casos interesantes, en la [**mayorÃ­a de ocasiones han quedado caducas y vamos a poder evitarlas**]{.hl-red} (en especial los bucles) ya que `R` estÃ¡ especialmente [**diseÃ±ado para trabajar de manera funcional**]{.hl-yellow} (en lugar de elemento a elemento).

---

## Â¿QuÃ© es tidyverse?

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

En ese contexto de programaciÃ³n funcional, hace una dÃ©cada nacÃ­a `{tidyverse}`, un [**Â«universoÂ» de paquetes**]{.hl-yellow} para garantizar un flujo de trabajo eficiente, coherente y lexicogrÃ¡ficamente sencillo de entender, basado en la idea de que [**nuestros datos estÃ¡n limpios y ordenados (tidy)**]{.hl-purple}

---

## Â¿QuÃ© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)

-   `{lubridate}` manejo de fechas
-   `{rvest}`: web scraping
-   `{tidymodels}`: modelizaciÃ³n/predicciÃ³n

:::

::: {.column width="55%"}
-   `{tibble}`: optimizando data.frame
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv), `{readxl}` para importar archivos .xls y .xlsx
-   `{dplyr}`: gramÃ¡tica para depurar
-   `{stringr}`: manejo de textos
-   `{purrr}`: manejo de listas
-   `{forcats}`: manejo de cualitativas
-   `{ggplot2}`: visualizaciÃ³n de datos



:::
:::



---

## Â¿QuÃ© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)

-   `{lubridate}` manejo de fechas
-   `{rvest}`: web scraping
-   `{tidymodels}`: modelizaciÃ³n/predicciÃ³n


:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}
-   `{readr}`: carga datos rectangulares (.csv), `{readxl}` para importar archivos .xls y .xlsx
-   `{dplyr}`: gramÃ¡tica para depurar
-   `{stringr}`: manejo de textos
-   `{purrr}`: manejo de listas
-   `{forcats}`: manejo de cualitativas
-   `{ggplot2}`: visualizaciÃ³n de datos

:::
:::


---

## FilosofÃ­a base: tidy data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

El [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducida por **Hadley Wickham** (el Dios al que rezamos) de [**estandarizar**]{.hl-yellow} el formato de los datos para

::: incremental
-   [**sistematizar**]{.hl-green} la depuraciÃ³n
-   hacer mÃ¡s [**sencillo**]{.hl-green} su manipulaciÃ³n.
-   cÃ³digo [**legible**]{.hl-green}
:::

---

## Reglas del tidy data

Lo primero por tanto serÃ¡ entender quÃ© son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos estÃ¡n estandarizados.

::: columns
::: {.column width="50%"}
::: {.fragment .fade-in}
1.  Cada [**variable**]{.hl-yellow} en una [**Ãºnica columna**]{.hl-purple}
:::

::: {.fragment .fade-in}
2.  Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}
:::

::: {.fragment .fade-in}
3.  Cada [**celda**]{.hl-yellow} con un [**Ãºnico valor**]{.hl-purple}
:::

::: {.fragment .fade-in}
4.  Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5.  Si queremos cruzar [**mÃºltiples tablas**]{.hl-yellow} debemos tener una [**columna comÃºn**]{.hl-purple}
:::
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
:::

---

## TuberÃ­a (pipe)

En `{tidyverse}` serÃ¡ clave el [**operador pipe (tuberÃ­a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): serÃ¡ una [**tuberÃ­a que recorre los datos**]{.hl-yellow} y los transforma.

. . .

::: columns
::: {.column width="50%"}
En R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, serÃ­a

```{r}
#| eval: false
third(second(first(datos)))
```
:::

::: {.column width="50%"}
En `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones

```{r}
#| eval: false
datos |> first() |> second() |> third()
```
:::
:::


. . .

::: callout-caution
## Apunte importante

Desde la versiÃ³n 4.1.0 de `R` disponemos de `|>`, un pipe **nativo** disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que dependÃ­a del paquete `{magrittr}` (bastante problemÃ¡tico).
:::

---

## TuberÃ­a (pipe)

La principal ventaja es que el [**cÃ³digo sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas cÃ³digo.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::

::: {.column width="50%"}
<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
:::

---

## Datos SUCIOS: messy data

Â¿Pero quÃ© aspecto tienen los [**datos no tidy**]{.hl-yellow}? Vamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).


```{r}
library(tidyr)
table4a
```


[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="40%"}
```{r}
table4a
```
:::

::: {.column width="60%"}
â Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) â†’ las columnas `1999` y `2000` en realidad deberÃ­an ser en sÃ­ [**valores de una variable**]{.hl-yellow} y no nombres de columnas.
:::
:::

. . .

Incluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el aÃ±o y otra que guarde el valor de la variable de interÃ©s en cada uno de esos aÃ±os. Y lo haremos con la funciÃ³n `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="50%"}
```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
               values_to = "cases")
```
:::

::: {.column width="50%"}
![](img/table4a.jpg)
:::
:::



-   `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}
-   `names_to`: nombre de la nueva variable a la quemandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).
-   `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table2`


```{r}
table2
```


[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_wider()

::: columns
::: {.column width="60%"}
```{r}
#| echo: false
table2
```
:::

::: {.column width="40%"}
â Cada [**observaciÃ³n estÃ¡ dividido en dos filas**]{.hl-red} â†’ los [**registros con el mismo aÃ±o deberÃ­an ser el mismo**]{.hl-yellow}
:::
:::

. . .

Lo que haremos serÃ¡ lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table3`


```{r}
table3
```


[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Separar: separate()

::: columns
::: {.column width="60%"}
```{r}
table3
```
:::

::: {.column width="40%"}
â Cada [**celda contiene varios valores**]{.hl-red}
:::
:::

. . .

Lo que haremos serÃ¡ hacer uso de la funciÃ³n `separate()` para mandar [**separar cada valor**]{.hl-yellow} a una columna diferente.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

---

## Separar: separate()

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

FÃ­jate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deberÃ­an ser variables numÃ©ricas. Para ello podemos aÃ±adir el argumento opcional `convert = TRUE`

. . .

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

---

## Datos SUCIOS: messy data

Veamos el Ãºltimo ejemplo con la tabla `table5`


```{r}
table5
```


[**Â¿QuÃ© puede estar fallando?**]{.hl-red}

---

## Unir unite()

::: columns
::: {.column width="50%"}
```{r}
table5
```
:::

::: {.column width="50%"}
â Tenemos [**mismos valores divididos en dos columnas**]{.hl-red}
:::
:::

. . .

Usaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y aÃ±o en una misma columna

```{r}
table5 |> unite(col = year_completo, century, year, sep = "")
```

---

## Ejemplo: relig_income

Vamos a realizar un ejemplo juntos con la tabla `relig_income` del paquete `{tidyr}`. Como se indica en la ayuda `? relig_income`, la tabla representa la cantidad de personas que hay en cada tramo de ingresos anuales (20k = 20 000$) y en cada religiÃ³n.

```{r}
relig_income
```

---

## Ejemplo: relig_income

```{r}
relig_income
```

[**Â¿Es tidydata?**]{.hl-yellow} 

---

## Ejemplo: relig_income

```{r}
relig_income
```

No lo es ya que en realidad [**solo deberÃ­amos tener una variable de ingresos**]{.hl-red} y la tenemos dividida en 11: todas ellas es la misma variable solo que adopta un valor diferente.  [**Â¿CÃ³mo convertirla a tidy data?**]{.hl-green}

---

## Ejemplo: relig_income


La idea es [**pivotar todas las columnas de ingresos**]{.hl-yellow} para que acaben en una sola columna llamada `income`, y los valores (el nÃºmero de personas) en otra llamada `people` (por ejemplo). La tabla la haremos mÃ¡s larga y menos ancha asÃ­ que...

. . .

```{r}
relig_tidy <-
  relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused", names_to = "income",
               values_to = "people")
relig_tidy 
```

---

## Ejemplo: relig_income

Vamos a hilar mÃ¡s fino: ahora mismo en la variable `income` en realidad tenemos dos valores, el lÃ­mite inferior y el superior de la renta. Vamos a [**separar dicha variable e ingresos**]{.hl-yellow} en dos, llamadas `income_inf` y `income_sup`

```{r}
relig_tidy 
```

---

## Ejemplo: relig_income

Vamos a hilar mÃ¡s fino: ahora mismo en la variable `income` en realidad tenemos dos valores, el lÃ­mite inferior y el superior de la renta. Vamos a [**separar dicha variable e ingresos**]{.hl-yellow} en dos, llamadas `income_inf` y `income_sup`


```{r}
relig_tidy |>
  # Separamos por -
  separate(income, into = c("income_inf", "income_sup"), sep = "-")
```

. . .

Â¿EstÃ¡ ya bien? FÃ­jate bien...

---

## Ejemplo: relig_income

```{r}
relig_tidy |>
  # Separamos por -
  separate(income, into = c("income_inf", "income_sup"), sep = "-")
```

Si te fijas la primera columna el `"$10k"` deberÃ­a ser una cota superior, no inferior. Â¿CÃ³mo indicarle que separe bien ese caso?

---

## Ejemplo: relig_income

Le indicaremos que separe si encuentra `"-"` o `"<"` (usamos `|` para separar ambas opciones)

```{r}
relig_tidy |>
  # Separamos por -
  separate(income, into = c("income_inf", "income_sup"), sep = "-|<")
```

---

## Ejemplo: relig_income

```{r}
relig_tidy <-
  relig_tidy |>
  # Separamos por -
  separate(income, into = c("income_inf", "income_sup"), sep = "-|<")
relig_tidy
```

Piensa ahora como podemos [**convertir los lÃ­mites de ingresos a numÃ©ricas (eliminando sÃ­mbolos, letras, etc)**]{.hl-yellow}

---

## Ejemplo: relig_income

Para ello usaremos el paquete `{stringr}` que hemos visto antes, en concreto la funciÃ³n `str_remove_all()` a la que le podemos pasar los caracteres que queremos eliminar (fÃ­jate que `$` al ser un caracter reservado en `R` hay que indicÃ¡rselo con `\\$`)

```{r}
relig_tidy$income_inf <-
  str_remove_all(relig_tidy$income_inf, "\\$|>|k")
relig_tidy$income_sup <-
  str_remove_all(relig_tidy$income_sup, "\\$|>|k")

relig_tidy
```

---

## Ejemplo: relig_income

FÃ­jate que tenemos `"Don't now/refused"`. Â¿QuÃ© deberÃ­amos tener?

. . .

DeberÃ­a ser un [**dato ausente**]{.hl-yellow} asÃ­ que usaremos `if_else()`: si contiene dicha frase, `NA`, en caso contrario su valor (consejo: `str_detect()` para detectar patrones en textos, y evitar tener que escribir toda la palabra sin errores)

```{r}
relig_tidy$income_inf <-
  if_else(str_detect(relig_tidy$income_inf, "refused"), NA, relig_tidy$income_inf)
relig_tidy$income_sup <-
  if_else(str_detect(relig_tidy$income_sup, "refused"), NA, relig_tidy$income_sup)
relig_tidy
```

---

## Ejemplo: relig_income

```{r}
relig_tidy
```

En la primera lÃ­nea, ese `""` tambiÃ©n deberÃ­a ser `NA``

```{r}
relig_tidy$income_inf <-
  if_else(relig_tidy$income_inf == "", NA, relig_tidy$income_inf)
relig_tidy$income_suop <-
  if_else(relig_tidy$income_sup == "", NA, relig_tidy$income_sup)
```

---

## Ejemplo: relig_income

```{r}
relig_tidy
```

AdemÃ¡s si te fijas los nÃºmeros son en realidad caracteres, asÃ­ que vamos a [**convertirlos a nÃºmeros**]{.hl-yellow}



---

## Ejemplo: relig_income


AdemÃ¡s si te fijas los nÃºmeros son en realidad caracteres, asÃ­ que vamos a [**convertirlos a nÃºmeros**]{.hl-yellow}

```{r}
relig_tidy$income_inf <- as.numeric(relig_tidy$income_inf)
relig_tidy$income_sup <- as.numeric(relig_tidy$income_sup)
relig_tidy
```

---

## Ejemplo: relig_income

Â¿Se te ocurre alguna forma de **Â«cuantificar numÃ©ricamenteÂ»** los valores ausentes que tenemos en este caso?

. . .

Si te fijas en realidad cuando hay ausente en el lÃ­mite inferior en realidad podrÃ­amos poner un 0 (nadie puede ganar menos de eso) y cuando lo tenemos en el lÃ­mite superior serÃ­a `Inf`

```{r}
relig_tidy$income_inf <-
  if_else(is.na(relig_tidy$income_inf), 0, relig_tidy$income_inf)
relig_tidy$income_sup <-
  if_else(is.na(relig_tidy$income_sup), Inf, relig_tidy$income_sup)
relig_tidy
```

---

## Ejemplo: relig_income

Aunque nos haya llevado un rato este es el **cÃ³digo completo resumido**

```{r}
#| eval: false
relig_tidy <-
  relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused", names_to = "income",
               values_to = "people") |>
  separate(income, into = c("income_inf", "income_sup"), sep = "-|<")

relig_tidy$income_inf <- str_remove_all(relig_tidy$income_inf, "\\$|>|k")
relig_tidy$income_sup <- str_remove_all(relig_tidy$income_sup, "\\$|>|k")

relig_tidy$income_inf <-
  if_else(str_detect(relig_tidy$income_inf, "refused") |
            relig_tidy$income_inf == "", 0, as.numeric(relig_tidy$income_inf))
relig_tidy$income_sup <-
  if_else(str_detect(relig_tidy$income_sup, "refused") |
            relig_tidy$income_sup == "", Inf, as.numeric(relig_tidy$income_sup))
```

---

## Ejemplo: relig_income

Â¿Por quÃ© era [**importante tenerlo en tidydata**]{.hl-yellow}? Lo veremos mÃ¡s adelante al visualizar los datos pero esto ya nos permite realizar filtros muy rÃ¡pidos con muy poco cÃ³digo.

Por ejemplo: Â¿cuÃ¡ntas personas agnÃ³sticas con ingresos superiores (o iguales) a 30 tenemos?

. . .

```{r}
# una lÃ­nea de cÃ³digo
sum(relig_tidy$people[relig_tidy$religion == "Agnostic" & relig_tidy$income_inf >= 30])
```

---

## ğŸ’» Tu turno {#tu-turno-8}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Usa el dataset original `relig_income` y trata de responder a la Ãºltima pregunta:  Â¿cuÃ¡ntas personas agnÃ³sticas con ingresos superiores (o iguales) a 30 tenemos? Compara el cÃ³digo a realizar cuando tenemos tidydata a cuando no. Â¿CuÃ¡l es mÃ¡s legible si no supieses `R`? Â¿CuÃ¡l tiene mayor probabilidad de error?

```{r}
#| code-fold: true
#| eval: false

sum(relig_income[relig_income$religion == "Agnostic",
             c("$30-40k", "$40-50k", "$50-75k", "$75-100k", "$100-150k", ">150k")])
```


### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Usando `relig_tidy` determina quiÃ©n tiene mÃ¡s ingresos medios, Â¿catÃ³licos (`Catholic`) o agnÃ³sticos (`Agnostic`)? Crea antes una variable `avg_income` (ingresos medios por intervalo): si hay 5 personas entre 20 y 30, y 3 personas entre 30 y 50, la media serÃ­a $(25*5 + 40*3)/8$ (si es `Inf` por arriba, `NA`)

```{r}
#| code-fold: true
#| eval: false
relig_tidy$avg_income <- 
  if_else(is.infinite(relig_tidy$income_sup), NA, (relig_tidy$income_sup + relig_tidy$income_inf)/2)

# Agnosticos vs catolicos
sum((relig_tidy$avg_income[relig_tidy$religion == "Agnostic"] * relig_tidy$people[relig_tidy$religion == "Agnostic"]), na.rm = TRUE) /
  sum(relig_tidy$people[relig_tidy$religion == "Agnostic"], na.rm = TRUE)

sum((relig_tidy$avg_income[relig_tidy$religion == "Catholic"] * relig_tidy$people[relig_tidy$religion == "Catholic"]), na.rm = TRUE) /
  sum(relig_tidy$people[relig_tidy$religion == "Catholic"], na.rm = TRUE)
```


### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Si debemos elegir budismo (`Buddhist`) e hinduismo (`Hindu`), Â¿cuÃ¡l de las dos es la religiÃ³n mayoritaria entre los que ganan mÃ¡s de 50 000$ anuales?

```{r}
#| code-fold: true
#| eval: false

greatest_income <-
  relig_tidy[relig_tidy$income_inf >= 50 & relig_tidy$religion %in% c("Buddhist", "Hindu"), ]

sum(greatest_income$people[greatest_income$religion == "Buddhist"], na.rm = TRUE)
sum(greatest_income$people[greatest_income$religion == "Hindu"], na.rm = TRUE)
```


### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. Â¿Es tidydata? En caso negativo, Â¿quÃ© falla? Â¿CÃ³mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```


### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. Â¿Es tidydata? En caso negativo, Â¿quÃ© falla? Â¿CÃ³mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```

:::

---

## ğŸ£ Caso prÃ¡ctico {#caso-practico-8}

En el paquete `{tidyr}` contamos con el dataset `who2` (dataset de la OrganizaciÃ³n Mundial de la Salud). Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/tidydatos/).

```{r}
who2
```


# Clase 9: [entrega II]{.flow} {#clase-9}

[**PonderaciÃ³n: 15%**]{style="color:#444442;"}

---

## Instrucciones

El dÃ­a de la entrega tendrÃ¡s subido una [**plantilla de entrega**]{.hl-yellow} en formato `.qmd` en el campus.

* **Descomprime la carpeta** (Â¡importante! si no descomprimes, aunque puedas editar el `.qmd`, no podrÃ¡s generar el `.html`)

* **Edita la cabecera** con tu nombre y DNI

* DeberÃ¡s **rellenar cada chunk** con el cÃ³digo que consideres (en algunos te he dejado pistas) y **cambiar** de `#| eval: false` a `#| eval: true` (si los quitas directamente, por defecto ya es true)

* DeberÃ¡s de **comentar** con texto normal lo que consideres para responder a las preguntas.

* SerÃ¡ [**OBLIGATORIO**]{.hl-yellow} subir el archivo `.html` generado (solo se corregirÃ¡ dicho archivo) asÃ­ que ve renderizando segÃºn rellenas el documento, no lo dejes para el final.


# Clase 10: [tidyverse (filas)]{.flow} {#clase-10}

[**Tidyverse: operaciones por filas**]{style="color:#444442;"}

* [ğŸ’» Ejercicios resueltos: filter](#tu-turno-10-1) 

* [ğŸ’» Ejercicios resueltos: slice, sample, arrange](#tu-turno-10-2) 

* [ğŸ£ Workbook/caso prÃ¡ctico](#caso-practico-10)

* [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## ResoluciÃ³n de entrega II

El nombre de las columnas codifica el sexo (H hombre, M mujer, NC no consta) y el grupo etario (0-9, 10-19, 20-29, 30-39, 40-49, 50-59, 60-69, 70-79, â‰¥80 aÃ±os y NC no consta).


```{r}
library(readr)
datos <- read_csv(file = "./datos/messy_covid_data.csv")
datos
```

---

## ResoluciÃ³n de entrega II

DiseÃ±a un bucle que recorra todas las filas y, salvo en las dos primeras columnas, convierta cada 0 casos que encuentre en la fila por un `NA`

```{r}
#| echo: false
datos <- datos[1:5000, ]
```

Necesitamos 2 bucles: uno que **recorra filas** (desde la primera hasta la Ãºltima) y otro que **recorra columnas** (desde la tercera hasta la Ãºltima), y dentro del bucle: si el elemento (i, j) es 0 (o ausente), lo pasamos a ausente; en caso contrario, lo que habÃ­a guardado.

```{r}
library(dplyr)
for (i in 1:nrow(datos)) {
  for (j in 3:ncol(datos)) {
  
    datos[i, j] <- if_else(datos[i, j] == 0, NA, datos[i, j], missing = NA)
    
  }
}
```

---

## ResoluciÃ³n de entrega II

Razona por quÃ© no es tidydata y conviÃ©rte a tidy data. Si te fijas hay muchÃ­simas filas que nos sobran (ausentes) asÃ­ que haz que al pivotar las elimine.

&nbsp;

Es un `pivot_longer()` sin mÃ¡s: le indicamos que **columnas no queremos pivotar**, la **variable a donde irÃ¡n los nombres** y cÃ³mo se llamarÃ¡ la variable de casos; le incluimos `values_drop_na = TRUE` para que elimine los ausentes (de ahÃ­ que hayamos convertido los 0 para hacerlo mÃ¡s sencillo aquÃ­)

```{r}
tidy_covid <-
  datos |> 
  pivot_longer(cols = -c("provincia_iso", "fecha"), names_to = "grupo", values_to = "casos",
               values_drop_na = TRUE)
tidy_covid
```

---

## ResoluciÃ³n de entrega II

Una de las columnas la tenemos codificada a veces como `cosa-cosa_cosa`, otras como `80-Inf_cosa`, otras como `NC-NC_cosa`. Intenta separar dicha columna para generar tres columnas nuevas `edad_inf`, `edad_sup` y `sexo` de manera adecuada. Recuerda que `NC` es un ausente. 

&nbsp;

Si lo intentamos hacer sin procesar nada antes, vemos que los `Inf` y los `NC` figuran como tal, como cadena texto, lo que nos impide convertir a numÃ©rica el resto de la columna.

```{r}
tidy_covid2 <-
  tidy_covid |> 
  separate(col = "grupo", into = c("edad_inf", "edad_sup", "sexo"), convert = TRUE)
tidy_covid2
```

---

## ResoluciÃ³n de entrega II

Por eso antes vamos a reemplazar los `"Inf"` y `"NC"` por `"NA"`, para que luego al convertirlos pueda pasarlos a `NA` numÃ©ricos

```{r}
tidy_covid$grupo <- str_replace_all(tidy_covid$grupo, "Inf|NC", "NA")
tidy_covid2 <-
  tidy_covid |>
  separate(col = "grupo", into = c("edad_inf", "edad_sup", "sexo"), convert = TRUE)
tidy_covid2
```

---


## ResoluciÃ³n de entrega II

Incorpora una nueva variable a la tabla que codifice el mes y el aÃ±o (por ejemplo, cualquier dÃ­a de enero de 2020 serÃ¡ algo similar a "1-2020" y cualquier dÃ­a de febrero del 2021 serÃ¡ "2-2021").

```{r}
library(glue)
tidy_covid2$mes_year <- glue("{month(tidy_covid2$fecha)}-{year(tidy_covid2$fecha)}")
tidy_covid2
```


----


## ResoluciÃ³n de entrega II

Haciendo uso de esa variable de grupo `mes_year` y del vector de provincias permitidas que aparece debajo (busca en <https://es.wikipedia.org/wiki/ISO_3166-2:ES#Provincias>) obtÃ©n un resumen que nos devuelva en un tibble, por cada provincia permitida y cada mes-aÃ±o, la media de casos (sin importar edad ni sexo)

&nbsp;

Solo necesitamos **recorrer cada provincia permitida** y **cada valor `mes_year` distinto**, asÃ­ que creamos ambos vectores. TambiÃ©n creamos un dataset vacÃ­o `resumen_mes_provincia` donde, en cada iteraciÃ³n, pegaremos una fila con su resumen.

```{r}
provincias_permitidas <- c("M", "B", "SE", "V", "Z")
for_values <- unique(tidy_covid2$mes_year)
resumen_mes_provincia <- tibble()
```

---

## ResoluciÃ³n de entrega II

Una vez creados esos objetos, el **bucle simplemente deberÃ¡ recorrer cada valor de provincia y de mes-aÃ±o**: para el mes-aÃ±o i y la provincia j, filtramos solo los casos para esos valores concretos (de todo el vector de casos nos quedamos con aquellos que cumplan dicha condiciÃ³n, eliminando tambiÃ©n provincias ausentes). Tras filtrar guardamos la media ese filtro de casos

```{r}
for (i in 1:length(for_values)) {
  for (j in 1:length(provincias_permitidas)) {
    
    casos_mes_provincia <-
      tidy_covid2$casos[!is.na(tidy_covid2$provincia_iso) &
                          tidy_covid2$provincia_iso == provincias_permitidas[j] &
                          tidy_covid2$mes_year == for_values[i]]
    
    resumen_mes_provincia <-
      rbind(resumen_mes_provincia, 
            tibble("mes_year" = for_values[i], "provincia_iso" = provincias_permitidas[j],
                   "casos" = mean(casos_mes_provincia, na.rm = TRUE)))
  }
}
```

---

## ResoluciÃ³n de entrega II

DiseÃ±a una funciÃ³n `resumen_por_fecha_provincia()` que dada un vector de cÃ³digos ISO de provincias permitidas, y un tabla, nos devuelva la media de casos diarios que hubo cada mes-aÃ±o (sin importar sexo ni edad) en las provincias permitidas. Es decir: debes "adaptar" el cÃ³digo anterior a una funciÃ³n.

&nbsp;

Simplemente debes **copiar y pegar el cÃ³digo de los dos anteriores** (salvo el vector de provincias que ahora serÃ¡ un argumento), y adaptarlo a que las provincias estÃ¡n en `prov_iso` y la tabla en `datos`.

---

## ResoluciÃ³n de entrega II


```{r}
resumen_por_fecha_provincia <- function(prov_iso, datos) {
  
  datos$mes_year <- glue("{month(datos$fecha)}-{year(datos$fecha)}")
  for_values <- unique(datos$mes_year)
  resumen_mes_provincia <- tibble()
  
  for (i in 1:length(for_values)) {
    for (j in 1:length(prov_iso)) {
      
      casos_mes_provincia <-
        datos$casos[!is.na(datos$provincia_iso) &
                            datos$provincia_iso == prov_iso[j] &
                            datos$mes_year == for_values[i]]
      
      resumen_mes_provincia <-
        rbind(resumen_mes_provincia, 
              tibble("mes_year" = for_values[i], "provincia_iso" = prov_iso[j],
                     "casos" = mean(casos_mes_provincia, na.rm = TRUE)))
    }
  }

    return(resumen_mes_provincia)
}
resumen_por_fecha_provincia(c("M", "B", "SE", "V", "Z"), tidy_covid2)
```

---

## Â¿QuÃ© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: [**gramÃ¡tica para depurar**]{.hl-yellow}
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualizaciÃ³n de datos
-   `{tidymodels}`: modelizaciÃ³n/predicciÃ³n
:::
:::



---

## Preprocesamiento: dplyr

Dentro de `{tidyverse}` usaremos el paquete `{dplyr}` para el [**preprocesamiento y depuraciÃ³n**]{.hl-yellow} de los datos.

::: columns
::: {.column width="60%"}
![](img/dplyr.png){width=450}
:::

::: {.column width="40%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::
:::

La idea es que el [**cÃ³digo sea legible**]{.hl-yellow}, como si fuese una **lista de instrucciones** que al leerla nos diga de manera muy evidente lo que estÃ¡ haciendo.

---

## HipÃ³tesis: tidydata

::: columns
::: {.column width="50%"}
Toda la depuraciÃ³n que vamos a realizar es sobre la [**hipÃ³tesis de que nuestros datos estÃ¡n en tidydata**]{.hl-yellow}
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
::::

Recuerda que en `{tidyverse}` serÃ¡ clave el [**operador pipe (tuberÃ­a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): serÃ¡ una [**tuberÃ­a que recorre los datos**]{.hl-yellow} y los transforma.

. . .

Vamos a practicar con el dataset `starwars` del paquete cargado `{dplyr}`

```{r}
#| eval: false
library(tidyverse)
starwars
```

---


## Muestreo

:::: columns
::: {.column width="60%"}

Una de las operaciones mÃ¡s comunes es lo que se conoce en estadÃ­stica como [**muestreo**]{.hl-yellow}: una [**selecciÃ³n o filtrado de registros**]{.hl-yellow} (una submuestra)

:::

::: {.column width="40%"}

![](img/muestreo.jpeg){width=500}
:::
::::

. . .


* [**No aleatorio (por cuotas)**]{.hl-purple}: en base a condiciones lÃ³gicas sobre los registros (`filter()`)

. . .

* [**No aleatorio (intencional/discreccional)**]{.hl-purple}: en base a posiciÃ³n (`slice()`)

. . .

* [**Aleatorio simple**]{.hl-purple} (`slice_sample()`)

. . .

* [**Aleatorio estratificado**]{.hl-purple} (`group_by()` + `slice_sample()`)


---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

El mÃ¡s simple es cuando [**filtramos registros**]{.hl-yellow} en base a alguna condiciÃ³n lÃ³gica: con `filter()` se seleccionarÃ¡n solo individuos que cumplan ciertas condiciones (muestreo no aleatorio por condiciones)


::: incremental
-   `==`, `!=`: [**igual**]{.hl-purple} o [**distinto**]{.hl-yellow} que (`|> filter(variable == "a")`)
-   `>`, `<`: [**mayor**]{.hl-purple} o [**menor**]{.hl-yellow} que (`|> filter(variable < 3)`)
-   `>=`, `<=`: [**mayor o igual**]{.hl-yellow} o [**menor o igual**]{.hl-purple} que (`|> filter(variable >= 5)`)
-   `%in%`: valores [**pertenencen**]{.hl-yellow} a un listado de opciones (`|> filter(variable %in% c("azul", "verde"))`)
-   `between(variable, val1, val2)`: si los valores (continuos) [**caen dentro de un rango**]{.hl-yellow} de valores (`|> filter(between(variable, 160, 180))`)
:::

---

## Filtrar filas: filter()

Dichas [**condiciones lÃ³gicas**]{.hl-yellow} las podemos [**combinar**]{.hl-yellow} de diferentes maneras (y, o, o excluyente)

![](img/tablas_verdad.png)

. . .


::: callout-tip
## Importante

Recuerda que dentro de `filter()` debe ir siempre algo que devuelva un [**vector de valores lÃ³gicos**]{.hl-green}.
:::

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para... [**filtrar**]{.hl-yellow} los personajes de [**ojos marrones**]{.hl-purple}?

. . .

[**Â¿QuÃ© tipo de variable es?**]{.hl-yellow} --> La variable `eye_color` es cualitativa asÃ­ que estÃ¡ representada por textos

. . .

```{r}
#| echo: false
#| include: false
library(tidyverse)
```

```{r}
starwars |>
  filter(eye_color == "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para... [**filtrar**]{.hl-yellow} los personajes que [**no tienen ojos marrones**]{.hl-purple}?

. . .


```{r}
starwars |>
  filter(eye_color != "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para ... [**filtrar**]{.hl-yellow} los personajes que [**tengan los ojos marrones o azules**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color %in% c("blue", "brown"))
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

FÃ­jate que `%in%` es equivalente a concatenar varios `==` con una conjunciÃ³n o (`|`)

```{r}
starwars |>
  filter(eye_color == "blue" | eye_color == "brown")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as para ... [**filtrar**]{.hl-yellow} los personajes que [**midan entre 120 y 160 cm**]{.hl-purple}?

. . .

[**Â¿QuÃ© tipo de variable es?**]{.hl-yellow} --> La variable `height` es cuantitativa continua asÃ­ que deberemos filtrar por rangos de valores (intervalos) --> usaremos `between()`

. . .

```{r}
starwars |>
  filter(between(height, 120, 160))
```


---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color == "brown" & species != "Human")
```

---

## Filtrar filas: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
:::

Â¿CÃ³mo harÃ­as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos, o que tengan mÃ¡s de 60 aÃ±os**]{.hl-purple}? PiÃ©nsalo bien: los [**parÃ©ntesis son importantes**]{.hl-yellow}: no es lo mismo $(a+b)*c$ que $a+(b*c)$

. . .

```{r}
starwars |>
  filter((eye_color == "brown" & species != "Human") | birth_year > 60)
```

---

## Eliminar ausentes: drop_na()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  retirar_ausentes(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(var1, var2, ...)
```
:::
:::

Hay un **filtro especial** para una de las operaciones mÃ¡s habituales en depuraciÃ³n: [**retirar los ausentes**]{.hl-yellow}. Para ello podemos usar dentro de un filtro `is.na()`, que nos devuelve `TRUE/FALSE` en funciÃ³n de si es ausente, o bien ...

. . .

Usar `drop_na()`: si no indicamos variable, elimina registros con ausente en cualquier variable. MÃ¡s adelante veremos como [**imputar esos ausentes**]{.hl-yellow} 

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(mass, height)
```

```{r}
#| echo: false
starwars |>
  drop_na(mass, height, sex) |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na()
```

```{r}
#| echo: false
starwars |>
  drop_na() |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::
:::

---

## ğŸ’» Tu turno {#tu-turno-10-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Selecciona del conjunto de starwars solo los personajes que sean androides o cuyo valor en `species` sea desconocido

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Droid" | is.na(species))
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Selecciona del conjunto de starwars solo los personajes cuyo peso estÃ© entre 65 y 90 kg.

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(between(mass, 65, 90))
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Tras limpiar de ausentes en todas las variables, selecciona del conjunto de starwars solo los personajes que sean humanos y que vengan de Tatooine

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na() |> 
  filter(species == "Human" & homeworld == "Tatooine")
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Selecciona del conjunto original de starwars los personajes no humanos, `male` en el sexo y que midan entre 120 y 170 cm, o los personajes con ojos marrones o rojos.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter((species != "Human" & sex == "male" &
            between(height, 120, 170)) |
           eye_color %in% c("brown", "red"))
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Busca informaciÃ³n en la ayuda de la funciÃ³n `str_detect()` del paquete `{stringr}` (cargado en `{tidyverse}`). Consejo: prueba antes las funciones que vayas a usar con algÃºn vector de prueba para poder comprobar su funcionamiento. Tras saber lo que hace, filtra solo aquellos personajes con apellido `Skywalker`

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(str_detect(name, "Skywalker"))
```
:::

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice(posiciones)
```
:::
:::

A veces nos puede interesar realizar un [**muestreo no aleatorio discreccional**]{.hl-yellow}, o lo que es lo mismo, [**filtrar por posiciÃ³n**]{.hl-yellow}: con `slice(posiciones)` podremos seleccionar filas concretas pasando como argumento un [**vector de Ã­ndices**]{.hl-yellow}

. . .

::: columns
::: {.column width="50%"}
```{r}
#| eval: false

# fila 1
starwars |>
  slice(1)
```

```{r}
#| echo: false
starwars |> slice(1) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false

# filas de la 7 a la 9
starwars |>
  slice(7:9)
```

```{r}
#| echo: false
starwars |> slice(7:9) |> select(name:hair_color)
```
:::
:::

. . .

```{r}
#| eval: false

# filas 2, 7, 10 y 31
starwars |>
  slice(c(2, 7, 10, 31))
```

```{r}
#| echo: false
starwars |>
  slice(c(2, 7, 10, 31)) |> select(name:sex)
```

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(posiciones)
```
:::
:::

Disponemos de opciones por defecto:

* con `slice_head(n = ...)` y `slice_tail(n = ...)` podemos obtener la [**cabecera y cola**]{.hl-yellow} de la tabla

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_head(n = 2)
```

```{r}
#| echo: false
starwars |> slice_head(n = 2) |> select(name:hair_color)
```
:::

::: {.column width="\"50%"}
```{r}
#| eval: false
starwars |> slice_tail(n = 2)
```

```{r}
#| echo: false
starwars |> slice_tail(n = 2) |> select(name:hair_color)
```
:::
:::

---

## Rebanadas de datos: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(posiciones)
```
:::
:::

Disponemos de opciones por defecto:

* con `slice_max()` y `slice_min()` obtenemos la [**filas con menor/mayor valor de una variable**]{.hl-yellow} (si empate, todas salvo que `with_ties = FALSE`) que indicamos en `order_by = ...`

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_min(mass, n = 2)
```

```{r}
#| echo: false
starwars |> slice_min(n = 2, order_by = mass) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_max(height, n = 2)
```

```{r}
#| echo: false
starwars |> slice_max(n = 2, order_by = height) |> select(name:hair_color)
```
:::
:::

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

El conocido como [**muestreo aleatorio simple**]{.hl-yellow} se basa en [**seleccionar individuos aleatoriamente**]{.hl-yellow}, de forma que cada uno tenga ciertas [**probabilidades**]{.hl-yellow} de ser seleccionado. Con `slice_sample(n = ...)` podemos extraer n registros aleatoriamente (a priori equiprobables).

```{r}
starwars |> slice_sample(n = 2)
```

. . .

::: callout-important
## Importante...

[**Â«AleatorioÂ» no implica equiprobable**]{.hl-yellow}: es igual de aleatorio un dado normal que uno trucado. No hay cosas Â«mÃ¡s aleatoriasÂ» que otras, simplemente tienen subyacente distintas leyes de probabilidad.

:::

---

## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

TambiÃ©n podremos indicarle la [**proporciÃ³n de datos a samplear**]{.hl-yellow} (en lugar del nÃºmero) y si queremos que sea [**con reemplazamiento (que se puedan repetir)**]{.hl-yellow}.

```{r}
# 5% de registros aleatorios con reemplazamiento
starwars |> 
  slice_sample(prop = 0.05, replace = TRUE)

```


---


## Aleatorio: slice_sample()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  rebanadas_aleatorias(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(posiciones)
```
:::
:::

Como decÃ­amos, Â«aleatorioÂ» no es igual que Â«equiprobableÂ», asÃ­ que podemos pasarle un [**vector de probabilidades**]{.hl-yellow}. Por ejemplo, vamos a forzar que sea muy improbable sacar una fila que no sean las dos primeras

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

. . .

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

---

## ParÃ©ntesis: sample()

La funciÃ³n `slice_sample()` es simplemente una integraciÃ³n de `{tidyverse}` de la funciÃ³n bÃ¡sica de `R` conocida como `sample()` que nos permite [**muestrear elementos**]{.hl-yellow}

. . .

Por ejemplo, vamos a [**muestrear 10 tiradas de un dado**]{.hl-yellow}, indicÃ¡ndole

- [**soporte**]{.hl-purple} de nuestra variable aleatorio (valores permitidos en `x`)
- [**tamaÃ±o**]{.hl-purple} muestral (`size`)
- [**reemplazamiento**]{.hl-purple} (si `TRUE` entonces pueden salir repetidas, como en el caso del dado)

```{r}
sample(x = 1:6, size = 10, replace = TRUE)
```

---

## ParÃ©ntesis: sample()

La opciÃ³n anterior lo que genera son sucesos de una variable aleatoria [**equiprobable**]{.hl-yellow} pero al igual que antes, podemos asignarle un vector de probabilidades o [**funciÃ³n de masa**]{.hl-yellow} concreta con el argumento  `prob = ...`

```{r}
sample(x = 1:6, size = 50, replace = TRUE,
       prob = c(0.5, 0.2, 0.1, 0.1, 0.05, 0.05))
```

---


## ParÃ©ntesis: sample()

**Â¿CÃ³mo harÃ­as el siguiente enunciado?**

&nbsp;

Supongamos que en una ciudad se han estudiado episodios de gripe estacional. Sean las variables aleatorias $X_m$ y $X_p$ tal que $X_m=1$ si la madre tiene gripe, $X_m=0$ si la madre no tiene gripe, $X_p=1$ si el padre tiene gripe y $X_p=0$ si el padre no tiene gripe. El modelo teÃ³rico asociado a este tipo de epidemias indica que la distribuciÃ³n conjunta viene dada por $P(X_m = 1, X_p=1)=0.02$, $P(X_m = 1, X_p=0)=0.08$, $P(X_m = 1, X_p=0)=0.1$ y $P(X_m = 0, X_p=0)=0.8$

**Genera una muestra** de tamaÃ±o $n = 1000$ (soporte `"10"`, `"01"`, `"00"` y `"11"`) haciendo uso de `runif()` y haciendo uso de `sample()`

---


## Reordenar filas: arrange()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> ordenar(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(var1, var2, ...)
```
:::
:::

TambiÃ©n podemos [**ordenar filas**]{.hl-yellow} en funciÃ³n de alguna variable con `arrange()`

```{r}
#| eval: false
starwars |> arrange(mass)
```

```{r}
#| echo: false
starwars |> arrange(mass) |> select(name:eye_color) |> slice(1:5) 
```

. . .

Por [**defecto de menor a mayor**]{.hl-yellow} pero podemos [**invertir el orden**]{.hl-purple} con `desc()`

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(desc(height))
```

```{r}
#| echo: false
starwars |> arrange(desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(mass, desc(height))
```

```{r}
#| echo: false
starwars |> arrange(mass, desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::
:::

---

## Eliminar duplicados: distinct()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> sin_duplicados(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> distinct(var1, var2, ...)
```
:::
:::

Muchas veces necesitaremos asegurarnos que no hay duplicados en alguna variable (DNI) y podemos [**eliminar filas duplicadas**]{.hl-yellow} con `distinct()`.

```{r}
starwars |> distinct(sex)
```

. . .

Para mantener todas las columnas de la tabla usaremos `.keep_all = TRUE`.

```{r}
#| eval: false
starwars |> distinct(sex, .keep_all = TRUE)
```

```{r}
#| echo: false
starwars |> distinct(sex, .keep_all = TRUE) |> slice(1:3)
```

---

## AÃ±adir filas: bind_rows()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> encuadernar_filas(tibble2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> bind_rows(tibble2)
```
:::
:::

Por Ãºltimo, podemos [**concatenar nuevas filas**]{.hl-yellow} con `bind_rows()` con [**las nuevas observaciones en tabla**]{.hl-red} (si no cuadran columnas rellena con ausentes)

```{r}
datos <-
  tibble("nombre" = c("javi", "laura"), "edad" = c(33, 50))
datos
```

. . .

```{r}
datos |> bind_rows(tibble("nombre" = c("carlos", NA), "cp" = c(28045, 28019)))
```

---


## ğŸ’» Tu turno {#tu-turno-10-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Selecciona solo los personajes que sean humanos y de ojos marrones, para despuÃ©s ordernarlos en altura descendente y peso ascendente.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(eye_color == "brown" & species == "Human") |> 
  arrange(height, desc(mass))
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Extrae 3 registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(n = 3)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Extrae el 10% de los registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(prop = 0.1)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Extrae aleatoriamente 10 personajes pero de forma que la probabilidad de que salga cada uno sea proporcional a su peso (mÃ¡s pesados, mÃ¡s probable)

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass) |> 
  slice_sample(n = 10, weight_by = mass)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Selecciona los 3 personajes mÃ¡s mayores.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_max(birth_year, n = 3)
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Para saber que valores Ãºnicos hay en el color de pelo, elimina duplicados de la variable `hair_color`, eliminando antes los ausentes de dicha variable.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(hair_color) |> 
  distinct(hair_color)
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ De los personajes que son humanos y miden mÃ¡s de 160 cm, elimina duplicados en color de ojos, elimina ausentes en peso, selecciona los 3 mÃ¡s altos, y orden de mayor a menor peso. Devuelve la tabla.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Human" & height > 160) |> 
  distinct(eye_color, .keep_all = TRUE) |> 
  drop_na(mass) |> 
  slice_max(height, n = 3) |> 
  arrange(desc(mass))
```

:::


---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "2"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "2"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "3"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "3"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "4"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "4"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen


La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "5"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "5"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## Resumen

La clave de `{tidyverse}` es la [**legibilidad**]{.hl-yellow}: es importantÃ­simo que el cÃ³digo se entienda, por nuestro yo el futuro pero tambiÃ©n por la [**transparencia algorÃ­tmica**]{.hl-yellow} hacia los demÃ¡s

[**Por ejemplo**]{.hl-purple}: quitaremos ausentes de la variable peso, filtraremos los personajes humanos y altura superior a 140cm, sin duplicados en el color de pelo, extrayendo los 5 mÃ¡s altos y obteniendo 2 personajes aleatorios finalmente.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "6"
starwars |>
  elimino_ausentes(peso) |> 
  filtro(especie humana Y altura > 140 cm) |> 
  sin_duplicados(color de pelo) |>
  rebanadas_max(peso, n = 5) |> 
  rebanadas_aleatorias(n = 2)
```
:::


::: {.column width="50%"}
```{r}
#| eval: false
#| code-line-numbers: "6"
starwars |>
  drop_na(mass) |> 
  filter(species == "Human" & height > 140) |> 
  distinct(hair_color, .keep_all = TRUE) |>
  slice_max(mass, n = 5) |> 
  slice_sample(n = 2)
```
:::
:::

---

## ğŸ£ Caso prÃ¡ctico {#caso-practico-10}

Vamos a volver aun viejo conocido: en el paquete `{datasets}` (ya instalado por defecto) tenÃ­amos diversos conjuntos de datos y uno de ellos era `airquality` con el que ya trabajamos. Los datos capturan [**medidas diarias (n = 153 observaciones) de la calidad del aire**]{.hl-yellow} en Nueva York, de mayo a septiembre de 1973.

En ese momento lo trabajamos desde la perspectiva de R base y extrayendo algunas variables del mismo. El objetivo ahora serÃ¡ trabajarlo desde la perspectiva de `{tidyverse}` fijÃ¡ndonos en las diferencias de una y otra forma.

```{r}
#| eval: false
library(datasets)
airquality
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-filas-columnas/#caso-pr%C3%A1ctico-i-airquality-tidyverse).


# Clase 11: [tidyverse (columnas)]{.flow} {#clase-11}

[**Tidyverse: operaciones por columnas**]{style="color:#444442;"}

* [ğŸ’» Ejercicios resueltos: select](#tu-turno-11-1) 

* [ğŸ’» Ejercicios resueltos: mutate, if_else, case_when](#tu-turno-11-2) 

* [ğŸ£ Workbook/caso prÃ¡ctico I: simulaciÃ³n](#caso-practico-11-1)

* [ğŸ£ Workbook/caso prÃ¡ctico II](#caso-practico-11-2)

* [ğŸ£ Workbook/caso prÃ¡ctico III: El SeÃ±or de los Anillos](#caso-practico-11-3)

* [ğŸ“† PlanificaciÃ³n](#planificacion)

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Hasta ahora todas las operaciones realizadas (aunque usÃ¡semos info de columnas) eran por filas. En elc aso de columnas, la acciÃ³n mÃ¡s sencilla es [**seleccionar variables por nombre**]{.hl-yellow} con `select()`, dando como argumentos los nombres de columnas [**sin comillas**]{.hl-purple}.

```{r}
starwars |> select(name, hair_color)
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

La funciÃ³n `select()` nos permite seleccionar varias variables a la vez, incluso [**concatenando sus nombres como si fuesen Ã­ndices numÃ©ricos**]{.hl-yellow}

```{r}
#| eval: false
starwars |> select(name:eye_color) 
```

```{r}
#| echo: false
starwars |> select(name:eye_color) |> slice(1:4)
```

. . .

Y podemos [**deseleccionar columnas**]{.hl-yellow} con `-` delante

```{r}
#| eval: false
starwars |>  select(-mass, -(eye_color:starships))
```

```{r}
#| echo: false
starwars |> select(-mass, -(eye_color:starships)) |> slice(1:4)
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Tenemos ademÃ¡s [**palabras reservadas**]{.hl-yellow}: `everything()` [**todas las variables**]{.hl-purple}...

```{r}
#| eval: false
starwars |> select(mass, homeworld, everything())
```

```{r}
#| echo: false
starwars |> select(mass, homeworld, everything()) |> slice(1:4)
```

. . .

...y `last_col()` para referirnos a [**la Ãºltima columna**]{.hl-purple}.

```{r}
#| eval: false
starwars |> select(name:mass, homeworld, last_col())
```

```{r}
#| echo: false
starwars |> select(name:mass, homeworld, last_col()) |> slice(1:4)
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

TambiÃ©n podemos jugar con [**patrones**]{.hl-yellow} en el nombre, aquellas que [**comiencen por un prefijo**]{.hl-purple} (`starts_with()`), [**terminen con un sufijo**]{.hl-purple} (`ends_with()`), [**contengan un texto**]{.hl-purple} (`contains()`) o cumplan una [**expresiÃ³n regular**]{.hl-purple} (`matches()`).

```{r}
# variables cuyo nombre acaba en "color" y contengan sexo o gÃ©nero
starwars |> select(ends_with("color"), matches("sex|gender"))
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Incluso podemos [**seleccionar por rango numÃ©rico**]{.hl-yellow} si tenemos variables con un prefijo y nÃºmeros.

```{r}
datos <-
  tibble("semana1" = c(115, 141, 232), "semana2" = c(7, NA, 17),
         "semana3" = c(95, 162, NA), "semana4" = c(11, 19, 15),
         "semana5" = c(NA, 262, 190), "semana6" = c(21, 15, 23))
```

. . .

Con `num_range()` podemos seleccionar con un prefijo y una secuencia numÃ©rica.

```{r}
datos |> select(num_range("semana", 1:4))
```

---

## SelecciÃ³n columnas: select()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
:::

Por Ãºltimo, podemos seleccionar columnas por [**tipo de dato**]{.hl-yellow} haciendo uso de `where()` y dentro una funciÃ³n que devuelva un valor lÃ³gico de tipo de dato.

```{r}
# Solo columnas numÃ©ricas o de texto
starwars |> select(where(is.numeric) | where(is.character))
```


---

## Mover columnas: relocate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  recolocar(var1, despues_de = var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  relocate(var1, .after = var2)
```
:::
:::

Para facilitar la [**recolocaciÃ³n de variables**]{.hl-yellow} tenemos una funciÃ³n para ello, `relocate()`, indicÃ¡ndole en `.after` o `.before` [**detrÃ¡s**]{.hl-purple} o [**delante**]{.hl-purple} de quÃ© columnas queremos moverlas.

```{r}
starwars |> relocate(species, .before = name)
```

---

## Renombrar: rename()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> renombrar(nuevo = antiguo)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> rename(nuevo = antiguo)
```
:::
:::

A veces tambiÃ©n podemos querer [**modificar la Â«metainformaciÃ³nÂ»**]{.hl-yellow} de los datos, [**renombrando columnas**]{.hl-yellow}. Para ello usaremos de `rename()` poniendo [**primero el nombre nuevo**]{.hl-purple} y luego el [**antiguo**]{.hl-purple}.

```{r}
starwars |> rename(nombre = name, altura = height, peso = mass)
```

---

## Extraer columnas: pull()


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> retirar(var)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> pull(var)
```
:::
:::


Si observas la salida de los `select()` [**sigue siendo una tabla tibble**]{.hl-yellow}, ya que nos preserva la naturaleza de nuestros datos.

```{r}
starwars |> select(name)
```

---


## Extraer columnas: pull()


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> retirar(var)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> pull(var)
```
:::
:::


A veces no querremos dicha estructura sino [**extraer literalmente la columna en un VECTOR**]{.hl-yellow}, algo que podemos hacer con `pull()`

```{r}
starwars |> pull(name)
```


---


## ğŸ’» Tu turno {#tu-turno-11-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Filtra el conjunto de personajes y quÃ©date solo con aquellos que en la variable `height` no tengan un dato ausente. Con los datos obtenidos del filtro anterior, selecciona solo las variables name, height, asÃ­ como todas aquellas variables que CONTENGAN la palabra color en su nombre.


```{r}
#| code-fold: true
#| eval: false

starwars_2 <-
  starwars |> 
  drop_na(height) |> 
  select(name, height, contains("color"))
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano.

```{r}
#| code-fold: true
#| eval: false

starwars_2 |> 
  rename(nombre = name, altura = height, color_pelo = hair_color,
         color_piel = skin_color, color_ojos = eye_color)
```


### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio 1, coloca la variable de color de pelo justo detrÃ¡s de la variable de nombres.


```{r}
#| code-fold: true
#| eval: false

starwars_2 |>
  relocate(hair_color, .after = name)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio 1, comprueba cuÃ¡ntas modalidades Ãºnicas hay en la variable de color de pelo (sin usar `unique()`).

```{r}
#| code-fold: true
#| eval: false

starwars_2 |>
  distinct(hair_color) |> 
  nrow()
```


### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Del conjunto de datos originales, elimina las columnas de tipo lista, y tras ello elimina duplicados en la variable `eye_color`. Tras eliminar duplicados extrae dicha columna en un vector.

```{r}
#| code-fold: true
#| eval: false

starwars |> 
  select(-where(is.list)) |> 
  distinct(eye_color, .keep_all = TRUE) |> 
  pull(eye_color)
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Del conjunto de datos original de starwars, con solo los personajes cuya altura es conocida, extrae en un vector con dicha variable.

```{r}
#| code-fold: true
#| eval: false

starwars |> 
  drop_na(height) |> 
  pull(height)
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Tras obtener el vector del ejercicio anterior, usa dicho vector para realizar un muestreo aleatorio del 50% de los datos de manera que la probabilidad de cada personaje de ser elegido sea inversamente proporcional a su altura (mÃ¡s bajitos, mÃ¡s opciones).

```{r}
#| code-fold: true
#| eval: false

heights <-
  starwars |> 
  drop_na(height) |> 
  pull(height)
  
starwars |> 
  slice_sample(prop = 0.5, weight_by = 1/heights)
```

:::



---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

En muchas ocasiones querremos [**modificar o crear variables**]{.hl-yellow} con `mutate()`. 


. . . 

Vamos a crear por ejemplo una nueva variable `height_m` con la altura en metros.

```{r}
starwars |> mutate(height_m = height / 100)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

AdemÃ¡s con los argumentos opcionales podemos [**recolocar la columna modificada**]{.hl-yellow}

```{r}
starwars |> 
  mutate(height_m = height / 100,
         IMC = mass / (height_m^2), .before = name)
```

---

## Modificar columnas: mutate()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
:::

::: callout-important
## Importante...

Cuando aplicamos `mutate()`, debemos de acordarnos que las [**operaciones se realizan de manera vectorial**]{.hl-yellow}, elemento a elemento, por lo que la funciÃ³n que usemos dentro debe devolver un vector de igual longitud. En caso contrario, [**devolverÃ¡ una constante**]{.hl-red}
:::

. . .

```{r}
starwars |> 
  mutate(constante = mean(mass, na.rm = TRUE), .before = name)
```

---

## Recategorizar: if_else()

TambiÃ©n podemos combinar `mutate()` con la expresiÃ³n de control `if_else()` para [**recategorizar la variable**]{.hl-yellow}: si [**se cumple una condiciÃ³n**]{.hl-purple}, hace una cosa, en caso contrario otra.

```{r}
starwars |> 
  mutate(human = if_else(species == "Human", "Human", "Not Human"),
         .after = name) |> 
  select(name:mass)
```

---

## Recategorizar: case_when()

Para [**recategorizaciones mÃ¡s complejas**]{.hl-yellow} tenemos `case_when()`, por ejemplo, para crear una categorÃ­a de los personajes en funciÃ³n de su altura.

```{r}
starwars |> 
  drop_na(height) |> 
  mutate(altura = case_when(height < 120 ~ "enanos",
                            height < 160 ~ "bajito",
                            height < 180 ~ "normal",
                            height < 200 ~ "alto",
                            TRUE ~ "gigante"), .before = name)
```

---

## Datos anidados

TambiÃ©n podemos [**anidar o incrustar datasets uno dentro de otro**]{.hl-yellow}. Imagina que tenemos un dataset de variables `x` e `y ` con 2 registros, otro con las mismas variables pero solo un registro y otro de 3 registros.

```{r}
data_1 <- tibble("x" = c(0, 2), "y" = c(-1, NA))
data_2 <- tibble("x" = c(NA), "y" = c(5))
data_3 <- tibble("x" = c(-2, 6, 7), "y" = c(1.5, NA, -2))
```

. . .

Hasta ahora la Ãºnica manera que sabemos de [**juntar los 3 datasets**]{.hl-yellow} es haciendo uso de `bind_rows()` (por cierto, si usas el argumento `.id = "nombre_variable"` podemos hacer que se aÃ±ade sola una nueva variable que nos diga a que dataset pertenecÃ­a cada fila

```{r}
data <- bind_rows(data_1, data_2, data_3, .id = "dataset")
data
```

---

## Datos anidados

```{r}
data <- bind_rows(data_1, data_2, data_3, .id = "dataset")
data
```

Sin embargo en muchas ocasiones lo que querremos es tener [**los 3 en un mismo objeto PERO cada dataset por su cuenta**]{.hl-yellow}: un objeto (una lista) que almacene los 3 datasets separados entre sÃ­.

. . .

Para ello usaremos la funciÃ³n `nest()` indicando que variables comunes forman los datasets (en este caso `x` e `y`)


```{r}
data_nest <-
  data |>
  nest(data = c(x, y))
data_nest
```

---

## Datos anidados

```{r}
data_nest
```

FÃ­jate que ahora `data` es una lista ya que cada dataset almacenado podrÃ­a tener diferentes longitudes

---

## Datos anidados

Para [**desanidar podemos usar unnest()**]{.hl-yellow} indicando la columna que contiene los datasets

```{r}
data_nest |> unnest(cols = c(data))
```

---

## ğŸ’» Tu turno {#tu-turno-11-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Selecciona solo las variables nombre, altura y asÃ­ como todas aquellas variables relacionadas con el color, a la vez que te quedas solo con aquellos que no tengan ausente en la altura.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(name, height, contains("color")) |> 
  drop_na(height)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(name, height, contains("color")) |> 
  drop_na(height) |> 
  rename(nombre = name, altura = height,
         color_pelo = eye_color, color_piel = skin_color,
         color_pelo = hair_color)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detrÃ¡s de la variable de nombres.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  select(name, height, contains("color")) |> 
  drop_na(height) |> 
  rename(nombre = name, altura = height,
         color_pelo = eye_color, color_piel = skin_color,
         color_pelo = hair_color) |> 
  relocate(color_pelo, .after = nombre)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Con los datos originales, comprueba cuÃ¡ntas modalidades Ãºnicas hay en la variable de color de pelo.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  distinct(hair_color) |> 
  nrow()
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Del dataset original, selecciona solo las variables numÃ©ricas y de tipo texto. Tras ello define una nueva variable llamada `under_18` que nos recategorice la variable de edad: `TRUE` si es menor de edad y `FALSE` en caso contrario

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(where(is.numeric) | where(is.character)) |> 
  mutate(under_18 = birth_year < 18)
```

### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Del dataset original, crea una nueva columna llamada `auburn` (cobrizo/caoba) que nos diga TRUE si el color de pelo contiene dicha palabra y FALSE en caso contrario (reminder `str_detect()`).

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(auburn = str_detect(hair_color, "auburn"))
```

### [**Ejercicio 7**]{.hl-yellow}

ğŸ“ Del dataset original, incluye una columna que calcule el IMC. Tras ello, crea una nueva variable que valga `NA` si no es humano, `delgadez` por debajo de 18, `normal` entre 18 y 30, `sobrepeso` por encima de 30.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(IMC = mass / ((height/100)^2),
         IMC_recat = case_when(species != "Human" ~ NA,
                               IMC < 18 ~ "delgadez",
                               IMC < 30 ~ "normal",
                               TRUE ~ "sobrepeso"),
         .after = name)
```

:::

---


## ğŸ£ Caso prÃ¡ctico I: simulaciÃ³n {#caso-practico-11-1}


Haciendo uso de todo lo aprendido, vamos a proceder a [**crear una tabla con datos de bebÃ©s**]{.hl-yellow} de tamaÃ±o `n = 20` en donde [**simulemos el sexo de los bebÃ©s y su peso**]{.hl-yellow}

1. Crea un `tibble` con dos columnas, una llamada `id_bebe` y otra llamada `sexo`. En el primer caso debe ir de 1 a 20. En el segundo caso, simula su sexo de manera que haya un 0.5 de probabilidad de `chico` y 0.5 de `chica`.

2. Conocido el sexo, crea una tercera columna llamada `peso` en la que simules dicho valor. Supondremos que para los chicos el peso sigue una distribuciÃ³n $N(\mu = 3.266kg, \sigma = 0.514)$ y que para las chicas sigue una distribuciÃ³n $N(\mu = 3.155kg, \sigma = 0.495)$.

&nbsp;

Puedes ver la soluciÃ³n en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-filas-columnas/#caso-pr%C3%A1ctico-i-simulaci%C3%B3n)


--- 

## ğŸ£ Caso prÃ¡ctico II: Taylor Swift {#caso-practico-11-2}

Vamos a volver al [**anÃ¡lisis de Taylor Swift**]{.hl-yellow} pero esta vez desde una perspectiva [**tidyverse**]{.hl-yellow}


```{r}
library(taylor)
taylor_album_songs
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-filas-columnas/#caso-pr%C3%A1ctico-ii-taylor-swift)


---

## ğŸ£ Caso prÃ¡ctico III: seÃ±or de los anillos {#caso-practico-11-3}


Para practicar algunas funciones de `{dplyr}` vamos a usar datos de las pelÃ­culas de la [**trilogÃ­a de El SeÃ±or de los Anillos**]{.hl-yellow}. Los datos los cargaremos directamente desde la web (Github en este caso), sin pasar por el ordenador antes, simplemente **indicando como ruta la web donde estÃ¡ el archivo**

* La comunidad del anillo -> <https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Fellowship_Of_The_Ring.csv>

* Las 2 torres -> <https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Two_Towers.csv>

* El Retorno del Rey ->  <https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Return_Of_The_King.csv>

```{r}
#| code-fold: true
library(readr)
lotr_1 <-
  read_csv(file = "https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Fellowship_Of_The_Ring.csv")
lotr_2 <-
  read_csv(file = "https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Two_Towers.csv")
lotr_3 <-
  read_csv(file = "https://raw.githubusercontent.com/jennybc/lotr-tidy/master/data/The_Return_Of_The_King.csv")
```



Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-filas-columnas/#caso-pr%C3%A1ctico-iii-el-se%C3%B1or-de-los-anillos)

# Clase 12: [tidyverse (resÃºmenes)]{.flow} {#clase-12}

[**Summarise y group_by(). Contar y resumir: estadÃ­sticas desagregadas por factores/grupos.**]{style="color:#444442;"}


* [ğŸ’» Ejercicios resueltos](#tu-turno-12-1) 

* [ğŸ£ Workbook/caso prÃ¡ctico I: billboard](#caso-practico-12-1)

* [ğŸ£ Workbook/caso prÃ¡ctico II: fÃºtbol](#caso-practico-12-2)

* [ğŸ“† PlanificaciÃ³n](#planificacion)

---


## Contar: count()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
:::

Hasta ahora solo hemos transformado o consultado los datos pero no hemos generado estadÃ­sticas. Empecemos por lo sencillo: [**Â¿cÃ³mo contar (frecuencias)?**]{.hl-yellow}

. . .

Cuando lo usamos en solitario `count()` nos devolverÃ¡ simplemente el nÃºmero de registros , pero cuando lo usamos con variables `count()` calcula lo que se conoce como [**frecuencias**]{.hl-yellow}: [**nÃºmero de elementos de cada modalidad**]{.hl-purple}.

```{r}
starwars |> count(sex)
```

---

## Contar: count()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
:::

AdemÃ¡s si pasamos varias variables nos calcula lo que se conoce como una [**tabla de contigencia**]{.hl-yellow}. Con `sort = TRUE` nos devolverÃ¡ el [**conteo ordenado**]{.hl-purple} (mÃ¡s frecuentes primero).

```{r}
starwars |> count(sex, gender, sort = TRUE)
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Una de las [**funciones mÃ¡s potentes**]{.hl-yellow} a combinar con las acciones vistas es `group_by()`, que nos permitirÃ¡ [**agrupar nuestros registros**]{.hl-yellow} previamente

```{r}
starwars |> 
  group_by(sex) |>
  count() |>
  ungroup()
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Cuando apliquemos `group_by()` es importante entender que [**NO MODIFICA los datos**]{.hl-yellow}, sino que nos crea una [**variable de grupo**]{.hl-yellow} (subtablas por cada grupo) que modificarÃ¡ las acciones futuras: las [**operaciones se aplicarÃ¡n a cada subtabla por separado**]{.hl-purple}

. . .

Por ejemplo, imaginemos que queremos extraer el personaje mÃ¡s alto con `slice_max()`.

```{r}
starwars |> slice_max(height)
```


---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

Â¿Y si queremos [**extraer el personaje mÃ¡s alto pero...de cada uno de los sexos**]{.hl-yellow}?

. . .

```{r}
starwars |>
  group_by(sex) |> 
  slice_max(height) |> 
  ungroup()
```

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
:::

::: columns
::: {.column width="50%"}
![](img/tidydatatutor_1.jpg)
:::

::: {.column width="50%"}
![](img/tidydatatutor_2.jpg)
:::
:::

La web <https://tidydatatutor.com/> permite visualizar las operaciones de `{tidyverse}` (con el pipe antiguo)

---

## Agrupar: group_by()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |>
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |>
  ungroup()
```
:::
:::

::: callout-important
## Importante

Recuerda siempre [**hacer ungroup**]{.hl-red} para eliminar la variable de grupo creada
:::

. . .

En la nueva versiÃ³n de `{dplyr}` ahora se [**permite incluir la variable de grupo**]{.hl-yellow} en la llamada a muchas funciones con el argumento `by = ...` o `.by = ...`

```{r}
#| eval: false
starwars |> slice_max(height, by = sex)
```

```{r}
#| echo: false
starwars |> slice_max(height, by = sex) |> select(name:eye_color)
```

---

## Fila-a-fila: rowwise()

Una opciÃ³n muy Ãºtil usada antes de una operaciÃ³n tambiÃ©n es `rowwise()`: toda [**operaciÃ³n que venga despuÃ©s se aplicarÃ¡ en cada fila por separado**]{.hl-yellow}. Por ejemplo, vamos a definir un conjunto dummy de notas.

```{r}
notas <- tibble("mates" = c(7.5, 8, 9.1, 3),
                "lengua" = c(8, 6, 6.5, 9.2))
```

. . .

Si aplicamos la media directamente el valor serÃ¡ idÃ©ntico ya que nos ha hecho la media global, pero nos gustarÃ­a sacar una [**media por registro**]{.hl-yellow}. Para eso usaremos `rowwise()`

```{r}
notas |> 
  rowwise() |> 
  mutate(media_curso = mean(c(mates, lengua)))
```

---

## Resumir: summarise()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
:::

Por Ãºltimo tenemos `summarise()`, que nos permitirÃ¡ sacar resÃºmenes estadÃ­sticos. Por ejemplo, vamos a [**calcular la media de las alturas**]{.hl-yellow}.

```{r}
starwars |> 
  drop_na(height) |> 
  summarise(media_altura = mean(height))
```

. . .

::: callout-warning
## Cuidado

FÃ­jate que `mutate()` devuelve [**tantas filas como registros originales**]{.hl-yellow}, mientras que con `summarise()` calcula un [**nuevo dataset de resumen**]{.hl-purple}, solo incluyendo aquello que estÃ© indicado.
:::

---

## Resumir: summarise()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
:::

Si ademÃ¡s esto lo [**combinamos con la agrupaciÃ³n**]{.hl-yellow} de `group_by()` o `.by = ...`, en pocas lÃ­neas de cÃ³digo puedes obtener [**estadÃ­sticas desagreagadas**]{.hl-purple}

```{r}
starwars |> 
  drop_na(sex, height, mass) |> 
  summarise(media_altura = mean(height),
            media_peso = mean(mass),
            .by = sex)
```

---

## Resumir: reframe()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> reframe()
```
:::
:::

En el nuevo `{dplyr}` han incluido `reframe()` para evitar problemas de `summarise()` cuando [**devolvemos mÃ¡s de un valor por variable**]{.hl-yellow}.

::: columns
::: {.column width="50%"}
```{r}
#| warning: true
starwars |>
  drop_na(mass) |>
  summarise(quantile(mass))
```
:::

::: {.column width="50%"}
```{r}
starwars |>
  drop_na(mass) |>
  reframe(quantile(mass))
```
:::
:::

---

## Selectores: across()

Un truco es [**hacer uso de selectores**]{.hl-yellow} `across()` y `where()`. El primero nos permite [**actuar sobre varias columnas por nombre**]{.hl-purple} (con `mutate()` o `summarise()`)

```{r}
starwars |> summarise(medias = across(height:mass, mean, na.rm = TRUE), .by = sex)
```

. . .

El segundo, `where()`, nos permite hacer lo mismo pero [**seleccionando por tipo**]{.hl-yellow}.

```{r}
starwars |> 
  summarise(across(where(is.numeric), mean, na.rm = TRUE), .by = c(sex, gender))
```


---

## ğŸ’» Tu turno {#tu-turno-12-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Calcula cuÃ¡ntos personajes hay de cada especie, ordenados de mÃ¡s a menor frecuencia.

```{r}
#| code-fold: true
#| eval: false
starwars |> count(species, sort = TRUE)
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Tras eliminar ausentes en las variables de peso y estatura, aÃ±ade una nueva variable que nos calcule el IMC de cada personaje, y determina el IMC medio de nuestros personajes desagregada por sexo

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass, height) |> 
  mutate(IMC = mass / ((height/100)^2)) |> 
  summarise(IMC_medio = mean(IMC), .by = sex)
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ ObtÃ©n el personaje mÃ¡s joven por cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  slice_min(birth_year, by = sex)
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ ObtÃ©n la edad del personaje mÃ¡s joven y mÃ¡s viejo de cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(birth_year) |>
  summarise(min(birth_year), max(birth_year), .by = sex)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Determina la cantidad de personajes en cada dÃ©cada (echa un vistazo a `round()`, primero sin desagregar y luego desagregado por sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  count(birth_decade = round(birth_year, -1))
```
:::

---

## ğŸ£ Caso prÃ¡ctico I: billboard {#caso-practico-12-1}


Vamos a hacer un **repaso de lo aprendido** en `{tidyverse}` con la tabla billboard del paquete `{tidyr}`. El dataset representa algo parecido a Los 40 principales (pero versiÃ³n americana y un top 100 en lugar de 40): para cada artista y canciÃ³n se guarda la fecha en la que entrÃ³ en el ranking, y la posiciÃ³n que ocupaba en el ranking en cada una de las semanas (`wk1`, `wk2`, ...)


```{r}
#| eval: false
billboard
```

```{r}
#| echo: false
billboard[, 1:8]
```


Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-filas-columnas/#caso-pr%C3%A1ctico-i-billboard)


---

## ğŸ£ Caso prÃ¡ctico II: fÃºtbol  {#caso-practico-12-2}

Vamos a seguir  **practicando lo aprendido** en `{tidyverse}` con el fichero `futbol.csv`, donde tenemos **datos de los jugadores de las 5 principales ligas de futbol masculinas**, desde 2005 hasta 2019, recopilando diferentes estadÃ­sticas. Los datos se han extraÃ­do directamente haciendo uso del paquete `{worldfootballR}`, que nos permite extraer datos de <https://www.fbref.com>

```{r}
datos <- read_csv(file = "./datos/futbol.csv")
datos
```

---

## ğŸ£ Caso prÃ¡ctico II: fÃºtbol


Las variables capturan la siguiente informaciÃ³n:

* `season`, `team`, `league`: temporada, equipo y liga
* `player`, `country`, `position`, `date_birth`: nombre del jugador, paÃ­s, posiciÃ³n y aÃ±o de nacimiento.
* `minutes_playing`, `matches`: minutos totales jugados y partidos jugados en media (es decir, cuantos partidos de 90 minutos ha jugado con los minutos jugados).
* `goals`, `assist`: goles y asistencias totales
* `pk`, `pk_attemp`, `goals_minus_pk`: penalties marcados, penalties tirados y goles marcados sin contar los penalties.
* `yellow_card`, `red_card`: tarjetas amarillas/rojas.

---

## ğŸ£ Caso prÃ¡ctico II: fÃºtbol

```{r}
datos
```

&nbsp;


Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-filas-columnas/#caso-pr%C3%A1ctico-ii-messi-vs-ronaldo)

---

## ğŸ£ Caso prÃ¡ctico III: discursos

Volvamos al dataset `discursos` donde tenÃ­amos guardados los discursos navideÃ±os de los Â«jefesÂ» de Estado desde 1946 hasta 2021.

```{r}
load(file = "./datos/discursos.RData")
```

Piensa como responder a las mismas preguntas que hicimos en R base pero **en modo tidyverse** en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-filas-columnas/#caso-pr%C3%A1ctico-iii-discursos)

---

## ğŸ£ Caso prÃ¡ctico IV: covid again

Vamos a volver al [**dataset de covid**]{.hl-yellow} de la entrega II pero esta vez desde una **perspectiva tidyverse**

```{r}
library(readr)
datos <- read_csv(file = "./datos/messy_covid_data.csv")
datos
```

Piensa como responder a las mismas preguntas que hicimos en R base pero **en modo tidyverse** en el [**workbook**](https://javieralvarezliebana.quarto.pub/dplyr-filas-columnas/#caso-pr%C3%A1ctico-iv-r-base-vs-tidyverse)



# Clase 13: [importar y joins]{.flow} {#clase-13}

[**Â¿CÃ³mo cruzar dos tablas? Â¿CÃ³mo importar y exportar archivos?**]{style="color:#444442;"}


* [ğŸ’» Ejercicios resueltos: joins](#tu-turno-13-1) 

* [ğŸ’» Ejercicios resueltos: import/export](#tu-turno-13-2) 

* [ğŸ£ Workbook/caso prÃ¡ctico I: datos de renta](#caso-practico-13-1)

* [ğŸ£ Workbook/caso prÃ¡ctico II: tabla SPSS](#caso-practico-13-2)

* [ğŸ“† PlanificaciÃ³n](#planificacion)

---


## Relacionando datos

Al trabajar con datos [**no siempre tendremos la informaciÃ³n en una sola tabla**]{.hl-yellow} y a veces nos interesarÃ¡ cruzar la informaciÃ³n de distintas fuentes.

. . .

Para ello usaremos un clÃ¡sico de todo lenguaje que maneja datos: los famosos [**join**]{.hl-yellow}, que nos permitirÃ¡n [**cruzar una o varias tablas**]{.hl-yellow}, haciendo uso de una [**columna identificadora**]{.hl-yellow} de cada una de ellas (por ejemplo, imagina que cruzamos datos de hacienda y de antecedentes penales, haciendo `join` por la columna `DNI`).

---

## Relacionando datos

La estructura bÃ¡sica es la siguiente:

```{r}
#| eval: false
tabla_1 |>
  xxx_join(tabla_2, by = id)
```

![](img/sql-joins.jpg)

. . .


Vamos a probar los distintos joins con un ejemplo sencillo

```{r}
tb_1 <- tibble("key" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```

:::: columns
::: {.column width="50%"}

```{r}
tb_1
```

:::

::: {.column width="50%"}

```{r}
tb_2
```

:::
::::

---

## Left join


* `left_join()`: mantiene [**todos los registros de la primera tabla**]{.hl-yellow}, y busca cuales tienen id tambiÃ©n en la segunda (en caso de [**no tenerlo se rellena con NA**]{.hl-yellow} los campos de la 2Âª tabla).

En nuestra caso queremos incorporar a `tb_1` la informaciÃ³n de `tb_2`, identificando los registros por la columna key (`by = "key"`, la columna por la que tiene que cruzar)

:::: columns
::: {.column width="50%"}


```{r}
tb_1  |> 
  left_join(tb_2, by = "key")
```

:::
::: {.column width="50%"}


![](img/left_join.jpg)


:::
::::

---

## Left join

```{r}
tb_1 |> 
  left_join(tb_2, by = "key")
```

FÃ­jate que los [**registros de la primera cuya key no ha encontrado en la segunda**]{.hl-yellow} les ha dado el valor de [**ausente**]{.hl-yellow}.

---



## Right join


* `right_join()`: mantiene [**todos los registros de la segunda tabla**]{.hl-yellow}, y busca cuales tienen id tambiÃ©n en la primera.


Vamos ahora a incorporar a `tb_2` la informaciÃ³n de `tb_1`, identificando los registros por la columna key (`by = "key"`)

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

:::

::: {.column width="50%"}

![](img/right_join.jpg)

:::
::::

---

## Right join


```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

FÃ­jate que ahora los [**registros de la segunda cuya key no ha encontrado en la primera**]{.hl-yellow} son los que les ha dado el valor de [**ausente**]{.hl-yellow}.

---


## Claves y sufijos

Las columnas clave que usaremos para el cruce [**no siempre se llamarÃ¡n igual**]{.hl-yellow}.

```{r}
tb_1 <- tibble("key_1" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```

. . .

* `by = c("key_2" = "key_2")`: le indicaremos en quÃ© columna de cada tabla estÃ¡n las claves por las que vamos a cruzar.

:::: columns
::: {.column width="50%"}

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

```{r}
# Right
tb_1  |> 
  right_join(tb_2, by = c("key_1" = "key_2"))
```

:::
::::


---

## Claves y sufijos

AdemÃ¡s podemos [**cruzar por varias columnas a la vez**]{.hl-yellow} (interpretarÃ¡ como igual registro aquel que tenga el conjunto de claves igual), con `by = c("var1_t1" = "var1_t2", "var2_t1" = "var2_t2", ...)`. Modifiquemos el ejemplo anterior

```{r}
tb_1 <- tibble("k_11" = 1:3, "k_12" = c("a", "b", "c"),  "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("k_21" = c(1, 2, 4), "k_22" = c("a", "b", "e"), "val_y" = c("y1", "y2", "y3"))
```

. . .

```{r}
# Left
tb_1 |> 
  left_join(tb_2,
            by = c("k_11" = "k_21", "k_12" = "k_22"))
```


---

## Claves y sufijos

TambiÃ©n podrÃ­a suceder que al cruzar dos tablas, haya [**columnas de valores que se llamen igual**]{.hl-yellow}


```{r}
tb_1 <- tibble("key_1" = 1:3, "val" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val" = c("y1", "y2", "y3"))
```

. . .

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

FÃ­jate que [**por defecto nos aÃ±ade los sufijos**]{.hl-yellow} `.x` y `.y` para indicarnos de que tabla vienen.

---

## Claves y sufijos


Dicho [**sufijo podemos especificÃ¡rselo**]{.hl-yellow} en el argumento opcional `suffix = ...`, que nos permita [**distinguir las variables**]{.hl-yellow} de una tabla y de otra.


```{r}
# Left
tb_1 |>
  left_join(tb_2, by = c("key_1" = "key_2"), suffix = c("_tabla1", "_tabla2"))
```


---


## Full join


* `full_join()`: mantiene [**todos los registros de ambas**]{.hl-yellow} tablas.

Los dos anteriores casos forman lo que se conoce como [**outer joins**]{.hl-yellow}: cruces donde se mantienen observaciones que salgan en al menos una tabla. El tercer outer join es el conocido como `full_join()` que nos [**mantendrÃ¡ las observaciones de ambas**]{.hl-yellow} tablas, [**aÃ±adiendo las filas**]{.hl-yellow} que no casen con la otra tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  full_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

![](img/full_join.jpg)

:::
::::


---

## Inner join

* `inner_join()`: solo sobreviven los [**registros cuyo id estÃ© en ambas**]{.hl-yellow} tablas.

Frente a los outer join estÃ¡ lo que se conoce como [**inner join**]{.hl-yellow}, con `inner_join()`: un cruce en el que solo se mantienen las [**observaciones que salgan en ambas tablas**]{.hl-yellow}, solo mantiene aquellos registros matcheados.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

![](img/inner_join.png)


:::
::::

---

## Inner join

FÃ­jate que en tÃ©rminos de registros, `inner_join` si es conmutativa, **nos da igual el orden de las tablas**: lo Ãºnico que cambia es el orden de las columnas que aÃ±ade.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

:::

::: {.column width="50%"}


```{r}
tb_2 |> 
  inner_join(tb_1, by = c("key_2" = "key_1"))
```

:::
::::

---

## Anti/semi join

Por Ãºltimo tenemos dos herramientas interesantes para [**filtrar (no cruzar) registros**]{.hl-yellow}: `semi_join()` y `anti_join()`. El [**semi join**]{.hl-yellow} nos deja en la [**primera tabla los registros que cuya clave estÃ¡ tambiÃ©n en la segunda**]{.hl-yellow} (como un inner join pero sin aÃ±adir la info de la segunda tabla). Y el segundo, los anti join, hace justo lo contrario (aquellos que no estÃ¡n).


:::: columns
::: {.column width="50%"}

```{r}
# semijoin
tb_1 |> 
  semi_join(tb_2, by = c("key_1" = "key_2"))
```

:::

::: {.column width="50%"}

```{r}
# antijoin
tb_1 |> 
  anti_join(tb_2, by = c("key_1" = "key_2"))
```

:::
::::


---


## ğŸ’» Tu turno {#tu-turno-13-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

Para los ejercicios usaremos las tablas disponibles en el paquete `{nycflights13}` (echa un vistazo antes)

```{r}
library(nycflights13)
```

* [**airlines**]{.hl-yellow}: nombre de aerolÃ­neas (con su abreviatura).
* [**airports**]{.hl-yellow}: datos de aeropuertos (nombres, longitud, latitud, altitud, etc).
* [**flights**]{.hl-yellow}: datos de vuelos.
* [**planes**]{.hl-yellow}: datos de los aviones.
* [**weather**]{.hl-yellow}: datos meteorolÃ³gicos horarios de las estaciones LGA, JFK y EWR.

---

## ğŸ’» Tu turno {#tu-turno-16}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ Del paquete `{nycflights13}` cruza la tabla `flights` con `airlines`. Queremos mantener todos los registros de vuelos, aÃ±adiendo la informaciÃ³n de las aerolÃ­neas a la tabla de aviones.

```{r}
#| eval: false
#| code-fold: true
flights_airlines <-
  flights |> 
  left_join(airlines, by = "carrier")
flights_airlines
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ A la tabla obtenida del cruce del apartado anterior, cruza despuÃ©s con los datos de los aviones en `planes`, pero incluyendo solo aquellos vuelos de los que tengamos informaciÃ³n de sus aviones (y viceversa). 


```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum")
flights_airlines_planes
```


### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Repite el ejercicio anterior pero conservando ambas variables `year` (en una es el aÃ±o del vuelo, en la otra es el aÃ±o de construcciÃ³n del aviÃ³n), y distinguiÃ©ndolas entre sÃ­



```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum",
             suffix = c("_flight", "_build_aircraft"))
flights_airlines_planes
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Al cruce obtenido del ejercicio anterior incluye la longitud y latitud de los aeropuertos en `airports`, distinguiendo entre la latitud/longitud del aeropuerto en destino y en origen.

```{r}
#| eval: false
#| code-fold: true
flights_airlines_planes %>%
  left_join(airports %>% select(faa, lat, lon),
            by = c("origin" = "faa")) |> 
  rename(lat_origin = lat, lon_origin = lon) |> 
  left_join(airports %>% select(faa, lat, lon),
            by = c("dest" = "faa")) |> 
  rename(lat_dest = lat, lon_dest = lon)
```

### [**Ejercicio 5**]{.hl-yellow}

ğŸ“ Filtra de `airports` solo aquellos aeropuertos de los que salgan vuelos. Repite el proceso filtrado solo aquellos a los que lleguen vuelos

```{r}
#| eval: false
#| code-fold: true
airports |> 
  semi_join(flights, by = c("faa" = "origin"))
airports |> 
  semi_join(flights, by = c("faa" = "dest"))
```


### [**Ejercicio 6**]{.hl-yellow}

ğŸ“ Â¿De cuÃ¡ntos vuelos no disponemos informaciÃ³n del aviÃ³n? Elimina antes los vuelos que no tengan identificar (diferente a NA) del aviÃ³n


```{r}
#| eval: false
#| code-fold: true
flights |> 
  drop_na(tailnum) |>
  anti_join(planes, by = "tailnum") |>
  count(tailnum, sort = TRUE) # de mayor a menor ya de paso
```

:::

---

## ğŸ£ Caso prÃ¡ctico I: renta municipios {#caso-practico-13-1}

pendiente de subir

DistribuciÃ³n de la renta neta per cÃ¡pita (renta_municipio_data) por municipio (municipios) en EspaÃ±a en el aÃ±o 2019

---


## Importar/exportar

Hasta ahora sÃ³lo hemos utilizado datos ya cargados en paquetes, pero muchas veces [**necesitaremos importar datos externamente**]{.hl-yellow}. Una de las principales [**fortalezas**]{.hl-yellow} de `R` es que podemos importar datos muy fÃ¡cilmente en diferentes formatos:


* [**Formatos nativos de R**]{.hl-yellow}: archivos `.rda`, `.RData` y `.rds`

* [**Rectangular data (datos tabulados)**]{.hl-yellow}: archivos `.csv` y `.tsv`

* [**Datos sin tabular**]{.hl-yellow}: archivos `.txt`.

* [**Datos en excel**]{.hl-yellow}: archivos `.xls` y`.xlsx`.

* [**Datos desde SAS/Stata/SPSS**]{.hl-yellow}: archivos `.sas7bdat`, `.sav` y `.dat`.

* [**Datos desde Google Drive**]{.hl-yellow}

* [**Datos desde API's**]{.hl-yellow}: aemet, catastro, censo, spotify, etc.

---

## Formatos nativos

Los ficheros [**mÃ¡s sencillos**]{.hl-yellow} para importar a `R` (y que suelen ocupar menos espacio en disco) son sus propias [**extensiones nativas**]{.hl-yellow}: ficheros en formatos `.RData`, `.rda` y `.rds`. Para cargar los primeros basta con [**utilizar la funciÃ³n**]{.hl-yellow} `load()` proporcionÃ¡ndole la ruta del fichero.

* Archivos `RData`: vamos a importar el archivo `world_bank_pop.RData` que incluye la tabla `world_bank_pop`


```{r}
load("./datos/world_bank_pop.RData")
world_bank_pop
```


---

## Formatos nativos

* Archivos `.rda`: vamos a importar el dataset airquality desde `airquality.rda`

```{r}
load("./datos/airquality.rda")
airquality |> as_tibble()
```

---

## Formatos nativos

Tenga en cuenta que los archivos cargados con `load()` se cargan [**automÃ¡ticamente en el entorno**]{.hl-yellow} (con el nombre guardado originalmente), y no sÃ³lo se pueden cargar conjuntos de datos: `load()` nos permite cargar mÃºltiples objetos (no sÃ³lo datos tabulares).

Los archivos nativos `.rda` y `.RData` son una forma adecuada de guardar el entorno.

```{r}
load(file = "./datos/multiple_objects.rda")
```


---

## Formatos nativos

* Archivos `.rds`: para este tipo debemos utilizar `readRDS()`, y necesitamos incorporar un [**argumento `file`**]{.hl-yellow} con la ruta. En este caso vamos a importar [**datos de cÃ¡ncer de pulmÃ³n**]{.hl-purple} del North Central Cancer Treatment Group. Observe que ahora [**los archivos .rds incorporar solo una tabla, no un objeto en general**]{.hl-red}


```{r}
lung_cancer <-
  readRDS(file = "./datos/NCCTG_lung_cancer.rds") |>
  as_tibble()
lung_cancer
```


::: callout-important

## Importante

Las [**rutas**]{.hl-yellow deben ser siempre [**sin espacios, Ã±, ni acentos**]{.hl-yellow}. 


:::

---

## Datos tabulados: readr

El paquete `{readr}` dentro del entorno `{tidyverse}` contiene varias funciones Ãºtiles para [**cargar datos rectangulares (sin formatear pero tabulados)**]{.hl-yellow}.


:::: columns
::: {.column width="50%"}

* `read_csv()`: archivos `.csv` [**variables separadas por comas**]{.hl-purple}
* `read_csv2()`: variables separadas por [**punto y coma**]{.hl-purple}
* `read_tsv()`: variables separadas por [**tabuladores**]{.hl-purple}.
* `read_table()`: variables separadas por [**espacios**]{.hl-purple}.
* `read_delim()`: funciÃ³n generar con opciÃ³n de [**especificar el delimitador**]{.hl-purple}.


:::

::: {.column width="50%"}

![](img/data-import-readr.png)
:::
::::

Todos ellos necesitan como **argumento la ruta del fichero** mÃ¡s **otros opcionales** (saltar cabecera o no, decimales, etc). Ver mÃ¡s en <https://readr.tidyverse.org/>

---

## Datos tabulados (.csv, .tsv)

La principal ventaja de `{readr}` es que [**automatiza el formato**]{.hl-yellow} para pasar de un fichero plano (sin formato) a un tibble (en filas y columnas, con formato).


. . .

* Archivo `.csv`: con `read_csv()` cargaremos archivos [**separados por comas**]{.hl-purple}, pasando como [**argumento la ruta**]{.hl-yellow} en `file = ...`. Vamos a importar el conjunto de datos `chickens.csv` (sobre pollos de dibujos animados, por quÃ© no). Si nos fijamos en la salida nos da el tipo de variables.

```{r}
library(readr)
chickens <- read_csv(file = "./datos/chickens.csv")
chickens
```

---

## Datos tabulados (.csv, .tsv)


El [**formato de la variable**]{.hl-yellow} se harÃ¡ normalmente [**automÃ¡ticamente**]{.hl-yellow} por `read_csv()`, y podemos consultarlo con `spec()`.


```{r}
spec(chickens)
```

---

## Datos tabulados (.csv, .tsv)

Aunque normalmente lo hace bien automÃ¡ticamente podemos [**especificar el formato explÃ­citamente**]{.hl-yellow} en `col_types = lista()` (en formato lista, con `col_xxx()` para cada tipo de variable, por ejemplo `eggs_laid` se importarÃ¡ como carÃ¡cter). 


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_types = list(col_character(), col_character(),
                            col_character(), col_character()))
chickens
```

---

## Datos tabulados (.csv, .tsv)

Incluso podemos indicar que [**variables queremos seleccionar**]{.hl-yellow} (sin ocupar memoria), indicÃ¡ndolo en `col_select = ...` (en formato lista, con `col_select = ...`).


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_select = c(chicken, sex, eggs_laid))
chickens
```

---

## Datos tabulados (.txt)

Â¿QuÃ© ocurre cuando el [**separador no es correcto**]{.hl-red}?


. . .

Si usamos `read_csv()` espera que el separador entre columnas sea una coma pero, como puedes ver con el siguiente `.txt`, lo interpreta todo como una sola columna: [**no tiene coma y no sabe dÃ³nde separar**]{.hl-yellow}


```{r}
datos_txt <- read_csv(file = "./datos/massey-rating.txt")
dim(datos_txt)
as_tibble(datos_txt)
```


---

## Datos tabulados (.txt)

Para ello tenemos.

* `read_csv2()` cuando el [**separador es punto y coma**]{.hl-yellow}, `read_tsv()` cuando es un [**tabulador**]{.hl-yellow} y `read_table()` cuando es un  [**espacio**]{.hl-yellow}.

* `read_delim()` en general.

```{r}
datos_txt <- read_table(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```


---

## Datos Excel (.xls, .xlsx)

Otro paquete de importaciÃ³n clave serÃ¡ el paquete `{readxl}` para [**importar datos desde Excel**]{.hl-yellow}. Tres funciones serÃ¡n clave:

* `read_xls()` especÃ­fica para `.xls`, `read_xlsx()` especÃ­fica para `.xlsx`.
* `read_excel()`: tanto para `.xls` como para `.xlsx`.


. . .

Vamos a importar `deaths.xlsx` con los registros de defunciones de famosos.

```{r}
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths
```

---

## Datos Excel (.xls, .xlsx)


```{r}
deaths |> slice(1:6)
```

[**Una desgracia muy comÃºn**]{.hl-red} es que haya algÃºn tipo de comentario o texto al principio del fichero, teniendo que [**saltar esas filas**]{.hl-yellow}.


---

## Datos Excel (.xls, .xlsx)

Podemos [**saltar estas filas**]{.hl-yellow} directamente en la carga con `skip = ...` (indicando el nÃºmero de filas a saltar).


```{r}
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths
```


---

## Datos Excel (.xls, .xlsx)

AdemÃ¡s con `col_names = ...` ya podemos renombrar las columnas en la importaciÃ³n ([**proporcionar nombres supone 1Âª lÃ­nea ya como dato**]{.hl-yellow})


```{r}
#| code-line-numbers: "2-3"
deaths <-
  read_xlsx(path = "./datos/deaths.xlsx", skip = 5,
            col_names = c("nombre", "profesion", "edad", "hijos", "nacimiento", "muerte"))
deaths
```

---

## Datos Excel (.xls, .xlsx)

A veces las  [**fechas de Excel tienen un formato incorrecto**]{.hl-red} (sorpresa): podemos utilizar `convertToDate()` del paquete `{openxlsx}` para convertirlo.



```{r}
library(openxlsx)
deaths$muerte <- convertToDate(deaths$muerte)
deaths
```
   

---

## Datos Excel (.xls, .xlsx)

TambiÃ©n podemos [**cargar un Excel con varias hojas**]{.hl-yellow}: para [**indicar la hoja**]{.hl-yellow} (ya sea por su nombre o por su nÃºmero) utilizaremos el argumento `sheet = ...`.


```{r}
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars
```

---

## Datos Excel (.xls, .xlsx)

 
Incluso podemos indicar el [**rango de celdas**]{.hl-yellow} a cargar con `range = ...`.

```{r}
iris <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "iris", range = "C1:E4")
iris
```

---

## Importar desde SAS/STATA/SPSS

El paquete `{haven}` dentro del universo tidyverse nos permitirÃ¡ [**importar ficheros de los 3 software de pago mÃ¡s importantes**]{.hl-yellow}: SAS, SPSS y Stata.


```{r}
library(haven)

# SAS
iris_sas <- read_sas(data_file = "./datos/iris.sas7bdat")

# SPSS
iris_spss <- read_sav(file = "./datos/iris.sav")

# Stata
iris_stata <- read_dta(file = "./datos/iris.dta")
```

---


## Exportar

De la misma forma que podemos importar tambiÃ©n podemos [**exportar**]{.hl-yellow}

* exportar en `.RData` (opciÃ³n recomendada para variables almacenadas en `R`). Recuerda que esta extensiÃ³n [**sÃ³lo se puede utilizar en `R`**]{.hl-yellow}. Para ello, basta con utilizar `save(object, file = path)`.

```{r}
table <- tibble("a" = 1:4, "b" = 1:4)
save(table, file = "./datos/table.RData")
rm(table) # eliminar
load("./datos/table.RData")
table
```

---

## Exportar

La ventaja de `.RData` es que podemos [**exportar mÃºltiples variables de nuestro environment**]{.hl-yellow}, no solo un Ãºnico dataset.

```{r}
table <- tibble("a" = 1:4, "b" = 1:4)
a <- 1
b <- c("javi", "sandra")
save(table, a, b, file = "./datos/mult_obj.RData")
rm(list = c("a", "b", "table"))
load("./datos/mult_obj.RData")
table
```

---

## Exportar

* [**exportado en `.csv`**]{.hl-yellow}. Para ello simplemente utilizamos `write_csv(object, file = path)`, y es el mÃ¡s recomendable para exportar bases de datos de tamaÃ±o pequeÃ±o o mediano. Ver <https://arrow.apache.org/docs/r/> para bases de datos masivas.

```{r}
write_csv(table, file = "./datos/table.csv")
read_csv(file = "./datos/table.csv")
```

---

## Importar desde web

Una de las principales ventajas de `R` es que podemos hacer uso de todas las funciones anteriores de [**importar pero directamente desde una web**]{.hl-yellow}, sin necesidad de realizar la descarga manual: en lugar de pasarle la ruta local le indicaremos el [**enlace**]{.hl-yellow}. Por ejemplo, vamos a descargar los datos covid del ISCIII (<https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>)

```{r}
#| eval: false
covid_data <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
covid_data
```

```{r}
#| echo: false
covid_data <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv", n_max = 500)
covid_data
```

---

## Importar desde wikipedia

El paquete `{rvest}`, uno de los mÃ¡s Ãºtiles de `{tidyverse}` nos permite [**importar (scrappear) directamente desde un `html`**]{.hl-yellow}. Por ejemplo, para exportar tablas de wikipedia basta con `read_html()` para importar el html, `html_element(Â«tableÂ»)` para extraer los objetos tabla, y `html_table()` para convertir la tabla html a `tibble`.


```{r}
library(rvest)
wiki_jump <- 'https://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression'
wiki_jump |> read_html() |> 
  html_element("table") |> 
  html_table()
```

---

## Importar desde google drive

Otra opciÃ³n disponible (especialmente si trabajamos con otras personas trabajando) es [**importar desde una hoja de cÃ¡lculo de Google Drive**]{.hl-yellow}, haciendo uso de `read_sheet()` del paquete `{googlesheets4}`.

La primera vez se te pedirÃ¡ un permiso tidyverse para interactuar con tu drive


```{r}
library(googlesheets4)
google_sheet <-
  read_sheet("https://docs.google.com/spreadsheets/d/1Uz38nHjl3bmftxDpcXj--DYyPo1I39NHVf-xjeg1_wI/edit?usp=sharing")
google_sheet
```

---

## Importar desde API (owid)

Otra opciÃ³n interesante es la [**descarga de datos desde una API**]{.hl-yellow}: un intermediario entre una app o proveedor de datos y nuestro `R`. Por ejemplo, carguemos la librerÃ­a `{owidR}`, que nos permite descargar datos de la web <https://ourworldindata.org/>. Por ejemplo, la funciÃ³n `owid_covid()` carga sin darnos cuenta mÃ¡s de 400 000 registros con mÃ¡s de 60 variables de 238 paÃ­ses.


```{r}
#| eval: false
library(owidR)
owid_covid() |> as_tibble()
```

```{r}
#| echo: false
library(owidR)
owid_covid() |> as_tibble() |> slice(1:7)
```

---

## Importar desde API (aemet)

En muchas ocasiones para conectarnos a la API primero tendremos que [**registrarnos y obtener una clave**]{.hl-yellow}, este es el caso del paquete `{climaemet}` para acceder a [**datos meteorolÃ³gicos de EspaÃ±a**]{.hl-yellow} (<https://opendata.aemet.es/centrodedescargas/inicio>).


Una vez tengamos la clave API la registramos en nuestro RStudio para poder utilizarla en el futuro.

```{r}
#| eval: false
library(climaemet)

# Api key
apikey <- "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqYXZhbHYwOUB1Y20uZXMiLCJqdGkiOiI4YTU1ODUxMS01MTE3LTQ4MTYtYmM4OS1hYmVkNDhiODBkYzkiLCJpc3MiOiJBRU1FVCIsImlhdCI6MTY2NjQ2OTcxNSwidXNlcklkIjoiOGE1NTg1MTEtNTExNy00ODE2LWJjODktYWJlZDQ4YjgwZGM5Iiwicm9sZSI6IiJ9.HEMR77lZy2ASjmOxJa8ppx2J8Za1IViurMX3p1reVBU"

aemet_api_key(apikey, install = TRUE)
```


```{r}
#| echo: false
library(climaemet)
```

--- 

## Importar desde API (aemet)


Con este paquete podemos hacer una [**bÃºsqueda de estaciones**]{.hl-yellow} para conocer tanto su cÃ³digo postal como su cÃ³digo identificador dentro de la red AEMET

```{r}
stations <- aemet_stations()
stations
```

---

## Importar desde API (aemet)

Por ejemplo, para obtener datos de la estaciÃ³n del aeropuerto de El Prat, Barcelona, el cÃ³digo a proporcionar es `Â«0076Â»`, obteniendo **datos horarios**.

```{r}
aemet_last_obs("0076")
```


---

## Importar desde API (US census)

Una de las herramientas mÃ¡s Ãºtiles de los Ãºltimos aÃ±os es la conocida como `{tidycensus}`: una herramienta para [**facilitar el proceso de descarga de datos censales**]{.hl-yellow} de Estados Unidos desde `R`

```{r}
library(tidycensus)
```

* `get_decennial()`: para acceder a los [**datos de censos (US Decennial Census)**]{.hl-yellow}, se hacen cada 10 aÃ±os (aÃ±os 2000, 2010 y 2020).

* `get_acs()`: para acceder a los [**datos anuales y quinquenales (5 aÃ±os)  de la ACS (American Community Survey)**]{.hl-yellow} (censo != encuesta)

* `get_estimates()`: para acceder a las [**estimaciones anuales de poblaciÃ³n, natalidad y mortalidad**]{.hl-yellow}

* `get_pums()`: para acceder a los [**microdatos (datos sin agregar) de la ACS (anonimizados a nivel individual)**]{.hl-yellow}

* `get_flows()`: para acceder a los datos de [**flujo de migraciones**]{.hl-yellow}

---

## Importar desde API (US census)

Por ejemplo vamos a descargarnos los **datos censales** (`get_decennial()`) a nivel estado (`geography = "state"`) de la poblaciÃ³n (variable `variables = "P001001"`) para el aÃ±o 2010 (ver variables en `tidycensus::load_variables()`)

```{r}
total_population_10 <-
  get_decennial(geography = "state", 
  variables = "P001001",
  year = 2010)
total_population_10
```

---

## Importar desde API 

Otras opciones

* `{chessR}`: datos de partidas de ajedrez de las plataformas chess.com y lychess. Ver mÃ¡s en <https://github.com/JaseZiv/chessR>

* `{spotifyr}`: datos de canciones de Spotify. Ver mÃ¡s en <https://www.rcharlie.com/spotifyr/>

* `{gtrendsR}`: datos de Google Trends. Ver mÃ¡s en <https://github.com/PMassicotte/gtrendsR>

* `{scholar}`: datos de Google Scholar. Ver mÃ¡s en <https://github.com/jkeirstead/scholar>

---

## ğŸ’» Tu turno {#tu-turno-13-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

ğŸ“ El conjunto de datos `who2` del paquete `{tidyr}` que hemos utilizado en ejercicios anteriores, expÃ³rtalo a un formato nativo `R` en la carpeta `datos` de tu proyecto de RStudio

```{r}
#| code-fold: true
#| eval: false
library(tidyr)
save(who2, file = "./datos/who2.RData")
```

### [**Ejercicio 2**]{.hl-yellow}

ğŸ“ Carga el conjunto de datos `who2` pero desde la carpeta data (importa el fichero creado en el ejercicio anterior)


```{r}
#| code-fold: true
#| eval: false
load("./datos/who2.RData")
```

### [**Ejercicio 3**]{.hl-yellow}

ğŸ“ Repite lo mismo (exportar e importar) en 4 formatos: `.csv`, `.xlsx`, `.sav` (spss) y `.dta` (stata)

```{r}
#| code-fold: true
#| eval: false

# csv
library(readr)
write_csv(who2, file = "./datos/who2.csv")
who2_data <- read_csv(file = "./datos/who2.csv")

# excel
library(openxlsx)
write.xlsx(who2, file = "./datos/who2.xlsx")
who2_data <- read_xlsx(path = "./datos/who2.xlsx")

# sas y stata
library(haven)
write_sav(who2, path = "./datos/who2.sav")
who2_data <- read_spss(path = "./datos/who2.sav")

write_dta(who2, path = "./datos/who2.dta")
who2_data <- read_dta(path = "./datos/who2.dta")
```

### [**Ejercicio 4**]{.hl-yellow}

ğŸ“ Repita la carga de `who2.csv` pero seleccione sÃ³lo las 4 primeras columnas ya cargadas.

```{r}
#| code-fold: true
#| eval: false
who_select <-
  read_csv(file = "./datos/who2.csv",
           col_select = c("country", "iso2", "iso3", "year"))
who_select
```


:::

---

## ğŸ£ Caso prÃ¡ctico II: tabla en SPSS {#caso-practico-13-2}

pendiente de subir

DistribuciÃ³n de la renta neta per cÃ¡pita (renta_municipio_data) por municipio (municipios) en EspaÃ±a en el aÃ±o 2019

Â¿brexit?

# clase 14-15: concurso {#clase-14} {#clase-15}


[**Concurso: R base vs tidyverse**]{style="color:#444442;"}



---

solo practicar

- encuesta viogen

- contaminaciÃ³n (contam_mad)

- accidentes de trÃ¡fico (accidentes2020_data)


# clase 16: listas {#clase-16}


[**Manejo de listas con paquete purrr**]{style="color:#444442;"}


---

## ...

# Clase 17: inferencia {#clase-17}


[**Distribuciones, inferencia y simulaciÃ³n**]{style="color:#444442;"}

---

## ...

# Clase 18: repaso {#clase-18}


[**Repaso con casos reales**]{style="color:#444442;"}

---

## ...

# Clase 19: [entrega III]{.flow} {#clase-19}

[**PonderaciÃ³n: 25%**]{style="color:#444442;"}

---

## Instrucciones

El dÃ­a de la entrega tendrÃ¡s subido una [**plantilla de entrega**]{.hl-yellow} en formato `.qmd` en el campus.

* **Descomprime la carpeta** (Â¡importante! si no descomprimes, aunque puedas editar el `.qmd`, no podrÃ¡s generar el `.html`)

* **Edita la cabecera** con tu nombre y DNI

* DeberÃ¡s **rellenar cada chunk** con el cÃ³digo que consideres (en algunos te he dejado pistas) y **cambiar** de `#| eval: false` a `#| eval: true` (si los quitas directamente, por defecto ya es true)

* DeberÃ¡s de **comentar** con texto normal lo que consideres para responder a las preguntas.

* SerÃ¡ [**OBLIGATORIO**]{.hl-yellow} subir el archivo `.html` generado (solo se corregirÃ¡ dicho archivo) asÃ­ que ve renderizando segÃºn rellenas el documento, no lo dejes para el final.


# Clase 20: intro a dataviz {#clase-20}


[**Empieza la fantasÃ­a: visualizaciÃ³n de datos**]{style="color:#444442;"}

---

## ...




